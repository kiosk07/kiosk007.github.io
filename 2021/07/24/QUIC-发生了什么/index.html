<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="QUIC 发生了什么"><meta name="keywords" content="QUIC"><meta name="author" content="kiosk"><meta name="copyright" content="kiosk"><title>QUIC 发生了什么 | kiosk007's Blog</title><link rel="shortcut icon" href="/img/favicon-16x16-dragon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f3d277b6c83066a05a8b7db067b2308";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="kiosk007's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-number">1.</span> <span class="toc-text">HTTP 的演变</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QUIC-%E4%BB%8E%E5%93%AA%E6%9D%A5"><span class="toc-number">2.</span> <span class="toc-text">QUIC 从哪来</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QUIC-%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">3.</span> <span class="toc-text">QUIC 的版本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text"> aioquic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text"> Chromium</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text"> lsquic</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QUIC-%E5%AE%9E%E9%AA%8C"><span class="toc-number">4.</span> <span class="toc-text">QUIC 实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85"><span class="toc-number">4.1.</span> <span class="toc-text">编译安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">4.2.</span> <span class="toc-text">实验</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QUIC-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">5.</span> <span class="toc-text">QUIC 发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Packet-Header"><span class="toc-number">5.1.</span> <span class="toc-text">Packet Header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC-Frame-Header"><span class="toc-number">5.2.</span> <span class="toc-text">QUIC Frame Header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP3-Frame-Header"><span class="toc-number">5.3.</span> <span class="toc-text">HTTP3 Frame Header</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QUIC-Feature"><span class="toc-number">6.</span> <span class="toc-text">QUIC Feature</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-RTT"><span class="toc-number">6.1.</span> <span class="toc-text">0 RTT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E9%AA%8C%E8%AF%81%EF%BC%88Address-Validation%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">地址验证（Address Validation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E8%BF%81%E7%A7%BB"><span class="toc-number">6.3.</span> <span class="toc-text">链接迁移</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img1.kiosk007.top/static/images/avatar.jpg"></div><div class="author-info__name text-center">kiosk</div><div class="author-info__description text-center">NoOps</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/weijiaxiang007">Ordinary But Great</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">48</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img1.kiosk007.top/static/images/backgroud_sbpk.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">kiosk007's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/about/">关于</a><a class="site-page" href="/archives/">文章</a><a class="site-page" href="/tags/">标签</a><a class="site-page" href="/categories/">分类</a><a class="site-page" href="/express/">Express</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">QUIC 发生了什么</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/network/">network</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">6.8k</span><span class="post-meta__separator">|</span><span>Reading time: 26 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>从 HTTP/1.1（1999 年发布）到 HTTP/2 发布（2015 年发布）之间的发展差距很大，随着 2019 年 HTTP/3 的发布，HTTP/3 即将成为互联网上超文本传输协议的下一代协议，HTTP/3 是Google QUIC协议的演变。它与传统的 HTTP 有很大的不同。QUIC 是一种新的可靠传输协议，可以被视为一种下一代TCP。</p>
<a id="more"></a>
<p>QUIC 连接通过 UDP 端口和 IP 地址建立的，一旦建立，该连接就通过其“连接 ID”相关联（每个连接都拥有一组连接标识符或连接 ID，每个连接标识符都可用于识别连接）。</p>
<p>QUIC 提供 0-RTT 和 1-RTT 连接设置，所以建立新连接时，会比传统的 TCP + TLS 的组合要快许多。</p>
<h1 id="HTTP-的演变"><a href="#HTTP-的演变" class="headerlink" title="HTTP 的演变"></a>HTTP 的演变</h1><p>超文本传输协议 (HTTP) 是运行在 TCP/IP 之上的应用层协议，<br>HTTP 有 4 个稳定版本——HTTP/0.9、HTTP/1.0、HTTP/1.1 和 HTTP/2。在 2021年七月，市面上已经有 三分之二的浏览器支持了 HTTP/3 。</p>
<p>同年5月底，IETF：QUIC Version 1 (<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc9000.html#name-version-negotiation">RFC 9000</a>) 作为标准化版本现已发布，QUIC部署将从使用临时草案版本转向新创建的Version 1。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/http_protocol_versions.png"></p>
<h1 id="QUIC-从哪来"><a href="#QUIC-从哪来" class="headerlink" title="QUIC 从哪来"></a>QUIC 从哪来</h1><p>IETF 并不是从头开始研究 QUIC。2012 年，<a target="_blank" rel="noopener" href="https://blog.chromium.org/2013/06/experimenting-with-quic.html">谷歌设计了自己的 QUIC 版本</a>， 随后 Chrome 浏览器及其Google的大部分服务相继支持QUIC，包括 Youtube 和 Google 搜索。</p>
<p>IETF QUIC 与 早期的 gQUIC 相比也已经有了比较大的变化，这里不妨列举几个。</p>
<ul>
<li>加密协商：谷歌 QUIC 是定制加密握手，而 IETF 是采用了 TLS1.3</li>
<li>分离：IETF QUIC 的层级是分明的，其上可以承载的应用层协议不止 HTTP 协议</li>
<li>头部压缩：gQUIC 沿用了HTTP2的 HPack，而IETF QUIC 使用的是QPACK。</li>
</ul>
<h1 id="QUIC-的版本"><a href="#QUIC-的版本" class="headerlink" title="QUIC 的版本"></a>QUIC 的版本</h1><p>目前有<a target="_blank" rel="noopener" href="https://github.com/quicwg/base-drafts/wiki/Implementations">15种实验型QUIC</a>。【RFC9000 确定后，所有的QUIC版本会趋于统一】。但是这些实验性QUIC互操性比较差，因为各家的QUIC的实现标准不统一，对具体的一些功能实现存在diff。</p>
<p class="div-border yellow"> 数据截取于 2021.07</p>

<h2> <a target="_blank" rel="noopener" href="https://github.com/aiortc/aioquic" aria-hidden="true" class="header-anchor">aioquic</a></h2>

<p>使用Python和asyncio的QUIC实现</p>
<blockquote>
<ul>
<li>Language: Python </li>
<li>Version: draft-29 through version 1(RCF 9000)</li>
<li>Handshake: TLS 1.3</li>
<li>Protocol IDs: <code>0xff00001d</code>, <code>0xff00001e</code>, <code>0xff00001f</code>, <code>0xff000020</code>, <code>0x1</code></li>
</ul>
</blockquote>
<h2> <a target="_blank" rel="noopener" href="https://github.com/litespeedtech/lsquic" aria-hidden="true" class="header-anchor">Chromium</a></h2>

<p>Chromium的QUIC实现（chrome85.0.4171.0及更高版本支持draft-29）</p>
<blockquote>
<ul>
<li><strong>Languages</strong>: C, C++</li>
<li><strong>Versions</strong>: Q043, Q046, Q050, T050, T051, draft-27, draft-29.</li>
<li><strong>Handshakes</strong>: QUIC Crypto, TLS</li>
<li><strong>Protocol IDs</strong>: <code>Q043</code>, <code>Q046</code>, <code>Q050</code>, <code>T050</code>, <code>T051</code>, <code>0xff00001b</code>, <code>0xff00001d</code></li>
<li><strong>ALPNs</strong>: h3-Q043, h3-Q046, h3-Q050, h3-T050, h3-T051, h3-27, h3-29</li>
<li>Google将实现命名为“quiche”，但它与Cloudflare的Rust实现完全无关。</li>
</ul>
</blockquote>
<h2> <a target="_blank" rel="noopener" href="https://github.com/litespeedtech/lsquic" aria-hidden="true" class="header-anchor">lsquic</a></h2>

<p>LiteSpeed QUIC和HTTP/3库。适用于Linux、FreeBSD、MacOS、Android和Windows。</p>
<blockquote>
<ul>
<li><strong>Language</strong>: C</li>
<li><strong>Version</strong>: v1, Draft-34, Draft-29, Draft-27, Q043, Q046, and Q050.</li>
<li><strong>Roles</strong>: Client, Server, Library</li>
<li><strong>Handshake</strong>: QUIC Crypto, RFC 8446</li>
<li><strong>Protocol</strong> IDs: <code>0x00000001</code>, <code>0xFF000022</code>, <code>0xFF00001D</code>, <code>0xFF00001B</code></li>
</ul>
</blockquote>
<p>当前互联网上的<a target="_blank" rel="noopener" href="https://quic.netray.io/stats.html">QUIC流量</a>，draft-29 和 Version 1 版本 的量级在逐渐上升。国内的一些大厂也在使用QUIC来作为当前主要的流量接入，比如微信的视频号就使用 gQUIC 43 、快手也宣布了线上的<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/41HJkeZM7hEgIYlJRFK0">千万级QUIC计划</a>。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_version.png"></p>
<p>相信今年的 RFC9000 推出 QUICv1 版本后，QUIC的互操性能得到更广泛的运用。当前各大版本实现的<a target="_blank" rel="noopener" href="https://interop.seemann.io/">QUIC互操性</a>能得到进一步的提升。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_interop.png"></p>
<h1 id="QUIC-实验"><a href="#QUIC-实验" class="headerlink" title="QUIC 实验"></a>QUIC 实验</h1><p>当前的QUIC 版本很多，支持的比较完整的是 Chromium 和 lsquic 。</p>
<p>下面将以 <a target="_blank" rel="noopener" href="https://github.com/litespeedtech/lsquic">lsquic</a> 为例，实际剖析一下QUIC。</p>
<p>目前支持的QUIC版本有v1、Internet draft-27 和 draft-29, 包括老一些的Google QUIC 版本 <code>Q043</code> 、<code>Q046</code> 和 <code>Q050</code> 。</p>
<p>相关文档: <a target="_blank" rel="noopener" href="https://lsquic.readthedocs.io/en/latest/">https://lsquic.readthedocs.io/en/latest/</a></p>
<p>要构建LSQUIC，需要CMake、zlib和BoringSSL。</p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><ul>
<li>Building BoringSSL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国内可用 git clone https://github.com/google/boringssl.git</span></span><br><span class="line">git <span class="built_in">clone</span> https://boringssl.googlesource.com/boringssl</span><br><span class="line"><span class="built_in">cd</span> boringssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到特殊版本</span></span><br><span class="line">git checkout a2278d4d2cabe73f6663e3299ea7808edfa306b9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 </span></span><br><span class="line">cmake . &amp;&amp;  make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录当前位置</span></span><br><span class="line">BORINGSSL=<span class="variable">$PWD</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Building LSQUIC Library</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：测试程序由 libevent 驱动，测试程序需要先装 libevent-dev</span></span><br><span class="line">sudo apt-get install libevent-dev</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/litespeedtech/lsquic.git</span><br><span class="line"><span class="built_in">cd</span> lsquic</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Statically:</span></span><br><span class="line"><span class="comment"># $BORINGSSL is the top-level BoringSSL directory from the previous step</span></span><br><span class="line">cmake -DBORINGSSL_DIR=<span class="variable">$BORINGSSL</span> .</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># As a dynamic library:</span></span><br><span class="line">cmake -DLSQUIC_SHARED_LIB=1 -DBORINGSSL_DIR=<span class="variable">$BORINGSSL</span> .</span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>demo</li>
</ul>
<p>quic 的 demo 在 $lsquic_pwd/bin 目录下, 我们实验用就用 <code>http_client</code> 吧。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>先看看 <code>http_client</code> 支持的几个命令行参数.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">./http_client -<span class="built_in">help</span> </span><br><span class="line">Usage: http_client [opts]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">   -p PATH     Path to request.  May be specified more than once.  If no</span><br><span class="line">                 path is specified, the connection is closed as soon as</span><br><span class="line">                 handshake succeeds.</span><br><span class="line">   -n CONNS    Number of concurrent connections.  Defaults to 1.</span><br><span class="line">   -r NREQS    Total number of requests to send.  Defaults to 1.</span><br><span class="line">   -R MAXREQS  Maximum number of requests per single connection.  Some</span><br><span class="line">                 connections will have fewer requests than this.</span><br><span class="line">   -w CONCUR   Number of concurrent requests per single connection.</span><br><span class="line">                 Defaults to 1.</span><br><span class="line">   -M METHOD   Method.  Defaults to GET.</span><br><span class="line">   -P PAYLOAD  Name of the file that contains payload to be used <span class="keyword">in</span> the</span><br><span class="line">                 request.  This adds two more headers to the request:</span><br><span class="line">                 content-type: application/octet-stream and</span><br><span class="line">                 content-length</span><br><span class="line">   -K          Discard server response</span><br><span class="line">   -I          Abort on incomplete reponse from server</span><br><span class="line">   -4          Prefer IPv4 when resolving hostname</span><br><span class="line">   -6          Prefer IPv6 when resolving hostname</span><br><span class="line">   -C DIR      Certificate store.  If specified, server certificate will</span><br><span class="line">                 be verified.</span><br><span class="line">   -a          Display server certificate chain after successful handshake.</span><br><span class="line">   -b N_BYTES  Send RESET_STREAM frame after the client has <span class="built_in">read</span> n bytes.</span><br><span class="line">   -t          Print stats to stdout.</span><br><span class="line">   -T FILE     Print stats to FILE.  If FILE is -, <span class="built_in">print</span> stats to stdout.</span><br><span class="line">   -q FILE     QIF mode: issue requests from the QIF file and validate</span><br><span class="line">                 server responses.</span><br><span class="line">   -e TOKEN    Hexadecimal string representing resume token.</span><br><span class="line">   -3 MAX      Close stream after reading at most MAX bytes.  The actual</span><br><span class="line">                 number of bytes <span class="built_in">read</span> is randominzed.</span><br><span class="line">   -9 SPEC     Priority specification.  May be specified several <span class="built_in">times</span>.</span><br><span class="line">                 SPEC takes the form stream_id:nread:UI, <span class="built_in">where</span> U is</span><br><span class="line">                 urgency and I is incremental.  Matched \d+:\d+:[0-7][01]</span><br><span class="line">   -7 DIR      Save fetched resources into this directory.</span><br><span class="line">   -Q ALPN     Use hq ALPN.  Specify, <span class="keyword">for</span> example, <span class="string">&quot;h3-29&quot;</span>.</span><br><span class="line">   -0 FILE     Provide session resumption file (reading or writing)</span><br><span class="line">   -s SVCPORT  Service port.  Takes on the form of host:port, host,</span><br><span class="line">                 or port.  If host is not an IPv4 or IPv6 address, it is</span><br><span class="line">                 resolved.  If host is not <span class="built_in">set</span>, the value of SNI is</span><br><span class="line">                 used (see the -H flag).  If port is not <span class="built_in">set</span>, the default</span><br><span class="line">                 is 443.</span><br><span class="line">                 Examples:</span><br><span class="line">                     127.0.0.1:12345</span><br><span class="line">                     ::1:443</span><br><span class="line">                     example.com</span><br><span class="line">                     example.com:8443</span><br><span class="line">                     8443</span><br><span class="line">                 If no -s option is given, 0.0.0.0:12345 address</span><br><span class="line">                 is used.</span><br><span class="line">   -D          Do not <span class="built_in">set</span> <span class="string">&#x27;do not fragment&#x27;</span> flag on outgoing UDP packets</span><br><span class="line">   -z BYTES    Maximum size of outgoing UDP packets (client only).</span><br><span class="line">                 Overrides -o base_plpmtu.</span><br><span class="line">   -L LEVEL    Log level <span class="keyword">for</span> all modules.  Possible values are `debug<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                 `info&#x27;</span>, `notice<span class="string">&#x27;, `warn&#x27;</span>, `error<span class="string">&#x27;, `alert&#x27;</span>, `emerg<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                 and `crit&#x27;</span>.</span><br><span class="line">   -l LEVELS   Log levels <span class="keyword">for</span> modules, e.g.</span><br><span class="line">                 -l event=info,engine=debug</span><br><span class="line">               Can be specified more than once.</span><br><span class="line">   -m MAX      Maximum number of outgoing packet buffers that can be</span><br><span class="line">                 assigned at any one time.  By default, there is no max.</span><br><span class="line">   -y style    Timestamp style used <span class="keyword">in</span> <span class="built_in">log</span> messages.  The following styles</span><br><span class="line">                 are supported:</span><br><span class="line">                   0   No timestamp</span><br><span class="line">                   1   Millisecond time (this is the default).</span><br><span class="line">                         Example: 11:04:05.196</span><br><span class="line">                   2   Full date and millisecond time.</span><br><span class="line">                         Example: 2017-03-21 13:43:46.671</span><br><span class="line">                   3   Chrome-like timestamp: date/time.microseconds.</span><br><span class="line">                         Example: 1223/104613.946956</span><br><span class="line">                   4   Microsecond time.</span><br><span class="line">                         Example: 11:04:05.196308</span><br><span class="line">                   5   Full date and microsecond time.</span><br><span class="line">                         Example: 2017-03-21 13:43:46.671345</span><br><span class="line">   -S opt=val  Socket options.  Supported options:</span><br><span class="line">                   sndbuf=12345    <span class="comment"># Sets SO_SNDBUF</span></span><br><span class="line">                   rcvbuf=12345    <span class="comment"># Sets SO_RCVBUF</span></span><br><span class="line">   -W          Use stock PMI (malloc &amp; free)</span><br><span class="line">   -g          Use sendmmsg() to send packets.</span><br><span class="line">   -j          Use recvmmsg() to receive packets.</span><br><span class="line">   -H host     Value of `host<span class="string">&#x27; HTTP header.  This is also used as SNI</span></span><br><span class="line"><span class="string">                 in Client Hello.  This option is used to override the</span></span><br><span class="line"><span class="string">                 `host&#x27;</span> part of the address specified using -s flag.</span><br><span class="line">   -G dir      SSL keys will be logged to files <span class="keyword">in</span> this directory.</span><br><span class="line">   -k          Connect UDP socket.  Only meant to be used with clients</span><br><span class="line">                 to pick up ICMP errors.</span><br><span class="line">   -i USECS    Clock granularity <span class="keyword">in</span> microseconds.  Defaults to 1000.</span><br><span class="line">   -h          Print this <span class="built_in">help</span> screen and <span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="QUIC-发生了什么"><a href="#QUIC-发生了什么" class="headerlink" title="QUIC 发生了什么"></a>QUIC 发生了什么</h1><p>lsquic 提供了测试网站 <code>www.litespeedtech.com</code>，我们用下面的命令行工具访问这个网站, 并使用Wireshark 抓包和 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/151858528">qlog 去解析QUIC</a>，探索一些QUIC究竟发生了什么。</p>
<p class="div-border green">Wireshark （3.4.2）已经支持了解析 IETF QUIC，加载秘钥的方法参考 <a target="_blank" rel="noopener" href="https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/">Wireshark Tutorial: Decrypting HTTPS Traffic
</a></p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不指定版本。默认是使用 Version 1 版本 </span></span><br><span class="line">$ http_client -H www.litespeedtech.com:443 -p /  -G . -o version=h3-29</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当前目录下会生成一个 sslkeylog <code>F9CE5E3D598B8D80.keys</code>，wireshark 导入，注意<a target="_blank" rel="noopener" href="https://github.com/quicwg/base-drafts/wiki/Tools#wireshark">Wireshark 要装最新版本（当前是 3.4.2）</a>。</p>
<blockquote>
<p>注意： Wireshark 本身无法解密 GQUIC 数据包，即使已配置NSS Keylogging。</p>
</blockquote>
<p class="div-border green">更多QUIC debug or 可视化工具参考: https://github.com/quicwg/base-drafts/wiki/Tools </p>

<p>抓包内容如下：<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_capture_handshake.png"></p>
<p><strong>这里再介绍一下HTTP3的分层结构。</strong></p>
<p>一个 HTTP3 包会按照以下方式分层。实时上 QUIC 已经完全可以理解为一个传输层协议了，QUIC的实现也是和HTTP协议分离的，正如 RFC 9000 所描述的。“<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc9000.html#section-1-2">QUIC 是一种面向连接的协议，它在客户端和服务器之间创建有状态的交互。</a>”</p>
<p class="div-border blue"> <a target="_blank" rel="noopener" href="https://github.com/lucas-clemente/quic-go/blob/master/example/echo/echo.go">  quic-go 的 echo 示例 </a> 也在其示例代码中提供了QUIC层的demo `session.OpenStreamSync(context.Background())` </p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UDP Header</span><br><span class="line">Packet Header     -----</span><br><span class="line">QUIC Frame Header    --  TLS1.3</span><br><span class="line">HTTP3 Frame Header   --   </span><br><span class="line">HTTP Message      -----</span><br></pre></td></tr></table></figure>
<h2 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h2><p>Packet Header实现了可靠的连接。当UDP报文丢失后，通过Packet Header中的Packet Number实现报文重传。连接也是通过其中的Connection ID字段定义的</p>
<p>这里会有两种 Header 类型，<strong>Long Header</strong> 和 <strong>Short Header</strong>。Long Header 用于初始化交换 直到 可以1RTT可以被激动和版本协商完成。Short Header 用于承载数据。</p>
<ul>
<li><strong>Long Header</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|S|Typ|  Next   |              Magic <span class="string">&quot;uic&quot;</span>/<span class="string">&quot;UIC&quot;</span>                |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                         Connection ID                         +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            Version                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Packet Number                         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       [Header Extensions]                   ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Payload                           ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>建立连接时，连接是由服务器通过Source Connection ID字段分配的，这样，后续传输时，双方只需要固定住Destination Connection ID，就可以在客户端IP地址、端口变化后，绕过UDP四元组（与TCP四元组相同），实现连接迁移功能。如下图，后续的DCID和SCID都会统一为 <code>752566b9c5e2b77a</code></p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_connection_id.png"></p>
<ul>
<li><strong>Short Header</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|S|K|                Packet Number (30)                         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                         Connection ID                         +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>Packet Number是每个报文独一无二的序号，基于它可以实现丢失报文的精准重发。</p>
<p>参考: <a target="_blank" rel="noopener" href="https://gist.github.com/martinthomson/744d04cbcec9be554f2f8e7bae2715b8">martinthomson/quic_header.md</a></p>
<h2 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h2><p>在Packet Header之上的QUIC Frame Header, QUIC中的流为应用程序提供了轻量级的有序字节流抽象。流可以是单向的或双向的，而且Stream之间可以实现真正的并发。</p>
<p>所有的帧被包含在单独的QUIC Packet 中，且没有帧可以跨越QUIC Packet 边界。一个Packet报文中可以存放多个QUIC Frame，当然所有Frame的长度之和不能大于PMTUD（Path Maximum Transmission Unit Discovery，这是大于1200字节的值）, 一个QUIC Frame 也不允许跨Packet。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_frame1.png"></p>
<p>每一个QUIC Frame 都有明确的帧类型。</p>
<p>参考： <a target="_blank" rel="noopener" href="https://quic.readthedocs.io/zh/latest/Frame%20Types%20and%20Formats.html">帧类型和格式</a></p>
<p class="div-border red"> 上述文档比较老，很多数据有变动，下面是结合 <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc9000.html#name-frames-and-frame-types"> RFC9000 </a> 的版本 </p>




<p>当前定义的<strong>普通帧类型</strong>如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+-----------------------------+------------+</span><br><span class="line">| Type-field value      |     Control Frame-type      |    Spec    |</span><br><span class="line">+-----------------------+-----------------------------+------------+</span><br><span class="line">| 00000000B (0x00)      |  PADDING                    |     NP     |</span><br><span class="line">| 00000001B (0x01)      |  PING                       |            |</span><br><span class="line">| 00000010B (0x02-0x03) |  ACK                        |     NC     |</span><br><span class="line">| 00000100B (0x04)      |  RESET_STREAM               |            |</span><br><span class="line">| 00000101B (0x05)      |  STOP_SENDING               |            |</span><br><span class="line">| 00000110B (0x06)      |  CRYPTO                     |            |</span><br><span class="line">| 00000111B (0x07)      |  NEW_TOKEN                  |            |</span><br><span class="line">| 00001000B (0x08-0x0F) |  STREAM                     |     F      |</span><br><span class="line">| 00010000B (0x10)      |  MAX_DATA                   |            |</span><br><span class="line">| 00010001B (0x11)      |  MAX_STREAM_DATA            |            |</span><br><span class="line">| 00001100B (0x12-0x13) |  MAX_STREAMS                |            |</span><br><span class="line">| 00001110B (0x14)      |  DATA_BLOCKED               |            |</span><br><span class="line">| 00001111B (0x15)      |  STREAM_DATA_BLOCKED        |            |</span><br><span class="line">| 00010000B (0x16-0x17) |  STREAMS_BLOCKED            |            |</span><br><span class="line">| 00010010B (0x18)      |  NEW_CONNECTION_ID	      |     P      |</span><br><span class="line">| 00010011B (0x19)      |  RETIRE_CONNECTION_ID       |            |</span><br><span class="line">| 00010100B (0x1a)      |  PATH_CHALLENGE             |     P      |</span><br><span class="line">| 00010101B (0x1b)      |  PATH_RESPONSE              |     P      |</span><br><span class="line">| 00010110B (0x1c-0x1d) |  CONNECTION_CLOSE           |     N      |</span><br><span class="line">| 00011000B (0x1e)      |  HANDSHAKE_DONE             |            |</span><br><span class="line">+-----------------------+-----------------------------+------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三列 SPEC 规定了该帧的一些特殊用法<br>N : 该类帧不会被ACK<br>C : 出于拥塞控制目的,该类型帧不会被计入飞行中的字节数<br>P : 该类型帧的数据包可用于在连接迁移期间探测新的网络路径<br>F : 该类型帧用于流控</p>
</blockquote>
<ul>
<li><strong>PADDING 帧</strong>：PADDING帧使用0x00字节填充一个包。当遇到该帧时，包的剩余部分需要被填充字节。 该帧包含0x00字节并扩展至QUIC包的末端。</li>
<li><strong>PING 帧</strong>：PING帧用来验证对端是否仍然存活。PING帧不包含载荷。 PING帧的接收方只需要应答（ACK）包含该帧的包。 PING帧应该被用于当一条流被打开时，保持连接存活。 默认是30s</li>
<li><strong>ACK 帧</strong>: 发送ACK帧以通知对端已经接收了哪些分组，以及接收方仍然认为丢失了哪些分组（可能需要重新发送丢失分组的内容）。<ul>
<li>如果帧类型为0x02：普通的ACK应答作用</li>
<li>如果帧类型为0x03：则ACK帧还包含在此点之前在连接上接收到的具有相关ECN标记的QUIC数据包的累积计数。如果发送的数据包启用了ECN，则应使用ECN部分中的信息来管理拥塞状态</li>
</ul>
</li>
<li><strong>RST_STREAM 帧</strong>：RST_STREAM帧允许异常终止一条流。当这个帧是流的创建者发出的，表示创建者希望取消这条流。 当接收端发送这个帧，表示有错误或者当前接收端不希望接收这个流，因此这个流应该被关闭。</li>
<li><strong>STOP_SENDING 帧</strong>：请求对等方停止流上的传输.</li>
<li><strong>CRYPTO 帧</strong>：用于传输加密握手消息，加密帧在功能上与STREAM帧相同,但是不受流控。加密帧上传输 TLS 握手细信息。</li>
<li><strong>NEW_TOKEN 帧</strong>：为客户端提供一个令牌，以便用于之后的链接0-RTT。</li>
<li><strong>STREAM 帧</strong> : STREAM帧同时被用于隐式地创建流和在流上发送数据。STREAM帧中的类型字段的格式为0B00001xxx（或0x08到0x0f的一组值）,帧类型的三个低阶位确定帧中存在的字段。流可以是单向的，也可以是双向的，对于连接上的所有流都是唯一的。流低2位可标识是客户端还是服务端发起的单向流或双向流。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bits	Stream Type</span><br><span class="line">0x00	Client-Initiated, Bidirectional</span><br><span class="line">0x01	Server-Initiated, Bidirectional</span><br><span class="line">0x02	Client-Initiated, Unidirectional</span><br><span class="line">0x03	Server-Initiated, Unidirectional</span><br></pre></td></tr></table></figure></li>
<li><strong>MAX_DATA 帧</strong>：用于流控,用于通知对端整个连接上可发送的最大数据量。</li>
<li><strong>MAX_STREAM_DATA 帧</strong>：用于流控，用于通知对端流上可发送的最大数据量。</li>
<li><strong>MAX_STREAMS 帧</strong>：通知对等端允许打开的给定类型的流的最大数。<ul>
<li>0x12 的MAX_STREAM适用于双向流</li>
<li>0x13 的MAX_STREAM适用于单向流</li>
</ul>
</li>
<li><strong>DATA_BLOCKED 帧</strong>：BLOCKED帧用于向远端指明本端点已经准备好发送数据了（且有数据要发送）， 但是当前被流量控制阻塞了。这是一个纯粹的信息帧，它对于调试极其有用。 BLOCKED帧的接收者应该简单的丢弃它（可能在打印了一条有帮助的log消息之后）</li>
<li><strong>STREAM_DATA_BLOCKED 帧</strong>：当发送方希望发送数据但由于流级流控制而无法发送数据时，发送方应发送 STREAM_DATA_BLOCKED。</li>
<li><strong>STREAMS_BLOCKED 帧</strong>：当发送方希望打开流，但由于其对等方设置的最大流限制而无法打开流时，发送方应发送STREAMS_BLOCKED,<ul>
<li>0x16 的STREAMS_BLOCKED适用于双向流</li>
<li>0x17 的STREAMS_BLOCKED适用于单向流</li>
</ul>
</li>
<li><strong>NEW_CONNECTION_ID 帧</strong>：发送一个新的 NEW_CONNECTION_ID 帧, 为其对端提供可用于在迁移连接时中断可链接性的替代连接ID</li>
<li><strong>RETIRE_CONNECTION_ID 帧</strong>: 一端发送 RETIRE_CONNECTION_ID 表示不再使用对端发送的CONNECTION ID ，包含握手时确定的 连接id，后续可以发送新的 CONNECTION ID 再。</li>
<li><strong>PATH_CHALLENGE 帧</strong>：来检查对等方的可达性，并在连接迁移期间进行路径验证</li>
<li><strong>PATH_RESPONSE 帧</strong>: PATH_CHALLENGE 的响应帧</li>
<li><strong>CONNECTION_CLOSE 帧</strong>：CONNECTION_CLOSE帧用来通知连接将被关闭。如果流仍然有数据在发送，那么在连接关闭时， 这些流将被隐式关闭。</li>
<li><strong>HANDSHAKE_DONE 帧</strong>：向客户端发送握手确认信号。</li>
</ul>
<h2 id="HTTP3-Frame-Header"><a href="#HTTP3-Frame-Header" class="headerlink" title="HTTP3 Frame Header"></a>HTTP3 Frame Header</h2><p>QUIC 的 STREAM 帧是实际承载流量的帧。自然也是 <a target="_blank" rel="noopener" href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html#name-reserved-frame-types">HTTP3 协议</a>的承载。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_stream_frame.png"> </p>
<p>Stream Frame头部的3个字段，完成了多路复用、有序字节流以及报文段层面的二进制分隔功能</p>
<ul>
<li><strong>Stream ID</strong> 标识了一个有序字节流。当HTTP Body非常大，需要跨越多个Packet时，只要在每个Stream Frame中含有同样的Stream ID，就可以传输任意长度的消息。多个并发传输的HTTP消息，通过不同的Stream ID加以区别</li>
<li>消息序列化后的“有序”特性，是通过Offset字段完成的，它类似于TCP协议中的Sequence序号，用于实现Stream内多个Frame间的累计确认功能；</li>
<li>Length指明了Frame数据的长度。</li>
</ul>
<p>HTTP3 的Frame 继承了 HTTP2 的Frame 设计。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Frame         Control Stream	Request Stream	Push Stream	</span><br><span class="line">DATA          No                Yes               Yes	</span><br><span class="line">HEADERS       No                Yes               Yes	</span><br><span class="line">CANCEL_PUSH   Yes               No                No	</span><br><span class="line">SETTINGS      Yes              (1)                No	</span><br><span class="line">PUSH_PROMISE  No                Yes               No	</span><br><span class="line">GOAWAY        Yes               No                No	</span><br><span class="line">MAX_PUSH_ID   Yes               No                No	</span><br><span class="line">Reserved      Yes               Yes               Yes	</span><br></pre></td></tr></table></figure>
<p>QUIC Stream Frame定义了有序字节流，且多个Stream间的传输没有时序性要求，这样，HTTP消息基于QUIC Stream就实现了真正的多路复用，队头阻塞问题自然就被解决掉了。</p>
<p><strong>HTTP Header头部的编码方式，它需要面对另一种队头阻塞问题</strong></p>
<p>与HTTP2中的HPACK编码方式相似，HTTP3中的QPACK也采用了静态表、动态表及Huffman编码：</p>
<p>在HTTP2中，共有61个静态表项,而在QPACK中，则上升为98个静态表项, 比如 qpack 的golang 实现中的 <code>staticTableEntries</code> 所示。可以从<a target="_blank" rel="noopener" href="https://github.com/marten-seemann/qpack/blob/master/static_table.go">这里</a>找到 HTTP3 的完整静态表</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/qpack.png"></p>
<p>相较于HTTP3的静态表，和HTTP2协议其实并没有特别大的变化。但动态表编解码方式差距很大。</p>
<p>所谓动态表，就是将未包含在静态表中的Header项，在其首次出现时加入动态表，这样后续传输时仅用1个数字表示，大大提升了编码效率。因此，动态表是天然具备时序性的，如果首次出现的请求出现了丢包，后续请求解码HPACK头部时，一定会被阻塞！</p>
<p>事实上，QPACK将动态表的编码、解码独立在单向Stream中传输，仅当单向Stream中的动态表编码成功后，接收端才能解码双向Stream上HTTP消息里的动态表索引。</p>
<p>因此，当Stream ID是0、4、8、12时，这就是客户端发起的双向Stream（HTTP3不支持服务器发起双向Stream），它用于传输HTTP请求与响应。单向Stream有很多用途，所以它在数据前又多出一个Stream Type字段：</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_stream_type.png"></p>
<p>Stream Type有以下取值：</p>
<ul>
<li>0x00：控制Stream，传递各类Stream控制消息；</li>
<li>0x01：服务器推送消息；</li>
<li>0x02：用于编码QPACK动态表，比如面对不属于静态表的HTTP请求头部，客户端可以通过这个Stream发送动态表编码；</li>
<li>0x03：用于通知编码端QPACK动态表的更新结果。</li>
</ul>
<p>由于HTTP3的STREAM之间是乱序传输的，因此，若先发送的编码Stream后到达，双向Stream中的QPACK头部就无法解码，此时传输HTTP消息的双向Stream就会进入Block阻塞状态（两端可以通过控制帧定义阻塞Stream的处理方式）。</p>
<p>QPack 在编解码原理上和 HPack 没有本质区别。从 <a target="_blank" rel="noopener" href="https://github.com/marten-seemann/qpack">QPACK</a> 的代码中可以看出，其内部完全是套了一层 HAPCK 的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteField encodes f into a single Write to e&#x27;s underlying Writer.</span></span><br><span class="line"><span class="comment">// This function may also produce bytes for the Header Block Prefix</span></span><br><span class="line"><span class="comment">// if necessary. If produced, it is done before encoding f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encoder)</span> <span class="title">WriteField</span><span class="params">(f HeaderField)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// write the Header Block Prefix</span></span><br><span class="line">	<span class="keyword">if</span> !e.wrotePrefix &#123;</span><br><span class="line">		e.buf = appendVarInt(e.buf, <span class="number">8</span>, <span class="number">0</span>)</span><br><span class="line">		e.buf = appendVarInt(e.buf, <span class="number">7</span>, <span class="number">0</span>)</span><br><span class="line">		e.wrotePrefix = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	idxAndVals, nameFound := encoderMap[f.Name]</span><br><span class="line">	<span class="keyword">if</span> nameFound &#123;</span><br><span class="line">		<span class="keyword">if</span> idxAndVals.values == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(f.Value) == <span class="number">0</span> &#123;</span><br><span class="line">				e.writeIndexedField(idxAndVals.idx)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				e.writeLiteralFieldWithNameReference(&amp;f, idxAndVals.idx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			valIdx, valueFound := idxAndVals.values[f.Value]</span><br><span class="line">			<span class="keyword">if</span> valueFound &#123;</span><br><span class="line">				e.writeIndexedField(valIdx)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				e.writeLiteralFieldWithNameReference(&amp;f, idxAndVals.idx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		e.writeLiteralFieldWithoutNameReference(f)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e.w.Write(e.buf)</span><br><span class="line">	e.buf = e.buf[:<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="QUIC-Feature"><a href="#QUIC-Feature" class="headerlink" title="QUIC Feature"></a>QUIC Feature</h1><h2 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0 RTT"></a>0 RTT</h2><p>使用 0-RTT 取决于客户端和服务器使用从先前连接协商的协议参数。为了启用 0-RTT, 客户端将服务器传输参数与它在连接上收到的 session tickets 一起存储, 另外还存储应用程序或加密握手所需的信息。</p>
<p>和握手相关的报头都是长报头(<code>Long Packet</code>) 。分别是 <strong><code>Initial (0x00)</code></strong>、<strong><code>0-RTT    (0x01)</code></strong>、<strong><code>Handshake (0x02)</code></strong>、<strong><code>Retry (0x03)</code></strong>。</p>
<ul>
<li><code>CRYPTO</code> 帧可以在不同的数据包编号空间（packet number spaces）中发送。CRYPTO 帧使用偏移量（offsets）来确保加密握手数据的有序传递的在每个包编号空间（packet number spaces）都是从零开始。</li>
</ul>
<p><strong>握手流程示例</strong></p>
<ol>
<li>QUIC 在握手前会先进行地址验证（Address Validation），确保请求包里面的源地址不是伪造的。</li>
<li>一旦地址验证交换完成，就可以使用加密握手来获取加密密钥。加密握手通过初始（Initial）和握手（Handshake）包进行传输。</li>
<li>下图展示了 1-RTT 握手的示例。每行显示一个 QUIC 包（packet），首先显示包类型（type）和包编号（number），然后是帧（frames）。例如，第一个包是 Initial 类型，包编号为 0，并且包含一个携带 ClientHello（缩写：CH） 的 CRYPTO 帧。</li>
<li>多个 QUIC 数据包（即便是不同的类型）也可以合并成一个单独的 UDP 数据报（datagram）。因此，下图所示的 1-RTT 握手可以由 4 个UDP数据报（datagrams）组成。如果受协议固有的限制（如拥塞控制（congestion control）和反放大（anti-amplification））也可以使用更多的数据报。</li>
</ol>
<ul>
<li>1 - RTT</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[0]</span><br><span class="line">                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]</span><br><span class="line">                                 &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;]</span><br><span class="line"></span><br><span class="line">Initial[1]: ACK[0]</span><br><span class="line">Handshake[0]: CRYPTO[FIN], ACK[0]</span><br><span class="line">1-RTT[0]: STREAM[0, &quot;...&quot;], ACK[0] -&gt;</span><br><span class="line"></span><br><span class="line">                                          Handshake[1]: ACK[0]</span><br><span class="line">         &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, &quot;...&quot;], ACK[0]</span><br></pre></td></tr></table></figure>
<ul>
<li>0 - RTT</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH]</span><br><span class="line">0-RTT[0]: STREAM[0, &quot;...&quot;] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[0]</span><br><span class="line">                                  Handshake[0] CRYPTO[EE, FIN]</span><br><span class="line">                          &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;] ACK[0]</span><br><span class="line"></span><br><span class="line">Initial[1]: ACK[0]</span><br><span class="line">Handshake[0]: CRYPTO[FIN], ACK[0]</span><br><span class="line">1-RTT[1]: STREAM[0, &quot;...&quot;] ACK[0] -&gt;</span><br><span class="line"></span><br><span class="line">                                          Handshake[1]: ACK[0]</span><br><span class="line">         &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, &quot;...&quot;], ACK[1]</span><br></pre></td></tr></table></figure>
<p>如下是取自于 qvis的 1-RTT 握手请求。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/qvis_quictools_info.png"></p>
<h2 id="地址验证（Address-Validation）"><a href="#地址验证（Address-Validation）" class="headerlink" title="地址验证（Address Validation）"></a>地址验证（Address Validation）</h2><p>地址验证主要是用于确保端点（endpoint）不能被用于流量放大攻击（traffic amplification attack）。攻击者如果伪造数据包的源地址为受害者的地址，发送大量的数据包给服务端，如果服务端没有进行地址验证，直接响应大量数据包给源地址（受害者），就会被攻击者利用、进行流量放大攻击。</p>
<p>QUIC 针对放大攻击的主要防御措施是验证端点（endpoint）是否能够在其声明的传输地址接收数据包。地址验证在<strong>连接建立（connection establishment）期间</strong>和 <strong>连接迁移（connection migration）期间</strong>进行。</p>
<ul>
<li>连接建立时，为了验证客户端的地址是否是攻击者伪造的，服务端会生成一个令牌（token）并通过重试包（Retry packet）响应给客户端。客户端需要在后续的初始包（Initial packet）带上这个令牌，以便服务端进行地址验证。</li>
<li>服务端可以在当前连接中通过 NEW_TOKEN 帧预先发布令牌，以便客户端在后续的新连接使用，这是 QUIC 实现 0-RTT 很重要的一个功能。</li>
<li>当我们的网络路径变化时（比如从蜂窝网络切换到 WIFI），QUIC 提供了连接迁移（connection migration）的功能来避免连接中断。QUIC 通过路径验证（Path Validation）验证网络新地址的可达性（reachability），防止在连接迁移中的地址是攻击者伪造的。</li>
</ul>
<p><strong>使用重试数据包（Retry Packets）验证地址</strong></p>
<p>在接收到客户端的初始数据包（Initial packet）后，服务端可以通过发送包含令牌（token）的重试数据包（Retry packet）来请求地址验证。客户端在接收到这个重试数据包（Retry packet）的令牌（token）之后，必须在该连接中后续所有初始数据包（Initial packet）中附上该令牌（token）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                                &lt;- Retry+Token</span><br><span class="line"></span><br><span class="line">Initial+Token[1]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[1]</span><br><span class="line">                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]</span><br><span class="line">                                 &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>后续的连接使用 NEW_TOKEN 帧的令牌（token）</strong></p>
<p>服务端可以在一次连接中向客户端提供地址验证令牌（token），该令牌可用于后续的连接。这对于 0-RTT 尤其重要，后续的新连接可以直接使用该令牌进行地址验证，而无需额外的 1-RTT。</p>
<p>服务端使用 NEW_TOKEN 帧向客户端提供地址验证令牌，该令牌可用于验证后续的连接。在后续的连接中，客户端在初始数据包（Initial packets）中包含该令牌，以提供地址验证。</p>
<p>重试数据包（Retry packet）中提供的令牌只能立即使用，不能用于后续连接的地址验证。而 NEW_TOKEN 帧生成的令牌可以在一个时间范围内使用，这个令牌应该有一个过期时间，可以是显式的过期时间，也可以是可用于动态计算过期时间的时间戳（timestamp）。服务端可以存储过期时间，也可以在令牌中以加密的形式包含它。</p>
<p>参考： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/290694322">跟坚哥学QUIC系列：地址验证（Address Validation)</a></p>
<h2 id="链接迁移"><a href="#链接迁移" class="headerlink" title="链接迁移"></a>链接迁移</h2><p>QUIC 使用连接ID（而不是 ip + port）来确保数据包的路由一致性。如果用户的 IP 发生变化时，比如从移动蜂窝 4G 网络切换到 WiFi，IP 地址会改变。而使用一个唯一的连接ID 可以确保用户的 IP 变化时业务请求依然能够被继续处理，不用重新建连，可以继续使用当前连接ID 路由数据包，因此 QUIC 可以通过这个特性支持连接迁移</p>
<p>QUIC 的数据包（packets）长报头（long header）包含两个连接ID：目标连接ID（Destination Connection ID）由数据包的接收者选择并用于提供一致的路由，源连接ID（Source Connection ID）用于对端（peer）响应时使用的目标连接ID（Destination Connection ID）。</p>
<p>在握手过程中，带有长报头的包用于建立两端（both endpoints）使用的连接ID。在处理第一个初始数据包（Initial packet）之后，每个端点使用其接收到的源连接ID（Source Connection ID）字段的值设置为后续数据包中的目标连接ID（Destination Connection ID）字段。</p>
<p>当客户端发送了一个初始包（Initial packet），而该客户端之前没有从服务端接收过初始数据包（Initial packet）或重试包（Retry packet），则客户端将用一个不可预测的值（长度至少为8字节）填充到目标连接ID字段。在从服务端接收到数据包之前，客户端必须对该连接中的所有数据包使用相同的目标连接ID值。</p>
<p>当第一次从服务端接收到初始（Initial）或重试（Retry）数据包时，客户端使用服务端提供的源连接ID作为后续数据包（包括任何 0-RTT 数据包）的目标连接ID。这意味着在建立连接的过程中，客户端可能需要两次更改它的目标连接ID字段：一次用于响应重试（Retry），一次用于响应来自服务端的初始数据包（Initial）。一旦客户端从服务端接收到有效的初始数据包，客户端必须丢弃它后续接收到的具有不同源连接ID的数据包。</p>
<p>服务端必须根据第一个接收到的初始数据包（Initial packet）的源连接ID，设置为用于发送数据包的目标连接ID。后续只有当接收到 NEW_CONNECTION_ID 帧时，才允许对目标连接ID进行更改。如果后续初始数据包包含不同的源连接ID，则必须将其丢弃。这样可以避免由于无状态（stateless）处理具有不同源连接ID的多个初始数据包而导致的不可预测结果。</p>
<p>参考文章： </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ietf.org/blog/whats-happening-quic/">What’s Happening with QUIC</a></li>
<li><a target="_blank" rel="noopener" href="https://blogs.keysight.com/blogs/tech/nwvs.entry.html/2021/07/16/road_to_quic-DGa5.html">Road To QUIC</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.org.cn/article/detail/422">深入剖析HTTP3协议</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/290694322">跟坚哥学QUIC系列：地址验证（Address Validation)</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">kiosk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://kiosk007.top/2021/07/24/QUIC-发生了什么/">http://kiosk007.top/2021/07/24/QUIC-发生了什么/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/QUIC/">QUIC</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=kiosk" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/07/31/%E5%B0%9D%E8%AF%95-Nginx-%E4%B8%8A%E4%BD%BF%E7%94%A8HTTP3/"><i class="fa fa-chevron-left">  </i><span>尝试 Nginx 上使用HTTP3</span></a></div><div class="next-post pull-right"><a href="/2021/07/10/Wireshark%E8%A7%A3%E6%9E%90%E5%99%A8Lua%E8%84%9A%E6%9C%AC/"><span>Wireshark解析器Lua脚本</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'XhYn8GEq1Sg7ufJQAVmR4dWN-gzGzoHsz',
  appKey:'r42k4lqU022wD7IvtwGaQfjN',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://img1.kiosk007.top/static/images/backgroud_sbpk.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By kiosk</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">京ICP备20015006号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://img1.kiosk007.top/static/js/utils.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fancybox.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/sidebar.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/copy.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fireworks.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/transition.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/scroll.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="https://img1.kiosk007.top/static/js/katex.js"></script><script src="https://img1.kiosk007.top/static/js/search/local-search.js"></script><script id="ribbon" src="https://img1.kiosk007.top/static/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zIndex="-1" data-click="true"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>