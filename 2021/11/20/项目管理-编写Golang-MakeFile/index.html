<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="项目管理--编写Golang MakeFile"><meta name="keywords" content=""><meta name="author" content="kiosk"><meta name="copyright" content="kiosk"><title>项目管理--编写Golang MakeFile | kiosk007's Blog</title><link rel="shortcut icon" href="/img/favicon-16x16-dragon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f3d277b6c83066a05a8b7db067b2308";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="kiosk007's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Make-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Make 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">伪目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F-Automatic-Variables%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">自动化变量 (Automatic Variables）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F%EF%BC%88Implicit-Variables%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">内置变量（Implicit Variables）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.</span> <span class="toc-text">条件语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Makefile-%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">Makefile 要实现的功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%90%88%E7%90%86%E7%9A%84-Makefile-%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">设计合理的 Makefile 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%8C%E6%8F%A1-Makefile-%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7"><span class="toc-number">4.</span> <span class="toc-text">掌握 Makefile 编写技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7-1%EF%BC%9A%E5%96%84%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">技巧 1：善用通配符和自动变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7-2%EF%BC%9A%E5%96%84%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">技巧 2：善用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7-3%EF%BC%9A%E4%BE%9D%E8%B5%96%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">4.3.</span> <span class="toc-text">技巧 3：依赖需要用到的工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84-Makefile"><span class="toc-number">4.4.</span> <span class="toc-text">编写可扩展的 Makefile</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img1.kiosk007.top/static/images/avatar.jpg"></div><div class="author-info__name text-center">kiosk</div><div class="author-info__description text-center">NoOps</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/weijiaxiang007">Ordinary But Great</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">45</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img1.kiosk007.top/static/images/backgroud_sbpk.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">kiosk007's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/about/">关于</a><a class="site-page" href="/archives/">文章</a><a class="site-page" href="/tags/">标签</a><a class="site-page" href="/categories/">分类</a><a class="site-page" href="/express/">Express</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">项目管理--编写Golang MakeFile</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-20</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><span>Reading time: 16 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要先编译，那些文件需要后编译，那些文件需要重建等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，Makefile 可以使得我们的项目工程的编译变得自动化，不需要每次都手动输入一堆源文件和参数。</p>
<a id="more"></a>
<blockquote>
<p>参考：《孔令飞老师的 Go语言开发实战》</p>
</blockquote>
<p>以 Linux 下的C语言开发为例来具体说明一下，多文件编译生成一个文件，编译的命令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o outfile name1.c name2.c ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>outfile 要生成的可执行程序的名字，nameN.c 是源文件的名字。</p>
<p>下面列举了一些需要我们手动链接的标准库：</p>
<ul>
<li>name1.c 用到了数学计算库 math 中的函数，我们得手动添加参数 -Im；</li>
<li>name4.c 用到了小型数据库 SQLite 中的函数，我们得手动添加参数 -lsqlite3；</li>
<li>name5.c 使用到了线程，我们需要去手动添加参数 -lpthread。</li>
</ul>
<h1 id="Make-语法"><a href="#Make-语法" class="headerlink" title="Make 语法"></a>Make 语法</h1><p>编写高质量 Makefile 的第一步，便是熟练掌握 Makefile 的核心语法。<br>这里可以参考 <a target="_blank" rel="noopener" href="https://github.com/seisman/how-to-write-makefile">《跟我一起写Makefile (PDF重制版)》</a>、<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7097.html">Makefile 教程</a></p>
<p>makefile 完整案例<a target="_blank" rel="noopener" href="https://github.com/marmotedu/iam/blob/master/Makefile">IAM Makefile</a></p>
<p>makefile 的基本写法如下图，由 <code>target</code>,<code>dependencies</code>,<code>command</code>（command前必须是 tab 键） 组成<br><img src="https://img1.kiosk007.top/static/images/makefile/grammar1.png"></p>
<ul>
<li><code>target</code>：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；</li>
<li><code>dependencies</code>：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</li>
<li><code>command</code>：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li>
</ul>
<p>一个最基本的 golang Makefile 文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">build: clean vet</span></span><br><span class="line">  @mkdir -p ./Role</span><br><span class="line">  @<span class="keyword">export</span> GOOS=linux &amp;&amp; go build -v .</span><br><span class="line"></span><br><span class="line"><span class="section">vet:</span></span><br><span class="line">  go vet ./...</span><br><span class="line"></span><br><span class="line"><span class="section">fmt:</span></span><br><span class="line">  go fmt ./...</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  rm -rf dashboard</span><br></pre></td></tr></table></figure>
<blockquote>
<p>shell 命令行前的 @ 是为了防止回显，否则会将 <code>mkdir -p ./Role</code>输出出来再执行</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ==============================================================================</span></span><br><span class="line"><span class="comment"># Usage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> USAGE_OPTIONS</span><br><span class="line"></span><br><span class="line"><span class="section">Options:</span></span><br><span class="line">  DEBUG        Whether to generate debug symbols. Default is 0.</span><br><span class="line">  BINS         The binaries to build. Default is all of cmd.</span><br><span class="line">               This option is available when using: make </span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"><span class="keyword">export</span> USAGE_OPTIONS</span><br><span class="line"></span><br><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">	@<span class="variable">$(MAKE)</span> go.build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## help: Show this help info.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: help</span></span><br><span class="line"><span class="section">help: Makefile</span></span><br><span class="line">	@echo -e <span class="string">&quot;\nUsage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...\n\nTargets:&quot;</span></span><br><span class="line">	@sed -n &#x27;s/^<span class="comment">##//p&#x27; $&lt; | column -t -s &#x27;:&#x27; | sed -e &#x27;s/^/ /&#x27;</span></span><br><span class="line">	@echo <span class="string">&quot;$$USAGE_OPTIONS&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个进阶的Makefile有以下知识点</p>
<h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>所谓的伪目标可以这样来理解，它并不会创建目标文件，只是想去执行这个目标下面的命令。伪目标的存在可以帮助我们找到命令并执行。</p>
<p>特殊的标记 “.PHONY” 来显式地指明一个目标是“伪目标”，“.PHONY” 标记的target可以理解成一个无条件执行的动作。<br>这样就可以执行 <code>make help</code> 命令了。</p>
<p>使用<code>伪目标</code>主要有2个原因：</p>
<ol>
<li>避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。</li>
<li>提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。</li>
</ol>
<p>如下命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o test</span><br></pre></td></tr></table></figure>
<p>规则中 rm 命令不是创建文件 clean 的命令，而是执行删除任务，删除当前目录下的所有的 .o 结尾和文件名为 test 的文件。当工作目录下不存在以 clean 命令的文件时，在 shell 中输入 make clean 命令，命令 rm -rf *.o test 总会被执行 ，这也是我们期望的结果。</p>
<p>如果当前目录下存在文件名为  clean 的文件时情况就会不一样了，当我们在 shell 中执行命令 make clean，由于这个规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令。因此命令 rm 将不会被执行。为了解决这个问题，删除 clean 文件或者是在 Makefile 中将目标 clean 声明为伪目标。将一个目标声明称伪目标的方法是将它作为特殊的目标.PHONY的依赖，比如 <code>.PHONY:clean</code></p>
<h2 id="自动化变量-Automatic-Variables）"><a href="#自动化变量-Automatic-Variables）" class="headerlink" title="自动化变量 (Automatic Variables）"></a>自动化变量 (Automatic Variables）</h2><p>help 后面跟了一个文件 <code>Makefile</code>, 没错！就是help会将<code>Makefile</code> 当成参数。help 后面里有几个 $$$$、<code>$&lt;</code> 变量</p>
<p><code>$&lt;</code> 可以引用 Makefile 当成参数。没错，上述的命令展开就是 <code>sed -n &#39;s/^##//p&#39; Makefile | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39;</code>。<br>其实是将整个 <code>Makefile</code> 中的双井号解析成帮助命令。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">自动化变量</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成.a文件为文档文件，也成为静态的库文件），那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>
</tr>
<tr>
<td style="text-align:left">$%</td>
<td style="text-align:left">当目标文件是一个静态库文件时，代表静态库的一个成员名。</td>
</tr>
<tr>
<td style="text-align:left">$&lt;</td>
<td style="text-align:left">规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td>
</tr>
<tr>
<td style="text-align:left">$^</td>
<td style="text-align:left">代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件</td>
</tr>
<tr>
<td style="text-align:left">$+</td>
<td style="text-align:left">类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td>
</tr>
</tbody>
</table>
</div>
<p>举个例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o test1.o test2.o</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">test.o:test.c test.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">test1.o:test1.c test1.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">test2.o:test2.c test2.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这个规则模式中用到了 “$@” 、”$&lt;” 和 “$^” 这三个自动化变量，对比之前写的 Makefile 中的命令，我们可以发现</p>
<ul>
<li>“$@” 代表的是目标文件test</li>
<li>“$^”代表的是依赖的文件</li>
<li>“$&lt;”代表的是依赖文件中的第一个。</li>
</ul>
<p>我们在执行 make 的时候，make 会自动识别命令中的自动化变量，并自动实现自动化变量中的值的替换，这个类似于编译C语言文件的时候的预处理的作用。</p>
<h2 id="内置变量（Implicit-Variables）"><a href="#内置变量（Implicit-Variables）" class="headerlink" title="内置变量（Implicit Variables）"></a>内置变量（Implicit Variables）</h2><p>上面的实例中有这样一个表达式 </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">	@<span class="variable">$(MAKE)</span> go.build</span><br></pre></td></tr></table></figure>
<p>Make命令提供一系列内置变量，（感觉上和gcc/g++的预定义宏差不多）比如，<code>$(CC)</code> 指向当前使用的编译器，<code>$(MAKE)</code> 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册</a>。</p>
<hr>
<p>看下面的例子，其是一个 <code>common.mk</code> 提供一些 Makefile 文件调用时的基础变量环境。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SHELL := /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># include the common make file</span></span><br><span class="line">COMMON_SELF_DIR := <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> ROOT_DIR)</span>,undefined)</span><br><span class="line">ROOT_DIR := <span class="variable">$(<span class="built_in">abspath</span> $(<span class="built_in">shell</span> cd <span class="variable">$(COMMON_SELF_DIR)</span>/../.. &amp;&amp; pwd -P)</span>)</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> OUTPUT_DIR)</span>,undefined)</span><br><span class="line">OUTPUT_DIR := <span class="variable">$(ROOT_DIR)</span>/_output</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(OUTPUT_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> TOOLS_DIR)</span>,undefined)</span><br><span class="line">TOOLS_DIR := <span class="variable">$(OUTPUT_DIR)</span>/tools</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(TOOLS_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> TMP_DIR)</span>,undefined)</span><br><span class="line">TMP_DIR := <span class="variable">$(OUTPUT_DIR)</span>/tmp</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(TMP_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的例子有以下几个知识点，<code>:=</code>、<code>ifeq</code>、<code>$()</code> 等。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>先说变量，变量对于我们来说是不陌生的，在学习各种编程语言时会经常用到。就拿C语言来说，变量的使用是十分常见的，变量可以用来保存一个值或者是使用变量进行运算操作。</p>
<p>调用变量的时候可以用 “$(VALUE_LIST)” 或者是 “${VALUE_LIST}” 来替换，这就是变量的引用。实例：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJ=main.o test.o test1.o test2.o</span><br><span class="line"><span class="section">test:<span class="variable">$(OBJ)</span></span></span><br><span class="line">      gcc -o test <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><br><strong>变量的基本赋值</strong><br>知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：</p>
<ul>
<li>简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。</li>
<li>递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。</li>
<li>条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。</li>
<li>追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。</li>
</ul>
<p>其中的简单赋值和条件赋值比较简单字面意思就可以理解，下面介绍一下另外两种。<br><strong>递归赋值</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=foo</span><br><span class="line">y=<span class="variable">$(x)</span>b</span><br><span class="line">x=new</span><br><span class="line">test：</span><br><span class="line">      @echo <span class="string">&quot;y=&gt;<span class="variable">$(y)</span>&quot;</span></span><br><span class="line">      @echo <span class="string">&quot;x=&gt;<span class="variable">$(x)</span>&quot;</span></span><br><span class="line"><span class="comment">## 执行结果</span></span><br><span class="line"><span class="comment">## y=&gt;newb</span></span><br><span class="line"><span class="comment">## x=&gt;new</span></span><br></pre></td></tr></table></figure>
<p><strong>追加赋值</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x:=foo</span><br><span class="line">y:=<span class="variable">$(x)</span>b</span><br><span class="line">x+=<span class="variable">$(y)</span></span><br><span class="line">test：</span><br><span class="line">      @echo <span class="string">&quot;y=&gt;<span class="variable">$(y)</span>&quot;</span></span><br><span class="line">      @echo <span class="string">&quot;x=&gt;<span class="variable">$(x)</span>&quot;</span></span><br><span class="line"><span class="comment">## 执行结果</span></span><br><span class="line"><span class="comment">## y=&gt;foob</span></span><br><span class="line"><span class="comment">## x=&gt;foo foob</span></span><br></pre></td></tr></table></figure>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句只能用于控制 make 实际执行的 Makefile 文件部分，不能控制规则的 shell 命令执行的过程。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ifeq</td>
<td style="text-align:left">判断参数是否不相等，相等为 true，不相等为 false</td>
</tr>
<tr>
<td style="text-align:left">ifneq</td>
<td style="text-align:left">判断参数是否不相等，不相等为 true，相等为 false</td>
</tr>
<tr>
<td style="text-align:left">ifeq</td>
<td style="text-align:left">判断是否有值，有值为 true，没有值为 false</td>
</tr>
<tr>
<td style="text-align:left">ifneq</td>
<td style="text-align:left">判断是否有值，没有值为 true，有值为 false</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Makefile-要实现的功能"><a href="#Makefile-要实现的功能" class="headerlink" title="Makefile 要实现的功能"></a>Makefile 要实现的功能</h1><p>对于 Go 项目来说，虽然不同项目集成的功能不一样，但绝大部分项目都需要实现一些通用的功能。接下来，我们就来看看，在一个大型 Go 项目中 Makefile 通常可以实现的功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ make <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...</span><br><span class="line"></span><br><span class="line">Targets:</span><br><span class="line">  <span class="comment"># 代码生成类命令</span></span><br><span class="line">  gen                Generate all necessary files, such as error code files.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 格式化类命令</span></span><br><span class="line">  format             Gofmt (reformat) package sources (exclude vendor dir <span class="keyword">if</span> existed).</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 静态代码检查</span></span><br><span class="line">  lint               Check syntax and styling of go sources.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 测试类命令</span></span><br><span class="line">  <span class="built_in">test</span>               Run unit <span class="built_in">test</span>.</span><br><span class="line">  cover              Run unit <span class="built_in">test</span> and get <span class="built_in">test</span> coverage.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构建类命令</span></span><br><span class="line">  build              Build <span class="built_in">source</span> code <span class="keyword">for</span> host platform.</span><br><span class="line">  build.multiarch    Build <span class="built_in">source</span> code <span class="keyword">for</span> multiple platforms. See option PLATFORMS.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Docker镜像打包类命令</span></span><br><span class="line">  image              Build docker images <span class="keyword">for</span> host arch.</span><br><span class="line">  image.multiarch    Build docker images <span class="keyword">for</span> multiple platforms. See option PLATFORMS.</span><br><span class="line">  push               Build docker images <span class="keyword">for</span> host arch and push images to registry.</span><br><span class="line">  push.multiarch     Build docker images <span class="keyword">for</span> multiple platforms and push images to registry.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 部署类命令</span></span><br><span class="line">  deploy             Deploy updated components to development env.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 清理类命令</span></span><br><span class="line">  clean              Remove all files that are created by building.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 其他命令，不同项目会有区别</span></span><br><span class="line">  release            Release project</span><br><span class="line">  verify-copyright   Verify the boilerplate headers <span class="keyword">for</span> all files.</span><br><span class="line">  ca                 Generate CA files <span class="keyword">for</span> all project components.</span><br><span class="line">  install            Install project system with all its components.</span><br><span class="line">  swagger            Generate swagger document.</span><br><span class="line">  tools              install dependent tools.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 帮助命令</span></span><br><span class="line">  <span class="built_in">help</span>               Show this <span class="built_in">help</span> info.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项</span></span><br><span class="line">Options:</span><br><span class="line">  DEBUG        Whether to generate debug symbols. Default is 0.</span><br><span class="line">  BINS         The binaries to build. Default is all of cmd.</span><br><span class="line">               This option is available when using: make build/build.multiarch</span><br><span class="line">               Example: make build BINS=<span class="string">&quot;iam-apiserver iam-authz-server&quot;</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>通常而言，Go 项目的 Makefile 应该实现以下功能：<strong>格式化代码</strong>、<strong>静态代码检查</strong>、<strong>单元测试</strong>、<strong>代码构建</strong>、<strong>文件清理</strong>、<strong>帮助</strong>等等。如果通过 docker 部署，还需要有 <strong>docker镜像打包</strong>功能。因为 Go 是跨平台的语言，所以构建和 docker 打包命令，还要能够支持不同的 CPU 架构和平台。为了能够更好地控制 Makefile 命令的行为，还需要支持 Options。</p>
<p>为了方便查看 Makefile 集成了哪些功能，我们需要支持 help 命令。help 命令最好通过解析 Makefile 文件来输出集成的功能，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## help: Show this help info.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: help</span></span><br><span class="line"><span class="section">help: Makefile</span></span><br><span class="line">  @echo -e <span class="string">&quot;\nUsage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...\n\nTargets:&quot;</span></span><br><span class="line">  @sed -n &#x27;s/^<span class="comment">##//p&#x27; $&lt; | column -t -s &#x27;:&#x27; | sed -e &#x27;s/^/ /&#x27;</span></span><br><span class="line">  @echo <span class="string">&quot;$$USAGE_OPTIONS&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="设计合理的-Makefile-结构"><a href="#设计合理的-Makefile-结构" class="headerlink" title="设计合理的 Makefile 结构"></a>设计合理的 Makefile 结构</h1><p>对于大型项目来说，需要管理的内容很多，所有管理功能都集成在一个 Makefile 中，可能会导致 Makefile 很大，难以阅读和维护，所以建议采用分层的设计方法，根目录下的 Makefile 聚合所有的 Makefile 命令，具体实现则按功能分类，放在另外的 Makefile 中。</p>
<p><img src="https://img1.kiosk007.top/static/images/makefile/makefile_struct.webp"></p>
<p>在上面的 Makefile 组织方式中，根目录下的 Makefile 聚合了项目所有的管理功能，这些管理功能通过 Makefile 伪目标的方式实现。同时，还将这些伪目标进行分类，把相同类别的伪目标放在同一个 Makefile 中，这样可以使得 Makefile 更容易维护。对于复杂的命令，则编写成独立的 shell 脚本，并在 Makefile 命令中调用这些 shell 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">├── Makefile</span><br><span class="line">├── scripts</span><br><span class="line">│   ├── gendoc.sh</span><br><span class="line">│   ├── make-rules</span><br><span class="line">│   │   ├── gen.mk</span><br><span class="line">│   │   ├── golang.mk</span><br><span class="line">│   │   ├── image.mk</span><br><span class="line">│   │   └── ...</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure>
<p>为了跟 Makefile 的层级相匹配，golang.mk 中的所有目标都按go.xxx这种方式命名。通过这种命名方式，我们可以很容易分辨出某个目标完成什么功能，放在什么文件里，这在复杂的 Makefile 中尤其有用。例如</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/golang.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/image.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/gen.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/...</span><br><span class="line"></span><br><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> go.build</span><br><span class="line"></span><br><span class="line"><span class="comment">## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build.multiarch</span></span><br><span class="line"><span class="section">build.multiarch:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> go.build.multiarch</span><br><span class="line"></span><br><span class="line"><span class="comment">## image: Build docker images for host arch.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: image</span></span><br><span class="line"><span class="section">image:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> image.build</span><br><span class="line"></span><br><span class="line"><span class="comment">## push: Build docker images for host arch and push images to registry.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: push</span></span><br><span class="line"><span class="section">push:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> image.push</span><br><span class="line"></span><br><span class="line"><span class="comment">## ca: Generate CA files for all iam components.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: ca</span></span><br><span class="line"><span class="section">ca:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> gen.ca</span><br></pre></td></tr></table></figure>
<h1 id="掌握-Makefile-编写技巧"><a href="#掌握-Makefile-编写技巧" class="headerlink" title="掌握 Makefile 编写技巧"></a>掌握 Makefile 编写技巧</h1><h2 id="技巧-1：善用通配符和自动变量"><a href="#技巧-1：善用通配符和自动变量" class="headerlink" title="技巧 1：善用通配符和自动变量"></a>技巧 1：善用通配符和自动变量</h2><p>Makefile 允许对目标进行类似正则运算的匹配，主要用到的通配符是%。通过使用通配符，可以使不同的目标使用相同的规则，从而使 Makefile 扩展性更强，也更简洁。</p>
<p>这里，我们来看一个具体的例子，tools.verify.%（位于<a target="_blank" rel="noopener" href="https://github.com/marmotedu/iam/blob/master/scripts/make-rules/tools.mk#L17">scripts/make-rules/tools.mk</a>文件中）定义如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TOOLS ?=<span class="variable">$(BLOCKER_TOOLS)</span> <span class="variable">$(CRITICAL_TOOLS)</span> <span class="variable">$(TRIVIAL_TOOLS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: tools.install</span></span><br><span class="line"><span class="section">tools.install: $(addprefix tools.install., <span class="variable">$(TOOLS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: tools.install.%</span></span><br><span class="line"><span class="section">tools.install.%:</span></span><br><span class="line">	@echo <span class="string">&quot;===========&gt; Installing <span class="variable">$*</span>&quot;</span></span><br><span class="line">	@<span class="variable">$(MAKE)</span> install.<span class="variable">$*</span></span><br><span class="line"></span><br><span class="line"><span class="section">tools.verify.%:</span></span><br><span class="line">	@if ! which <span class="variable">$*</span> &amp;&gt;/dev/null; then <span class="variable">$(MAKE)</span> tools.install.<span class="variable">$*</span>; fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>make tools.verify.swagger</code>, <code>make tools.verify.mockgen</code>等均可以使用上面定义的规则，%分别代表了<code>swagger</code>和<code>mockgen</code>。</p>
<p>如果执行了 <code>make install</code> , 则执行的逻辑是，将执行<code>$(addprefix tools.install., $(TOOLS))</code> 这个命令的意思这时执行 <code>tools.install</code>,进一步拼装了一系列的<code>tools.install.xxxxxx</code> 并执行。</p>
<p>如果不使用<code>%</code>，则我们需要分别为<code>tools.verify.swagger</code>和<code>tools.verify.mockgen</code>定义规则，很麻烦，后面修改也困难。</p>
<p>另外，这里也能看出<code>tools.verify.%</code>这种命名方式的好处：tools 说明依赖的定义位于scripts/make-rules/tools.mk Makefile 中；verify说明tools.verify.%伪目标属于 verify 分类，主要用来验证工具是否安装。通过这种命名方式，你可以很容易地知道目标位于哪个 Makefile 文件中，以及想要完成的功能。另外，上面的定义中还用到了自动变量<code>$*</code>，用来指代被匹配的值<code>swagger、mockgen</code>。</p>
<h2 id="技巧-2：善用函数"><a href="#技巧-2：善用函数" class="headerlink" title="技巧 2：善用函数"></a>技巧 2：善用函数</h2><p>Makefile 自带的函数能够帮助我们实现很多强大的功能。所以，在我们编写 Makefile 的过程中，如果有功能需求，可以优先使用这些函数。我把常用的函数以及它们实现的功能整理在了 <a target="_blank" rel="noopener" href="https://github.com/marmotedu/geekbang-go/blob/master/makefile/Makefile%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md">Makefile 常用函数列表</a> 中</p>
<h2 id="技巧-3：依赖需要用到的工具"><a href="#技巧-3：依赖需要用到的工具" class="headerlink" title="技巧 3：依赖需要用到的工具"></a>技巧 3：依赖需要用到的工具</h2><p>如果 Makefile 某个目标的命令中用到了某个工具，可以将该工具放在目标的依赖中。这样，当执行该目标时，就可以指定检查系统是否安装该工具，如果没有安装则自动安装，从而实现更高程度的自动化。例如，/Makefile 文件中，format 伪目标，定义如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: format</span></span><br><span class="line"><span class="section">format: tools.verify.golines tools.verify.goimports</span></span><br><span class="line">  @echo <span class="string">&quot;===========&gt; Formating codes&quot;</span></span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> gofmt -s -w</span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> goimports -w -local <span class="variable">$(ROOT_PACKAGE)</span></span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> golines -w --max-len=120 --reformat-tags --shorten-comments --ignore-generated .</span><br></pre></td></tr></table></figure>
<p>可以看到，format 依赖tools.verify.golines tools.verify.goimports。我们再来看下tools.verify.golines的定义：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">tools.verify.%:</span></span><br><span class="line">  @if ! which <span class="variable">$*</span> &amp;&gt;/dev/null; then <span class="variable">$(MAKE)</span> tools.install.<span class="variable">$*</span>; fi</span><br></pre></td></tr></table></figure>
<p>通过<code>tools.verify.%</code>规则定义，我们可以知道，<code>tools.verify.%</code>会先检查工具是否安装，如果没有安装，就会执行<code>tools.install.$*</code>来安装。如此一来，当我们执行<code>tools.verify.%</code>目标时，如果系统没有安装 golines 命令，就会自动调用go get安装，提高了 Makefile 的自动化程度。</p>
<h2 id="编写可扩展的-Makefile"><a href="#编写可扩展的-Makefile" class="headerlink" title="编写可扩展的 Makefile"></a>编写可扩展的 Makefile</h2><p>举个例子，执行 <code>make go.build</code> 时能够构建 cmd/ 目录下的所有组件，也就是说，当有新组件添加时， <code>make go.build</code> 仍然能够构建新增的组件。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COMMANDS ?= <span class="variable">$(<span class="built_in">filter</span>-out %.md, $(<span class="built_in">wildcard</span> $&#123;ROOT_DIR&#125;/cmd/*)</span>)</span><br><span class="line">BINS ?= <span class="variable">$(<span class="built_in">foreach</span> cmd,$&#123;COMMANDS&#125;,$(<span class="built_in">notdir</span> $&#123;cmd&#125;)</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: go.build</span></span><br><span class="line"><span class="section">go.build: go.build.verify $(addprefix go.build., $(addprefix <span class="variable">$(PLATFORM)</span>., <span class="variable">$(BINS)</span>))</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: go.build.%               </span></span><br><span class="line"></span><br><span class="line"><span class="section">go.build.%:             </span></span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> COMMAND := $(<span class="built_in">word</span> 2,$(<span class="built_in">subst</span> ., ,<span class="variable">$*</span>)</span>))</span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> PLATFORM := $(<span class="built_in">word</span> 1,$(<span class="built_in">subst</span> ., ,<span class="variable">$*</span>)</span>))</span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> OS := $(<span class="built_in">word</span> 1,$(<span class="built_in">subst</span> _, ,<span class="variable">$(PLATFORM)</span>)</span>))           </span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> ARCH := $(<span class="built_in">word</span> 2,$(<span class="built_in">subst</span> _, ,<span class="variable">$(PLATFORM)</span>)</span>))                         </span><br><span class="line">  @echo <span class="string">&quot;===========&gt; Building binary <span class="variable">$(COMMAND)</span> <span class="variable">$(VERSION)</span> for <span class="variable">$(OS)</span> <span class="variable">$(ARCH)</span>&quot;</span></span><br><span class="line">  @mkdir -p <span class="variable">$(OUTPUT_DIR)</span>/platforms/<span class="variable">$(OS)</span>/<span class="variable">$(ARCH)</span></span><br><span class="line">  @CGO_ENABLED=0 GOOS=<span class="variable">$(OS)</span> GOARCH=<span class="variable">$(ARCH)</span> <span class="variable">$(GO)</span> build <span class="variable">$(GO_BUILD_FLAGS)</span> -o <span class="variable">$(OUTPUT_DIR)</span>/platforms/<span class="variable">$(OS)</span>/<span class="variable">$(ARCH)</span>/<span class="variable">$(COMMAND)</span><span class="variable">$(GO_OUT_EXT)</span> <span class="variable">$(ROOT_PACKAGE)</span>/cmd/<span class="variable">$(COMMAND)</span></span><br></pre></td></tr></table></figure>
<p>当执行make go.build 时，会执行 go.build 的依赖 <code>$(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS)))</code> , <code>addprefix</code>函数最终返回字符串 <code>go.build.linux_amd64.iamctl go.build.linux_amd64.iam-authz-server go.build.linux_amd64.iam-apiserver ...</code>，这时候就会执行 <code>go.build.%</code> 伪目标。在 <code>go.build.%</code>伪目标中，通过 <code>eval</code>、<code>word</code>、<code>subst</code> 函数组合，算出了 COMMAND 的值 <code>iamctl/iam-apiserver/iam-authz-server/...</code>，最终通过 <code>$(ROOT_PACKAGE)/cmd/$(COMMAND)</code> 定位到需要构建的组件的 main 函数所在目录。</p>
<p>通过以下方法可以获取到 cmd 下所有的组件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS ?= $(filter-out %.md, $(wildcard <span class="variable">$&#123;ROOT_DIR&#125;</span>/cmd/*))</span><br><span class="line">BINS ?= $(foreach cmd,<span class="variable">$&#123;COMMANDS&#125;</span>,$(notdir <span class="variable">$&#123;cmd&#125;</span>))</span><br></pre></td></tr></table></figure>
<p>接着，通过使用通配符和自动变量，自动匹配到go.build.linux_amd64.iam-authz-server 这类伪目标并构建。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">kiosk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://kiosk007.top/2021/11/20/项目管理-编写Golang-MakeFile/">http://kiosk007.top/2021/11/20/项目管理-编写Golang-MakeFile/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=kiosk" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/11/26/Go-Module-%E6%B1%87%E6%80%BB/"><i class="fa fa-chevron-left">  </i><span>Go Module 基本使用</span></a></div><div class="next-post pull-right"><a href="/2021/09/19/Service-Mesh-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"><span>Service Mesh 是什么？</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'XhYn8GEq1Sg7ufJQAVmR4dWN-gzGzoHsz',
  appKey:'r42k4lqU022wD7IvtwGaQfjN',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://img1.kiosk007.top/static/images/backgroud_sbpk.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By kiosk</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">京ICP备20015006号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://img1.kiosk007.top/static/js/utils.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fancybox.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/sidebar.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/copy.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fireworks.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/transition.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/scroll.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="https://img1.kiosk007.top/static/js/katex.js"></script><script src="https://img1.kiosk007.top/static/js/search/local-search.js"></script><script id="ribbon" src="https://img1.kiosk007.top/static/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zIndex="-1" data-click="true"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>