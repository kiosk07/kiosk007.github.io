<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="GoLang 编程模式 -- 基本概念"><meta name="keywords" content=""><meta name="author" content="kiosk"><meta name="copyright" content="kiosk"><title>GoLang 编程模式 -- 基本概念 | kiosk007's Blog</title><link rel="shortcut icon" href="/img/favicon-16x16-dragon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f3d277b6c83066a05a8b7db067b2308";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="kiosk007's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Slice"><span class="toc-number">1.1.</span> <span class="toc-text">Slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">与数组的不同：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Golang%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">在Golang中创建切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">切片引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interface"><span class="toc-number">1.2.</span> <span class="toc-text">Interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">接口式编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Functional-Option"><span class="toc-number">2.</span> <span class="toc-text">Functional Option</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-Server-%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">初始化 Server 示例</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img1.kiosk007.top/static/images/avatar.jpg"></div><div class="author-info__name text-center">kiosk</div><div class="author-info__description text-center">NoOps</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/weijiaxiang007">Ordinary But Great</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">28</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img1.kiosk007.top/static/images/background_2.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">kiosk007's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/about/">关于</a><a class="site-page" href="/archives/">文章</a><a class="site-page" href="/tags/">标签</a><a class="site-page" href="/categories/">分类</a><a class="site-page" href="/express/">Express</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">GoLang 编程模式 -- 基本概念</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-30</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3k</span><span class="post-meta__separator">|</span><span>Reading time: 12 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文为了巩固一下 Go 的基础，主要涉及 Slice、Interface、函数式编程等。</p>
<a id="more"></a>
<p>也是读了<a target="_blank" rel="noopener" href="https://coolshell.cn/" style>左耳朵耗子</a> 叔的 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/21128.html">Go编程模式</a> 的系列文章发现有的细节确实之前也有遗漏，刚好也趁机复习巩固一下。</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">//指向存放数据的数组指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span>            <span class="comment">//长度有多大</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span>            <span class="comment">//容量有多大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Slicce标头的<strong>array</strong>字段是底层真正指向数组的指针。</p>
<p><img src="https://i0.wp.com/golangbyexample.com/wp-content/uploads/2020/05/slice.jpg?w=391&amp;ssl=1" alt></p>
<p>Golang 的切片是子集。切片可以是数组、列表或字符串的子集。可以从一个字符串中提取多个片段，每个片段作为一个新变量。</p>
<h3 id="与数组的不同："><a href="#与数组的不同：" class="headerlink" title="与数组的不同："></a><strong>与数组的不同</strong>：</h3><p>数组在声明为一定大小后，不能调整大小，而切片可以调整大小。切片是引用类型，而数组是值类型。</p>
<h3 id="在Golang中创建切片"><a href="#在Golang中创建切片" class="headerlink" title="在Golang中创建切片"></a><strong>在Golang中创建切片</strong></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stringSlice = []<span class="keyword">string</span>&#123;<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;slice&quot;</span>&#125;</span><br><span class="line">	fmt.Println(stringSlice)  <span class="comment">// prints [This is a string slice]</span></span><br><span class="line">	<span class="comment">// res:  [This is a string slice]</span></span><br><span class="line"></span><br><span class="line">	myset := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* take slice */</span></span><br><span class="line">	s1 := myset[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	<span class="comment">// res:  [0 1 2 3]</span></span><br><span class="line"></span><br><span class="line">	mystring := <span class="string">&quot;Go programming&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* take slice */</span></span><br><span class="line">	s2 := mystring[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	<span class="comment">// res:  Go</span></span><br><span class="line"></span><br><span class="line">	numbers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;numbers=%v\n&quot;</span>, numbers)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;length=%d\n&quot;</span>, <span class="built_in">len</span>(numbers))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;capacity=%d\n&quot;</span>, <span class="built_in">cap</span>(numbers))</span><br><span class="line">	<span class="comment">// res:</span></span><br><span class="line">	<span class="comment">//numbers=[0 0 0]</span></span><br><span class="line">	<span class="comment">//length=3</span></span><br><span class="line">	<span class="comment">//capacity=5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片引用"><a href="#切片引用" class="headerlink" title="切片引用"></a><strong>切片引用</strong></h3><p>切片是引用类型，那么就意味着数组指针的问题——数据会发生共享！下面我们来看看 Slice 的一些操作：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">foo[<span class="number">3</span>] = <span class="number">42</span></span><br><span class="line">foo[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">bar  := foo[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">bar[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 foo</span></span><br><span class="line"><span class="comment">// 打印 bar</span></span><br></pre></td></tr></table></figure>
<ol>
<li>首先，创建一个 foo 的 Slice，其中的长度和容量都是 5；</li>
<li>然后，开始对 foo 所指向的数组中的索引为 3 和 4 的元素进行赋值；</li>
<li>最后，对 foo 做切片后赋值给 bar，再修改 bar[1]。</li>
</ol>
<p>最终的foo和bar的结果是什么呢? 是不是和想象的不太一样，这是因为切片操作的底层数组是同一个数组。foo 和 bar 的内存是共享的，所以，foo 和 bar 对数组内容的修改都会影响到对方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(foo)  &#x2F;&#x2F; res: [0 0 99 42 100]</span><br><span class="line">fmt.Println(bar)  &#x2F;&#x2F; res: [0 99 42]</span><br></pre></td></tr></table></figure></p>
<p>再来看一个 <code>append</code> 的例子。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">16</span>]</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印a</span></span><br><span class="line"><span class="comment">// 打印b</span></span><br></pre></td></tr></table></figure><br>在这段代码中，把 <code>a[1:16]</code> 的切片赋给 b ，此时，a 和 b 的内存空间是共享的，然后，对 a 做了一个 append()的操作，这个操作会让 a 重新分配内存，这就会导致 a 和 b 不再共享，如下图所示：<br><img src="https://static001.geekbang.org/resource/image/9a/13/9a29d71d309616f6092f6bea23f30013.png" style="max-width: 70%;border-radius: 6px"></p>
<p>这时 a 和 b 的值是多少？append()操作让 a 的容量变成了 64，而长度是 33。这里你需要重点注意一下，<strong>append()这个函数在 cap 不够用的时候，就会重新分配内存以扩大容量，如果够用，就不会重新分配内存了！</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(a)  &#x2F;&#x2F; res: [0 0 42 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]</span><br><span class="line">fmt.Println(b)  &#x2F;&#x2F; res: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>那既然这样相同的例子我们再来一遍，如果让a不要重新分配内存(比如初始化a的时候使用<code>a := make([]int, 33))</code>，那么b的结果就会变成 <code>[0 42 0 0 0 0 0 0 0 0 0 0 0 0 0]</code> <strong>注意</strong>：这时的b会因为<code>a[2]</code> 的变化而变化。</p>
<p>同样的例子如下，只要没有发生<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path := []<span class="keyword">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">	sepIndex := bytes.IndexByte(path,<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	dir1 := path[:sepIndex]</span><br><span class="line">	dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir1),<span class="built_in">cap</span>(dir1)) <span class="comment">// prints: len: 4 cap: 14</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir2),<span class="built_in">cap</span>(dir2)) <span class="comment">// prints: len: 9 cap: 14</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">	dir1 = <span class="built_in">append</span>(dir1,<span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; uffixBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子中，dir1 和 dir2 共享内存，虽然 dir1 有一个 append() 操作，但是因为 cap 足够，于是数据扩展到了dir2 的空间。下面是相关的图示（注意上图中 dir1 和 dir2 结构体中的 cap 和 len 的变化）：</p>
<p><img src="https://static001.geekbang.org/resource/image/17/aa/1727ca49dfe2e6a73627a52a899535aa.png" style="max-width: 70%;border-radius: 6px"></p>
<p>这里的 <code>dir1:=path[:sepIndex]</code> 没有触发重新分配内存，如果想要强行重新分配内存的话可以使用<code>dir1 := path[:sepIndex:sepIndex]</code> 最后一个参数叫“Limited Capacity”，于是，后续的 append() 操作会导致重新分配内存。</p>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface 接口是一个抽象概念，它支持Go中的<strong>多态</strong>。该接口的变量可以保存实现该类型的值。类型断言用于获取底层的具体值。接口也是给Go语言带来了无限扩展空间。其中 <code>io.Reader</code> 接口就是一个典型的例子，<strong>io.Reader</strong> 表示读取设备数据流的能力，可以从<a target="_blank" rel="noopener" href="https://golang.cafe/blog/golang-reader-example.html">网络、文件、字符串</a>等等。先简单介绍下 <code>io.Reader</code> 接口 ，后面会介绍如何使用接口式编程的方式封装 Reader 。</p>
<h3 id="接口式编程"><a href="#接口式编程" class="headerlink" title="接口式编程"></a>接口式编程</h3><p><a target="_blank" rel="noopener" href="https://golang.org/pkg/io/#Reader">io.Reader</a> interface 可以表示从实体中读取字节流。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即只要实现了 <code>Read(buf []byte) (n int, err error)</code> 方法便就是 <code>io.Reader</code> 接口。Read最多将 <code>len(buf)</code> 字节读入buf并返回读取的字节, 直到读到 <code>io.EOF</code> 时返回。标准库中实现了很多Reader的实现。并且很多应用程序都接受 <code>Reader</code> 作为输入。</p>
<ul>
<li><strong>直接从字节流中读取</strong></li>
</ul>
<p>这里分为 <code>Read</code>、 <code>io.ReadFull</code>、 <code>ioutil.ReadAll</code> 三种方法。每种方法都有一些区别。</p>
<ol>
<li>直接使用 Read 方法</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r := strings.NewReader(<span class="string">&quot;abcde&quot;</span>)</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	n, err := r.Read(buf)</span><br><span class="line">	fmt.Println(n, err, buf[:n])</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个字节流 <code>r</code>, 在循环从r中读取出数据。循环会执行3次，第一次读取4个字节，第二次读取1个字节，第三次读到 <code>io.EOF</code> 返回跳出循环。注意，Read方法读取时会清空 <code>buf</code> 里的数据，所以这里需要每次读完打印一下。再次读时，<code>buf</code> 里的数据会被重新覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 &lt;nil&gt; [97 98 99 100]</span><br><span class="line">1 &lt;nil&gt; [101]</span><br><span class="line">0 EOF []</span><br></pre></td></tr></table></figure>
<p>另外还可以使用 <code>io.ReadFull</code> 或者 <code>ioutil.ReadAll</code> 取读取字节流,<code>io.ReadFull</code>用法和<code>Read</code>差不多，<code>ioutil.ReadAll</code>不需要设置buf可直接返回buf。更多可参考：<a target="_blank" rel="noopener" href="https://yourbasic.org/golang/io-reader-interface-explained/">How to use the io.Reader interface
</a></p>
<ul>
<li><strong>利用接口特性</strong></li>
</ul>
<p>下面的代码是一个实时统计标准输入字符个数的代码。用户每次按下回车都可以看到当前输入的字符以及历史上已经输入的字符的个数。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountNumber</span><span class="params">(input <span class="keyword">chan</span> []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> data := <span class="keyword">range</span> input &#123;</span><br><span class="line">		count += <span class="built_in">len</span>(data)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> 	bytes := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>)</span><br><span class="line"> 	fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line"> 	<span class="keyword">go</span> CountNumber(bytes)</span><br><span class="line"> 	<span class="keyword">for</span> &#123;</span><br><span class="line">    	<span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">		_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">		bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，但是似乎和我们要讲到的接口式编程没什么关系。下面我们用接口封装一下。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCountReader</span><span class="params">()</span> *<span class="title">CountReader</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;CountReader&#123;</span><br><span class="line">		bytes: <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>),</span><br><span class="line">		data:  <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountReader <span class="keyword">struct</span> &#123;     <span class="comment">// 声明CountReader对象</span></span><br><span class="line">	bytes    <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line">	data     []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123; <span class="comment">// 实现Read方法</span></span><br><span class="line">	ok := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> ok &amp;&amp; <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line">		h.data, ok = &lt;-h.bytes   <span class="comment">// 将bytes里的数据全部传给 data</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !ok || <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, io.EOF    <span class="comment">// 可能读到了结尾</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l := <span class="built_in">copy</span>(p, h.data)</span><br><span class="line">	h.data = h.data[l:]</span><br><span class="line">	<span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := bufio.NewReader(h)</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">		n,err := b.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		count += <span class="built_in">len</span>(buf[:n])</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, buf)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先声明了一个结构体 <code>CountReader</code>, 再实现了一个 <code>Read()</code> 方法调用，我们知道实现了<code>Read()</code>即可以成为 <code>io.Reader</code> 接口的实现。也就是说 <code>CountReader</code> 就是一个 <code>io.Reader</code> ，那么 <code>io.Reader</code> 可以使用的方法，也可以给 <code>CountReader</code> 使用。这时就可以使用 <code>bufio</code> 这个库了。使用 <code>bufio.NewReader</code> 的函数对输入数据进行读取和计算。</p>
<p class="div-border yellow"><code>bufio.NewReader()</code> 方法提供一个缓存buf, 默认缓存4k buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。</p>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line">	Counter := NewCountReader()</span><br><span class="line">	<span class="keyword">go</span> Counter.run()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">		_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">		Counter.bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来通过上述代码即可完成相同的操作，这只是一个简单的例子，如果换成文件io、网络io就会有非常可观的收益。带来业务性能的提升。</p>
<h1 id="Functional-Option"><a href="#Functional-Option" class="headerlink" title="Functional Option"></a>Functional Option</h1><p>Functional Options 这个编程模式是一个函数式编程的应用案例，编程技巧也很好，是目前 Go 语言中最流行的一种编程模式。</p>
<p>假设实际编程中需要针对业务对象设置很多属性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr     <span class="keyword">string</span></span><br><span class="line">    Port     <span class="keyword">int</span></span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    MaxConns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 Server 对象中，我们可以看到：</p>
<ul>
<li>要设置侦听的 IP 地址 Addr 和端口号 Port。（必填）</li>
<li>协议、超时时间、最大链接数、TLS选项等属性需要配置。（非必填）</li>
</ul>
<p>那么如何让调用方实现这个必填参数和非必填参数呢？一个方法是将非必填参数设成 <code>...interface&#123;&#125;</code> 但这样肯定不好，因为不同的参数类型都不一样。另一种方式就是将 必填参数和非必填参数分开了。</p>
<p>如非必填参数搞成一个结构体</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    Maxconns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必填参数和这个 <code>Config</code> 直接传给初始化函数，如果没有要填的参数可以将 <code>Config</code> 设为 <code>nil</code> 。</p>
<p>这样一来 <code>Server</code> 结构体便成了这样, 初始化</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Conf *Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, conf *Config)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using the default configuratrion</span></span><br><span class="line">srv1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="literal">nil</span>) </span><br><span class="line"></span><br><span class="line">conf := ServerConfig&#123;Protocol:<span class="string">&quot;tcp&quot;</span>, Timeout: <span class="number">60</span>*time.Duration&#125;</span><br><span class="line">srv2, _ := NewServer(<span class="string">&quot;locahost&quot;</span>, <span class="number">9000</span>, &amp;conf)</span><br></pre></td></tr></table></figure>
<p>这样便已经是大多数人的作法了。但是不是没有修改空间，下面介绍一下 Functional Option 方式。</p>
<h2 id="初始化-Server-示例"><a href="#初始化-Server-示例" class="headerlink" title="初始化 Server 示例"></a><strong>初始化 Server 示例</strong></h2><p>首先我们定义一个 <code>Option</code> 类型:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span></span></span><br></pre></td></tr></table></figure>
<p>用函数式方式定义一组函数。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Protocol = p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Timeout = timeout</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxConns</span><span class="params">(maxconns <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.MaxConns = maxconns</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TLS</span><span class="params">(tls *tls.Config)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.TLS = tls</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这组代码的含义是传入一个参数，返回一个函数，函数会将 <code>Server</code> 结构的对应参数值进行设置。例如，当我们调用其中的一个函数 MaxConns(30) 时，其返回值是一个 func(s* Server) { s.MaxConns = 30 } 的函数。</p>
<p>这下，我们可以定义一个 <code>NewServer</code> 函数，其中有一个可变参数 <code>option</code> ,用一个循环来设置 Server 的属性。不仅提供了默认值，还提供将默认值改成可修改选项进行修改。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...<span class="keyword">func</span>(*Server)</span>) <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  srv := Server&#123;</span><br><span class="line">    Addr:     addr,</span><br><span class="line">    Port:     port,</span><br><span class="line">    Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">    Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">    MaxConns: <span class="number">1000</span>,</span><br><span class="line">    TLS:      <span class="literal">nil</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">    option(&amp;srv)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，我们在创建 Server 对象的时候，就可以像下面这样：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">1024</span>)</span><br><span class="line">s2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">2048</span>, Protocol(<span class="string">&quot;udp&quot;</span>))</span><br><span class="line">s3, _ := NewServer(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8080</span>, Timeout(<span class="number">300</span>*time.Second), MaxConns(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<p>这下对 Server 的封装就像搭积木一样简单容易并且可视化很好。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">kiosk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://kiosk007.top/2021/01/30/GoLang-函数式编程/">http://kiosk007.top/2021/01/30/GoLang-函数式编程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=kiosk" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/21/HTTP3/"><i class="fa fa-chevron-left">  </i><span>HTTP/3</span></a></div><div class="next-post pull-right"><a href="/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/"><span>探索 Webtransport</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'XhYn8GEq1Sg7ufJQAVmR4dWN-gzGzoHsz',
  appKey:'r42k4lqU022wD7IvtwGaQfjN',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://img1.kiosk007.top/static/images/background_2.png)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By kiosk</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">京ICP备20015006号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://img1.kiosk007.top/static/js/utils.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fancybox.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/sidebar.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/copy.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fireworks.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/transition.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/scroll.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="https://img1.kiosk007.top/static/js/katex.js"></script><script src="https://img1.kiosk007.top/static/js/search/local-search.js"></script><script id="ribbon" src="https://img1.kiosk007.top/static/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zIndex="-1" data-click="true"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>