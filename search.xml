<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>QUIC 发生了什么</title>
    <url>/2021/07/24/QUIC-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从 HTTP/1.1（1999 年发布）到 HTTP/2 发布（2015 年发布）之间的发展差距很大，随着 2019 年 HTTP/3 的发布，HTTP/3 即将成为互联网上超文本传输协议的下一代协议，HTTP/3 是Google QUIC协议的演变。它与传统的 HTTP 有很大的不同。QUIC 是一种新的可靠传输协议，可以被视为一种下一代TCP。</p>
<a id="more"></a>
<p>QUIC 连接通过 UDP 端口和 IP 地址建立的，一旦建立，该连接就通过其“连接 ID”相关联（每个连接都拥有一组连接标识符或连接 ID，每个连接标识符都可用于识别连接）。</p>
<p>QUIC 提供 0-RTT 和 1-RTT 连接设置，所以建立新连接时，会比传统的 TCP + TLS 的组合要快许多。</p>
<h1 id="HTTP-的演变"><a href="#HTTP-的演变" class="headerlink" title="HTTP 的演变"></a>HTTP 的演变</h1><p>超文本传输协议 (HTTP) 是运行在 TCP/IP 之上的应用层协议，<br>HTTP 有 4 个稳定版本——HTTP/0.9、HTTP/1.0、HTTP/1.1 和 HTTP/2。在 2021年七月，市面上已经有 三分之二的浏览器支持了 HTTP/3 。</p>
<p>同年5月底，IETF：QUIC Version 1 (<a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-version-negotiation">RFC 9000</a>) 作为标准化版本现已发布，QUIC部署将从使用临时草案版本转向新创建的Version 1。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/http_protocol_versions.png"></p>
<h1 id="QUIC-从哪来"><a href="#QUIC-从哪来" class="headerlink" title="QUIC 从哪来"></a>QUIC 从哪来</h1><p>IETF 并不是从头开始研究 QUIC。2012 年，<a href="https://blog.chromium.org/2013/06/experimenting-with-quic.html">谷歌设计了自己的 QUIC 版本</a>， 随后 Chrome 浏览器及其Google的大部分服务相继支持QUIC，包括 Youtube 和 Google 搜索。</p>
<p>IETF QUIC 与 早期的 gQUIC 相比也已经有了比较大的变化，这里不妨列举几个。</p>
<ul>
<li>加密协商：谷歌 QUIC 是定制加密握手，而 IETF 是采用了 TLS1.3</li>
<li>分离：IETF QUIC 的层级是分明的，其上可以承载的应用层协议不止 HTTP 协议</li>
<li>头部压缩：gQUIC 沿用了HTTP2的 HPack，而IETF QUIC 使用的是QPACK。</li>
</ul>
<h1 id="QUIC-的版本"><a href="#QUIC-的版本" class="headerlink" title="QUIC 的版本"></a>QUIC 的版本</h1><p>目前有<a href="https://github.com/quicwg/base-drafts/wiki/Implementations">15种实验型QUIC</a>。【RFC9000 确定后，所有的QUIC版本会趋于统一】。但是这些实验性QUIC互操性比较差，因为各家的QUIC的实现标准不统一，对具体的一些功能实现存在diff。</p>
<p class="div-border yellow"> 数据截取于 2021.07</p>

<h2> <a href="https://github.com/aiortc/aioquic" aria-hidden="true" class="header-anchor">aioquic</a></h2>

<p>使用Python和asyncio的QUIC实现</p>
<blockquote>
<ul>
<li>Language: Python </li>
<li>Version: draft-29 through version 1(RCF 9000)</li>
<li>Handshake: TLS 1.3</li>
<li>Protocol IDs: <code>0xff00001d</code>, <code>0xff00001e</code>, <code>0xff00001f</code>, <code>0xff000020</code>, <code>0x1</code></li>
</ul>
</blockquote>
<h2> <a href="https://github.com/litespeedtech/lsquic" aria-hidden="true" class="header-anchor">Chromium</a></h2>

<p>Chromium的QUIC实现（chrome85.0.4171.0及更高版本支持draft-29）</p>
<blockquote>
<ul>
<li><strong>Languages</strong>: C, C++</li>
<li><strong>Versions</strong>: Q043, Q046, Q050, T050, T051, draft-27, draft-29.</li>
<li><strong>Handshakes</strong>: QUIC Crypto, TLS</li>
<li><strong>Protocol IDs</strong>: <code>Q043</code>, <code>Q046</code>, <code>Q050</code>, <code>T050</code>, <code>T051</code>, <code>0xff00001b</code>, <code>0xff00001d</code></li>
<li><strong>ALPNs</strong>: h3-Q043, h3-Q046, h3-Q050, h3-T050, h3-T051, h3-27, h3-29</li>
<li>Google将实现命名为“quiche”，但它与Cloudflare的Rust实现完全无关。</li>
</ul>
</blockquote>
<h2> <a href="https://github.com/litespeedtech/lsquic" aria-hidden="true" class="header-anchor">lsquic</a></h2>

<p>LiteSpeed QUIC和HTTP/3库。适用于Linux、FreeBSD、MacOS、Android和Windows。</p>
<blockquote>
<ul>
<li><strong>Language</strong>: C</li>
<li><strong>Version</strong>: v1, Draft-34, Draft-29, Draft-27, Q043, Q046, and Q050.</li>
<li><strong>Roles</strong>: Client, Server, Library</li>
<li><strong>Handshake</strong>: QUIC Crypto, RFC 8446</li>
<li><strong>Protocol</strong> IDs: <code>0x00000001</code>, <code>0xFF000022</code>, <code>0xFF00001D</code>, <code>0xFF00001B</code></li>
</ul>
</blockquote>
<p>当前互联网上的<a href="https://quic.netray.io/stats.html">QUIC流量</a>，draft-29 和 Version 1 版本 的量级在逐渐上升。国内的一些大厂也在使用QUIC来作为当前主要的流量接入，比如微信的视频号就使用 gQUIC 43 、快手也宣布了线上的<a href="https://www.infoq.cn/article/41HJkeZM7hEgIYlJRFK0">千万级QUIC计划</a>。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_version.png"></p>
<p>相信今年的 RFC9000 推出 QUICv1 版本后，QUIC的互操性能得到更广泛的运用。当前各大版本实现的<a href="https://interop.seemann.io/">QUIC互操性</a>能得到进一步的提升。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_interop.png"></p>
<h1 id="QUIC-实验"><a href="#QUIC-实验" class="headerlink" title="QUIC 实验"></a>QUIC 实验</h1><p>当前的QUIC 版本很多，支持的比较完整的是 Chromium 和 lsquic 。</p>
<p>下面将以 <a href="https://github.com/litespeedtech/lsquic">lsquic</a> 为例，实际剖析一下QUIC。</p>
<p>目前支持的QUIC版本有v1、Internet draft-27 和 draft-29, 包括老一些的Google QUIC 版本 <code>Q043</code> 、<code>Q046</code> 和 <code>Q050</code> 。</p>
<p>相关文档: <a href="https://lsquic.readthedocs.io/en/latest/">https://lsquic.readthedocs.io/en/latest/</a></p>
<p>要构建LSQUIC，需要CMake、zlib和BoringSSL。</p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><ul>
<li>Building BoringSSL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 国内可用 git clone https://github.com/google/boringssl.git</span></span><br><span class="line">git <span class="built_in">clone</span> https://boringssl.googlesource.com/boringssl</span><br><span class="line"><span class="built_in">cd</span> boringssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到特殊版本</span></span><br><span class="line">git checkout a2278d4d2cabe73f6663e3299ea7808edfa306b9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 </span></span><br><span class="line">cmake . &amp;&amp;  make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录当前位置</span></span><br><span class="line">BORINGSSL=<span class="variable">$PWD</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Building LSQUIC Library</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：测试程序由 libevent 驱动，测试程序需要先装 libevent-dev</span></span><br><span class="line">sudo apt-get install libevent-dev</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/litespeedtech/lsquic.git</span><br><span class="line"><span class="built_in">cd</span> lsquic</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Statically:</span></span><br><span class="line"><span class="comment"># $BORINGSSL is the top-level BoringSSL directory from the previous step</span></span><br><span class="line">cmake -DBORINGSSL_DIR=<span class="variable">$BORINGSSL</span> .</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># As a dynamic library:</span></span><br><span class="line">cmake -DLSQUIC_SHARED_LIB=1 -DBORINGSSL_DIR=<span class="variable">$BORINGSSL</span> .</span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>demo</li>
</ul>
<p>quic 的 demo 在 $lsquic_pwd/bin 目录下, 我们实验用就用 <code>http_client</code> 吧。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>先看看 <code>http_client</code> 支持的几个命令行参数.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./http_client -<span class="built_in">help</span> </span><br><span class="line">Usage: http_client [opts]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">   -p PATH     Path to request.  May be specified more than once.  If no</span><br><span class="line">                 path is specified, the connection is closed as soon as</span><br><span class="line">                 handshake succeeds.</span><br><span class="line">   -n CONNS    Number of concurrent connections.  Defaults to 1.</span><br><span class="line">   -r NREQS    Total number of requests to send.  Defaults to 1.</span><br><span class="line">   -R MAXREQS  Maximum number of requests per single connection.  Some</span><br><span class="line">                 connections will have fewer requests than this.</span><br><span class="line">   -w CONCUR   Number of concurrent requests per single connection.</span><br><span class="line">                 Defaults to 1.</span><br><span class="line">   -M METHOD   Method.  Defaults to GET.</span><br><span class="line">   -P PAYLOAD  Name of the file that contains payload to be used <span class="keyword">in</span> the</span><br><span class="line">                 request.  This adds two more headers to the request:</span><br><span class="line">                 content-type: application/octet-stream and</span><br><span class="line">                 content-length</span><br><span class="line">   -K          Discard server response</span><br><span class="line">   -I          Abort on incomplete reponse from server</span><br><span class="line">   -4          Prefer IPv4 when resolving hostname</span><br><span class="line">   -6          Prefer IPv6 when resolving hostname</span><br><span class="line">   -C DIR      Certificate store.  If specified, server certificate will</span><br><span class="line">                 be verified.</span><br><span class="line">   -a          Display server certificate chain after successful handshake.</span><br><span class="line">   -b N_BYTES  Send RESET_STREAM frame after the client has <span class="built_in">read</span> n bytes.</span><br><span class="line">   -t          Print stats to stdout.</span><br><span class="line">   -T FILE     Print stats to FILE.  If FILE is -, <span class="built_in">print</span> stats to stdout.</span><br><span class="line">   -q FILE     QIF mode: issue requests from the QIF file and validate</span><br><span class="line">                 server responses.</span><br><span class="line">   -e TOKEN    Hexadecimal string representing resume token.</span><br><span class="line">   -3 MAX      Close stream after reading at most MAX bytes.  The actual</span><br><span class="line">                 number of bytes <span class="built_in">read</span> is randominzed.</span><br><span class="line">   -9 SPEC     Priority specification.  May be specified several <span class="built_in">times</span>.</span><br><span class="line">                 SPEC takes the form stream_id:nread:UI, <span class="built_in">where</span> U is</span><br><span class="line">                 urgency and I is incremental.  Matched \d+:\d+:[0-7][01]</span><br><span class="line">   -7 DIR      Save fetched resources into this directory.</span><br><span class="line">   -Q ALPN     Use hq ALPN.  Specify, <span class="keyword">for</span> example, <span class="string">&quot;h3-29&quot;</span>.</span><br><span class="line">   -0 FILE     Provide session resumption file (reading or writing)</span><br><span class="line">   -s SVCPORT  Service port.  Takes on the form of host:port, host,</span><br><span class="line">                 or port.  If host is not an IPv4 or IPv6 address, it is</span><br><span class="line">                 resolved.  If host is not <span class="built_in">set</span>, the value of SNI is</span><br><span class="line">                 used (see the -H flag).  If port is not <span class="built_in">set</span>, the default</span><br><span class="line">                 is 443.</span><br><span class="line">                 Examples:</span><br><span class="line">                     127.0.0.1:12345</span><br><span class="line">                     ::1:443</span><br><span class="line">                     example.com</span><br><span class="line">                     example.com:8443</span><br><span class="line">                     8443</span><br><span class="line">                 If no -s option is given, 0.0.0.0:12345 address</span><br><span class="line">                 is used.</span><br><span class="line">   -D          Do not <span class="built_in">set</span> <span class="string">&#x27;do not fragment&#x27;</span> flag on outgoing UDP packets</span><br><span class="line">   -z BYTES    Maximum size of outgoing UDP packets (client only).</span><br><span class="line">                 Overrides -o base_plpmtu.</span><br><span class="line">   -L LEVEL    Log level <span class="keyword">for</span> all modules.  Possible values are `debug<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                 `info&#x27;</span>, `notice<span class="string">&#x27;, `warn&#x27;</span>, `error<span class="string">&#x27;, `alert&#x27;</span>, `emerg<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                 and `crit&#x27;</span>.</span><br><span class="line">   -l LEVELS   Log levels <span class="keyword">for</span> modules, e.g.</span><br><span class="line">                 -l event=info,engine=debug</span><br><span class="line">               Can be specified more than once.</span><br><span class="line">   -m MAX      Maximum number of outgoing packet buffers that can be</span><br><span class="line">                 assigned at any one time.  By default, there is no max.</span><br><span class="line">   -y style    Timestamp style used <span class="keyword">in</span> <span class="built_in">log</span> messages.  The following styles</span><br><span class="line">                 are supported:</span><br><span class="line">                   0   No timestamp</span><br><span class="line">                   1   Millisecond time (this is the default).</span><br><span class="line">                         Example: 11:04:05.196</span><br><span class="line">                   2   Full date and millisecond time.</span><br><span class="line">                         Example: 2017-03-21 13:43:46.671</span><br><span class="line">                   3   Chrome-like timestamp: date/time.microseconds.</span><br><span class="line">                         Example: 1223/104613.946956</span><br><span class="line">                   4   Microsecond time.</span><br><span class="line">                         Example: 11:04:05.196308</span><br><span class="line">                   5   Full date and microsecond time.</span><br><span class="line">                         Example: 2017-03-21 13:43:46.671345</span><br><span class="line">   -S opt=val  Socket options.  Supported options:</span><br><span class="line">                   sndbuf=12345    <span class="comment"># Sets SO_SNDBUF</span></span><br><span class="line">                   rcvbuf=12345    <span class="comment"># Sets SO_RCVBUF</span></span><br><span class="line">   -W          Use stock PMI (malloc &amp; free)</span><br><span class="line">   -g          Use sendmmsg() to send packets.</span><br><span class="line">   -j          Use recvmmsg() to receive packets.</span><br><span class="line">   -H host     Value of `host<span class="string">&#x27; HTTP header.  This is also used as SNI</span></span><br><span class="line"><span class="string">                 in Client Hello.  This option is used to override the</span></span><br><span class="line"><span class="string">                 `host&#x27;</span> part of the address specified using -s flag.</span><br><span class="line">   -G dir      SSL keys will be logged to files <span class="keyword">in</span> this directory.</span><br><span class="line">   -k          Connect UDP socket.  Only meant to be used with clients</span><br><span class="line">                 to pick up ICMP errors.</span><br><span class="line">   -i USECS    Clock granularity <span class="keyword">in</span> microseconds.  Defaults to 1000.</span><br><span class="line">   -h          Print this <span class="built_in">help</span> screen and <span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="QUIC-发生了什么"><a href="#QUIC-发生了什么" class="headerlink" title="QUIC 发生了什么"></a>QUIC 发生了什么</h1><p>lsquic 提供了测试网站 <code>www.litespeedtech.com</code>，我们用下面的命令行工具访问这个网站, 并使用Wireshark 抓包和 <a href="https://zhuanlan.zhihu.com/p/151858528">qlog 去解析QUIC</a>，探索一些QUIC究竟发生了什么。</p>
<p class="div-border green">Wireshark （3.4.2）已经支持了解析 IETF QUIC，加载秘钥的方法参考 <a href="https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/">Wireshark Tutorial: Decrypting HTTPS Traffic
</a></p>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定版本。默认是使用 Version 1 版本 </span></span><br><span class="line">$ http_client -H www.litespeedtech.com:443 -p /  -G . -o version=h3-29</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当前目录下会生成一个 sslkeylog <code>F9CE5E3D598B8D80.keys</code>，wireshark 导入，注意<a href="https://github.com/quicwg/base-drafts/wiki/Tools#wireshark">Wireshark 要装最新版本（当前是 3.4.2）</a>。</p>
<blockquote>
<p>注意： Wireshark 本身无法解密 GQUIC 数据包，即使已配置NSS Keylogging。</p>
</blockquote>
<p class="div-border green">更多QUIC debug or 可视化工具参考: https://github.com/quicwg/base-drafts/wiki/Tools </p>

<p>抓包内容如下：<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_capture_handshake.png"></p>
<p><strong>这里再介绍一下HTTP3的分层结构。</strong></p>
<p>一个 HTTP3 包会按照以下方式分层。实时上 QUIC 已经完全可以理解为一个传输层协议了，QUIC的实现也是和HTTP协议分离的，正如 RFC 9000 所描述的。“<a href="https://www.rfc-editor.org/rfc/rfc9000.html#section-1-2">QUIC 是一种面向连接的协议，它在客户端和服务器之间创建有状态的交互。</a>”</p>
<p class="div-border blue"> <a href="https://github.com/lucas-clemente/quic-go/blob/master/example/echo/echo.go">  quic-go 的 echo 示例 </a> 也在其示例代码中提供了QUIC层的demo `session.OpenStreamSync(context.Background())` </p>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UDP Header</span><br><span class="line">Packet Header     -----</span><br><span class="line">QUIC Frame Header    --  TLS1.3</span><br><span class="line">HTTP3 Frame Header   --   </span><br><span class="line">HTTP Message      -----</span><br></pre></td></tr></table></figure>
<h2 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h2><p>Packet Header实现了可靠的连接。当UDP报文丢失后，通过Packet Header中的Packet Number实现报文重传。连接也是通过其中的Connection ID字段定义的</p>
<p>这里会有两种 Header 类型，<strong>Long Header</strong> 和 <strong>Short Header</strong>。Long Header 用于初始化交换 直到 可以1RTT可以被激动和版本协商完成。Short Header 用于承载数据。</p>
<ul>
<li><strong>Long Header</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|S|Typ|  Next   |              Magic <span class="string">&quot;uic&quot;</span>/<span class="string">&quot;UIC&quot;</span>                |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                         Connection ID                         +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            Version                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Packet Number                         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       [Header Extensions]                   ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Payload                           ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>建立连接时，连接是由服务器通过Source Connection ID字段分配的，这样，后续传输时，双方只需要固定住Destination Connection ID，就可以在客户端IP地址、端口变化后，绕过UDP四元组（与TCP四元组相同），实现连接迁移功能。如下图，后续的DCID和SCID都会统一为 <code>752566b9c5e2b77a</code></p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_connection_id.png"></p>
<ul>
<li><strong>Short Header</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|S|K|                Packet Number (30)                         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                         Connection ID                         +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>Packet Number是每个报文独一无二的序号，基于它可以实现丢失报文的精准重发。</p>
<p>参考: <a href="https://gist.github.com/martinthomson/744d04cbcec9be554f2f8e7bae2715b8">martinthomson/quic_header.md</a></p>
<h2 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h2><p>在Packet Header之上的QUIC Frame Header, QUIC中的流为应用程序提供了轻量级的有序字节流抽象。流可以是单向的或双向的，而且Stream之间可以实现真正的并发。</p>
<p>所有的帧被包含在单独的QUIC Packet 中，且没有帧可以跨越QUIC Packet 边界。一个Packet报文中可以存放多个QUIC Frame，当然所有Frame的长度之和不能大于PMTUD（Path Maximum Transmission Unit Discovery，这是大于1200字节的值）, 一个QUIC Frame 也不允许跨Packet。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_frame1.png"></p>
<p>每一个QUIC Frame 都有明确的帧类型。</p>
<p>参考： <a href="https://quic.readthedocs.io/zh/latest/Frame%20Types%20and%20Formats.html">帧类型和格式</a></p>
<p class="div-border red"> 上述文档比较老，很多数据有变动，下面是结合 <a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-frames-and-frame-types"> RFC9000 </a> 的版本 </p>




<p>当前定义的<strong>普通帧类型</strong>如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+-----------------------+-----------------------------+------------+</span><br><span class="line">| Type-field value      |     Control Frame-type      |    Spec    |</span><br><span class="line">+-----------------------+-----------------------------+------------+</span><br><span class="line">| 00000000B (0x00)      |  PADDING                    |     NP     |</span><br><span class="line">| 00000001B (0x01)      |  PING                       |            |</span><br><span class="line">| 00000010B (0x02-0x03) |  ACK                        |     NC     |</span><br><span class="line">| 00000100B (0x04)      |  RESET_STREAM               |            |</span><br><span class="line">| 00000101B (0x05)      |  STOP_SENDING               |            |</span><br><span class="line">| 00000110B (0x06)      |  CRYPTO                     |            |</span><br><span class="line">| 00000111B (0x07)      |  NEW_TOKEN                  |            |</span><br><span class="line">| 00001000B (0x08-0x0F) |  STREAM                     |     F      |</span><br><span class="line">| 00010000B (0x10)      |  MAX_DATA                   |            |</span><br><span class="line">| 00010001B (0x11)      |  MAX_STREAM_DATA            |            |</span><br><span class="line">| 00001100B (0x12-0x13) |  MAX_STREAMS                |            |</span><br><span class="line">| 00001110B (0x14)      |  DATA_BLOCKED               |            |</span><br><span class="line">| 00001111B (0x15)      |  STREAM_DATA_BLOCKED        |            |</span><br><span class="line">| 00010000B (0x16-0x17) |  STREAMS_BLOCKED            |            |</span><br><span class="line">| 00010010B (0x18)      |  NEW_CONNECTION_ID	      |     P      |</span><br><span class="line">| 00010011B (0x19)      |  RETIRE_CONNECTION_ID       |            |</span><br><span class="line">| 00010100B (0x1a)      |  PATH_CHALLENGE             |     P      |</span><br><span class="line">| 00010101B (0x1b)      |  PATH_RESPONSE              |     P      |</span><br><span class="line">| 00010110B (0x1c-0x1d) |  CONNECTION_CLOSE           |     N      |</span><br><span class="line">| 00011000B (0x1e)      |  HANDSHAKE_DONE             |            |</span><br><span class="line">+-----------------------+-----------------------------+------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三列 SPEC 规定了该帧的一些特殊用法<br>N : 该类帧不会被ACK<br>C : 出于拥塞控制目的,该类型帧不会被计入飞行中的字节数<br>P : 该类型帧的数据包可用于在连接迁移期间探测新的网络路径<br>F : 该类型帧用于流控</p>
</blockquote>
<ul>
<li><strong>PADDING 帧</strong>：PADDING帧使用0x00字节填充一个包。当遇到该帧时，包的剩余部分需要被填充字节。 该帧包含0x00字节并扩展至QUIC包的末端。</li>
<li><strong>PING 帧</strong>：PING帧用来验证对端是否仍然存活。PING帧不包含载荷。 PING帧的接收方只需要应答（ACK）包含该帧的包。 PING帧应该被用于当一条流被打开时，保持连接存活。 默认是30s</li>
<li><strong>ACK 帧</strong>: 发送ACK帧以通知对端已经接收了哪些分组，以及接收方仍然认为丢失了哪些分组（可能需要重新发送丢失分组的内容）。<ul>
<li>如果帧类型为0x02：普通的ACK应答作用</li>
<li>如果帧类型为0x03：则ACK帧还包含在此点之前在连接上接收到的具有相关ECN标记的QUIC数据包的累积计数。如果发送的数据包启用了ECN，则应使用ECN部分中的信息来管理拥塞状态</li>
</ul>
</li>
<li><strong>RST_STREAM 帧</strong>：RST_STREAM帧允许异常终止一条流。当这个帧是流的创建者发出的，表示创建者希望取消这条流。 当接收端发送这个帧，表示有错误或者当前接收端不希望接收这个流，因此这个流应该被关闭。</li>
<li><strong>STOP_SENDING 帧</strong>：请求对等方停止流上的传输.</li>
<li><strong>CRYPTO 帧</strong>：用于传输加密握手消息，加密帧在功能上与STREAM帧相同,但是不受流控。加密帧上传输 TLS 握手细信息。</li>
<li><strong>NEW_TOKEN 帧</strong>：为客户端提供一个令牌，以便用于之后的链接0-RTT。</li>
<li><strong>STREAM 帧</strong> : STREAM帧同时被用于隐式地创建流和在流上发送数据。STREAM帧中的类型字段的格式为0B00001xxx（或0x08到0x0f的一组值）,帧类型的三个低阶位确定帧中存在的字段。流可以是单向的，也可以是双向的，对于连接上的所有流都是唯一的。流低2位可标识是客户端还是服务端发起的单向流或双向流。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bits	Stream Type</span><br><span class="line">0x00	Client-Initiated, Bidirectional</span><br><span class="line">0x01	Server-Initiated, Bidirectional</span><br><span class="line">0x02	Client-Initiated, Unidirectional</span><br><span class="line">0x03	Server-Initiated, Unidirectional</span><br></pre></td></tr></table></figure></li>
<li><strong>MAX_DATA 帧</strong>：用于流控,用于通知对端整个连接上可发送的最大数据量。</li>
<li><strong>MAX_STREAM_DATA 帧</strong>：用于流控，用于通知对端流上可发送的最大数据量。</li>
<li><strong>MAX_STREAMS 帧</strong>：通知对等端允许打开的给定类型的流的最大数。<ul>
<li>0x12 的MAX_STREAM适用于双向流</li>
<li>0x13 的MAX_STREAM适用于单向流</li>
</ul>
</li>
<li><strong>DATA_BLOCKED 帧</strong>：BLOCKED帧用于向远端指明本端点已经准备好发送数据了（且有数据要发送）， 但是当前被流量控制阻塞了。这是一个纯粹的信息帧，它对于调试极其有用。 BLOCKED帧的接收者应该简单的丢弃它（可能在打印了一条有帮助的log消息之后）</li>
<li><strong>STREAM_DATA_BLOCKED 帧</strong>：当发送方希望发送数据但由于流级流控制而无法发送数据时，发送方应发送 STREAM_DATA_BLOCKED。</li>
<li><strong>STREAMS_BLOCKED 帧</strong>：当发送方希望打开流，但由于其对等方设置的最大流限制而无法打开流时，发送方应发送STREAMS_BLOCKED,<ul>
<li>0x16 的STREAMS_BLOCKED适用于双向流</li>
<li>0x17 的STREAMS_BLOCKED适用于单向流</li>
</ul>
</li>
<li><strong>NEW_CONNECTION_ID 帧</strong>：发送一个新的 NEW_CONNECTION_ID 帧, 为其对端提供可用于在迁移连接时中断可链接性的替代连接ID</li>
<li><strong>RETIRE_CONNECTION_ID 帧</strong>: 一端发送 RETIRE_CONNECTION_ID 表示不再使用对端发送的CONNECTION ID ，包含握手时确定的 连接id，后续可以发送新的 CONNECTION ID 再。</li>
<li><strong>PATH_CHALLENGE 帧</strong>：来检查对等方的可达性，并在连接迁移期间进行路径验证</li>
<li><strong>PATH_RESPONSE 帧</strong>: PATH_CHALLENGE 的响应帧</li>
<li><strong>CONNECTION_CLOSE 帧</strong>：CONNECTION_CLOSE帧用来通知连接将被关闭。如果流仍然有数据在发送，那么在连接关闭时， 这些流将被隐式关闭。</li>
<li><strong>HANDSHAKE_DONE 帧</strong>：向客户端发送握手确认信号。</li>
</ul>
<h2 id="HTTP3-Frame-Header"><a href="#HTTP3-Frame-Header" class="headerlink" title="HTTP3 Frame Header"></a>HTTP3 Frame Header</h2><p>QUIC 的 STREAM 帧是实际承载流量的帧。自然也是 <a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html#name-reserved-frame-types">HTTP3 协议</a>的承载。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_stream_frame.png"> </p>
<p>Stream Frame头部的3个字段，完成了多路复用、有序字节流以及报文段层面的二进制分隔功能</p>
<ul>
<li><strong>Stream ID</strong> 标识了一个有序字节流。当HTTP Body非常大，需要跨越多个Packet时，只要在每个Stream Frame中含有同样的Stream ID，就可以传输任意长度的消息。多个并发传输的HTTP消息，通过不同的Stream ID加以区别</li>
<li>消息序列化后的“有序”特性，是通过Offset字段完成的，它类似于TCP协议中的Sequence序号，用于实现Stream内多个Frame间的累计确认功能；</li>
<li>Length指明了Frame数据的长度。</li>
</ul>
<p>HTTP3 的Frame 继承了 HTTP2 的Frame 设计。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Frame         Control Stream	Request Stream	Push Stream	</span><br><span class="line">DATA          No                Yes               Yes	</span><br><span class="line">HEADERS       No                Yes               Yes	</span><br><span class="line">CANCEL_PUSH   Yes               No                No	</span><br><span class="line">SETTINGS      Yes              (1)                No	</span><br><span class="line">PUSH_PROMISE  No                Yes               No	</span><br><span class="line">GOAWAY        Yes               No                No	</span><br><span class="line">MAX_PUSH_ID   Yes               No                No	</span><br><span class="line">Reserved      Yes               Yes               Yes	</span><br></pre></td></tr></table></figure>
<p>QUIC Stream Frame定义了有序字节流，且多个Stream间的传输没有时序性要求，这样，HTTP消息基于QUIC Stream就实现了真正的多路复用，队头阻塞问题自然就被解决掉了。</p>
<p><strong>HTTP Header头部的编码方式，它需要面对另一种队头阻塞问题</strong></p>
<p>与HTTP2中的HPACK编码方式相似，HTTP3中的QPACK也采用了静态表、动态表及Huffman编码：</p>
<p>在HTTP2中，共有61个静态表项,而在QPACK中，则上升为98个静态表项, 比如 qpack 的golang 实现中的 <code>staticTableEntries</code> 所示。可以从<a href="https://github.com/marten-seemann/qpack/blob/master/static_table.go">这里</a>找到 HTTP3 的完整静态表</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/qpack.png"></p>
<p>相较于HTTP3的静态表，和HTTP2协议其实并没有特别大的变化。但动态表编解码方式差距很大。</p>
<p>所谓动态表，就是将未包含在静态表中的Header项，在其首次出现时加入动态表，这样后续传输时仅用1个数字表示，大大提升了编码效率。因此，动态表是天然具备时序性的，如果首次出现的请求出现了丢包，后续请求解码HPACK头部时，一定会被阻塞！</p>
<p>事实上，QPACK将动态表的编码、解码独立在单向Stream中传输，仅当单向Stream中的动态表编码成功后，接收端才能解码双向Stream上HTTP消息里的动态表索引。</p>
<p>因此，当Stream ID是0、4、8、12时，这就是客户端发起的双向Stream（HTTP3不支持服务器发起双向Stream），它用于传输HTTP请求与响应。单向Stream有很多用途，所以它在数据前又多出一个Stream Type字段：</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_stream_type.png"></p>
<p>Stream Type有以下取值：</p>
<ul>
<li>0x00：控制Stream，传递各类Stream控制消息；</li>
<li>0x01：服务器推送消息；</li>
<li>0x02：用于编码QPACK动态表，比如面对不属于静态表的HTTP请求头部，客户端可以通过这个Stream发送动态表编码；</li>
<li>0x03：用于通知编码端QPACK动态表的更新结果。</li>
</ul>
<p>由于HTTP3的STREAM之间是乱序传输的，因此，若先发送的编码Stream后到达，双向Stream中的QPACK头部就无法解码，此时传输HTTP消息的双向Stream就会进入Block阻塞状态（两端可以通过控制帧定义阻塞Stream的处理方式）。</p>
<p>QPack 在编解码原理上和 HPack 没有本质区别。从 <a href="https://github.com/marten-seemann/qpack">QPACK</a> 的代码中可以看出，其内部完全是套了一层 HAPCK 的实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteField encodes f into a single Write to e&#x27;s underlying Writer.</span></span><br><span class="line"><span class="comment">// This function may also produce bytes for the Header Block Prefix</span></span><br><span class="line"><span class="comment">// if necessary. If produced, it is done before encoding f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encoder)</span> <span class="title">WriteField</span><span class="params">(f HeaderField)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// write the Header Block Prefix</span></span><br><span class="line">	<span class="keyword">if</span> !e.wrotePrefix &#123;</span><br><span class="line">		e.buf = appendVarInt(e.buf, <span class="number">8</span>, <span class="number">0</span>)</span><br><span class="line">		e.buf = appendVarInt(e.buf, <span class="number">7</span>, <span class="number">0</span>)</span><br><span class="line">		e.wrotePrefix = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	idxAndVals, nameFound := encoderMap[f.Name]</span><br><span class="line">	<span class="keyword">if</span> nameFound &#123;</span><br><span class="line">		<span class="keyword">if</span> idxAndVals.values == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(f.Value) == <span class="number">0</span> &#123;</span><br><span class="line">				e.writeIndexedField(idxAndVals.idx)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				e.writeLiteralFieldWithNameReference(&amp;f, idxAndVals.idx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			valIdx, valueFound := idxAndVals.values[f.Value]</span><br><span class="line">			<span class="keyword">if</span> valueFound &#123;</span><br><span class="line">				e.writeIndexedField(valIdx)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				e.writeLiteralFieldWithNameReference(&amp;f, idxAndVals.idx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		e.writeLiteralFieldWithoutNameReference(f)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e.w.Write(e.buf)</span><br><span class="line">	e.buf = e.buf[:<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="QUIC-Feature"><a href="#QUIC-Feature" class="headerlink" title="QUIC Feature"></a>QUIC Feature</h1><h2 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0 RTT"></a>0 RTT</h2><p>使用 0-RTT 取决于客户端和服务器使用从先前连接协商的协议参数。为了启用 0-RTT, 客户端将服务器传输参数与它在连接上收到的 session tickets 一起存储, 另外还存储应用程序或加密握手所需的信息。</p>
<p>和握手相关的报头都是长报头(<code>Long Packet</code>) 。分别是 <strong><code>Initial (0x00)</code></strong>、<strong><code>0-RTT    (0x01)</code></strong>、<strong><code>Handshake (0x02)</code></strong>、<strong><code>Retry (0x03)</code></strong>。</p>
<ul>
<li><code>CRYPTO</code> 帧可以在不同的数据包编号空间（packet number spaces）中发送。CRYPTO 帧使用偏移量（offsets）来确保加密握手数据的有序传递的在每个包编号空间（packet number spaces）都是从零开始。</li>
</ul>
<p><strong>握手流程示例</strong></p>
<ol>
<li>QUIC 在握手前会先进行地址验证（Address Validation），确保请求包里面的源地址不是伪造的。</li>
<li>一旦地址验证交换完成，就可以使用加密握手来获取加密密钥。加密握手通过初始（Initial）和握手（Handshake）包进行传输。</li>
<li>下图展示了 1-RTT 握手的示例。每行显示一个 QUIC 包（packet），首先显示包类型（type）和包编号（number），然后是帧（frames）。例如，第一个包是 Initial 类型，包编号为 0，并且包含一个携带 ClientHello（缩写：CH） 的 CRYPTO 帧。</li>
<li>多个 QUIC 数据包（即便是不同的类型）也可以合并成一个单独的 UDP 数据报（datagram）。因此，下图所示的 1-RTT 握手可以由 4 个UDP数据报（datagrams）组成。如果受协议固有的限制（如拥塞控制（congestion control）和反放大（anti-amplification））也可以使用更多的数据报。</li>
</ol>
<ul>
<li>1 - RTT</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[0]</span><br><span class="line">                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]</span><br><span class="line">                                 &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;]</span><br><span class="line"></span><br><span class="line">Initial[1]: ACK[0]</span><br><span class="line">Handshake[0]: CRYPTO[FIN], ACK[0]</span><br><span class="line">1-RTT[0]: STREAM[0, &quot;...&quot;], ACK[0] -&gt;</span><br><span class="line"></span><br><span class="line">                                          Handshake[1]: ACK[0]</span><br><span class="line">         &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, &quot;...&quot;], ACK[0]</span><br></pre></td></tr></table></figure>
<ul>
<li>0 - RTT</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH]</span><br><span class="line">0-RTT[0]: STREAM[0, &quot;...&quot;] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[0]</span><br><span class="line">                                  Handshake[0] CRYPTO[EE, FIN]</span><br><span class="line">                          &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;] ACK[0]</span><br><span class="line"></span><br><span class="line">Initial[1]: ACK[0]</span><br><span class="line">Handshake[0]: CRYPTO[FIN], ACK[0]</span><br><span class="line">1-RTT[1]: STREAM[0, &quot;...&quot;] ACK[0] -&gt;</span><br><span class="line"></span><br><span class="line">                                          Handshake[1]: ACK[0]</span><br><span class="line">         &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, &quot;...&quot;], ACK[1]</span><br></pre></td></tr></table></figure>
<p>如下是取自于 qvis的 1-RTT 握手请求。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/qvis_quictools_info.png"></p>
<h2 id="地址验证（Address-Validation）"><a href="#地址验证（Address-Validation）" class="headerlink" title="地址验证（Address Validation）"></a>地址验证（Address Validation）</h2><p>地址验证主要是用于确保端点（endpoint）不能被用于流量放大攻击（traffic amplification attack）。攻击者如果伪造数据包的源地址为受害者的地址，发送大量的数据包给服务端，如果服务端没有进行地址验证，直接响应大量数据包给源地址（受害者），就会被攻击者利用、进行流量放大攻击。</p>
<p>QUIC 针对放大攻击的主要防御措施是验证端点（endpoint）是否能够在其声明的传输地址接收数据包。地址验证在<strong>连接建立（connection establishment）期间</strong>和 <strong>连接迁移（connection migration）期间</strong>进行。</p>
<ul>
<li>连接建立时，为了验证客户端的地址是否是攻击者伪造的，服务端会生成一个令牌（token）并通过重试包（Retry packet）响应给客户端。客户端需要在后续的初始包（Initial packet）带上这个令牌，以便服务端进行地址验证。</li>
<li>服务端可以在当前连接中通过 NEW_TOKEN 帧预先发布令牌，以便客户端在后续的新连接使用，这是 QUIC 实现 0-RTT 很重要的一个功能。</li>
<li>当我们的网络路径变化时（比如从蜂窝网络切换到 WIFI），QUIC 提供了连接迁移（connection migration）的功能来避免连接中断。QUIC 通过路径验证（Path Validation）验证网络新地址的可达性（reachability），防止在连接迁移中的地址是攻击者伪造的。</li>
</ul>
<p><strong>使用重试数据包（Retry Packets）验证地址</strong></p>
<p>在接收到客户端的初始数据包（Initial packet）后，服务端可以通过发送包含令牌（token）的重试数据包（Retry packet）来请求地址验证。客户端在接收到这个重试数据包（Retry packet）的令牌（token）之后，必须在该连接中后续所有初始数据包（Initial packet）中附上该令牌（token）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                                &lt;- Retry+Token</span><br><span class="line"></span><br><span class="line">Initial+Token[1]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[1]</span><br><span class="line">                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]</span><br><span class="line">                                 &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>后续的连接使用 NEW_TOKEN 帧的令牌（token）</strong></p>
<p>服务端可以在一次连接中向客户端提供地址验证令牌（token），该令牌可用于后续的连接。这对于 0-RTT 尤其重要，后续的新连接可以直接使用该令牌进行地址验证，而无需额外的 1-RTT。</p>
<p>服务端使用 NEW_TOKEN 帧向客户端提供地址验证令牌，该令牌可用于验证后续的连接。在后续的连接中，客户端在初始数据包（Initial packets）中包含该令牌，以提供地址验证。</p>
<p>重试数据包（Retry packet）中提供的令牌只能立即使用，不能用于后续连接的地址验证。而 NEW_TOKEN 帧生成的令牌可以在一个时间范围内使用，这个令牌应该有一个过期时间，可以是显式的过期时间，也可以是可用于动态计算过期时间的时间戳（timestamp）。服务端可以存储过期时间，也可以在令牌中以加密的形式包含它。</p>
<p>参考： <a href="https://zhuanlan.zhihu.com/p/290694322">跟坚哥学QUIC系列：地址验证（Address Validation)</a></p>
<h2 id="链接迁移"><a href="#链接迁移" class="headerlink" title="链接迁移"></a>链接迁移</h2><p>QUIC 使用连接ID（而不是 ip + port）来确保数据包的路由一致性。如果用户的 IP 发生变化时，比如从移动蜂窝 4G 网络切换到 WiFi，IP 地址会改变。而使用一个唯一的连接ID 可以确保用户的 IP 变化时业务请求依然能够被继续处理，不用重新建连，可以继续使用当前连接ID 路由数据包，因此 QUIC 可以通过这个特性支持连接迁移</p>
<p>QUIC 的数据包（packets）长报头（long header）包含两个连接ID：目标连接ID（Destination Connection ID）由数据包的接收者选择并用于提供一致的路由，源连接ID（Source Connection ID）用于对端（peer）响应时使用的目标连接ID（Destination Connection ID）。</p>
<p>在握手过程中，带有长报头的包用于建立两端（both endpoints）使用的连接ID。在处理第一个初始数据包（Initial packet）之后，每个端点使用其接收到的源连接ID（Source Connection ID）字段的值设置为后续数据包中的目标连接ID（Destination Connection ID）字段。</p>
<p>当客户端发送了一个初始包（Initial packet），而该客户端之前没有从服务端接收过初始数据包（Initial packet）或重试包（Retry packet），则客户端将用一个不可预测的值（长度至少为8字节）填充到目标连接ID字段。在从服务端接收到数据包之前，客户端必须对该连接中的所有数据包使用相同的目标连接ID值。</p>
<p>当第一次从服务端接收到初始（Initial）或重试（Retry）数据包时，客户端使用服务端提供的源连接ID作为后续数据包（包括任何 0-RTT 数据包）的目标连接ID。这意味着在建立连接的过程中，客户端可能需要两次更改它的目标连接ID字段：一次用于响应重试（Retry），一次用于响应来自服务端的初始数据包（Initial）。一旦客户端从服务端接收到有效的初始数据包，客户端必须丢弃它后续接收到的具有不同源连接ID的数据包。</p>
<p>服务端必须根据第一个接收到的初始数据包（Initial packet）的源连接ID，设置为用于发送数据包的目标连接ID。后续只有当接收到 NEW_CONNECTION_ID 帧时，才允许对目标连接ID进行更改。如果后续初始数据包包含不同的源连接ID，则必须将其丢弃。这样可以避免由于无状态（stateless）处理具有不同源连接ID的多个初始数据包而导致的不可预测结果。</p>
<p>参考文章： </p>
<ul>
<li><a href="https://www.ietf.org/blog/whats-happening-quic/">What’s Happening with QUIC</a></li>
<li><a href="https://blogs.keysight.com/blogs/tech/nwvs.entry.html/2021/07/16/road_to_quic-DGa5.html">Road To QUIC</a></li>
<li><a href="https://www.nginx.org.cn/article/detail/422">深入剖析HTTP3协议</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/290694322">跟坚哥学QUIC系列：地址验证（Address Validation)</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>QUIC</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（Design Pattern）</title>
    <url>/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Pattern%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<a id="more"></a>
<h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>“设计模式”总的来说有设计原则6个.</p>
<ul>
<li><strong>单一职责原则(Single Responsibility Principle, SRP)</strong> : 每个模块或类都应该对软件提供的功能的一部分负责，而这个责任应该完全由类来封装。它的所有服务都应严格遵守这一职责。</li>
<li><strong>开闭原则(Open Close Principle, OCP)</strong> : 软件中的对象(类、模块、函数等)对扩展是开放的，对修改是封闭的。</li>
<li><strong>里氏替换原则(Liskov Substitution Principle, LSP)</strong> : 所有使用基类的地方必须能透明地使用其子类的对象</li>
<li><strong>依赖倒转原则(Dependence Inversion Principle, DIP)</strong> : 是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</li>
<li><strong>接口隔离原则(Interface Segregation Principle, ISP)</strong> : 客户端不应该依赖它不需要的接口。</li>
<li><strong>迪米特法则(Law of Demeter, LoD), 最少知识原则(Principle of Least Knowledge)</strong> : 1. 每个对象应该对其他对象尽可能最少的知道 2. 每个对象应该仅和其朋友通信；不和陌生人通信 3. 仅仅和直接朋友通信</li>
</ul>
<hr>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 (Singleton)"></a>单例模式 (Singleton)</h2><ul>
<li><font color="#200000">定义以及使用场景</font>
</li>
</ul>
<ol>
<li>确保某一个类只有一个实例，而且向整个系统提供这个实例</li>
<li>确保某个类有且仅有一个对象的场景，避免产生多个对象消耗过多的资源；或者某种类型的对象应该有且只有一个。（如 Logger 实例、Config 实例等）</li>
</ol>
<ul>
<li><font color="#200000">实现单例模式的几个关键点</font>
</li>
</ul>
<ol>
<li>构造函数不对外开放，一般为private</li>
<li>通过一个静态方法或者枚举返回单例类对象</li>
<li>确保单例类的对象有且只有一个，尤其是在多线程环境下</li>
<li>确保单例类对象在反序列化时不会重新构建对象</li>
</ol>
<ul>
<li><font color="#200000">饥汉模式</font>

</li>
</ul>
<p>直接创建好对象，这样不需要判断为空，同时也是线程安全。唯一的缺点是在导入包的同时会创建该对象，并持续占有在内存中。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance Tool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#200000"> 懒汉模式 (Lazy Loading) </font>

</li>
</ul>
<p>只有需要时才会初始化，在一定程度上节约了资源。如果不加锁的话非线程安全，即在多线程下可能会创建多次对象。<strong>懒汉方式是开源项目中使用最多的</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// private</span></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// public</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		instance = &amp;singleton&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#200000"> DCL(双重检查)模式 (推荐) </font>

</li>
</ul>
<p>DCL的优点就是资源利用率高，只有第一次执行getInstance才会初始化。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> instance Tool</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第一次判断不加锁，第二次加锁保证线程安全，一旦对象建立后,获取对象就不用加锁了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">            instance = <span class="built_in">new</span>(Tool)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者在golang中还可以使用 <code>sync.Once</code> 保证单例。</p>
<pre><code>
var once sync.Once

func GetInstance() *Tool &#123;
    once.Do(func() &#123;
        instance = new(Tool)
    &#125;)
    return instance
&#125;
</code></pre>

<hr>
<h2 id="工厂方法模式-Factory-method"><a href="#工厂方法模式-Factory-method" class="headerlink" title="工厂方法模式(Factory method)"></a>工厂方法模式(Factory method)</h2><ul>
<li><font color="#808080"> 定义以及使用场景</font>

</li>
</ul>
<p>创建一个用户创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p>
<p><strong>使用场景</strong>：</p>
<ol>
<li>工厂方法模式通过依赖抽象来达到解耦的效果，并且将实例化的任务交给子类去完成，有非常好的扩展性</li>
<li>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂方法</li>
<li>工厂方法模式的应用非常广泛，然而缺点也很明显，就是每次我们为工厂方法添加新的产品时，都需要编写一个新的产品类，所以要根据实际情况来权衡是否要用工厂方法模式</li>
</ol>
<p>类似我要造汽车，将造汽车的通用的几个方法定义好，就可以创建一个接口。任何实现了这套造汽车标准的厂商都可以被初始化。并造出一辆汽车。</p>
<ul>
<li><font color="#808080"> 举例实现工厂方法模式 </font>

</li>
</ul>
<p>假设我们在做一款小型翻译软件，软件可以将德语、英语、日语都翻译成目标中文，并显示在前端。</p>
<ul>
<li><font color="#200000"> 简单工厂模式 </font>

</li>
</ul>
<p>我们会有三个具体的语言翻译结构体，或许以后还有更多，但现在分别是GermanTranslater、EnglishTranslater、JapaneseTranslater，他们都共同实现了一个接口Translator。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//翻译接口</span></span><br><span class="line"><span class="keyword">type</span> Translator <span class="keyword">interface</span> &#123;</span><br><span class="line">	Translate(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//德语翻译类</span></span><br><span class="line"><span class="keyword">type</span> GermanTranslator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*GermanTranslator)</span> <span class="title">Translate</span><span class="params">(words <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;德语&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//英语翻译类</span></span><br><span class="line"><span class="keyword">type</span> EnglishTranslator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*EnglishTranslator)</span> <span class="title">Translate</span><span class="params">(words <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;英语&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在程序入口获取用户输入的文本，并将其翻译</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> lan <span class="keyword">int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s ,%s&quot;</span>, <span class="string">&quot;以下是可翻译的语言种类，请输入代表数字&quot;</span>, <span class="string">&quot;1：德语、2：英语&quot;</span>)</span><br><span class="line">	_, _ = fmt.Scanln(&amp;lan)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入要翻译成中文的文本：&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> inputWords <span class="keyword">string</span></span><br><span class="line">	_, _ = fmt.Scanln(&amp;inputWords)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> translator Translator</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据不同的语言种类，实例化不同的翻译类</span></span><br><span class="line">	<span class="keyword">switch</span> lan &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		translator = <span class="built_in">new</span>(GermanTranslator)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		translator = <span class="built_in">new</span>(EnglishTranslator)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;no such translator&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(translator.Translate(inputWords))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong></p>
<ol>
<li>违背了开闭原则，以后还可能有法语、俄语、阿拉伯语等其他翻译器，每一次添加翻译器都要在客户端代码增加对应的switch分支，维护成本高。倘若还有不止一处调用了创建逻辑，还要维护多处代码。</li>
<li>违背了单一职责原则，客户端处理类的职责应该只是负责接收用户的输入并将其打印，现在还负责翻译类的创建逻辑，导致这个类的职责过多。</li>
</ol>
<p>改造</p>
<pre>
// 工厂函数
func CreateTranslator(lan int) Translator {
    var translator Translator

    switch lan {
    case 1:
        translator = new(GermanTranslator)
    case 2:
        translator = new(EnglishTranslator)
    default:
        panic("no such translator")
    }

    return translator
}

// 主函数
...
    fmt.Println("请输入要翻译成中文的文本：")
    var inputWords string
    fmt.Scanln(&inputWords)

    //客户端只关注如何获取翻译类，而不用关注创建翻译类的细节
    translator:=CreateTranslator(lan)

    fmt.Println(translator.Translate(inputWords))
...
</pre>

<hr>
<h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式(Builder)"></a>建造者模式(Builder)</h2><ul>
<li><strong>定义以及使用场景</strong> </li>
</ul>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时</li>
<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果却又不相同时<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的结果，这个时候使用建造者模式非常合适</li>
<li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时</li>
</ol>
<blockquote>
<p><strong>Product</strong> 产品类——产品的抽象类<br><strong>Builder</strong> 抽象Builder类，规范产品的组建，一般由子类实现具体的组建过程<br><strong>ConcreteBuilder</strong> 具体的Builder类<br><strong>Director</strong> 统一组装过程</p>
</blockquote>
<ul>
<li><strong>举个例子</strong> </li>
</ul>
<p>我们需要创建汽车，而汽车有轮胎的个数以及车身的颜色可定制，那么用Builder模式可以这样。</p>
<p>我们的目标是建一辆车</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一辆车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">	Wheels 	<span class="keyword">string</span></span><br><span class="line">	Chassis <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Builder Complete ...&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Wheels : %s Chassis: %s \n&quot;</span>, c.Wheels, c.Chassis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设计出完整的建设规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为建造者实现 Builder 接口</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">	NewProduct()       	<span class="comment">// 创建一个空产品</span></span><br><span class="line">	BuildWheels()      	<span class="comment">// 建造轮子</span></span><br><span class="line">	BuildChassis()    	<span class="comment">// 建造底盘</span></span><br><span class="line">	GetResult() <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 获取建造好的产品</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照Builder规划一个大型项目构造者CarBuilder, 包含如何具体实现Build</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义汽车建造项目 CarBuilder</span></span><br><span class="line"><span class="keyword">type</span> CarBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">	Car *Car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> cb.Car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">NewProduct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cb.Car = <span class="built_in">new</span>(Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">BuildWheels</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cb.Car.Wheels = <span class="string">&quot;米其林轮胎&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">BuildChassis</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cb.Car.Chassis = <span class="string">&quot;沃尔沃底盘&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面要把具体建造者传入指挥者:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把建造者传入指挥者</span></span><br><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span> &#123;</span><br><span class="line">	builder Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">SetBuilder</span><span class="params">(builder Builder)</span></span> &#123;</span><br><span class="line">	d.builder = builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>建造实施</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">CarBuilderImpl</span><span class="params">()</span> *<span class="title">Car</span></span> &#123;</span><br><span class="line">	d.builder.NewProduct()</span><br><span class="line">	d.builder.BuildChassis()</span><br><span class="line">	d.builder.BuildWheels()</span><br><span class="line">	<span class="keyword">return</span> d.builder.GetResult().(*Car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整过程</p>
<pre>
func main() {
    // 创建一个指挥者
    director := new(Director)
    // 创建建造者
    builder := new(CarBuilder)

    director.SetBuilder(builder)
    car := director.CarBuilderImpl()
    car.Show()
}
</pre>

<hr>
<h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h2><ul>
<li><font color="#808080">**定义以及使用场景**</font>

</li>
</ul>
<p>原型模式用于创建重复的对象。当一个类在创建时开销比较大时(比如大量数据准备，数据库连接)，我们可以缓存该对象，当下一次调用时，返回该对象的克隆。</p>
<blockquote>
<p><strong>不过大多数原型模式不在日常中使用，一般会使用 <code>sync.pool</code> 替代，详见 <a href="https://kiosk007.top/2021/03/21/Worker-Pool-in-Golang/">Worker Pool in Golang</a></strong></p>
</blockquote>
<p><strong>使用场景</strong></p>
<ol>
<li>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗</li>
<li>原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好滴体现其优点</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝</li>
</ol>
<ul>
<li><font color="#200000">举个例子</font>

</li>
</ul>
<p>定义一个原型管理器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 样品（原型）Clone能力约定类</span></span><br><span class="line"><span class="keyword">type</span> Cloneable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Clone() Cloneable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样品（原型）管理器类</span></span><br><span class="line"><span class="keyword">type</span> PrototypeManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	prototypes <span class="keyword">map</span>[<span class="keyword">string</span>]Cloneable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(that *PrototypeManager)</span> <span class="title">Set</span><span class="params">( cloneName <span class="keyword">string</span>, cloneable Cloneable)</span></span> &#123;</span><br><span class="line">	that.prototypes[cloneName] = cloneable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(that *PrototypeManager)</span> <span class="title">Get</span><span class="params">(cloneName <span class="keyword">string</span>)</span> <span class="params">(prototype Cloneable, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> prototype, ok:=that.prototypes[cloneName]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> prototype, <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;%s 不存在&quot;</span>, cloneName))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取一个样品（原型）管理器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个样品（原型）管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrototypeManager</span> <span class="params">()</span> *<span class="title">PrototypeManager</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;PrototypeManager&#123;</span><br><span class="line">		prototypes:<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Cloneable),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manager *PrototypeManager</span><br></pre></td></tr></table></figure>
<p>定义一个样品原型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个样品（原型） 实现 Clone 方法 相当于把自己做成了一个样品</span></span><br><span class="line"><span class="keyword">type</span> PT <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(that *PT)</span> <span class="title">Clone</span><span class="params">()</span> <span class="title">Cloneable</span></span> &#123;</span><br><span class="line">	temp := *that</span><br><span class="line">	<span class="keyword">return</span> &amp;temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试</p>
<pre>

func Test() {
    prototypeOne,_ := manager.Get("prototypeOne")
    prototypeTwo := prototypeOne.Clone()
    prototypeThree := prototypeOne.Clone()
    fmt.Printf(" prototypeOne地址:%v \n " +
        "prototypeTwo地址: %v \n " +
        "prototypeThree地址: %v \n", &prototypeOne, &prototypeTwo, &prototypeThree)
}

func main() {
    manager = NewPrototypeManager()
    pt1 := &PT{}
    manager.Set("prototypeOne", pt1)
    Test()
}

// 输出
 prototypeOne地址:   0xc000010200 
 prototypeTwo地址:   0xc000010210 
 prototypeThree地址: 0xc000010220 

</pre>

<hr>
<h2 id="过滤器模式-Pipe-filter"><a href="#过滤器模式-Pipe-filter" class="headerlink" title="过滤器模式 (Pipe-filter)"></a>过滤器模式 (Pipe-filter)</h2><ul>
<li><font color="#808080">**定义以及使用场景**</font>

</li>
</ul>
<p>对一数据需要经过顺序的多个过滤器函数处理。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>多个对象可以处理同一请求，其架构适用于 解析，过滤，处理，返回这样的架构，如数据分析。</li>
<li>在请求处理者不明确的情况下向多个对象中的一个提交一个请求需要动态指定一组对象处理请求<br><img style="height:320px" src="https://img1.kiosk007.top/static/images/design_pattern/pipe_filter.webp"></li>
</ol>
<ul>
<li><font color="#200000">**举个例子**</font>

</li>
</ul>
<p>下面的例子是一个将 字符串“1，2，3” 按逗号切分后，再字符转数字相加的过程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;1,2,3&quot;</span> --&gt; [SplitFilter] --&gt; [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>] --&gt; [ToIntFilter] --&gt; [1,2,3] -&gt; [SumFilter] --&gt; 6</span><br></pre></td></tr></table></figure>
<p>首先实现一个 filter 的接口。该接口定义了数据的来源接口，输出接口，该filter接口必须拥有的处理方法, 所有的过滤器必须参考这个接口实现。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Request is the input of the filter</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response is the output of the filter</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter interface is the definition of the data processing components</span></span><br><span class="line"><span class="comment">// Pipe-Filter structure</span></span><br><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(data Request) (Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现SplitFilter，SplitFilter必须实现处理器Process。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SplitFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SplitFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">    delimiter <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSplitFilter</span><span class="params">(delimiter <span class="keyword">string</span>)</span> *<span class="title">SplitFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SplitFilter&#123;delimiter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SplitFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    str, ok := data.(<span class="keyword">string</span>) <span class="comment">//检查数据格式/类型，是否可以处理</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, SplitFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    parts := strings.Split(str, sf.delimiter)</span><br><span class="line">    <span class="keyword">return</span> parts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现ToIntFilter</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ToIntFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ToIntFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToIntFilter</span><span class="params">()</span> *<span class="title">ToIntFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ToIntFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tif *ToIntFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    parts, ok := data.([]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ToIntFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">        s, err := strconv.Atoi(part)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 SumFilter</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SumFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []int&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SumFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSumFilter</span><span class="params">()</span> *<span class="title">SumFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SumFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SumFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    elems, ok := data.([]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, SumFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">        ret += elem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个pipe-line， 目的是为了将所有的filter串起来。循环遍历整个filter并执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewStraightPipeline create a new StraightPipelineWithWallTime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStraightPipeline</span><span class="params">(name <span class="keyword">string</span>, filters ...Filter)</span> *<span class="title">StraightPipeline</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;StraightPipeline&#123;</span><br><span class="line">        Name:    name,</span><br><span class="line">        Filters: &amp;filters,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StraightPipeline is composed of the filters, and the filters are piled as a straigt line.</span></span><br><span class="line"><span class="keyword">type</span> StraightPipeline <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Filters *[]Filter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process is to process the coming data by the pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *StraightPipeline)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> _, filter := <span class="keyword">range</span> *f.Filters &#123;</span><br><span class="line">        ret, err = filter.Process(data)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret, err</span><br><span class="line">        &#125;</span><br><span class="line">        data = ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<pre>
func main() {
    spliter := pipe_filter.NewSplitFilter(",")
    converter := pipe_filter.NewToIntFilter()
    sum := pipe_filter.NewSumFilter()
    sp := pipe_filter.NewStraightPipeline("p1", spliter, converter, sum)
    ret, err := sp.Process("1,2,3")
    if err != nil {
        log.Fatal(err)
    }
    if ret != 6 {
        log.Fatalf("The expected is 6, but the actual is %d", ret)
    }
    fmt.Println(ret)
}

执行结果：
6

</pre>

<hr>
<h2 id="微内核模式-Micro-Kernel"><a href="#微内核模式-Micro-Kernel" class="headerlink" title="微内核模式 (Micro Kernel)"></a>微内核模式 (Micro Kernel)</h2><ul>
<li><font color="#808080"> 定义以及使用场景 </font>

</li>
</ul>
<p>可以将 微核心架构理解成一个 核心要添加新功能就是加插件。其特点为 易扩展，错误隔离，保持架构的一致性。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>如Nginx，启动前可以加载多个某块功能在应用上，不需要的时候可以剔除，但不影响整个应用的生命周期，适合一个应用的整体架构设计</li>
</ol>
<ul>
<li><font color="#200000"> 举个例子 </font>

</li>
</ul>
<p><strong>Agent</strong>: agent 相当于一个注册中心，所有要Agent去做的事情都注册到Agent里面来，注册进Agent的操作叫做 Collector 。每个Collector有一个名字。用map存储。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Agent <span class="keyword">struct</span> &#123;</span><br><span class="line">    collectors <span class="keyword">map</span>[<span class="keyword">string</span>]Collector  <span class="comment">//  注册进 Agent的collector</span></span><br><span class="line">    evtBuf     <span class="keyword">chan</span> Event            <span class="comment">//  collector 回传给 Agent 的事件</span></span><br><span class="line">    cancel     context.CancelFunc <span class="comment">//  任务取消的方法</span></span><br><span class="line">    ctx        context.Context    <span class="comment">//  任务取消的上下文</span></span><br><span class="line">    state      <span class="keyword">int</span>                <span class="comment">//  Agent 的运行状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Collector</strong>: Collector 是一个执行器，是需要注册进上面的Agent的。每个Collector需要实现 Init，Start，Stop，Destroy 方法，到时候由 Agent 统一进行Init，Start等操作，这里在Init中提到了 EventReceiver，所有的Collector在初始化的时候传入一个事件接收源</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Collector <span class="keyword">interface</span> &#123;</span><br><span class="line">    Init(evtReceiver EventReceiver) error    <span class="comment">// Collector 将收集到的数据回传到 Agent （任何实现EventReceiver的对象）</span></span><br><span class="line">    Start(agtCtx context.Context) error      <span class="comment">// 启动所有的Collector（参数为agent中的取消上下文）</span></span><br><span class="line">    Stop() error                              <span class="comment">//   停止</span></span><br><span class="line">    Destroy() error                           <span class="comment">//   摧毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Event</strong>: Agent 实现了 OnEvent 方法，所以Agent 可以作为上面Init 方法的参数，作为事件的接收者。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">    Source  <span class="keyword">string</span>   <span class="comment">// 事件源</span></span><br><span class="line">    Content <span class="keyword">string</span>   <span class="comment">// 事件内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EventReceiver <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnEvent(evt Event)  <span class="comment">// 实现OnEvent 既可以作为 EventReciver来接收事件 如下面的 Agent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">OnEvent</span><span class="params">(evt Event)</span></span> &#123;</span><br><span class="line">    agt.evtBuf &lt;- evt  <span class="comment">// Agent 可以来接收事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>开始起一个微内核</strong>: 整个 微内核的架构就是这样了，刚才提到了，Agent会统一对注册进去的Collector进行初始化（Init），启动（Start），停止（Stop）的操作。 所以这里还差一个注册函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">RegisterCollector</span><span class="params">(name <span class="keyword">string</span>, collector Collector)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line">        <span class="keyword">return</span> WrongStateError</span><br><span class="line">    &#125;</span><br><span class="line">    agt.collectors[name] = collector   <span class="comment">// agent map注册</span></span><br><span class="line">    <span class="keyword">return</span> collector.Init(agt)  <span class="comment">// 注册完立即进行Init 操作。且事件接收者为Agent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>启动、停止、摧毁</strong><br>启动会将所有的Controller都拉起来，同理停止和摧毁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> agt.state != Waiting &#123;     <span class="comment">// 状态不对，直接报错</span></span><br><span class="line">        <span class="keyword">return</span> WrongStateError</span><br><span class="line">    &#125;</span><br><span class="line">    agt.state = Running    <span class="comment">// 启动了，更改状态</span></span><br><span class="line">    agt.ctx, agt.cancel = context.WithCancel(context.Background())  <span class="comment">// 来一个取消的上下文和取消函数</span></span><br><span class="line">    <span class="keyword">go</span> agt.EventProcessGroutine()    <span class="comment">// 收集事件 (具体业务了)</span></span><br><span class="line">    <span class="keyword">return</span> agt.startCollectors()    <span class="comment">//  启动所有的Collector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的收集具体的业务事件。这里的事件是由各个 collector 上报的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">EventProcessGroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> evtSeg [<span class="number">10</span>]Event</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> evtSeg[i] = &lt;-agt.evtBuf:   <span class="comment">// 将 collector 收集的事件放到 evtBuf 中</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-agt.ctx.Done():           <span class="comment">// 执行上下文完成，结束 </span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(evtSeg)   <span class="comment">// 当 collector 收集的事件满 10 个，打印一次。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Agent 来拉起所有的 Collectors</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">startCollectors</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">var</span> errs CollectorsError</span><br><span class="line">    <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, collector Collector, ctx context.Context)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">            &#125;()</span><br><span class="line">            err = collector.Start(ctx)</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                errs.CollectorErrors = <span class="built_in">append</span>(errs.CollectorErrors,</span><br><span class="line">                    errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(name, collector, agt.ctx)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorErrors) == <span class="number">0</span> &#123;     <span class="comment">// 这里需要判断有没有错误，确定没有错误，返回nil。否则其实返回的也不是nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模拟</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DemoCollector <span class="keyword">struct</span> &#123;      <span class="comment">// 示例 Collector</span></span><br><span class="line">    evtReceiver microkernel.EventReceiver   <span class="comment">// 事件发给这里</span></span><br><span class="line">    stopChan    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;    <span class="comment">// 用来停止该Collector</span></span><br><span class="line">    name        <span class="keyword">string</span>    <span class="comment">// Collector 名字</span></span><br><span class="line">    content     <span class="keyword">string</span>    <span class="comment">// Collector 的要做的内容（假设，这个根据业务场景，都不一定是string）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCollect</span><span class="params">(name <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> *<span class="title">DemoCollector</span></span> &#123;   <span class="comment">// 创建一个 Collect</span></span><br><span class="line">    <span class="keyword">return</span> &amp;DemoCollector&#123;</span><br><span class="line">        stopChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        name:     name,</span><br><span class="line">        content:  content,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Init</span><span class="params">(evtReceiver microkernel.EventReceiver)</span> <span class="title">error</span></span> &#123;   <span class="comment">// 初始化一个这个 Collect</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;initialize collector&quot;</span>, c.name)</span><br><span class="line">    c.evtReceiver = evtReceiver    <span class="comment">// Agent 作为数据的上报源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Start</span><span class="params">(agtCtx context.Context)</span> <span class="title">error</span></span> &#123;   <span class="comment">// 拉起一个 Collect</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;start collector&quot;</span>, c.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;    <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-agtCtx.Done():      <span class="comment">// 收到 Done 了</span></span><br><span class="line">            c.stopChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="comment">// 停掉该 Collect （Stop 方法那里会等 stopChan 这个信号）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">            c.evtReceiver.OnEvent(microkernel.Event&#123;c.name, c.content&#125;) <span class="comment">// 向 Agent 上报事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;stop collector&quot;</span>, c.name)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-c.stopChan:   <span class="comment">// 收到停止信号了，停掉</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// 一般停完再做点啥，在这做些善后吧</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;failed to stop for timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Destroy</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(c.name, <span class="string">&quot;released resources.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error = <span class="literal">nil</span></span><br><span class="line">    agt := microkernel.NewAgent(<span class="number">100</span>)</span><br><span class="line">    c1 := NewCollect(<span class="string">&quot;c1&quot;</span>, <span class="string">&quot;1a&quot;</span>)</span><br><span class="line">    c2 := NewCollect(<span class="string">&quot;c2&quot;</span>, <span class="string">&quot;2b&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err = agt.RegisterCollector(<span class="string">&quot;c1&quot;</span>, c1);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = agt.RegisterCollector(<span class="string">&quot;c2&quot;</span>, c2);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = agt.Start();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err = agt.Stop();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ERR:</span><br><span class="line">    fmt.Println(<span class="string">&quot;An Error Occur :&quot;</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 (Command)"></a>命令模式 (Command)</h2><ul>
<li><font color="#808080">**定义以及使用场景**</font>

</li>
</ul>
<p>它可将请求或简单操作转换为一个对象。此类转换让你能够延迟进行或远程执行请求， 还可将其放入队列中。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>需要抽象出待执行的行动，然后以参数的形式提供出来——类似于过程设计中的回调机制，而命令模式正是回调机制的一个面向对象的代替品。</li>
<li>在不同的时刻指定、排列和执行请求，一个命令对象可以有与初始请求无关的生存期</li>
<li>需要支持事务操作</li>
</ol>
<ul>
<li><font color="#200000">**举个例子**</font>

</li>
</ul>
<p><strong>电视遥控器</strong>:</p>
<p>遥控器从实现 ON 命令对象并以电视机作为接收者入手。 当在此命令上调用 execute执行方法时， 方法会调用 TV.on打开电视函数。 最后的工作是定义请求者： 这里实际上有两个请求者： 遥控器和电视机。 两者都将嵌入 ON 命令对象。</p>
<ul>
<li>实现 command 和 device </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command define</span></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">interface</span> &#123;</span><br><span class="line">	execute()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> button <span class="keyword">struct</span> &#123;</span><br><span class="line">	command command</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *button)</span> <span class="title">press</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b.command.execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// device define ， 设备可执行的命令</span></span><br><span class="line"><span class="keyword">type</span> device <span class="keyword">interface</span> &#123;</span><br><span class="line">	on()</span><br><span class="line">	off()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现要执行命令</span></span><br><span class="line"><span class="keyword">type</span> onCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">	device device</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *onCommand)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.device.on()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> offCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">	device device</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *offCommand)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.device.off()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建命令的发出者和执行者</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令的执行者</span></span><br><span class="line"><span class="keyword">type</span> tv <span class="keyword">struct</span> &#123;</span><br><span class="line">	isRunning <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tv)</span> <span class="title">on</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t.isRunning = <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Turning tv on&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tv)</span> <span class="title">off</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t.isRunning = <span class="literal">false</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Turning tv off&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行者就是按下按钮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tv := &amp;tv&#123;&#125;</span><br><span class="line"></span><br><span class="line">	onButton := &amp;button&#123;</span><br><span class="line">		command: &amp;onCommand&#123; device: tv &#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	onButton.press()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 (Bridge)"></a>桥接模式 (Bridge)</h2><ul>
<li><strong>定义以及使用场景</strong> </li>
</ul>
<p>将抽象与实现分离，使它们可以独立变化。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMsgSender IMsgSender</span></span><br><span class="line"><span class="keyword">type</span> IMsgSender <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(msg <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EmailMsgSender 发送邮件</span></span><br><span class="line"><span class="comment">// 可能还有 电话、短信等各种实现</span></span><br><span class="line"><span class="keyword">type</span> EmailMsgSender <span class="keyword">struct</span> &#123;</span><br><span class="line">	emails []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewEmailMsgSender NewEmailMsgSender</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEmailMsgSender</span><span class="params">(emails []<span class="keyword">string</span>)</span> *<span class="title">EmailMsgSender</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;EmailMsgSender&#123;emails: emails&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send Send</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmailMsgSender)</span> <span class="title">Send</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里去发送消息</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// INotification 通知接口</span></span><br><span class="line"><span class="keyword">type</span> INotification <span class="keyword">interface</span> &#123;</span><br><span class="line">	Notify(msg <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrorNotification 错误通知</span></span><br><span class="line"><span class="comment">// 后面可能还有 warning 各种级别</span></span><br><span class="line"><span class="keyword">type</span> ErrorNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">	sender IMsgSender</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewErrorNotification NewErrorNotification</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewErrorNotification</span><span class="params">(sender IMsgSender)</span> *<span class="title">ErrorNotification</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ErrorNotification&#123;sender: sender&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify 发送通知</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *ErrorNotification)</span> <span class="title">Notify</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n.sender.Send(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元测试<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestErrorNotification_Notify</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	sender := NewEmailMsgSender([]<span class="keyword">string</span>&#123;<span class="string">&quot;test@test.com&quot;</span>&#125;)</span><br><span class="line">	n := NewErrorNotification(sender)</span><br><span class="line">	err := n.Notify(<span class="string">&quot;test msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="访问者模式-visitor"><a href="#访问者模式-visitor" class="headerlink" title="访问者模式 (visitor)"></a>访问者模式 (visitor)</h2><ul>
<li><strong>定义以及使用场景</strong> </li>
</ul>
<p>由于没有函数重载，所以我们并不知道传递过来的对象是什么类型，这个时候只能采用类型断言的方式来对不同的类型做不同的操作，但是正式由于没有函数重载，所以其实完全可以不用访问者模式直接传入参数。</p>
<p><strong>使用场景</strong></p>
<p>访问者模式一共有五种角色：</p>
<p>(1) Vistor（抽象访问者）：为该对象结构中具体元素角色声明一个访问操作接口。<br>(2) ConcreteVisitor（具体访问者）：每个具体访问者都实现了Vistor中定义的操作。<br>(3) Element（抽象元素）：定义了一个accept操作，以Visitor作为参数。<br>(4) ConcreteElement（具体元素）：实现了Element中的accept()方法，调用Vistor的访问方法以便完成对一个元素的操作。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visitor 访问者</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Visit(IResourceFile) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IResourceFile IResourceFile</span></span><br><span class="line"><span class="keyword">type</span> IResourceFile <span class="keyword">interface</span> &#123;</span><br><span class="line">	Accept(Visitor) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewResourceFile NewResourceFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourceFile</span><span class="params">(filepath <span class="keyword">string</span>)</span> <span class="params">(IResourceFile, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> path.Ext(filepath) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;.ppt&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;PPTFile&#123;path: filepath&#125;, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;.pdf&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;PdfFile&#123;path: filepath&#125;, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found file type: %s&quot;</span>, filepath)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PdfFile PdfFile</span></span><br><span class="line"><span class="keyword">type</span> PdfFile <span class="keyword">struct</span> &#123;</span><br><span class="line">	path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept Accept</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PdfFile)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> visitor.Visit(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PPTFile PPTFile</span></span><br><span class="line"><span class="keyword">type</span> PPTFile <span class="keyword">struct</span> &#123;</span><br><span class="line">	path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept Accept</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PPTFile)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> visitor.Visit(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compressor 实现压缩功能</span></span><br><span class="line"><span class="keyword">type</span> Compressor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visit 实现访问者模式方法</span></span><br><span class="line"><span class="comment">// 我们可以发现由于没有函数重载，我们只能通过断言来根据不同的类型调用不同函数</span></span><br><span class="line"><span class="comment">// 但是我们即使不采用访问者模式，我们其实也是可以这么操作的</span></span><br><span class="line"><span class="comment">// 并且由于采用了类型断言，所以如果需要操作的对象比较多的话，这个函数其实也会膨胀的比较厉害</span></span><br><span class="line"><span class="comment">// 后续可以考虑按照命名约定使用 generate 自动生成代码</span></span><br><span class="line"><span class="comment">// 或者是使用反射简化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">Visit</span><span class="params">(r IResourceFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> f := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *PPTFile:</span><br><span class="line">		<span class="keyword">return</span> c.VisitPPTFile(f)</span><br><span class="line">	<span class="keyword">case</span> *PdfFile:</span><br><span class="line">		<span class="keyword">return</span> c.VisitPDFFile(f)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not found resource typr: %#v&quot;</span>, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VisitPPTFile VisitPPTFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">VisitPPTFile</span><span class="params">(f *PPTFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is ppt file&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VisitPDFFile VisitPDFFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">VisitPDFFile</span><span class="params">(f *PdfFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is pdf file&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元测试<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCompressor_Visit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		name    <span class="keyword">string</span></span><br><span class="line">		path    <span class="keyword">string</span></span><br><span class="line">		wantErr <span class="keyword">string</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			name: <span class="string">&quot;pdf&quot;</span>,</span><br><span class="line">			path: <span class="string">&quot;./xx.pdf&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			name: <span class="string">&quot;ppt&quot;</span>,</span><br><span class="line">			path: <span class="string">&quot;./xx.ppt&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			name:    <span class="string">&quot;404&quot;</span>,</span><br><span class="line">			path:    <span class="string">&quot;./xx.xx&quot;</span>,</span><br><span class="line">			wantErr: <span class="string">&quot;not found file type&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">			f, err := NewResourceFile(tt.path)</span><br><span class="line">			<span class="keyword">if</span> tt.wantErr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				require.Error(t, err)</span><br><span class="line">				require.Contains(t, err.Error(), tt.wantErr)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			require.NoError(t, err)</span><br><span class="line">			compressor := &amp;Compressor&#123;&#125;</span><br><span class="line">			f.Accept(compressor)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 (Strategy)"></a>策略模式 (Strategy)</h2><ul>
<li><strong>定义以及使用场景</strong> </li>
</ul>
<p>策略模式（Strategy Pattern）定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p>
<p><strong>使用场景</strong></p>
<p>在项目开发中，我们经常要根据不同的场景，采取不同的措施，也就是不同的策略。比如，假设我们需要对 a、b 这两个整数进行计算，根据条件的不同，需要执行不同的计算方式。我们可以把所有的操作都封装在同一个函数中，然后通过 if … else … 的形式来调用不同的计算方式，这种方式称之为硬编码。</p>
<p>在实际应用中，随着功能和体验的不断增长，我们需要经常添加 / 修改策略，这样就需要不断修改已有代码，不仅会让这个函数越来越难维护，还可能因为修改带来一些 bug。所以为了解耦，需要使用策略模式，定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法（即策略）。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个策略类</span></span><br><span class="line"><span class="keyword">type</span> IStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">  do(<span class="keyword">int</span>, <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略实现：加</span></span><br><span class="line"><span class="keyword">type</span> add <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*add)</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略实现：减</span></span><br><span class="line"><span class="keyword">type</span> reduce <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*reduce)</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略的执行者</span></span><br><span class="line"><span class="keyword">type</span> Operator <span class="keyword">struct</span> &#123;</span><br><span class="line">  strategy IStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(operator *Operator)</span> <span class="title">setStrategy</span><span class="params">(strategy IStrategy)</span></span> &#123;</span><br><span class="line">  operator.strategy = strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用策略中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(operator *Operator)</span> <span class="title">calculate</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> operator.strategy.do(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们定义了策略接口 IStrategy，还定义了 add 和 reduce 两种策略。最后定义了一个策略执行者，可以设置不同的策略，并执行，例如：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStrategy</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  operator := Operator&#123;&#125;</span><br><span class="line"></span><br><span class="line">  operator.setStrategy(&amp;add&#123;&#125;)</span><br><span class="line">  result := operator.calculate(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;add:&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">  operator.setStrategy(&amp;reduce&#123;&#125;)</span><br><span class="line">  result = operator.calculate(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;reduce:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>GoLang 静态代码分析工具</title>
    <url>/2021/12/18/GoLang-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在日常Golang编程过程中，需要对 Go 代码做静态代码检查。虽然 Go 命令提供了 <code>go vet</code> 和 <code>go tool vet</code>，但是它们检查的内容还不够全面。go 的 vet 工具可以用来检查 go 代码中可以通过编译但仍然有可能存在错误的代码。包括并发访问安全、死锁、泄露上下文、结构体反射等等，参考<a href="https://zhuanlan.zhihu.com/p/357406395">文章</a></p>
<a id="more"></a>
<p>可用于 Go 语言代码分析的工具有很多，比如 golint、gofmt、misspell 等，如果一一引用配置，就会比较烦琐，所以通常我们不会单独地使用它们，而是使用 golangci-lint。</p>
<p>golangcli-lint 官网 : <a href="https://golangci-lint.run/">https://golangci-lint.run/</a></p>
<p>golangci-lint 是一个集成工具，它集成了很多静态代码分析工具，便于我们使用。通过配置这一工具，我们可以很灵活地启用需要的代码规范检查。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>golangci-lint</code> 本身是通过 GO 编写，所以可以直接使用 <code>go get</code> 安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/golangci/golangci-lint/cmd/golangci-lint</span><br></pre></td></tr></table></figure>
<p>或者按照官网的方式<a href="https://golangci-lint.run/usage/install/">安装</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># binary will be $(go env GOPATH)/bin/golangci-lint</span></span><br><span class="line">curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.43.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># or install it into ./bin/</span></span><br><span class="line">curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s v1.43.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># In alpine linux (as it does not come with curl by default)</span></span><br><span class="line">wget -O- -nv https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s v1.43.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装完成后，在终端输入如下命令，检测是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">golangci-lint --version</span><br><span class="line">golangci-lint has version v1.43.0 built </span><br></pre></td></tr></table></figure>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><p>选择 <code>golangci-lint</code>，是因为它具有其他静态代码检查工具不具备的一些优点。</p>
<ul>
<li>速度非常快：golangci-lint 是基于 gometalinter 开发的，但是平均速度要比 gometalinter 快 5 倍。golangci-lint 速度快的原因有三个：可以并行检查代码；可以复用 go build 缓存；会缓存分析结果。</li>
<li>可配置：支持 YAML 格式的配置文件，让检查更灵活，更可控。</li>
<li>IDE 集成：可以集成进多个主流的 IDE，例如 VS Code、GNU Emacs、Sublime Text、Goland 等。</li>
<li>linter 聚合器：1.41.1 版本的 golangci-lint 集成了 76 个 linter，不需要再单独安装这 76 个 linter。并且 golangci-lint 还支持自定义 linter。</li>
<li>最小的误报数：golangci-lint 调整了所集成 linter 的默认设置，大幅度减少了误报。</li>
<li>良好的输出：输出的结果带有颜色、代码行号和 linter 标识，易于查看和定位。</li>
</ul>
<p><code>golangci-lint</code> 有诸多大公司背书，，例如 Google、Facebook、Istio、Red Hat OpenShift 等。</p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>安装成功 golangci-lint 后，就可以使用它进行代码检查了，示例代码</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如下, 提示对返回内容进行错误检查。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">golangci-lint run </span><br><span class="line">main.go:11:9: Error <span class="built_in">return</span> value of `os.Open` is not checked (errcheck)</span><br><span class="line">        os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">               ^</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="golangci-lint-命令"><a href="#golangci-lint-命令" class="headerlink" title="golangci-lint 命令"></a>golangci-lint 命令</h1><p>我们可以通过执行 golangci-lint -h 查看其用法，golangci-lint 支持的子命令见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">子命令</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cache</td>
<td style="text-align:center">缓存控制，并打印缓存信息</td>
</tr>
<tr>
<td style="text-align:center">completion</td>
<td style="text-align:center">输出 bash\fish\powershell\zsh 补全脚本</td>
</tr>
<tr>
<td style="text-align:center">config</td>
<td style="text-align:center">打印golangci-lint使用的配置文件路径</td>
</tr>
<tr>
<td style="text-align:center">help</td>
<td style="text-align:center">打印帮助信息</td>
</tr>
<tr>
<td style="text-align:center">linters</td>
<td style="text-align:center">打印golangci-lint所支持的全部linter</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">使用golangci-lint对代码进行检查</td>
</tr>
<tr>
<td style="text-align:center">version</td>
<td style="text-align:center">打印golangci-lint的版本号</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>run 命令</strong>: run 命令执行 golangci-lint，对代码进行检查，是 golangci-lint 最为核心的一个命令。run 没有子命令，但有很多选项。</p>
</li>
<li><p><strong>cache 命令</strong>: cache 命令用来进行缓存控制，并打印缓存的信息。它包含两个子命令, <code>status</code> 、 <code>clean</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">golangci-lint cache status</span><br><span class="line">Dir: /home/ubuntu/.cache/golangci-lint</span><br><span class="line">Size: 71.3KiB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>completion 命令</strong>: completion 命令包含 4 个子命令 bash、fish、powershell 和 zsh，分别用来输出 bash、fish、powershell 和 zsh 的自动补全脚本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ golangci-lint completion bash &gt; ~/.golangci-lint.bash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;source &#x27;<span class="variable">$HOME</span>/.golangci-lint.bash&#x27;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>linters 命令</strong>: linters 命令可以打印出 golangci-lint 所支持的 linter，并将这些 linter 分成两类，分别是配置为启用的 linter 和配置为禁用的 linter，例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ golangci-lint linters</span><br><span class="line">Enabled by your configuration linters:</span><br><span class="line">...</span><br><span class="line">deadcode: Finds unused code [fast: <span class="literal">true</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">...</span><br><span class="line">Disabled by your configuration linters:</span><br><span class="line">exportloopref: checks <span class="keyword">for</span> pointers to enclosing loop variables [fast: <span class="literal">true</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>运行指定的 linter</p>
<p>你可以传入参数-E/—enable来使某个 linter 可用，也可以使用-D/—disable参数来使某个 linter 不可用。下面的示例仅仅启用了 errcheck linter：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ golangci-lint run --no-config --disable-all -E errcheck ./...</span><br></pre></td></tr></table></figure>
<h1 id="golangci-lint-配置"><a href="#golangci-lint-配置" class="headerlink" title="golangci-lint 配置"></a>golangci-lint 配置</h1><p><code>golangci-lint</code> 的配置比较灵活，比如你可以自定义要启用哪些 <code>linter</code>。<code>golangci-lint</code> 默认启用的 <code>linter</code>，包括这些：</p>
<ul>
<li>deadcode - 死代码检查</li>
<li>errcheck - 返回错误是否使用检查</li>
<li>gosimple - 检查代码是否可以简化</li>
<li>govet - 代码可疑检查，比如格式化字符串和类型不一致</li>
<li>ineffassign - 检查是否有未使用的代码</li>
<li>staticcheck - 静态分析检查</li>
<li>structcheck - 查找未使用的结构体字段</li>
<li>typecheck - 类型检查</li>
<li>unused - 未使用代码检查</li>
<li>varcheck - 未使用的全局变量和常量检查</li>
</ul>
<p>可以使用 <code>golangci-lint linters</code> 查看;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">golangci-lint linters</span><br><span class="line">Enabled by your configuration linters:</span><br><span class="line">deadcode: Finds unused code [fast: <span class="literal">false</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">errcheck: Errcheck is a program <span class="keyword">for</span> checking <span class="keyword">for</span> unchecked errors <span class="keyword">in</span> go programs. These unchecked errors can be critical bugs <span class="keyword">in</span> some cases [fast: <span class="literal">false</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Disabled by your configuration linters:</span><br><span class="line">asciicheck: Simple linter to check that your code does not contain non-ASCII identifiers [fast: <span class="literal">true</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">bidichk: Checks <span class="keyword">for</span> dangerous unicode character sequences [fast: <span class="literal">true</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">bodyclose: checks whether HTTP response body is closed successfully [fast: <span class="literal">false</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">contextcheck: check the <span class="keyword">function</span> whether use a non-inherited context [fast: <span class="literal">false</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">cyclop: checks <span class="keyword">function</span> and package cyclomatic complexity [fast: <span class="literal">false</span>, auto-fix: <span class="literal">false</span>]</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些 linter 分为两类，一类是默认启用的，另一类是默认禁用的。每个 linter 都有两个属性：</p>
<ul>
<li><p>fast：true/false，如果为 true，说明该 linter 可以缓存类型信息，支持快速检查。因为第一次缓存了这些信息，所以后续的运行会非常快。</p>
</li>
<li><p>auto-fix：true/false，如果为 true 说明该 linter 支持自动修复发现的错误；如果为 false 说明不支持自动修复。</p>
</li>
</ul>
<p>如果要修改默认启用的 <code>linter</code>，就需要对 <code>golangci-lint</code> 进行配置。即在项目根目录下新建一个名字为 <code>.golangci.yml</code> 的文件，这就是 <code>golangci-lint</code> 的配置文件。在运行代码规范检查的时候，<code>golangci-lint</code> 会自动使用它。假设我只启用 unused 检查，可以这样配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">linters:</span></span><br><span class="line">  <span class="attr">disable-all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">unused</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更详细的配置内容，你可以参考 <a href="https://golangci-lint.run/usage/configuration/">Configuration</a><br><a href="https://github.com/marmotedu/iam/blob/master/.golangci.yaml">IAM 项目参考</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="attr">linters-settings:</span></span><br><span class="line">  <span class="attr">golint:</span></span><br><span class="line">    <span class="attr">min-confidence:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">misspell:</span></span><br><span class="line">    <span class="attr">locale:</span> <span class="string">US</span></span><br><span class="line"><span class="attr">linters:</span></span><br><span class="line">  <span class="attr">disable-all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typecheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">goimports</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">misspell</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">govet</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">golint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ineffassign</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gosimple</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deadcode</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">structcheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">unused</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">errcheck</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">golangci-lint-version:</span> <span class="number">1.32</span><span class="number">.2</span> <span class="comment"># use the fixed version to not introduce new linters unexpectedly</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="忽略检查"><a href="#忽略检查" class="headerlink" title="忽略检查"></a>忽略检查</h1><ul>
<li>某一行忽略检查</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span> <span class="comment">//nolint</span></span><br></pre></td></tr></table></figure>
<ul>
<li>某个函数块忽略检查</li>
</ul>
<p>代码中忽略检查, 注释中加 //nolint<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//nolint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allIssuesInThisFunctionAreExcluded</span><span class="params">()</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nolint:govet</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a <span class="keyword">int</span></span><br><span class="line">  b <span class="keyword">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>文件忽略检查</li>
</ul>
<p>在 package xx 上面一行添加//nolint注释。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nolint:unparam</span></span><br><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h1 id="继承到CI"><a href="#继承到CI" class="headerlink" title="继承到CI"></a>继承到CI</h1><p>集成到 <code>CI</code> 代码检查一定要集成到 <code>CI</code> 流程中，效果才会更好，这样开发者提交代码的时候，<code>CI</code> 就会自动检查代码，及时发现问题并进行修正。</p>
<p>不管你是使用 <code>Jenkins</code>，还是 <code>Gitlab CI</code>，或者 <code>Github Action</code>，都可以通过 <code>Makefile</code> 的方式运行 <code>golangci-lint</code> 。现在我在项目根目录下创建一个 <code>Makefile</code> 文件，并添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getdeps:</span><br><span class="line">   @mkdir -p $&#123;GOPATH&#125;&#x2F;bin</span><br><span class="line">   @which golangci-lint 1&gt;&#x2F;dev&#x2F;null || (echo &quot;Installing golangci-lint&quot; &amp;&amp; go get github.com&#x2F;golangci&#x2F;golangci-lint&#x2F;cmd&#x2F;golangci-lint@v1.32.2)</span><br><span class="line">lint:</span><br><span class="line">   @echo &quot;Running $@ check&quot;</span><br><span class="line">   @GO111MODULE&#x3D;on $&#123;GOPATH&#125;&#x2F;bin&#x2F;golangci-lint cache clean</span><br><span class="line">   @GO111MODULE&#x3D;on $&#123;GOPATH&#125;&#x2F;bin&#x2F;golangci-lint run --timeout&#x3D;5m --config .&#x2F;.golangci.yml</span><br><span class="line">verifiers: getdeps lint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx Lua 扩展 --（Nginx 监控）</title>
    <url>/2021/12/04/Nginx-Lua-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上周我从腾讯云买了一台服务器，开始将本站解析到腾讯云上，至此本站彻底支持了HTTP3访问。不过也需要对Nginx进行一定程度的封装。一个最佳的选择是使用 <code>lua-nginx-module</code> 来扩展Nginx的能力，比如我想对请求进行一些访问统计，将数据发送到 open-falcon 或者 Prometheus 上。</p>
<p><a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module</a> 是一个实现使用lua语言直接控制Nginx内HTTP请求的一个Nginx module。这个组合很强大，提供了动态语言的强悍性能和生产力。</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装可以参考我的之前这篇文章 <a href="https://kiosk007.top/2021/07/31/%E5%B0%9D%E8%AF%95-Nginx-%E4%B8%8A%E4%BD%BF%E7%94%A8HTTP3/#%E9%AA%8C%E8%AF%81">尝试 Nginx 上使用HTTP3</a>，不过有个坑，直接从github上下载的 lua-nginx-module 执行 nginx 命令时会失败，需要切换分支至 <code>v0.10.14</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> lua-nginx-module</span><br><span class="line">$ git checkout v0.10.14</span><br></pre></td></tr></table></figure>
<h1 id="Nginx-Lua-入门"><a href="#Nginx-Lua-入门" class="headerlink" title="Nginx Lua 入门"></a>Nginx Lua 入门</h1><p>Nginx Lua 首先是基于一个运行状态的Nginx，而Nginx的运行架构是 <strong>MASTER-WORKER</strong> 模式。<br>NGINX 启动后，会有一个 Master 进程和多个 Worker 进程。<br><img src="https://img1.kiosk007.top/static/images/nginx/nginx-master-worker.webp" style="height:500px"></p>
<p><strong>Master 进程</strong>：并不负责处理终端的请求。它是用来管理 Worker 进程的，包括接受管理员发送的信号量、监控 Worker 的运行状态。当 Worker 进程异常退出时，Master 进程会重新启动一个新的 Worker 进程。</p>
<p><strong>Worker 进程</strong>：用来处理终端用户的请求。它是从 Master 进程 fork 出来的，彼此之间相互独立，互不影响。即使某个进程崩溃退出了，也不会影响其他 Worker 进程正常工作。</p>
<h2 id="生效阶段"><a href="#生效阶段" class="headerlink" title="生效阶段"></a>生效阶段</h2><p>从 ngx_http_core_module.h 的源码中，可以看到Nginx有11个执行阶段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NGX_HTTP_POST_READ_PHASE = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    NGX_HTTP_SERVER_REWRITE_PHASE,</span><br><span class="line"></span><br><span class="line">    NGX_HTTP_FIND_CONFIG_PHASE,</span><br><span class="line">    NGX_HTTP_REWRITE_PHASE,</span><br><span class="line">    NGX_HTTP_POST_REWRITE_PHASE,</span><br><span class="line"></span><br><span class="line">    NGX_HTTP_PREACCESS_PHASE,</span><br><span class="line"></span><br><span class="line">    NGX_HTTP_ACCESS_PHASE,</span><br><span class="line">    NGX_HTTP_POST_ACCESS_PHASE,</span><br><span class="line"></span><br><span class="line">    NGX_HTTP_PRECONTENT_PHASE,</span><br><span class="line"></span><br><span class="line">    NGX_HTTP_CONTENT_PHASE,</span><br><span class="line"></span><br><span class="line">    NGX_HTTP_LOG_PHASE</span><br><span class="line">&#125; ngx_http_phases;</span><br></pre></td></tr></table></figure>
<p><code>lua-nginx-module</code> 有 11 个 *_by_lua指令，它们和 NGINX 阶段的关系如下图所示（图片来自 lua-nginx-module 文档）：</p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/nginx_lua_module.webp"></p>
<p>其中， <code>init_by_lua</code> 只会在 Master 进程被创建时执行，<code>init_worker_by_lua</code> 只会在每个 Worker 进程被创建时执行。其他的 <code>*_by_lua</code> 指令则是由终端请求触发，会被反复执行。</p>
<p>所以在 <code>init_by_lua</code> 阶段，我们可以预先加载 Lua 模块和公共的只读数据，这样可以利用操作系统的 COW（copy on write）特性，来节省一些内存。对于业务代码来说，其实大部分的操作都可以在 <code>content_by_lua</code> 里面完成，但我更推荐的做法，是根据不同的功能来进行拆分。</p>
<h2 id="lua-简单语法"><a href="#lua-简单语法" class="headerlink" title="lua 简单语法"></a>lua 简单语法</h2><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。lua的语法简单到直接参考一些网上教程就生产级别可用的代码。可以可参考 <a href="https://www.w3cschool.cn/lua/lua-tutorial.html">Lua 入门教程</a></p>
<p>详细的语法介绍介绍可以参考上述链接。这里不详述，需要注意的是 table 是 Lua 中唯一的数据结构，自然非常重要。另外lua有很多库，有 lua <a href="https://www.w3cschool.cn/lua/lua-strings.html">string 库</a>、<a href="https://www.w3cschool.cn/lua/lua-tables.html">table 库</a>(常用的 table.concat 、table.sort 等少数几个函数)</p>
<p><strong>局部变量 local</strong><br>lua 中的变量默认是全局变量，除非明确使用 <code>local</code> 声明。<br>lua 代码中可以看到大量的使用 <code>local</code> 关键字。<br>原因:</p>
<blockquote>
<ul>
<li>避免命名冲突</li>
<li>访问速度更快（原因是local变量是存放在lua的堆栈里面的是array操作，而全局变量是存放在_G中的table中，效率不及堆栈）</li>
</ul>
</blockquote>
<p><strong>这里会只介绍一下 lua 的唯一数据结构 table 和 metatable 特性。</strong></p>
<p>lua,只有 table 这一个数据结构，并没有区分开数组、哈希、集合等概念，而是揉在了一起。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> color = &#123;first = <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, third = <span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(color[<span class="string">&quot;first&quot;</span>])                 <span class="comment">--&gt; output: red</span></span><br><span class="line"><span class="built_in">print</span>(color[<span class="number">1</span>])                       <span class="comment">--&gt; output: blue</span></span><br><span class="line"><span class="built_in">print</span>(color[<span class="string">&quot;third&quot;</span>])                 <span class="comment">--&gt; output: green</span></span><br><span class="line"><span class="built_in">print</span>(color[<span class="number">2</span>])                       <span class="comment">--&gt; output: yellow</span></span><br><span class="line"><span class="built_in">print</span>(color[<span class="number">3</span>])                       <span class="comment">--&gt; output: nil</span></span><br></pre></td></tr></table></figure>
<p>这个例子中， color 这个 table 包含了数组和哈希，并且可以互不干扰地进行访问。比如，你可以用 ipairs 函数，只遍历数组部分的内容：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> color = &#123;first = <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, third = <span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(color) <span class="keyword">do</span></span><br><span class="line">     <span class="built_in">print</span>(k)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>常见的table有 <code>getn</code>、<code>remove</code> 、<code>concat</code>、 <code>insert</code> 等方法，都是看名字就知道其用途的方法。</p>
<p>元表(metatable)是 Lua 中独有的概念，在实际项目中的使用非常广泛。不夸张地说，在几乎所有的 <code>lua-resty-*</code> 库中，都能看到它的身影。</p>
<p>元表的表现行为类似于操作符重载，比如我们可以重载 <strong><strong>add，来计算两个 Lua 数组的并集；或者重载 </strong>tostring，来定义转换为字符串的函数</strong>。</p>
<p>metatable 有2个函数</p>
<ul>
<li>第一个是setmetatable(table, metatable), 用于为一个 table 设置元表；</li>
<li>第二个是getmetatable(table)，用于获取 table 的元表。</li>
</ul>
<p>举个例子，</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> version = &#123;</span><br><span class="line">  major = <span class="number">1</span>,</span><br><span class="line">  minor = <span class="number">1</span>,</span><br><span class="line">  patch = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">version = <span class="built_in">setmetatable</span>(version, &#123;</span><br><span class="line">    <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d.%d.%d&quot;</span>, t.major, t.minor, t.patch)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(version))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先定义了一个 名为 version的 table ，这段代码的目的，是想把 version 中的版本号打印出来。但是，我们并不能直接打印 version，直接打印的话，只会输出这个 table 的地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tostring(version))   --output: 1.1.1</span><br></pre></td></tr></table></figure>
<p>除了<code>__tostring</code> 之外，<strong>还有一个常用的就是 <code>__index</code> 。我们在 table 中查找一个元素时，首先会直接从 table 中查询，如果没有找到，就继续到元表的 <code>__index</code> 中查询。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> version = &#123;</span><br><span class="line">  major = <span class="number">1</span>,</span><br><span class="line">  minor = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">version = <span class="built_in">setmetatable</span>(version, &#123;</span><br><span class="line">     <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, key)</span></span></span><br><span class="line">         <span class="keyword">if</span> key == <span class="string">&quot;patch&quot;</span> <span class="keyword">then</span></span><br><span class="line">             <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span>,</span><br><span class="line">     <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d.%d.%d&quot;</span>, t.major, t.minor, t.patch)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(version))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样的话，t.patch 其实获取不到值，那么就会走到 <code>__index</code> 这个函数中，结果就会打印出 1.1.2。</p>
<p><strong>另一个元方法则是__call。它类似于仿函数，可以让 table 被调用。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> version = &#123;</span><br><span class="line">  major = <span class="number">1</span>,</span><br><span class="line">  minor = <span class="number">1</span>,</span><br><span class="line">  patch = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">print_version</span><span class="params">(t)</span></span></span><br><span class="line">     <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d.%d.%d&quot;</span>, t.major, t.minor, t.patch))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">version = <span class="built_in">setmetatable</span>(version,</span><br><span class="line">     &#123;<span class="built_in">__call</span> = print_version&#125;)</span><br><span class="line"></span><br><span class="line">version()</span><br></pre></td></tr></table></figure>
<p>常见的元表就如上图所示，完整的元表可以参考 <a href="http://lua-users.org/wiki/MetamethodsTutorial">文档</a></p>
<p>以下是 <a href="https://github.com/openresty/lua-resty-mysql/blob/master/lib/resty/mysql.lua">lua-resty-mysql</a> 的源码，可以看看官方的一些lua代码的写法, 里面就用了元表来模拟类和方法。<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;local mysql = require &quot;resty.mysql&quot; -- 先引用 lua-resty 库</span></span><br><span class="line"><span class="string">local db, err = mysql:new() -- 新建一个类的实例</span></span><br><span class="line"><span class="string">db:set_timeout(1000) -- 调用类的方法&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意: 在这里冒号和点号都是可以的，db:set_timeout(1000) 和 db.set_timeout(db, 1000) 是完全等价的。冒号是 Lua 中的一个语法糖，可以省略掉函数的第一个参数 self。</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> _M = &#123; <span class="built_in">_VERSION</span> = <span class="string">&#x27;0.21&#x27;</span> &#125; <span class="comment">-- 使用 table 模拟类</span></span><br><span class="line"><span class="keyword">local</span> mt = &#123; <span class="built_in">__index</span> = _M &#125; <span class="comment">-- mt 即 metatable 的缩写，__index 指向类自身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 类的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.new</span><span class="params">(self)</span></span> </span><br><span class="line">     <span class="keyword">local</span> sock, err = tcp()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> sock <span class="keyword">then</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">setmetatable</span>(&#123; sock = sock &#125;, mt) <span class="comment">-- 使用 table 和 metatable 模拟类的实例</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 类的成员函数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">_M.set_timeout</span><span class="params">(self, timeout)</span></span> <span class="comment">-- 使用 self 参数，获取要操作的类的实例</span></span><br><span class="line">     <span class="keyword">local</span> sock = <span class="built_in">self</span>.sock</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> sock <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;not initialized&quot;</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock:settimeout(timeout)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>_M</code> 这个 table 模拟了一个类，初始化时，它只有 <code>_VERSION</code> 这一个成员变量，并在随后定义了 <code>_M.set_timeout</code> 等成员函数。在 <code>_M.new(self)</code> 这个构造函数中，我们返回了一个 table，这个 table 的元表就是 mt，而 mt 的 <code>__index</code> 元方法指向了 <code>_M</code>，这样，返回的这个 table 就模拟了类 <code>_M</code> 的实例。</p>
<h2 id="最小实现"><a href="#最小实现" class="headerlink" title="最小实现"></a>最小实现</h2><p>我们可以先构建一个最间版本的 Nginx 运行状态，这需要3步。1. 创建工作目录。2. 编写简版nginx.conf。3. 启动nginx</p>
<ul>
<li>创建工作目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">mkdir logs/ conf/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>最简版配置文件，更为丰富的配置指令可以参考 <a href="http://nginx.org/en/docs/ngx_core_module.html">ngx_core_module</a>、<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html">ngx_http_core_module</a>和<a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html">ngx_stream_core_module</a> 中的介绍。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">                ngx.say(&quot;hello, world&quot;)</span></span><br><span class="line"><span class="string">            &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动nginx</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -p <span class="built_in">test</span> -c conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>上面是一个最简单的lua代码，在 <code>location /</code> 中有一个 <code>content_by_lua</code> 可以在后面写lua代码，也可以 <code>content_by_lua_file lua/hello.lua;</code> 的形式</p>
<p>更多的例子可以参考 <a href="https://github.com/openresty/lua-nginx-module/#synopsis">这里</a></p>
<h2 id="Nginx-Lua-API"><a href="#Nginx-Lua-API" class="headerlink" title="Nginx Lua API"></a>Nginx Lua API</h2><p>nginx_lua_module 的 API 主要分为下面几个大类：<code>处理请求和响应</code>、<code>SSL 相关</code>、<code>shared dict</code>、<code>cosocket</code>、<code>处理四层流量</code>、<code>process 和 worker</code>、<code>获取 NGINX 变量和配置</code>、<code>字符串</code>、<code>时间</code>、<code>编解码</code>等通用功能。</p>
<p>完整可以API可以参考<a href="https://github.com/openresty/lua-nginx-module/#nginx-api-for-lua">官方文档</a></p>
<p>Nginx 中的请求变量可以在lua中获取到。</p>
<ul>
<li><code>$scheme</code> 这个内置变量，在 NGINX 中代表协议的名字，是 “http” 或者 “https”；而在 OpenResty 中，你可以通过 ngx.var.scheme 来返回同样的值。</li>
<li><code>$request_method</code> 代表的是请求的方法，“GET”、“POST” 等；而在 OpenResty 中，你可以通过 <code>ngx.var.request_method</code> 来返回同样的值。</li>
</ul>
<p>至于完整的 NGINX 内置变量列表，可以访问 NGINX 的官方文档来获取：</p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#variables">http://nginx.org/en/docs/http/ngx_http_core_module.html#variables</a></p>
<h2 id="worker-件通信"><a href="#worker-件通信" class="headerlink" title="worker 件通信"></a>worker 件通信</h2><p>共享内存字典 shared dict，是你在 Nginx lua 编程中最为重要的数据结构。它不仅支持数据的存放和读取，还支持原子计数和队列操作。基于 shared dict，你可以实现多个 worker 之间的缓存和通信，以及限流限速、流量统计等功能。你可以把 shared dict 当作简单的 Redis 来使用，只不过 shared dict 中的数据不能持久化，所以你存放在其中的数据，一定要考虑到丢失的情况。</p>
<p><strong>数据共享的几种方式</strong></p>
<p><strong>第一种是 Nginx 中的变量。</strong>它可以在 Nginx C 模块之间共享数据，自然的，也可以在 C 模块和 OpenResty 提供的 lua-nginx-module 之间共享数据</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /foo &#123;</span><br><span class="line">     <span class="attribute">set</span> $my_var <span class="string">&#x27;&#x27;</span>; <span class="comment"># this line is required to create $my_var at config time</span></span><br><span class="line">     <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">         ngx.var.my_var = 123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二种是ngx.ctx，可以在同一个请求的不同阶段之间共享数据。</strong>它其实就是一个普通的 Lua 的 table，所以速度很快，还可以存储各种 Lua 的对象。它的生命周期是请求级别的，当一个请求结束的时候，ngx.ctx 也会跟着被销毁掉。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">location</span> /test &#123;</span><br><span class="line">     <span class="section">rewrite_by_lua_block</span> &#123;</span><br><span class="line">         ngx.ctx.host = ngx.var.host</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="section">access_by_lua_block</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (ngx.ctx.host == <span class="string">&#x27;openresty.org&#x27;</span>) then</span><br><span class="line">            ngx.ctx.host = <span class="string">&#x27;test.com&#x27;</span></span><br><span class="line">        end</span><br><span class="line">     &#125;</span><br><span class="line">     content_by_lua_block &#123;</span><br><span class="line">         ngx.say(ngx.ctx.host)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>d第三种用 shared dict 来共享数据，这些数据可以在多个 worker 之间共享。</strong></p>
<p>这种方法是基于红黑树实现的，性能很好，但也有自己的局限性——你必须事先在 Nginx 的配置文件中，声明共享内存的大小，并且这不能在运行期更改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua_shared_dict dogs 10m;</span><br></pre></td></tr></table></figure>
<p>shared dict 同样只能缓存字符串类型的数据，不支持复杂的 Lua 数据类型。这也就意味着，当我需要存放 table 等复杂的数据类型时，我将不得不使用 json 或者其他的方法，来序列化和反序列化，这自然会带来不小的性能损耗。</p>
<p><code>shared dict</code> 同样支持多种api调用，如 <code>set</code>、<code>get</code>、<code>incr</code>、<code>replace</code>等，具体可以参考<a href="https://github.com/openresty/lua-nginx-module#ngxshareddict">官方文档</a></p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/nginx_share_dict.png" style="height:500px"></p>
<h1 id="prometheus-监控-Nginx"><a href="#prometheus-监控-Nginx" class="headerlink" title="prometheus 监控 Nginx"></a>prometheus 监控 Nginx</h1><p>Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展。</p>
<h2 id="安装-prometheus"><a href="#安装-prometheus" class="headerlink" title="安装 prometheus"></a>安装 prometheus</h2><ul>
<li><strong>安装 prometheus server</strong></li>
</ul>
<p>Prometheus基于Golang编写，编译后的软件包，不依赖于任何的第三方依赖。用户只需要下载对应平台的二进制包，解压并且添加基本的配置即可正常启动Prometheus Server。</p>
<p>安装的完整教程可以参考：<a href="https://www.prometheus.wang/quickstart/install-prometheus-server.html">https://www.prometheus.wang/quickstart/install-prometheus-server.html</a></p>
<p>Promtheus作为一个时间序列数据库，其采集的数据会以文件的形似存储在本地中，默认的存储路径为data/，因此我们需要先手动创建该目录：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir data</span><br></pre></td></tr></table></figure><br>用户也可以通过参数<code>--storage.tsdb.path=&quot;data/</code>“修改本地数据存储的路径。</p>
<p>启动prometheus服务，其会默认加载当前路径下的prometheus.yaml文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./prometheus </span><br><span class="line">level=info ts=2018-10-23T14:55:14.499484Z <span class="built_in">caller</span>=main.go:554 msg=<span class="string">&quot;Starting TSDB ...&quot;</span></span><br><span class="line">level=info ts=2018-10-23T14:55:14.499531Z <span class="built_in">caller</span>=web.go:397 component=web msg=<span class="string">&quot;Start listening for connections&quot;</span> address=0.0.0.0:9090</span><br><span class="line">level=info ts=2018-10-23T14:55:14.507999Z <span class="built_in">caller</span>=main.go:564 msg=<span class="string">&quot;TSDB started&quot;</span></span><br><span class="line">level=info ts=2018-10-23T14:55:14.508068Z <span class="built_in">caller</span>=main.go:624 msg=<span class="string">&quot;Loading configuration file&quot;</span> filename=prometheus.yml</span><br><span class="line">level=info ts=2018-10-23T14:55:14.509509Z <span class="built_in">caller</span>=main.go:650 msg=<span class="string">&quot;Completed loading of configuration file&quot;</span> filename=prometheus.yml</span><br><span class="line">level=info ts=2018-10-23T14:55:14.509537Z <span class="built_in">caller</span>=main.go:523 msg=<span class="string">&quot;Server is ready to receive web requests.&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动完成后，可以通过<a href="http://localhost:9090访问Prometheus的UI界面：">http://localhost:9090访问Prometheus的UI界面：</a></p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/nginx_promethues.png"></p>
<ul>
<li><strong>安装 Node exporter</strong></li>
</ul>
<p>在Prometheus的架构设计中，Prometheus Server并不直接服务监控特定的目标，其主要任务负责数据的收集，存储并且对外提供数据查询支持。因此为了能够能够监控到某些东西，如主机的CPU使用率，我们需要使用到Exporter。Prometheus周期性的从Exporter暴露的HTTP服务地址（通常是/metrics）拉取监控样本数据。</p>
<p>这里为了能够采集到主机的运行指标如CPU, 内存，磁盘等信息。我们可以使用 <a href="https://github.com/prometheus/node_exporter">Node Exporter</a>。</p>
<p>另外可以参考 <a href="https://devopscube.com/install-configure-prometheus-linux/">文章</a> 将prometheus 设置为systemd监管。</p>
<p>从日志上可以看出 node_exporter 监听在 9100 端口上，默认的 metrics 接口通过 /metrics 端点暴露，我们可以通过访问 <code>http://localhost:9100/metrics</code> 来获取监控指标数据，该 metrics 接口数据就是一个标准的 Prometheus 监控指标格式，我们只需要将该端点配置到 Prometheus 中即可抓取该指标数据。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul>
<li>参考<a href="https://www.jianshu.com/p/fa5f911003c6">文章</a></li>
<li>参考<a href="https://jishuin.proginn.com/p/763bfbd6a391">文章</a></li>
</ul>
<h3 id="Prometheus-四大度量指标"><a href="#Prometheus-四大度量指标" class="headerlink" title="Prometheus 四大度量指标"></a>Prometheus 四大度量指标</h3><ol>
<li>Counter (计数器)</li>
</ol>
<ul>
<li>描述：Counter 类型代表一个累积的指标数据，其<strong>单调递增</strong>，只增不减。在应用场景中，像是<strong>请求次数、错误数量</strong>等等，就非常适合用 Counter 来做指标类型，另外 Counter 类型，只有在被采集端重新启动时才会归零。</li>
</ul>
<ul>
<li>常用方法:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Inc()</td>
<td style="text-align:center">将计数器递增1</td>
</tr>
<tr>
<td style="text-align:center">Add(float64)</td>
<td style="text-align:center">将给定添加计数器中,小于0报错</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>Gauge (仪表盘)</li>
</ol>
<ul>
<li><p>描述: Gauge 类型代表一个可以任意变化的指标数据，其可增可减。在应用场景中，像是 Go 应用程序运行时的 <strong>Goroutine 的数量</strong>就可以用该类型来表示，在系统中统计 <strong>CPU、Memory </strong>等等时很常见，而在业务场景中，<strong>业务队列的数量</strong> 也可以用 Gauge 来统计，实时观察队列数量，及时发现堆积情况,因为其是浮动的数值，并非固定的，侧重于反馈当前的情况</p>
</li>
<li><p>常用方法:</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Set(float64)</td>
<td style="text-align:center">将仪表设置为任意值</td>
</tr>
<tr>
<td style="text-align:center">Inc()</td>
<td style="text-align:center">将仪表增加 1</td>
</tr>
<tr>
<td style="text-align:center">Dec()</td>
<td style="text-align:center">将仪表减少 1</td>
</tr>
<tr>
<td style="text-align:center">Add(float64)</td>
<td style="text-align:center">将给定值添加到仪表，该值如果为负数，那么将导致仪表值减少</td>
</tr>
<tr>
<td style="text-align:center">Sub(float64)</td>
<td style="text-align:center">从仪表中减去给定值，该值如果为负数，那么将导致仪表值增加</td>
</tr>
<tr>
<td style="text-align:center">SetToCurrentTime()</td>
<td style="text-align:center">将仪表设置为当前Unix时间（以秒为单位）</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>Histogram(累积直方图)</li>
</ol>
<ul>
<li>描述：Histogram 类型将会在一段时间范围内对数据进行采样（通常是请求持续时间或响应大小等等），并将其计入可配置的存储桶（bucket）中，后续可通过指定区间筛选样本，也可以统计样本总数。</li>
</ul>
<p>Histogram 类型在应用场景中非常的常用，因为其代表的就是分组区间的统计，而在分布式场景盛行的现在，链路追踪系统是必不可少的，那么针对不同的链路的分析统计就非常的有必要，例如像是对 <strong>RPC、SQL、HTTP、Redis 的 P90、P95、P99 </strong>进行计算统计，并且更进一步的做告警，就能够及时的发现应用链路缓慢，进而发现和减少第三方系统的影响。</p>
<ul>
<li>常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Observe(float64)</td>
<td style="text-align:center">将一个观察值添加到直方图。</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>Summary（摘要）</li>
</ol>
<ul>
<li><p>描述：Summary 类型将会在一段时间范围内对数据进行采样，但是与 Histogram 类型不同的是 Summary 类型将会存储分位数（在客户端进行计算），而不像 Histogram 类型，根据所设置的区间情况统计存储。提供三种摘要指标: 样本值的分位数分布情况,所有样本值的大小总和,样本总数</p>
</li>
<li><p>常用方法</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Observe(float64)</td>
<td style="text-align:center">将一个观察值添加到直方图。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="使用PromQL-查询监控"><a href="#使用PromQL-查询监控" class="headerlink" title="使用PromQL 查询监控"></a>使用PromQL 查询监控</h3><p>PromQL是Prometheus自定义的一套强大的数据查询语言，除了使用监控指标作为查询关键字以为，还内置了大量的函数，帮助用户进一步对时序数据进行处理。<br>具体可以参考 <a href="https://prometheus.fuckcloudnative.io/di-san-zhang-prometheus/di-4-jie-cha-xun/basics">教程</a></p>
<p><strong>下面以监控CPU为例</strong></p>
<p>对于节点我们首先能想到的就是要先对 CPU 进行监控，因为 CPU 是处理任务的核心，根据 CPU 的状态可以分析出当前系统的健康状态。要对节点进行 CPU 监控，需要用到 <code>node_cpu_seconds_total</code> 这个监控指标，在 metrics 接口中该指标内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl 127.0.0.1:9100&#x2F;metrics -s |grep -v &quot;#&quot; |grep node_cpu</span><br><span class="line">node_cpu_guest_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;nice&quot;&#125; 0</span><br><span class="line">node_cpu_guest_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;user&quot;&#125; 0</span><br><span class="line">node_cpu_guest_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;nice&quot;&#125; 0</span><br><span class="line">node_cpu_guest_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;user&quot;&#125; 0</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;idle&quot;&#125; 130304.6</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;iowait&quot;&#125; 17.37</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;irq&quot;&#125; 0</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;nice&quot;&#125; 20.25</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;softirq&quot;&#125; 12.51</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;steal&quot;&#125; 0</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;system&quot;&#125; 585.6</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,mode&#x3D;&quot;user&quot;&#125; 467.62</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;idle&quot;&#125; 130201.93</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;iowait&quot;&#125; 78.33</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;irq&quot;&#125; 0</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;nice&quot;&#125; 18.39</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;softirq&quot;&#125; 12.38</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;steal&quot;&#125; 0</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;system&quot;&#125; 590.54</span><br><span class="line">node_cpu_seconds_total&#123;cpu&#x3D;&quot;1&quot;,mode&#x3D;&quot;user&quot;&#125; 464.42</span><br></pre></td></tr></table></figure>
<p>从接口中描述可以看出该指标是用来统计 CPU 每种模式下所花费的时间，是一个 Counter 类型的指标，也就是会一直增长，这个数值其实是 CPU 时间片的一个累积值，意思就是从操作系统启动起来 CPU 开始工作，就开始记录自己总共使用的时间，然后保存下来，而且这里的累积的 CPU 使用时间还会分成几个不同的模式。</p>
<p>接下来我们来对节点的 CPU 进行监控，我们也知道一个一直增长的 CPU 时间对我们意义不大，一般我们更希望监控的是节点的 CPU 使用率。</p>
<p>要计算 CPU 的使用率，那么就需要搞清楚这个使用率的含义，CPU 使用率是 CPU 除空闲（idle）状态之外的其他所有 CPU 状态的时间总和除以总的 CPU 时间得到的结果，理解了这个概念后就可以写出正确的 promql 查询语句了。</p>
<p>要计算除空闲状态之外的 CPU 时间总和，更好的方式是不是直接计算空闲状态的 CPU 时间使用率，然后用 1 减掉就是我们想要的结果了，所以首先我们先过滤 idle 模式的指标，在 Prometheus 的 WebUI 中输入 <code>node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;</code>进行过滤：</p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/prometheus_cpu_idle1.png"></p>
<p>要计算使用率，肯定就需要知道 <code>idle</code> 模式的 CPU 用了多长时间，然后和总的进行对比，由于这是 <code>Counter</code> 指标，我们可以用 <code>increase</code> 函数来获取变化，使用查询语句 <code>increase(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[1m])</code>，因为 <code>increase</code> 函数要求输入一个区间向量，所以这里我们取 1 分钟内的数据：</p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/prometheus_cpu_idle2.png"></p>
<p>我们可以看到查询结果中有很多不同 cpu 序号的数据，我们当然需要计算所有 CPU 的时间，所以我们将它们聚合起来，我们要查询的是不同节点的 CPU 使用率，所以就需要根据 instance 标签进行聚合，使用查询语句 <code>sum(increase(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[1m])) by (instance)</code>：</p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/prometheus_cpu_idle3.png"></p>
<p>这样我们就分别拿到不同节点 1 分钟内的空闲 CPU 使用时间了，然后和总的 CPU （这个时候不需要过滤状态模式）时间进行比较即可，使用查询语句 <code>sum(increase(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[1m])) by (instance) / sum(increase(node_cpu_seconds_total[1m])) by (instance)</code>：</p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/prometheus_cpu_idle4.png"></p>
<p>然后计算 CPU 使用率就非常简单了，使用 1 减去乘以 100 即可：<code>(1 - sum(increase(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[1m])) by (instance) / sum(increase(node_cpu_seconds_total[1m])) by (instance) ) * 100</code>。这就是能够想到的最直接的 CPU 使用率查询方式了，当然前面我们学习的 promql 语法中提到过更多的时候我们会去使用 <code>rate</code> 函数，而不是用 <code>increase</code> 函数进行计算，所以最终的 CPU 使用率的查询语句为：<code>(1 - sum(increase(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[1m])) by (instance) / sum(increase(node_cpu_seconds_total[1m])) by (instance) ) * 100</code></p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/prometheus_cpu_idle6.png"></p>
<p><strong>和腾讯云控制台的数据作对比</strong>, 指标趋势是一致的。</p>
<p><img src="https://img1.kiosk007.top/static/images/nginx/lua/prometheus_cpu_idle7.png"></p>
<ul>
<li><strong>使用Grafana创建可视化Dashboard</strong></li>
</ul>
<p>Prometheus UI提供了快速验证PromQL以及临时可视化支持的能力，而在大多数场景下引入监控系统通常还需要构建可以长期使用的监控数据可视化面板（Dashboard）。这时用户可以考虑使用第三方的可视化工具如Grafana，Grafana是一个开源的可视化平台，并且提供了对Prometheus的完整支持。<br>安装 grafana 参考<a href="https://cloud.tencent.com/developer/article/1807679">文章</a></p>
<p>grafana 可以默认支持 prometheus 数据源的接入。访问<a href="http://localhost:3000就可以进入到Grafana的界面中，默认情况下使用账户admin/admin进行登录。在Grafana首页中显示默认的使用向导，包括：安装、添加数据源、创建Dashboard、邀请成员、以及安装应用和插件等主要流程。">http://localhost:3000就可以进入到Grafana的界面中，默认情况下使用账户admin/admin进行登录。在Grafana首页中显示默认的使用向导，包括：安装、添加数据源、创建Dashboard、邀请成员、以及安装应用和插件等主要流程。</a></p>
<p>按照上面的参考文章，可以完整的配置完成。</p>
<h2 id="grafana-监控"><a href="#grafana-监控" class="headerlink" title="grafana 监控"></a>grafana 监控</h2><p>首先在prometheus 上画好的图就可以在 grafana 上做监控了，我这里将 <code>nginx-lua-prometheus</code> 做了少许改造，可以参考:<br><code>https://github.com/weijiaxiang007/nginx-lua-prometheus</code></p>
<p>一般的查询语法可以在 grafana 的官方网站上找一些。</p>
<p><a href="https://grafana.com/grafana/dashboards/2949/revisions">https://grafana.com/grafana/dashboards/2949/revisions</a></p>
<h1 id="nginx-lua-prometheus"><a href="#nginx-lua-prometheus" class="headerlink" title="nginx-lua-prometheus"></a>nginx-lua-prometheus</h1><p><code>nginx-lua-prometheus</code> 是一个lua写的Nginx监控项目，可以拉取Nginx的相关metrics 生成监控dashboard。</p>
<p>参考<a href="https://github.com/knyar/nginx-lua-prometheus">github</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;github.com&#x2F;knyar&#x2F;nginx-lua-prometheus</span><br></pre></td></tr></table></figure>
<p>快速安装，需要将下面的内容写在 <code>nginx.conf</code> 的 <code>http</code> 块内。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lua_shared_dict</span> prometheus_metrics <span class="number">10M</span>;</span><br><span class="line"><span class="attribute">lua_package_path</span> <span class="string">&quot;/path/to/nginx-lua-prometheus/?.lua;;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">init_worker_by_lua_block</span> &#123;</span><br><span class="line">  <span class="attribute">prometheus</span> = require(<span class="string">&quot;prometheus&quot;</span>).init(<span class="string">&quot;prometheus_metrics&quot;</span>)</span><br><span class="line"></span><br><span class="line">  metric_requests = prometheus:counter(</span><br><span class="line">    &quot;nginx_http_requests_total&quot;, &quot;Number of HTTP requests&quot;, &#123;&quot;host&quot;, &quot;status&quot;&#125;)</span><br><span class="line">  <span class="attribute">metric_latency</span> = prometheus:histogram(</span><br><span class="line">    &quot;nginx_http_request_duration_seconds&quot;, &quot;HTTP request latency&quot;, &#123;&quot;host&quot;&#125;)</span><br><span class="line">  <span class="attribute">metric_connections</span> = prometheus:gauge(</span><br><span class="line">    &quot;nginx_http_connections&quot;, &quot;Number of HTTP connections&quot;, &#123;&quot;state&quot;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">log_by_lua_block</span> &#123;</span><br><span class="line">  metric_requests:inc(1, &#123;ngx.var.server_name, ngx.var.status&#125;)</span><br><span class="line">  metric_latency:observe(tonumber(ngx.var.request_time), &#123;ngx.var.server_name&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 prometheus 的统计代码中可以看到，在 <code>init_worker_by_lua_block</code> 有统计 HTTP 请求个数的 <code>metric_requests</code>, 和统计时延分布直方图的 <code>metric_latency</code> 和当前的链接数<code>metric_connections</code>。</p>
<p>总的来说，prometheus 提供了 <code>prometheus:counter</code>、<code>prometheus:histogram</code>、<code>prometheus:gauge</code> 3个方法，分别用于counter（计数）、Gauge (仪表盘)、Histogram(累积直方图)</p>
<p>在 <code>log_by_lua_block</code> 中有两个函数进行累加和赋值操作。</p>
<p>接下来我们分析分析它的源码。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>先看看代码的总体结构, 一个可供外部调用的代码应该按照下面的格式。<code>local Prometheus = &#123;&#125;</code> 最后再 <code>return Prometheus</code>。这里的 <code>mt = &#123; __index = Prometheus &#125;</code> 会在后面的 <code>init()</code> 实现类的构造函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> resty_counter_lib = <span class="built_in">require</span>(<span class="string">&quot;prometheus_resty_counter&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> key_index_lib = <span class="built_in">require</span>(<span class="string">&quot;prometheus_keys&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> Prometheus = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> mt = &#123; <span class="built_in">__index</span> = Prometheus &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> TYPE_COUNTER    = <span class="number">0x1</span></span><br><span class="line"><span class="keyword">local</span> TYPE_GAUGE      = <span class="number">0x2</span></span><br><span class="line"><span class="keyword">local</span> TYPE_HISTOGRAM  = <span class="number">0x4</span></span><br><span class="line"><span class="keyword">local</span> TYPE_LITERAL = &#123;</span><br><span class="line">  [TYPE_COUNTER]   = <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  [TYPE_GAUGE]     = <span class="string">&quot;gauge&quot;</span>,</span><br><span class="line">  [TYPE_HISTOGRAM] = <span class="string">&quot;histogram&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Prometheus</span><br></pre></td></tr></table></figure>
<p>再来分析其中的<code>init</code> 方法。这里的 <code>local self = setmetable(&#123;&#125;, mt)</code> 将self指向自己本身。<code>第19行</code> 开始设置参数, 这里可以设置的参数有错误metrics 名字和同步间隔。可以 <code>prometheus = require(&quot;prometheus&quot;).init(&quot;prometheus_metrics&quot;,&#123;sync_interval=0.4&#125;)</code> 这样的方式调用。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Prometheus.init</span><span class="params">(dict_name, options_or_prefix)</span></span></span><br><span class="line">  <span class="comment">-- 检查当前正在运行的阶段名称</span></span><br><span class="line">  <span class="keyword">if</span> ngx.get_phase() ~= <span class="string">&#x27;init&#x27;</span> <span class="keyword">and</span> ngx.get_phase() ~= <span class="string">&#x27;init_worker&#x27;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&#x27;Prometheus.init can only be called from &#x27;</span> ..</span><br><span class="line">      <span class="string">&#x27;init_by_lua_block or init_worker_by_lua_block&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 类的构造函数、并且判断是否在Nginx配置文件中设置共享内存。</span></span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">self</span> = <span class="built_in">setmetatable</span>(&#123;&#125;, mt)</span><br><span class="line">  dict_name = dict_name <span class="keyword">or</span> <span class="string">&quot;prometheus_metrics&quot;</span></span><br><span class="line">  <span class="built_in">self</span>.dict_name = dict_name</span><br><span class="line">  <span class="built_in">self</span>.dict = ngx.shared[dict_name]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">self</span>.dict == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Dictionary &#x27;&quot;</span> .. dict_name .. <span class="string">&quot;&#x27; does not seem to exist. &quot;</span> ..</span><br><span class="line">      <span class="string">&quot;Please define the dictionary using `lua_shared_dict`.&quot;</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 设置参数</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">type</span>(options_or_prefix) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">self</span>.prefix = options_or_prefix.prefix <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">self</span>.error_metric_name = options_or_prefix.error_metric_name <span class="keyword">or</span></span><br><span class="line">      DEFAULT_ERROR_METRIC_NAME</span><br><span class="line">    <span class="built_in">self</span>.sync_interval = options_or_prefix.sync_interval <span class="keyword">or</span></span><br><span class="line">      DEFAULT_SYNC_INTERVAL</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">self</span>.prefix = options_or_prefix <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">self</span>.error_metric_name = DEFAULT_ERROR_METRIC_NAME</span><br><span class="line">    <span class="built_in">self</span>.sync_interval = DEFAULT_SYNC_INTERVAL</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">self</span>.registry = &#123;&#125;</span><br><span class="line">  <span class="built_in">self</span>.key_index = key_index_lib.new(<span class="built_in">self</span>.dict, KEY_INDEX_PREFIX)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">self</span>.initialized = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 注册请求错误个数的 counter</span></span><br><span class="line">  <span class="built_in">self</span>:counter(<span class="built_in">self</span>.error_metric_name, <span class="string">&quot;Number of nginx-lua-prometheus errors&quot;</span>)</span><br><span class="line">  <span class="built_in">self</span>.dict:set(<span class="built_in">self</span>.error_metric_name, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">local</span> err = <span class="built_in">self</span>.key_index:add(<span class="built_in">self</span>.error_metric_name)</span><br><span class="line">  <span class="keyword">if</span> err <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">self</span>:log_error(err)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ngx.get_phase() == <span class="string">&#x27;init_worker&#x27;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">self</span>:init_worker(<span class="built_in">self</span>.sync_interval)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">self</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>接下来只介绍一下 <code>counter()</code> 函数的执行逻辑，其本质是一个工厂函数，实际调用的是 <code>register()</code> 方法。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Public function to register a counter.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Prometheus:counter</span><span class="params">(name, help, label_names)</span></span></span><br><span class="line">  <span class="keyword">return</span> register(<span class="built_in">self</span>, name, help, label_names, <span class="literal">nil</span>, TYPE_COUNTER)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- register 工厂函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">(self, name, help, label_names, buckets, typ)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">self</span>.initialized <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;Prometheus module has not been initialized&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">local</span> err = check_metric_and_label_names(name, label_names)</span><br><span class="line">  <span class="keyword">if</span> err <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">self</span>:log_error(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">local</span> name_maybe_historgram = name:<span class="built_in">gsub</span>(<span class="string">&quot;_bucket$&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                                    :<span class="built_in">gsub</span>(<span class="string">&quot;_count$&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                                    :<span class="built_in">gsub</span>(<span class="string">&quot;_sum$&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="comment">-- 判断是否有重复的metric                                  </span></span><br><span class="line">  <span class="keyword">if</span> (typ ~= TYPE_HISTOGRAM <span class="keyword">and</span> (</span><br><span class="line">      <span class="built_in">self</span>.registry[name] <span class="keyword">or</span> <span class="built_in">self</span>.registry[name_maybe_historgram]</span><br><span class="line">    )) <span class="keyword">or</span></span><br><span class="line">    (typ == TYPE_HISTOGRAM <span class="keyword">and</span> (</span><br><span class="line">      <span class="built_in">self</span>.registry[name] <span class="keyword">or</span></span><br><span class="line">      <span class="built_in">self</span>.registry[name .. <span class="string">&quot;_count&quot;</span>] <span class="keyword">or</span></span><br><span class="line">      <span class="built_in">self</span>.registry[name .. <span class="string">&quot;_sum&quot;</span>] <span class="keyword">or</span> <span class="built_in">self</span>.registry[name .. <span class="string">&quot;_bucket&quot;</span>]</span><br><span class="line">    )) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">self</span>:log_error(<span class="string">&quot;Duplicate metric &quot;</span> .. name)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 初始化 metrics</span></span><br><span class="line">  <span class="keyword">local</span> metric = &#123;</span><br><span class="line">    name = name,</span><br><span class="line">    help = help,</span><br><span class="line">    typ = typ,</span><br><span class="line">    label_names = label_names,</span><br><span class="line">    label_count = label_names <span class="keyword">and</span> #label_names <span class="keyword">or</span> <span class="number">0</span>,</span><br><span class="line">    <span class="comment">-- Lookup is a tree of lua tables that contain label values, with leaf</span></span><br><span class="line">    <span class="comment">-- tables containing full metric names. For example, given a metric</span></span><br><span class="line">    <span class="comment">-- `http_count` and labels `host` and `status`, it might contain the</span></span><br><span class="line">    <span class="comment">-- following values:</span></span><br><span class="line">    <span class="comment">-- [&#x27;me.com&#x27;][&#x27;200&#x27;][LEAF_KEY] = &#x27;http_count&#123;host=&quot;me.com&quot;,status=&quot;200&quot;&#125;&#x27;</span></span><br><span class="line">    lookup = &#123;&#125;,</span><br><span class="line">    parent = <span class="built_in">self</span>,</span><br><span class="line">    <span class="comment">-- Store a reference for logging functions for faster lookup.</span></span><br><span class="line">    _log_error = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span> <span class="built_in">self</span>:log_error(...) <span class="keyword">end</span>,</span><br><span class="line">    _log_error_kv = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span> <span class="built_in">self</span>:log_error_kv(...) <span class="keyword">end</span>,</span><br><span class="line">    _key_index = <span class="built_in">self</span>.key_index,</span><br><span class="line">    _dict = <span class="built_in">self</span>.dict,</span><br><span class="line">    reset = reset,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 将封装方法赋值给 metric </span></span><br><span class="line">  <span class="keyword">if</span> typ &lt; TYPE_HISTOGRAM <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> typ == TYPE_GAUGE <span class="keyword">then</span></span><br><span class="line">      metric.set = set</span><br><span class="line">      metric.inc = inc_gauge</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      metric.inc = inc_counter</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    metric.del = del</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    metric.observe = observe</span><br><span class="line">    metric.buckets = buckets <span class="keyword">or</span> DEFAULT_BUCKETS</span><br><span class="line">    metric.bucket_count = #metric.buckets</span><br><span class="line">    metric.bucket_format = construct_bucket_format(metric.buckets)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">self</span>.registry[name] = metric</span><br><span class="line">  <span class="keyword">return</span> metric</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Module 基本使用</title>
    <url>/2021/11/26/Go-Module-%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 1.13版本之后新的包管理器Modules趋于成熟，目前越来越多的开源项目已经支持Go Modules，典型的如etcd。Go具有相当长的包管理工具变迁史，各种包管理工具层出不穷，究其原因，还是官方没有实现足够好用包管理工具。本文不对部分基础知识做详解，主要重点是Go Modules</p>
<p>参考：<a href="https://roberto.selbach.ca/intro-to-go-modules/">https://roberto.selbach.ca/intro-to-go-modules/</a></p>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>几乎所有的包管理工具在Go 1.11版本之前都绕不开GOPATH这个环境变量。GOPATH主要用来放置项目依赖包的源代码，GOPATH不区分项目，代码中任何import的路径均从GOPATH为根目录开始；但现在GOPATH已经不够用了。</p>
<h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="开启-go-module"><a href="#开启-go-module" class="headerlink" title="开启 go module"></a>开启 go module</h2><p><code>go module</code> 没有默认开启，开关通过系统环境变量 <code>GO111MODULE</code> 控制。<br>这个变量有三个可选值 </p>
<blockquote>
<p>1.16 版本起，环境变量 GO111MODULE 的默认值正式修改为 on。</p>
</blockquote>
<p>这个变量有三个可选值 </p>
<ul>
<li><strong>auto</strong>: 默认值，如果项目在 <code>$GOPATH</code> 目录内则使用传统的 GOPATH 方式管理，否则使用 Go module 方式管理。 go1.13 后只要项目有 go.mod 文件，即使在 GOPATH 里，也会使用 Go module 方式管理。</li>
<li><strong>on</strong> : 不论项目在 <code>$GOPATH</code> 之内还是之外，全部使用 Go module 方式管理。 </li>
<li><strong>off</strong> : 项目在 <code>$GOPATH</code> 之内使用传统方式管理，不支持项目在 <code>$GOPATH</code> 之外。</li>
</ul>
<h2 id="模块-module"><a href="#模块-module" class="headerlink" title="模块 module"></a>模块 module</h2><p>go module 模式引入了一个新的概念 - 模块(module)，一个模块是一组包(package)的集合，这些包共用同一个版本信息。<br>模块里记录了准确的依赖信息。<br>一个包含 go.mod 的目录及其子目录构成了一个模块 (module)；一个目录即是一个包 (package)；再加上代码托管平台 (github, gitlab) 的仓库 (repositories)，他们的关系如下： </p>
<ul>
<li>一个仓库包含一个或者多个模块 </li>
<li>一个模块包含一个或多个包 </li>
<li>一个包包含该目录下的所有 go 源码文件 </li>
</ul>
<h2 id="go-mod-go-sum"><a href="#go-mod-go-sum" class="headerlink" title="go.mod, go.sum"></a>go.mod, go.sum</h2><p>使用 go module 模式进行依赖管理会生成 go.mod, go.sum 两个文件。<br>go.mod 有四个指令 <code>module</code>, <code>require</code>, <code>replace</code>, <code>exclude</code>。<br>常见的 go.mod 文件如下 </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">module github.com/lucas-clemente/quic-<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/cheekybits/genny v1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">	github.com/francoispqt/gojay v1<span class="number">.2</span><span class="number">.13</span></span><br><span class="line">	github.com/golang/mock v1<span class="number">.6</span><span class="number">.0</span></span><br><span class="line">	github.com/marten-seemann/qpack v0<span class="number">.2</span><span class="number">.1</span></span><br><span class="line">	github.com/marten-seemann/qtls-go1<span class="number">-15</span> v0<span class="number">.1</span><span class="number">.5</span></span><br><span class="line">	github.com/marten-seemann/qtls-go1<span class="number">-16</span> v0<span class="number">.1</span><span class="number">.4</span></span><br><span class="line">	github.com/marten-seemann/qtls-go1<span class="number">-17</span> v0<span class="number">.1</span><span class="number">.0</span>-rc<span class="number">.1</span></span><br><span class="line">	github.com/onsi/ginkgo v1<span class="number">.16</span><span class="number">.4</span></span><br><span class="line">	github.com/onsi/gomega v1<span class="number">.13</span><span class="number">.0</span></span><br><span class="line">	golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200622213623</span><span class="number">-75</span>b288015ac9</span><br><span class="line">	golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210428140749</span><span class="number">-89</span>ef3d95e781</span><br><span class="line">	golang.org/x/sync v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210220032951</span><span class="number">-036812</span>b2e83c</span><br><span class="line">	golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210510120138</span><span class="number">-977</span>fb7262007</span><br><span class="line">	gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20180628173108</span><span class="number">-788</span>fd7840127 <span class="comment">// indirect</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace (</span><br><span class="line">    golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200622213623</span><span class="number">-75</span>b288015ac9 =&gt; github.com/google/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200622213623</span><span class="number">-75</span>b288015ac9</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>module 用来定义当前模块名称 </p>
<ul>
<li><strong>require</strong>: 是描述依赖信息 </li>
<li><strong>replace</strong> 用于是用指定依赖（后者）去代替前者。比如 github 的仓库项目替代 golang.org 的。 </li>
<li><strong>exclude</strong> 用来忽略某些特定版本</li>
</ul>
<blockquote>
<p>Go1.16 针对 Go modules 放出了一个新特性，能够让维护 Go mod 库的开发者拥有反复吃 “后悔药” 的权力，提醒开发者已发布的脏版本存在问题。<code>go mod retract</code><br>参考：<a href="https://eddycjy.com/posts/go/go1.16-mod/">Go1.16 新特性 go mod retract</a></p>
</blockquote>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>go module 的版本通过仓库的 tag 来确定，所以推荐 master 上的重要版本都打上 tag。</p>
<p>对于没有打 tag 的仓库，go.mod 就会很丑陋，它的格式是 v0.0.0-<time>-<commit id> 。它的含义是v0.0.0-yyyymmddhhmmss-abcdefabcdef。</commit></time></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>对于一个新的项目，需要执行<code>go mod init xxxx</code>初始化 <code>go.mod</code> 文件。xxxx 为模块路径 (比如 <code>github.com/pkg/test</code>)，即 import 使用的路径。<br>然后执行 <code>go mod tidy</code> 整理依赖，这个命令会检索项目添加 <code>go.mod</code> 里面没有的依赖，同时也会删除不再使用的依赖。 </p>
<h2 id="添加新依赖"><a href="#添加新依赖" class="headerlink" title="添加新依赖"></a>添加新依赖</h2><ol>
<li>自动添加</li>
</ol>
<p>在代码里面 import 了某个依赖后，执行 <code>go build</code>、<code>go run</code>、<code>go test</code> 就会自动添加该依赖的最新版到 go.mod。</p>
<ol>
<li>手动添加</li>
</ol>
<p>如果新增了一个依赖，可以使用 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com&#x2F;pkg&#x2F;xxx@master</span><br></pre></td></tr></table></figure>
<p>@master 这里也可以指定特定版本，比如 @v1.0.1，或者 @latest 更新到最新版本。也可以指定特定的 commit id，比如 @aabbccdd。</p>
<h2 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod 命令"></a>go mod 命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod</span><br><span class="line">The commands are:</span><br><span class="line">  download    download modules to <span class="built_in">local</span> cache (下载依赖的module到本地cache))</span><br><span class="line">  edit        edit go.mod from tools or scripts (编辑go.mod文件)</span><br><span class="line">  graph       <span class="built_in">print</span> module requirement graph (打印模块依赖图))</span><br><span class="line">  init        initialize new module <span class="keyword">in</span> current directory (再当前文件夹下初始化一个新的module, 创建go.mod文件))</span><br><span class="line">  tidy        add missing and remove unused modules (增加丢失的module，去掉未用的module)</span><br><span class="line">  vendor      make vendored copy of dependencies (将依赖复制到vendor下)</span><br><span class="line">  verify      verify dependencies have expected content (校验依赖)</span><br><span class="line">  why         explain why packages or modules are needed (解释为什么需要依赖)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初始化项目使用 <code>go mod init xxxx</code><br>日常使用最多的命令就是 <code>go get -u xxxx</code> 来添加依赖和 <code>go mod tidy</code> 来清理依赖。</p>
<h1 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h1><ul>
<li>release version（发布版本）</li>
</ul>
<p>发布版本是一个由点号组成的三个正整数。比如 v1.2.3，从左到位每一位整数分别被称为 major, minor, patch。</p>
<ul>
<li>pseudo version（伪版本）</li>
</ul>
<p>伪版本号是通过编码一个版本唯一标识（比如 git 的 commit id)和一个时间戳组成的，比如 v0.0.0-20191109021931-daa7c04131f5。主要在两个场景使用，一是对于不是 go module 的仓库，二是一些场景下获取不到合适的 tag 信息，比如指定分支。</p>
<ul>
<li>pre-release version(预发布版本）</li>
</ul>
<p>预发布版本是发布版本后接一个预发布后缀。预发布后缀是 - 接一个字符串或者 + 接一个 build 元信息。比如 v8.0.5-pre, v2.0.9+meta<br>带有预发布后缀的版本都为被认为为不稳定版本，这类版本会认为与其他版本不兼容。</p>
<h1 id="Go-环境"><a href="#Go-环境" class="headerlink" title="Go 环境"></a>Go 环境</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 指定不走 proxy 的包路径，用于公司内网的仓库不走代理</span><br><span class="line"><span class="built_in">export</span> GOPRIVATE=<span class="string">&quot;*.taobao.com,*.abc.com&quot;</span></span><br><span class="line">// SUMDB 的代理，SUMDB 用于校验版本是否被恶意修改</span><br><span class="line"><span class="built_in">export</span> GOSUMDB=<span class="string">&quot;sum.golang.google.cn&quot;</span></span><br><span class="line"></span><br><span class="line">// GOPROXY，拉取依赖库使用的代理。</span><br><span class="line">// 适用于 GO 版本 1.15</span><br><span class="line"><span class="built_in">export</span> GOPROXY=<span class="string">&quot;https://goproxy.cn|direct&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理--编写Golang MakeFile</title>
    <url>/2021/11/20/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%BC%96%E5%86%99Golang-MakeFile/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要先编译，那些文件需要后编译，那些文件需要重建等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，Makefile 可以使得我们的项目工程的编译变得自动化，不需要每次都手动输入一堆源文件和参数。</p>
<a id="more"></a>
<blockquote>
<p>参考：《孔令飞老师的 Go语言开发实战》</p>
</blockquote>
<p>以 Linux 下的C语言开发为例来具体说明一下，多文件编译生成一个文件，编译的命令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o outfile name1.c name2.c ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>outfile 要生成的可执行程序的名字，nameN.c 是源文件的名字。</p>
<p>下面列举了一些需要我们手动链接的标准库：</p>
<ul>
<li>name1.c 用到了数学计算库 math 中的函数，我们得手动添加参数 -Im；</li>
<li>name4.c 用到了小型数据库 SQLite 中的函数，我们得手动添加参数 -lsqlite3；</li>
<li>name5.c 使用到了线程，我们需要去手动添加参数 -lpthread。</li>
</ul>
<h1 id="Make-语法"><a href="#Make-语法" class="headerlink" title="Make 语法"></a>Make 语法</h1><p>编写高质量 Makefile 的第一步，便是熟练掌握 Makefile 的核心语法。<br>这里可以参考 <a href="https://github.com/seisman/how-to-write-makefile">《跟我一起写Makefile (PDF重制版)》</a>、<a href="http://c.biancheng.net/view/7097.html">Makefile 教程</a></p>
<p>makefile 完整案例<a href="https://github.com/marmotedu/iam/blob/master/Makefile">IAM Makefile</a></p>
<p>makefile 的基本写法如下图，由 <code>target</code>,<code>dependencies</code>,<code>command</code>（command前必须是 tab 键） 组成<br><img src="https://img1.kiosk007.top/static/images/makefile/grammar1.png"></p>
<ul>
<li><code>target</code>：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；</li>
<li><code>dependencies</code>：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</li>
<li><code>command</code>：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li>
</ul>
<p>一个最基本的 golang Makefile 文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">build: clean vet</span></span><br><span class="line">  @mkdir -p ./Role</span><br><span class="line">  @<span class="keyword">export</span> GOOS=linux &amp;&amp; go build -v .</span><br><span class="line"></span><br><span class="line"><span class="section">vet:</span></span><br><span class="line">  go vet ./...</span><br><span class="line"></span><br><span class="line"><span class="section">fmt:</span></span><br><span class="line">  go fmt ./...</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  rm -rf dashboard</span><br></pre></td></tr></table></figure>
<blockquote>
<p>shell 命令行前的 @ 是为了防止回显，否则会将 <code>mkdir -p ./Role</code>输出出来再执行</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==============================================================================</span></span><br><span class="line"><span class="comment"># Usage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> USAGE_OPTIONS</span><br><span class="line"></span><br><span class="line"><span class="section">Options:</span></span><br><span class="line">  DEBUG        Whether to generate debug symbols. Default is 0.</span><br><span class="line">  BINS         The binaries to build. Default is all of cmd.</span><br><span class="line">               This option is available when using: make </span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"><span class="keyword">export</span> USAGE_OPTIONS</span><br><span class="line"></span><br><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">	@<span class="variable">$(MAKE)</span> go.build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## help: Show this help info.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: help</span></span><br><span class="line"><span class="section">help: Makefile</span></span><br><span class="line">	@echo -e <span class="string">&quot;\nUsage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...\n\nTargets:&quot;</span></span><br><span class="line">	@sed -n &#x27;s/^<span class="comment">##//p&#x27; $&lt; | column -t -s &#x27;:&#x27; | sed -e &#x27;s/^/ /&#x27;</span></span><br><span class="line">	@echo <span class="string">&quot;$$USAGE_OPTIONS&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个进阶的Makefile有以下知识点</p>
<h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>所谓的伪目标可以这样来理解，它并不会创建目标文件，只是想去执行这个目标下面的命令。伪目标的存在可以帮助我们找到命令并执行。</p>
<p>特殊的标记 “.PHONY” 来显式地指明一个目标是“伪目标”，“.PHONY” 标记的target可以理解成一个无条件执行的动作。<br>这样就可以执行 <code>make help</code> 命令了。</p>
<p>使用<code>伪目标</code>主要有2个原因：</p>
<ol>
<li>避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。</li>
<li>提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。</li>
</ol>
<p>如下命令：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o test</span><br></pre></td></tr></table></figure>
<p>规则中 rm 命令不是创建文件 clean 的命令，而是执行删除任务，删除当前目录下的所有的 .o 结尾和文件名为 test 的文件。当工作目录下不存在以 clean 命令的文件时，在 shell 中输入 make clean 命令，命令 rm -rf *.o test 总会被执行 ，这也是我们期望的结果。</p>
<p>如果当前目录下存在文件名为  clean 的文件时情况就会不一样了，当我们在 shell 中执行命令 make clean，由于这个规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令。因此命令 rm 将不会被执行。为了解决这个问题，删除 clean 文件或者是在 Makefile 中将目标 clean 声明为伪目标。将一个目标声明称伪目标的方法是将它作为特殊的目标.PHONY的依赖，比如 <code>.PHONY:clean</code></p>
<h2 id="自动化变量-Automatic-Variables）"><a href="#自动化变量-Automatic-Variables）" class="headerlink" title="自动化变量 (Automatic Variables）"></a>自动化变量 (Automatic Variables）</h2><p>help 后面跟了一个文件 <code>Makefile</code>, 没错！就是help会将<code>Makefile</code> 当成参数。help 后面里有几个 $$$$、<code>$&lt;</code> 变量</p>
<p><code>$&lt;</code> 可以引用 Makefile 当成参数。没错，上述的命令展开就是 <code>sed -n &#39;s/^##//p&#39; Makefile | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39;</code>。<br>其实是将整个 <code>Makefile</code> 中的双井号解析成帮助命令。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">自动化变量</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成.a文件为文档文件，也成为静态的库文件），那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>
</tr>
<tr>
<td style="text-align:left">$%</td>
<td style="text-align:left">当目标文件是一个静态库文件时，代表静态库的一个成员名。</td>
</tr>
<tr>
<td style="text-align:left">$&lt;</td>
<td style="text-align:left">规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td>
</tr>
<tr>
<td style="text-align:left">$^</td>
<td style="text-align:left">代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件</td>
</tr>
<tr>
<td style="text-align:left">$+</td>
<td style="text-align:left">类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td>
</tr>
</tbody>
</table>
</div>
<p>举个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test:test.o test1.o test2.o</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">test.o:test.c test.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">test1.o:test1.c test1.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">test2.o:test2.c test2.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这个规则模式中用到了 “$@” 、”$&lt;” 和 “$^” 这三个自动化变量，对比之前写的 Makefile 中的命令，我们可以发现</p>
<ul>
<li>“$@” 代表的是目标文件test</li>
<li>“$^”代表的是依赖的文件</li>
<li>“$&lt;”代表的是依赖文件中的第一个。</li>
</ul>
<p>我们在执行 make 的时候，make 会自动识别命令中的自动化变量，并自动实现自动化变量中的值的替换，这个类似于编译C语言文件的时候的预处理的作用。</p>
<h2 id="内置变量（Implicit-Variables）"><a href="#内置变量（Implicit-Variables）" class="headerlink" title="内置变量（Implicit Variables）"></a>内置变量（Implicit Variables）</h2><p>上面的实例中有这样一个表达式 </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">	@<span class="variable">$(MAKE)</span> go.build</span><br></pre></td></tr></table></figure>
<p>Make命令提供一系列内置变量，（感觉上和gcc/g++的预定义宏差不多）比如，<code>$(CC)</code> 指向当前使用的编译器，<code>$(MAKE)</code> 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册</a>。</p>
<hr>
<p>看下面的例子，其是一个 <code>common.mk</code> 提供一些 Makefile 文件调用时的基础变量环境。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SHELL := /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># include the common make file</span></span><br><span class="line">COMMON_SELF_DIR := <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> ROOT_DIR)</span>,undefined)</span><br><span class="line">ROOT_DIR := <span class="variable">$(<span class="built_in">abspath</span> $(<span class="built_in">shell</span> cd <span class="variable">$(COMMON_SELF_DIR)</span>/../.. &amp;&amp; pwd -P)</span>)</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> OUTPUT_DIR)</span>,undefined)</span><br><span class="line">OUTPUT_DIR := <span class="variable">$(ROOT_DIR)</span>/_output</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(OUTPUT_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> TOOLS_DIR)</span>,undefined)</span><br><span class="line">TOOLS_DIR := <span class="variable">$(OUTPUT_DIR)</span>/tools</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(TOOLS_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> TMP_DIR)</span>,undefined)</span><br><span class="line">TMP_DIR := <span class="variable">$(OUTPUT_DIR)</span>/tmp</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(TMP_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的例子有以下几个知识点，<code>:=</code>、<code>ifeq</code>、<code>$()</code> 等。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>先说变量，变量对于我们来说是不陌生的，在学习各种编程语言时会经常用到。就拿C语言来说，变量的使用是十分常见的，变量可以用来保存一个值或者是使用变量进行运算操作。</p>
<p>调用变量的时候可以用 “$(VALUE_LIST)” 或者是 “${VALUE_LIST}” 来替换，这就是变量的引用。实例：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJ=main.o test.o test1.o test2.o</span><br><span class="line"><span class="section">test:<span class="variable">$(OBJ)</span></span></span><br><span class="line">      gcc -o test <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><br><strong>变量的基本赋值</strong><br>知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：</p>
<ul>
<li>简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。</li>
<li>递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。</li>
<li>条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。</li>
<li>追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。</li>
</ul>
<p>其中的简单赋值和条件赋值比较简单字面意思就可以理解，下面介绍一下另外两种。<br><strong>递归赋值</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x=foo</span><br><span class="line">y=<span class="variable">$(x)</span>b</span><br><span class="line">x=new</span><br><span class="line">test：</span><br><span class="line">      @echo <span class="string">&quot;y=&gt;<span class="variable">$(y)</span>&quot;</span></span><br><span class="line">      @echo <span class="string">&quot;x=&gt;<span class="variable">$(x)</span>&quot;</span></span><br><span class="line"><span class="comment">## 执行结果</span></span><br><span class="line"><span class="comment">## y=&gt;newb</span></span><br><span class="line"><span class="comment">## x=&gt;new</span></span><br></pre></td></tr></table></figure>
<p><strong>追加赋值</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x:=foo</span><br><span class="line">y:=<span class="variable">$(x)</span>b</span><br><span class="line">x+=<span class="variable">$(y)</span></span><br><span class="line">test：</span><br><span class="line">      @echo <span class="string">&quot;y=&gt;<span class="variable">$(y)</span>&quot;</span></span><br><span class="line">      @echo <span class="string">&quot;x=&gt;<span class="variable">$(x)</span>&quot;</span></span><br><span class="line"><span class="comment">## 执行结果</span></span><br><span class="line"><span class="comment">## y=&gt;foob</span></span><br><span class="line"><span class="comment">## x=&gt;foo foob</span></span><br></pre></td></tr></table></figure>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句只能用于控制 make 实际执行的 Makefile 文件部分，不能控制规则的 shell 命令执行的过程。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ifeq</td>
<td style="text-align:left">判断参数是否不相等，相等为 true，不相等为 false</td>
</tr>
<tr>
<td style="text-align:left">ifneq</td>
<td style="text-align:left">判断参数是否不相等，不相等为 true，相等为 false</td>
</tr>
<tr>
<td style="text-align:left">ifeq</td>
<td style="text-align:left">判断是否有值，有值为 true，没有值为 false</td>
</tr>
<tr>
<td style="text-align:left">ifneq</td>
<td style="text-align:left">判断是否有值，没有值为 true，有值为 false</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Makefile-要实现的功能"><a href="#Makefile-要实现的功能" class="headerlink" title="Makefile 要实现的功能"></a>Makefile 要实现的功能</h1><p>对于 Go 项目来说，虽然不同项目集成的功能不一样，但绝大部分项目都需要实现一些通用的功能。接下来，我们就来看看，在一个大型 Go 项目中 Makefile 通常可以实现的功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ make <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...</span><br><span class="line"></span><br><span class="line">Targets:</span><br><span class="line">  <span class="comment"># 代码生成类命令</span></span><br><span class="line">  gen                Generate all necessary files, such as error code files.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 格式化类命令</span></span><br><span class="line">  format             Gofmt (reformat) package sources (exclude vendor dir <span class="keyword">if</span> existed).</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 静态代码检查</span></span><br><span class="line">  lint               Check syntax and styling of go sources.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 测试类命令</span></span><br><span class="line">  <span class="built_in">test</span>               Run unit <span class="built_in">test</span>.</span><br><span class="line">  cover              Run unit <span class="built_in">test</span> and get <span class="built_in">test</span> coverage.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构建类命令</span></span><br><span class="line">  build              Build <span class="built_in">source</span> code <span class="keyword">for</span> host platform.</span><br><span class="line">  build.multiarch    Build <span class="built_in">source</span> code <span class="keyword">for</span> multiple platforms. See option PLATFORMS.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Docker镜像打包类命令</span></span><br><span class="line">  image              Build docker images <span class="keyword">for</span> host arch.</span><br><span class="line">  image.multiarch    Build docker images <span class="keyword">for</span> multiple platforms. See option PLATFORMS.</span><br><span class="line">  push               Build docker images <span class="keyword">for</span> host arch and push images to registry.</span><br><span class="line">  push.multiarch     Build docker images <span class="keyword">for</span> multiple platforms and push images to registry.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 部署类命令</span></span><br><span class="line">  deploy             Deploy updated components to development env.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 清理类命令</span></span><br><span class="line">  clean              Remove all files that are created by building.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 其他命令，不同项目会有区别</span></span><br><span class="line">  release            Release project</span><br><span class="line">  verify-copyright   Verify the boilerplate headers <span class="keyword">for</span> all files.</span><br><span class="line">  ca                 Generate CA files <span class="keyword">for</span> all project components.</span><br><span class="line">  install            Install project system with all its components.</span><br><span class="line">  swagger            Generate swagger document.</span><br><span class="line">  tools              install dependent tools.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 帮助命令</span></span><br><span class="line">  <span class="built_in">help</span>               Show this <span class="built_in">help</span> info.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项</span></span><br><span class="line">Options:</span><br><span class="line">  DEBUG        Whether to generate debug symbols. Default is 0.</span><br><span class="line">  BINS         The binaries to build. Default is all of cmd.</span><br><span class="line">               This option is available when using: make build/build.multiarch</span><br><span class="line">               Example: make build BINS=<span class="string">&quot;iam-apiserver iam-authz-server&quot;</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>通常而言，Go 项目的 Makefile 应该实现以下功能：<strong>格式化代码</strong>、<strong>静态代码检查</strong>、<strong>单元测试</strong>、<strong>代码构建</strong>、<strong>文件清理</strong>、<strong>帮助</strong>等等。如果通过 docker 部署，还需要有 <strong>docker镜像打包</strong>功能。因为 Go 是跨平台的语言，所以构建和 docker 打包命令，还要能够支持不同的 CPU 架构和平台。为了能够更好地控制 Makefile 命令的行为，还需要支持 Options。</p>
<p>为了方便查看 Makefile 集成了哪些功能，我们需要支持 help 命令。help 命令最好通过解析 Makefile 文件来输出集成的功能，例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">## help: Show this help info.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: help</span></span><br><span class="line"><span class="section">help: Makefile</span></span><br><span class="line">  @echo -e <span class="string">&quot;\nUsage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...\n\nTargets:&quot;</span></span><br><span class="line">  @sed -n &#x27;s/^<span class="comment">##//p&#x27; $&lt; | column -t -s &#x27;:&#x27; | sed -e &#x27;s/^/ /&#x27;</span></span><br><span class="line">  @echo <span class="string">&quot;$$USAGE_OPTIONS&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="设计合理的-Makefile-结构"><a href="#设计合理的-Makefile-结构" class="headerlink" title="设计合理的 Makefile 结构"></a>设计合理的 Makefile 结构</h1><p>对于大型项目来说，需要管理的内容很多，所有管理功能都集成在一个 Makefile 中，可能会导致 Makefile 很大，难以阅读和维护，所以建议采用分层的设计方法，根目录下的 Makefile 聚合所有的 Makefile 命令，具体实现则按功能分类，放在另外的 Makefile 中。</p>
<p><img src="https://img1.kiosk007.top/static/images/makefile/makefile_struct.webp"></p>
<p>在上面的 Makefile 组织方式中，根目录下的 Makefile 聚合了项目所有的管理功能，这些管理功能通过 Makefile 伪目标的方式实现。同时，还将这些伪目标进行分类，把相同类别的伪目标放在同一个 Makefile 中，这样可以使得 Makefile 更容易维护。对于复杂的命令，则编写成独立的 shell 脚本，并在 Makefile 命令中调用这些 shell 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├── Makefile</span><br><span class="line">├── scripts</span><br><span class="line">│   ├── gendoc.sh</span><br><span class="line">│   ├── make-rules</span><br><span class="line">│   │   ├── gen.mk</span><br><span class="line">│   │   ├── golang.mk</span><br><span class="line">│   │   ├── image.mk</span><br><span class="line">│   │   └── ...</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure>
<p>为了跟 Makefile 的层级相匹配，golang.mk 中的所有目标都按go.xxx这种方式命名。通过这种命名方式，我们可以很容易分辨出某个目标完成什么功能，放在什么文件里，这在复杂的 Makefile 中尤其有用。例如</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/golang.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/image.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/gen.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/...</span><br><span class="line"></span><br><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> go.build</span><br><span class="line"></span><br><span class="line"><span class="comment">## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build.multiarch</span></span><br><span class="line"><span class="section">build.multiarch:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> go.build.multiarch</span><br><span class="line"></span><br><span class="line"><span class="comment">## image: Build docker images for host arch.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: image</span></span><br><span class="line"><span class="section">image:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> image.build</span><br><span class="line"></span><br><span class="line"><span class="comment">## push: Build docker images for host arch and push images to registry.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: push</span></span><br><span class="line"><span class="section">push:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> image.push</span><br><span class="line"></span><br><span class="line"><span class="comment">## ca: Generate CA files for all iam components.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: ca</span></span><br><span class="line"><span class="section">ca:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> gen.ca</span><br></pre></td></tr></table></figure>
<h1 id="掌握-Makefile-编写技巧"><a href="#掌握-Makefile-编写技巧" class="headerlink" title="掌握 Makefile 编写技巧"></a>掌握 Makefile 编写技巧</h1><h2 id="技巧-1：善用通配符和自动变量"><a href="#技巧-1：善用通配符和自动变量" class="headerlink" title="技巧 1：善用通配符和自动变量"></a>技巧 1：善用通配符和自动变量</h2><p>Makefile 允许对目标进行类似正则运算的匹配，主要用到的通配符是%。通过使用通配符，可以使不同的目标使用相同的规则，从而使 Makefile 扩展性更强，也更简洁。</p>
<p>这里，我们来看一个具体的例子，tools.verify.%（位于<a href="https://github.com/marmotedu/iam/blob/master/scripts/make-rules/tools.mk#L17">scripts/make-rules/tools.mk</a>文件中）定义如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TOOLS ?=<span class="variable">$(BLOCKER_TOOLS)</span> <span class="variable">$(CRITICAL_TOOLS)</span> <span class="variable">$(TRIVIAL_TOOLS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: tools.install</span></span><br><span class="line"><span class="section">tools.install: $(addprefix tools.install., <span class="variable">$(TOOLS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: tools.install.%</span></span><br><span class="line"><span class="section">tools.install.%:</span></span><br><span class="line">	@echo <span class="string">&quot;===========&gt; Installing <span class="variable">$*</span>&quot;</span></span><br><span class="line">	@<span class="variable">$(MAKE)</span> install.<span class="variable">$*</span></span><br><span class="line"></span><br><span class="line"><span class="section">tools.verify.%:</span></span><br><span class="line">	@if ! which <span class="variable">$*</span> &amp;&gt;/dev/null; then <span class="variable">$(MAKE)</span> tools.install.<span class="variable">$*</span>; fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>make tools.verify.swagger</code>, <code>make tools.verify.mockgen</code>等均可以使用上面定义的规则，%分别代表了<code>swagger</code>和<code>mockgen</code>。</p>
<p>如果执行了 <code>make install</code> , 则执行的逻辑是，将执行<code>$(addprefix tools.install., $(TOOLS))</code> 这个命令的意思这时执行 <code>tools.install</code>,进一步拼装了一系列的<code>tools.install.xxxxxx</code> 并执行。</p>
<p>如果不使用<code>%</code>，则我们需要分别为<code>tools.verify.swagger</code>和<code>tools.verify.mockgen</code>定义规则，很麻烦，后面修改也困难。</p>
<p>另外，这里也能看出<code>tools.verify.%</code>这种命名方式的好处：tools 说明依赖的定义位于scripts/make-rules/tools.mk Makefile 中；verify说明tools.verify.%伪目标属于 verify 分类，主要用来验证工具是否安装。通过这种命名方式，你可以很容易地知道目标位于哪个 Makefile 文件中，以及想要完成的功能。另外，上面的定义中还用到了自动变量<code>$*</code>，用来指代被匹配的值<code>swagger、mockgen</code>。</p>
<h2 id="技巧-2：善用函数"><a href="#技巧-2：善用函数" class="headerlink" title="技巧 2：善用函数"></a>技巧 2：善用函数</h2><p>Makefile 自带的函数能够帮助我们实现很多强大的功能。所以，在我们编写 Makefile 的过程中，如果有功能需求，可以优先使用这些函数。我把常用的函数以及它们实现的功能整理在了 <a href="https://github.com/marmotedu/geekbang-go/blob/master/makefile/Makefile%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md">Makefile 常用函数列表</a> 中</p>
<h2 id="技巧-3：依赖需要用到的工具"><a href="#技巧-3：依赖需要用到的工具" class="headerlink" title="技巧 3：依赖需要用到的工具"></a>技巧 3：依赖需要用到的工具</h2><p>如果 Makefile 某个目标的命令中用到了某个工具，可以将该工具放在目标的依赖中。这样，当执行该目标时，就可以指定检查系统是否安装该工具，如果没有安装则自动安装，从而实现更高程度的自动化。例如，/Makefile 文件中，format 伪目标，定义如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: format</span></span><br><span class="line"><span class="section">format: tools.verify.golines tools.verify.goimports</span></span><br><span class="line">  @echo <span class="string">&quot;===========&gt; Formating codes&quot;</span></span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> gofmt -s -w</span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> goimports -w -local <span class="variable">$(ROOT_PACKAGE)</span></span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> golines -w --max-len=120 --reformat-tags --shorten-comments --ignore-generated .</span><br></pre></td></tr></table></figure>
<p>可以看到，format 依赖tools.verify.golines tools.verify.goimports。我们再来看下tools.verify.golines的定义：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">tools.verify.%:</span></span><br><span class="line">  @if ! which <span class="variable">$*</span> &amp;&gt;/dev/null; then <span class="variable">$(MAKE)</span> tools.install.<span class="variable">$*</span>; fi</span><br></pre></td></tr></table></figure>
<p>通过<code>tools.verify.%</code>规则定义，我们可以知道，<code>tools.verify.%</code>会先检查工具是否安装，如果没有安装，就会执行<code>tools.install.$*</code>来安装。如此一来，当我们执行<code>tools.verify.%</code>目标时，如果系统没有安装 golines 命令，就会自动调用go get安装，提高了 Makefile 的自动化程度。</p>
<h2 id="编写可扩展的-Makefile"><a href="#编写可扩展的-Makefile" class="headerlink" title="编写可扩展的 Makefile"></a>编写可扩展的 Makefile</h2><p>举个例子，执行 <code>make go.build</code> 时能够构建 cmd/ 目录下的所有组件，也就是说，当有新组件添加时， <code>make go.build</code> 仍然能够构建新增的组件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">COMMANDS ?= <span class="variable">$(<span class="built_in">filter</span>-out %.md, $(<span class="built_in">wildcard</span> $&#123;ROOT_DIR&#125;/cmd/*)</span>)</span><br><span class="line">BINS ?= <span class="variable">$(<span class="built_in">foreach</span> cmd,$&#123;COMMANDS&#125;,$(<span class="built_in">notdir</span> $&#123;cmd&#125;)</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: go.build</span></span><br><span class="line"><span class="section">go.build: go.build.verify $(addprefix go.build., $(addprefix <span class="variable">$(PLATFORM)</span>., <span class="variable">$(BINS)</span>))</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: go.build.%               </span></span><br><span class="line"></span><br><span class="line"><span class="section">go.build.%:             </span></span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> COMMAND := $(<span class="built_in">word</span> 2,$(<span class="built_in">subst</span> ., ,<span class="variable">$*</span>)</span>))</span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> PLATFORM := $(<span class="built_in">word</span> 1,$(<span class="built_in">subst</span> ., ,<span class="variable">$*</span>)</span>))</span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> OS := $(<span class="built_in">word</span> 1,$(<span class="built_in">subst</span> _, ,<span class="variable">$(PLATFORM)</span>)</span>))           </span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> ARCH := $(<span class="built_in">word</span> 2,$(<span class="built_in">subst</span> _, ,<span class="variable">$(PLATFORM)</span>)</span>))                         </span><br><span class="line">  @echo <span class="string">&quot;===========&gt; Building binary <span class="variable">$(COMMAND)</span> <span class="variable">$(VERSION)</span> for <span class="variable">$(OS)</span> <span class="variable">$(ARCH)</span>&quot;</span></span><br><span class="line">  @mkdir -p <span class="variable">$(OUTPUT_DIR)</span>/platforms/<span class="variable">$(OS)</span>/<span class="variable">$(ARCH)</span></span><br><span class="line">  @CGO_ENABLED=0 GOOS=<span class="variable">$(OS)</span> GOARCH=<span class="variable">$(ARCH)</span> <span class="variable">$(GO)</span> build <span class="variable">$(GO_BUILD_FLAGS)</span> -o <span class="variable">$(OUTPUT_DIR)</span>/platforms/<span class="variable">$(OS)</span>/<span class="variable">$(ARCH)</span>/<span class="variable">$(COMMAND)</span><span class="variable">$(GO_OUT_EXT)</span> <span class="variable">$(ROOT_PACKAGE)</span>/cmd/<span class="variable">$(COMMAND)</span></span><br></pre></td></tr></table></figure>
<p>当执行make go.build 时，会执行 go.build 的依赖 <code>$(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS)))</code> , <code>addprefix</code>函数最终返回字符串 <code>go.build.linux_amd64.iamctl go.build.linux_amd64.iam-authz-server go.build.linux_amd64.iam-apiserver ...</code>，这时候就会执行 <code>go.build.%</code> 伪目标。在 <code>go.build.%</code>伪目标中，通过 <code>eval</code>、<code>word</code>、<code>subst</code> 函数组合，算出了 COMMAND 的值 <code>iamctl/iam-apiserver/iam-authz-server/...</code>，最终通过 <code>$(ROOT_PACKAGE)/cmd/$(COMMAND)</code> 定位到需要构建的组件的 main 函数所在目录。</p>
<p>通过以下方法可以获取到 cmd 下所有的组件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COMMANDS ?= $(filter-out %.md, $(wildcard <span class="variable">$&#123;ROOT_DIR&#125;</span>/cmd/*))</span><br><span class="line">BINS ?= $(foreach cmd,<span class="variable">$&#123;COMMANDS&#125;</span>,$(notdir <span class="variable">$&#123;cmd&#125;</span>))</span><br></pre></td></tr></table></figure>
<p>接着，通过使用通配符和自动变量，自动匹配到go.build.linux_amd64.iam-authz-server 这类伪目标并构建。</p>
]]></content>
  </entry>
  <entry>
    <title>Service Mesh 是什么？</title>
    <url>/2021/09/19/Service-Mesh-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面是摘自维基百科的一段话。</p>
<blockquote>
<p>微服务 (Microservices) 是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic) 的 API 集相互通信。</p>
</blockquote>
<p>看起来过于抽象，Service Mesh 在我看来，就是如何处理服务于服务之间的关系，如服务之间的相互调用关系，核心服务的熔断等，这不仅不含一个普通的 A 服务对 B 服务的一次 RPC 调用，也涉及RPC调用时具体的超时时间、重试次数等细节。最终目的是让整个服务形成一张网一般。而开发人员只需要注重自己的业务逻辑开发，而服务之间的联系全部交给 Service Mesh。</p>
<p>想象一下，你的代码不再需要考虑各种超时逻辑、也不需要考虑熔断和集成各种底层网络库。你的代码只有业务本身。</p>
<a id="more"></a>
<h1 id="Service-Mesh-的概念"><a href="#Service-Mesh-的概念" class="headerlink" title="Service Mesh 的概念"></a>Service Mesh 的概念</h1><p>微服务的架构特性</p>
<ol>
<li>特点一：围绕业务构建团队</li>
</ol>
<p>在最开始的时候，可能公司分为 前端RD、后端RD、数据库DBA、运维OPS，整个公司的全部前端服务全部交由前端RD开发，后端代码逻辑全部交由后端RD开发。比如互联网一部负责整个商城系统开发，商城系统服务本身错综复杂，但是大家写的代码都会部署到一起，是个单体服务。</p>
<p>微服务的诞生打破了这个结构。比如商城系统被拆分成了 售卖组、商品直播组、安全组、售后组等等，每个组自身有后端和前端开发，每个组专注于自身业务。每个组的业务本身也是分离的，互不影响。</p>
<p>这样的好处是服务彼此独立，独立部署，没有依赖，比如售卖组的业务量大，售卖组的服务可以多部署几份。售后组的服务少部署几份。</p>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/feature1.png"></p>
<ol>
<li>特点二：去中心化的数据管理</li>
</ol>
<p>由于业务部署的独立，数据库也会面临一定的拆分，比如每个业务用到的数据库 database 是不同的库，业务自身使用的是不同的表。</p>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/feature2.png"></p>
<p>为了满足上述的业务服务越拆越细的需求。微服务的概念便出现，随之微服务的几个核心便是<code>服务注册\发现</code>,<code>路由\流量转移</code>,<code>弹性能力、熔断、超时</code>,<code>安全</code>,<code>可链路追踪\监控</code>，而这些核心的实现便是 <strong>Service Mesh</strong></p>
<p>Service Mesh 发展至今，从最开始的“原始通信时代” 到依托于K8S的“SideCar”模式才发展成了真正的 Service Mesh</p>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/history.png"></p>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/61901608">什么是 Service Mesh</a></li>
</ul>
<h1 id="istlo"><a href="#istlo" class="headerlink" title="istlo"></a>istlo</h1><p>istlo 是什么？</p>
<blockquote>
<p>Istio 提供一种简单的方式来为已部署的服务建立网络，该网络具有负载均衡、服务间认证、监控等功能，而不需要对服务的代码做任何改动。</p>
</blockquote>
<ul>
<li>istio 适用于容器或虚拟机环境（特别是 k8s），兼容异构架构。</li>
<li>istio 使用 sidecar（边车模式）代理服务的网络，不需要对业务代码本身做任何的改动。</li>
<li>HTTP、gRPC、WebSocket 和 TCP 流量的自动负载均衡。</li>
<li>istio 通过丰富的路由规则、重试、故障转移和故障注入，可以对流量行为进行细粒度控制；支持访问控制、速率限制和配额。</li>
<li>istio 对出入集群入口和出口中所有流量的自动度量指标、日志记录和跟踪。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装教程参考官方 (<a href="https://istio.io/latest/zh/docs/setup/getting-started/">https://istio.io/latest/zh/docs/setup/getting-started/</a>), 不过网站似乎国内打不开，下面演示一下 。</p>
<ul>
<li><strong>准备 Kubernetes 环境</strong></li>
</ul>
<p>kubernetes 环境版本：v1.21.4</p>
<p>安装方法参考：<a href="https://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/">ubuntu20.04 部署 Kubernetes (k8s)</a></p>
<ul>
<li><strong>下载 istio</strong></li>
</ul>
<p>下载针对你操作系统的安装文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;istio&#x2F;istio&#x2F;master&#x2F;release&#x2F;downloadIstioCandidate.sh | sh -</span><br></pre></td></tr></table></figure><br>如果想要指定版本、不同处理器体系则可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;istio&#x2F;istio&#x2F;master&#x2F;release&#x2F;downloadIstioCandidate.sh | ISTIO_VERSION&#x3D;1.6.8 TARGET_ARCH&#x3D;x86_64  sh -</span><br></pre></td></tr></table></figure>
<p>转到istio的目录。例如 istio-1.11.2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd istio-1.11.2</span><br></pre></td></tr></table></figure><br>安装目录包含: <code>samples/</code> 目录下的示例应用程序 和 <code>bin/</code> 目录下的 <code>istioctl</code>客户端二进制工具。可将 <code>istioctl</code> 加入到 PATH 中。</p>
<ul>
<li><strong>安装 istio</strong></li>
</ul>
<p>istio本身提供不同模式的 <code>Configuration Profile</code></p>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/configuration.png"></p>
<p>对于本次安装，我们选择 <code>demo</code> 模式，这个是专门为了展示和学习而准备的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ istioctl install --set profile&#x3D;demo -y</span><br><span class="line">✔ Istio core installed                                                                                                                                                          </span><br><span class="line">✔ Istiod installed                                                                                                                                                              </span><br><span class="line">✔ Ingress gateways installed                                                                                                                                                    </span><br><span class="line">✔ Egress gateways installed                                                                                                                                                     </span><br><span class="line">✔ Installation complete                                                                                                                                                         </span><br><span class="line">Thank you for installing Istio 1.11.  Please take a few minutes to tell us about your install&#x2F;upgrade experience!  https:&#x2F;&#x2F;forms.gle&#x2F;kWULBRjUv7hHci7T6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>给 namespace 添加标签，指示istio在部署应用时自动注入 envoy sidecar 代理。可以简单的理解为当部署应用清单时，它会帮你改写清单，把具体的sidecar配置给你添加进去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl label namespace default istio-injection&#x3D;enabled</span><br></pre></td></tr></table></figure>
<p>查看istio部署的pods</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istio-egressgateway-6cb7bdc7fb-8h2n6    1&#x2F;1     Running   0          6m15s</span><br><span class="line">istio-ingressgateway-694d8d7656-z4ccc   1&#x2F;1     Running   0          6m15s</span><br><span class="line">istiod-6c68579c55-lmp8r                 1&#x2F;1     Running   0          7m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="部署-bookinfo-应用"><a href="#部署-bookinfo-应用" class="headerlink" title="部署 bookinfo 应用"></a>部署 bookinfo 应用</h1><p>bookinfo 是官方推荐的一个微服务案例。主要包含以下4个微服务，主页productpage服务是由python开发的，主要会调用评论和详细内容两个服务。评论服务有三个版本，reviews 微服务有 3 个版本：</p>
<blockquote>
<p>v1 版本不会调用 ratings 服务。<br>v2 版本会调用 ratings 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。<br>v3 版本会调用 ratings 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</p>
</blockquote>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/bookinfo.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples&#x2F;bookinfo&#x2F;platform&#x2F;kube&#x2F;bookinfo.yaml</span><br><span class="line">service&#x2F;details created</span><br><span class="line">serviceaccount&#x2F;bookinfo-details created</span><br><span class="line">deployment.apps&#x2F;details-v1 created</span><br><span class="line">service&#x2F;ratings created</span><br><span class="line">serviceaccount&#x2F;bookinfo-ratings created</span><br><span class="line">deployment.apps&#x2F;ratings-v1 created</span><br><span class="line">service&#x2F;reviews created</span><br><span class="line">serviceaccount&#x2F;bookinfo-reviews created</span><br><span class="line">deployment.apps&#x2F;reviews-v1 created</span><br><span class="line">deployment.apps&#x2F;reviews-v2 created</span><br><span class="line">deployment.apps&#x2F;reviews-v3 created</span><br><span class="line">service&#x2F;productpage created</span><br><span class="line">serviceaccount&#x2F;bookinfo-productpage created</span><br><span class="line">deployment.apps&#x2F;productpage-v1 created</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>应用很快会起来，等到应用就绪后，istio 的sidecar 代理将一起被部署。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get service</span><br><span class="line">NAME          TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">details       ClusterIP   10.80.140.94   &lt;none&gt;        9080&#x2F;TCP   61s</span><br><span class="line">kubernetes    ClusterIP   10.80.0.1      &lt;none&gt;        443&#x2F;TCP    24d</span><br><span class="line">productpage   ClusterIP   10.80.6.178    &lt;none&gt;        9080&#x2F;TCP   61s</span><br><span class="line">ratings       ClusterIP   10.80.32.218   &lt;none&gt;        9080&#x2F;TCP   61s</span><br><span class="line">reviews       ClusterIP   10.80.60.33    &lt;none&gt;        9080&#x2F;TCP   61s</span><br></pre></td></tr></table></figure><br>和 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line">NAME                                      READY   STATUS            RESTARTS   AGE</span><br><span class="line">details-v1-79f774bdb9-kl2dg               0/2     PodInitializing   0          2m40s</span><br><span class="line">nfs-client-provisioner-6d9cb7bf7d-wclzl   1/1     Running           38         24d</span><br><span class="line">productpage-v1-6b746f74dc-xt7qh           0/2     PodInitializing   0          2m39s</span><br><span class="line">ratings-v1-b6994bb9-r8pqp                 2/2     Running           0          2m40s</span><br><span class="line">reviews-v1-545db77b95-l6ctg               0/2     PodInitializing   0          2m40s</span><br><span class="line">reviews-v2-7bf8c9648f-72k95               2/2     Running           0          2m40s</span><br><span class="line">reviews-v3-84779c7bbc-zkp5r               0/2     PodInitializing   0          2m40s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建 Ingress</strong></li>
</ul>
<p>此时的bookinfo应用已经部署，但是还不能被外界访问，想要访问则需要创建 istio 入站网关 Ingress，他会在网格边缘把一个路径映射到路由。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>确定入站 IP 和 端口</strong></li>
</ul>
<p>访问网关有2个变量控制，<span style="color:red">INGRESS_HOST </span> 和 <span style="color:red">INGRESS_PORT</span> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.80.53.173   &lt;pending&gt;     15021:32628/TCP,80:30554/TCP,443:30266/TCP,31400:30402/TCP,15443:30959/TCP   83m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置 <span style="color:red">EXTERNAL-IP</span> 的值之后， 你的环境就有了一个外部的负载均衡，可以用它做入站网关。 但如果 <span style="color:red">EXTERNAL-IP</span> 的值为 <none> (或者一直是 <pending> 状态)， 则你的环境则没有提供可作为入站流量网关的外部负载均衡。 在这个情况下，你还可以用服务（Service）的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#nodeport">节点端口</a> 访问网关 (但是k8s的NodePort设置要求的范围是 30000-32767)。</pending></none></p>
<p>由于我本地的测试环境没有 Loadblance ，所以就用NodePort方式访问吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].nodePort&#125;&#x27;</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;https&quot;)].nodePort&#125;&#x27;</span>)</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=172.16.101.135</span><br><span class="line">$ <span class="built_in">export</span> GATEWAT_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span></span><br></pre></td></tr></table></figure>
<p>浏览器访问 <code>http://172.16.101.135:30554/productpage</code> 可以看到这个微服务。</p>
<ul>
<li><strong>查看仪表盘</strong></li>
</ul>
<p>istio 可以可以添加 kiali 仪表盘、Prometheus、grafana 还有 Jaeger 等。</p>
<ol>
<li>安装 并 等待其部署完成<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f samples/addons</span><br><span class="line">kubectl rollout status deployment/kiali -n istio-system</span><br></pre></td></tr></table></figure></li>
<li>访问 kiali 仪表盘</li>
</ol>
<p>kiali 在希腊语中是望远镜的意思，其官方定义是 istio 的可观察性控制台，通过服务拓扑帮助你理解服务网格的结构。通过服务拓扑帮助你理解服务网格的结构，并且具有配置网格的功能。</p>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/kiali_funcation.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">istioctl dashboard kiali</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我因为是在远端虚拟机搭建的k8s集群，所以将 kiali 改为 NodePort 模式</p>
</blockquote>
<ol>
<li>在左侧的导航栏菜单选择 <code>Graph</code>, 然后在Namespace下拉列表选择 default。kiali 仪表盘提供了网络的概览，以及 bookinfo 示例应用的各个服务的关系，它还提供过滤器可视化流量的流动。</li>
</ol>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/kiali.png"></p>
<h2 id="Virtual-Service-动态路由"><a href="#Virtual-Service-动态路由" class="headerlink" title="Virtual Service 动态路由"></a>Virtual Service 动态路由</h2><p>要路由到一个版本，需要为微服务进行默认模板的设置，在这种情况下，Virtual Service 将所有的流量路由到每一个v1版本的pod上。</p>
<p><strong>Virtual Service 的作用正是 1. 定义路由规则。 2. 满足描述条件的请求去哪里</strong></p>
<p>这里涉及到一个满足描述条件，这正是<strong>目标规则 (Destination Rule) 的功能，即 1. 定义子集策略。 2. 描述到达目标的子集怎么处理</strong></p>
<ol>
<li>执行以下命令，使所有的 review 流量都打到 review v1 版本上</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/destination-rule-all.yaml</span><br><span class="line">$ kubectl apply -f samples/bookinfo/networking/virtual-service-all-v1.yaml</span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/virtualservice.png"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">productpage</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>这个清单定义了4个 Virtual Service ，可以看到 所有的服务都被打向了 v1 版本。v1 版本是怎么定义出来的呢？在 <code>destination-rule-all.yaml</code> , <code>subsets</code> 中，将不同的labels中定义的版本进行标记，如  <strong>subsets.name.labels.version: v1</strong>, 可以使用 <code>kubectl get destinationrules</code> 查看</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<h2 id="Gateway-管理进入网格的流量"><a href="#Gateway-管理进入网格的流量" class="headerlink" title="Gateway 管理进入网格的流量"></a>Gateway 管理进入网格的流量</h2><p>网关是运行在网格边缘的负载均衡器，接收外部请求转发到网格内部的服务，配置对外端口与内部服务的对应关系。</p>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/gateway.png"></p>
<p>在之前搭建 bookinfo 时，其实我们已经创建了一个网关，这个网关暴露了bookinfo 这个微服务的对外应用 <code>productpage</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span> <span class="comment"># use istio default controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bookinfo-gateway</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">/productpage</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/static</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">/login</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">/logout</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/api/v1/products</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">          <span class="attr">number:</span> <span class="number">9080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>网关的 VirtualService 有一个 gateways, 正是上面创建 <code>Gateway</code> ，这个服务有5个被暴露出来的 uri，只有匹配的 uri 的流量才被打到 productpage 服务里。</p>
<h2 id="ServiceEntry-服务入口"><a href="#ServiceEntry-服务入口" class="headerlink" title="ServiceEntry 服务入口"></a>ServiceEntry 服务入口</h2><p>服务入口的作用是添加外部服务到内部网格内，是希望将管理内部服务队外部服务的请求，起到扩展网格的功能。</p>
<p>一般默认情况下，整个微服务是可以访问外部服务的。所以需要我们先禁止以下微服务访问外部。</p>
<p> Istio有一个安装选项<code>global.outboundTrafficPolicy.mode</code>用来配置sidecar对外部服务(未在istio内部服务注册中定义的服务)的处理方式。 如果选项值为<span style="color:red">ALLOW_ANY</span>，sidecar将允许调用未知的服务，如果选项值为<span style="color:red">REGISTRY_ONLY</span>，那么Istio代理将会阻止调用任何未在服务网格注册中定义的服务或ServiceEntry的host。</p>
<p>查看当前的规则则可以使用以下命令，没有任何输出表示默认的 <code>ALLOW_ANY</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get istiooperator installed-state -n istio-system -o jsonpath=<span class="string">&#x27;&#123;.spec.meshConfig.outboundTrafficPolicy.mode&#125;&#x27;</span></span><br></pre></td></tr></table></figure><br>在禁止直接访问之前。安装一个带 <code>curl</code> 命令的pod，访问微服务外的服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/sleep/sleep.yaml</span><br><span class="line">$ kubectl <span class="built_in">exec</span>  sleep-557747455f-svc9k -- curl http://httpbin.org/headers</span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;curl/7.78.0-DEV&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-6147eadc-3c6f1cdb3884436b76fca6f1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-B3-Sampled&quot;</span>: <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-B3-Spanid&quot;</span>: <span class="string">&quot;b0c944c749e6dcd8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-B3-Traceid&quot;</span>: <span class="string">&quot;5822ffcb03b68b61b0c944c749e6dcd8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Envoy-Attempt-Count&quot;</span>: <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Envoy-Peer-Metadata&quot;</span>: <span class="string">&quot;ChkKDkFQUF9DT05UQUlORVJTEgcaBXNsZWVwChoKCkNMVVNURVJfSUQSDBoKS3ViZXJuZXRlcwoZCg1JU1RJT19WRVJTSU9OEggaBjEuMTEuMgrEAQoGTEFCRUxTErkBKrYBCg4KA2FwcBIHGgVzbGVlcAohChFwb2QtdGVtcGxhdGUtaGFzaBIMGgo1NTc3NDc0NTVmCiQKGXNlY3VyaXR5LmlzdGlvLmlvL3Rsc01vZGUSBxoFaXN0aW8KKgofc2VydmljZS5pc3Rpby5pby9jYW5vbmljYWwtbmFtZRIHGgVzbGVlcAovCiNzZXJ2aWNlLmlzdGlvLmlvL2Nhbm9uaWNhbC1yZXZpc2lvbhIIGgZsYXRlc3QKGgoHTUVTSF9JRBIPGg1jbHVzdGVyLmxvY2FsCiAKBE5BTUUSGBoWc2xlZXAtNTU3NzQ3NDU1Zi1zdmM5awoWCglOQU1FU1BBQ0USCRoHZGVmYXVsdApJCgVPV05FUhJAGj5rdWJlcm5ldGVzOi8vYXBpcy9hcHBzL3YxL25hbWVzcGFjZXMvZGVmYXVsdC9kZXBsb3ltZW50cy9zbGVlcAoXChFQTEFURk9STV9NRVRBREFUQRICKgAKGAoNV09SS0xPQURfTkFNRRIHGgVzbGVlcA==&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Envoy-Peer-Metadata-Id&quot;</span>: <span class="string">&quot;sidecar~10.100.1.55~sleep-557747455f-svc9k.default~default.svc.cluster.local&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将 istio改为禁止调用未在网格内注册过的服务。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl install --<span class="built_in">set</span> profile=demo -y --<span class="built_in">set</span> meshConfig.outboundTrafficPolicy.mode=REGISTRY_ONLY</span><br><span class="line"></span><br><span class="line">$ kubectl get istiooperator installed-state -n istio-system -o jsonpath=<span class="string">&#x27;&#123;.spec.meshConfig.outboundTrafficPolicy.mode&#125;&#x27;</span></span><br><span class="line">REGISTRY_ONLY</span><br></pre></td></tr></table></figure><br>再访问已经无法访问<br>…</p>
<p>使用ServiceEntry将一个外部服务注册到服务网格中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f - &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="string">kind: ServiceEntry</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: httpbin-ext</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  hosts:</span></span><br><span class="line"><span class="string">  - httpbin.org</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - number: 80</span></span><br><span class="line"><span class="string">    name: http</span></span><br><span class="line"><span class="string">    protocol: HTTP</span></span><br><span class="line"><span class="string">  resolution: DNS</span></span><br><span class="line"><span class="string">  location: MESH_EXTERNAL</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时便可再访问外部服务。这里的 <code>location: MESH_EXTERNAL</code> 便是指定访问网格外的服务白名单</p>
<p>参考：<a href="https://blog.frognew.com/2021/07/learning-istio-1.10-11.html">https://blog.frognew.com/2021/07/learning-istio-1.10-11.html</a></p>
<h2 id="流量转移：灰度发布"><a href="#流量转移：灰度发布" class="headerlink" title="流量转移：灰度发布"></a>流量转移：灰度发布</h2><p>istio 可以实现改写路由的权重，可以完成 灰度发布、蓝绿部署、A/B 测试 等功能。</p>
<p>其本质还是利用 Virtual Service 进行服务权重的调整，bookinfo 里的 reviews 服务有3个版本，我们即可利用 reviews 服务进行测试。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">50</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>其本质是修改路由的权重值。</p>
<h2 id="Egress-控制出口流量"><a href="#Egress-控制出口流量" class="headerlink" title="Egress 控制出口流量"></a>Egress 控制出口流量</h2><p>查看 egress 网关已安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">grafana-68cc7d6d78-bnwc8                1/1     Running   0          13h</span><br><span class="line">istio-egressgateway-6cb7bdc7fb-8h2n6    1/1     Running   0          17h</span><br><span class="line">istio-ingressgateway-694d8d7656-z4ccc   1/1     Running   0          17h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看之前的 Service Entry 已配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get se</span><br><span class="line">NAME          HOSTS             LOCATION        RESOLUTION   AGE</span><br><span class="line">httpbin-ext   [<span class="string">&quot;httpbin.org&quot;</span>]   MESH_EXTERNAL   DNS          49m</span><br></pre></td></tr></table></figure>
<p>配置 Egress 网关、Destination 和 Virtual Service （Destination 和 Virtual Service 配置略）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  name: istio-egressgateway</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    istio: egressgateway</span><br><span class="line">  servers:</span><br><span class="line">  - port:</span><br><span class="line">      number: 80</span><br><span class="line">      name: http</span><br><span class="line">      protocol: HTTP</span><br><span class="line">    hosts:</span><br><span class="line">    - httpbin.org</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>详见： <a href="https://cloud.tencent.com/developer/article/1469811">https://cloud.tencent.com/developer/article/1469811</a></p>
<h2 id="超时重试"><a href="#超时重试" class="headerlink" title="超时重试"></a>超时重试</h2><p>一般一个微服务架构里，最常见的就是服务之间的相互调用。这种调用关系是基于网络的，网络是不可靠的，另外被调用方也有可能因为服务故障导致处理请求慢，调用方对其他服务的调用必然涉及到超时重试，一般来说，业务的服务应该关注业务而不是在这些调用超时、重试之类的细枝末节上，所以微服务的超时重试便由此诞生。</p>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/timeout_retry.png"></p>
<p>演示过程：</p>
<ul>
<li>给 ratings 服务添加延迟</li>
<li>给 reviews 服务添加超时策略</li>
<li>给 ratings 服务添加重试策略</li>
</ul>
<p>先将 review 切换到 v2 版本<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>为 rating 服务添加延迟 2s</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percent:</span> <span class="number">100.0</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">2s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为 review 服务添加超时时间 1s </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">1s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时review 服务将无法响应，页面上可以看到挂掉了。下来验证重试和超时。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">100.0</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">retries:</span></span><br><span class="line">      <span class="attr">attempts:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">1s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>熔断是一种过载保护的手段, 目的是避免服务的级联失败。</p>
<p>一个熔断器可以有三种状态：关闭、打开和半开，默认情况下处于关闭状态。在关闭状态下，无论请求成功或失败，到达预先设定的故障数量阈值前，都不会触发熔断。而当达到阈值时，熔断器就会打开。当调用处于打开状态的服务时，熔断器将断开请求，这意味着它会直接返回一个错误，而不去执行调用。通过在客户端断开下游请求的方式，可以在生产环境中防止级联故障的发生。在经过事先配置的超时时长后，熔断器进入半开状态，这种状态下故障服务有时间从其中断的行为中恢复。如果请求在这种状态下继续失败，则熔断器将再次打开并继续阻断请求。否则熔断器将关闭，服务将被允许再次处理请求。</p>
<p><img src="https://img1.kiosk007.top/static/images/service_mesh/circuit_breaking.png"></p>
<p>设置熔断器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f - &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="string">kind: DestinationRule</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: httpbin</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  host: httpbin</span></span><br><span class="line"><span class="string">  trafficPolicy:</span></span><br><span class="line"><span class="string">    connectionPool:</span></span><br><span class="line"><span class="string">      tcp:</span></span><br><span class="line"><span class="string">        maxConnections: 1</span></span><br><span class="line"><span class="string">      http:</span></span><br><span class="line"><span class="string">        http1MaxPendingRequests: 1</span></span><br><span class="line"><span class="string">        maxRequestsPerConnection: 1</span></span><br><span class="line"><span class="string">    outlierDetection:</span></span><br><span class="line"><span class="string">      consecutiveErrors: 1</span></span><br><span class="line"><span class="string">      interval: 1s</span></span><br><span class="line"><span class="string">      baseEjectionTime: 3m</span></span><br><span class="line"><span class="string">      maxEjectionPercent: 100</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>参考: <a href="https://www.servicemesher.com/blog/istio-circuit-breaking/">https://www.servicemesher.com/blog/istio-circuit-breaking/</a></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>系统的运行状态，除了通过 istio 自带的 <code>prometheus</code>、<code>kiali</code>、<code>grafna</code> 查看相关的日志。但是总是需要看更详细的文本日志输出。</p>
<p>原始的调用结构是 服务A 直接调用 服务B ，但是现在服务A 的sidecar 调用服务B 的sidecar然后才能调用服务B 。</p>
<p>那么想要定位问题，就是查看envoy的日志了。 </p>
<p>首先确保envoy 日志是打开的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> describe configmap istio -n istio-system | grep <span class="string">&quot;accessLogFile&quot;</span></span><br><span class="line">accessLogFile: /dev/stdout</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>envoy 的日志是定制的，在服务的pod里叫做 <code>istio-proxy</code> 这个contianer。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl logs -f productpage-v1-6b746f74dc-xt7qh istio-proxy</span><br><span class="line"></span><br><span class="line">[2021-09-20T14:12:23.277Z] <span class="string">&quot;GET /details/0 HTTP/1.1&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 0 178 24 23 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;768f9804-849c-9aca-b4f0-f85c838304e4&quot;</span> <span class="string">&quot;details:9080&quot;</span> <span class="string">&quot;10.100.1.49:9080&quot;</span> outbound|9080|v1|details.default.svc.cluster.local 10.100.1.51:54256 10.80.140.94:9080 10.100.1.51:46546 - -</span><br><span class="line">[2021-09-20T14:12:23.310Z] <span class="string">&quot;GET /reviews/0 HTTP/1.1&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 0 295 41 41 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;768f9804-849c-9aca-b4f0-f85c838304e4&quot;</span> <span class="string">&quot;reviews:9080&quot;</span> <span class="string">&quot;10.100.0.19:9080&quot;</span> outbound|9080|v1|reviews.default.svc.cluster.local 10.100.1.51:54950 10.80.60.33:9080 10.100.1.51:55736 - -</span><br><span class="line">[2021-09-20T14:12:23.253Z] <span class="string">&quot;GET /productpage HTTP/1.1&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 0 4288 106 105 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;768f9804-849c-9aca-b4f0-f85c838304e4&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:33335 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line">[2021-09-20T14:12:23.411Z] <span class="string">&quot;GET /static/bootstrap/css/bootstrap.min.css HTTP/1.1&quot;</span> 304 - via_upstream - <span class="string">&quot;-&quot;</span> 0 0 32 29 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;8df34a40-a462-99b3-afe3-ea90df5f09d4&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:53397 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line">[2021-09-20T14:12:23.429Z] <span class="string">&quot;GET /static/bootstrap/css/bootstrap-theme.min.css HTTP/1.1&quot;</span> 304 - via_upstream - <span class="string">&quot;-&quot;</span> 0 0 20 19 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;11b436e3-bad2-9608-b389-9eb8f422ca68&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:48115 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line">[2021-09-20T14:12:23.436Z] <span class="string">&quot;GET /static/jquery.min.js HTTP/1.1&quot;</span> 304 - via_upstream - <span class="string">&quot;-&quot;</span> 0 0 18 17 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;105258af-c512-9df4-b8cd-7063eb29ee70&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:50457 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line">[2021-09-20T14:12:23.436Z] <span class="string">&quot;GET /static/bootstrap/js/bootstrap.min.js HTTP/1.1&quot;</span> 304 - via_upstream - <span class="string">&quot;-&quot;</span> 0 0 26 24 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;adfefa36-12a2-90a2-b223-11c829cc2133&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:52945 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>envoy 日志配置项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配置项</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>global.proxy.accessLogFile</td>
<td style="text-align:right">日志输出文件，空为关闭输出</td>
</tr>
<tr>
<td>global.proxy.accessLogEncoding</td>
<td style="text-align:right">日志编码格式：JSON、TEXT</td>
</tr>
<tr>
<td>global.proxy.accessLogFormat</td>
<td style="text-align:right">配置显示在日志中的字段，空为默认格式</td>
</tr>
<tr>
<td>global.proxy.logLevel</td>
<td style="text-align:right">日志级别，空为 warning</td>
</tr>
</tbody>
</table>
</div>
]]></content>
  </entry>
  <entry>
    <title>Nginx Ingress</title>
    <url>/2021/09/05/Nginx-Ingress/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在K8S的中， Service 暴露给外界的三种方法。其中有一个叫作 LoadBalancer 类型的 Service，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务。</p>
<p>但是，由于每个 Service 都要有一个负载均衡服务，所以这个做法实际上既浪费成本又高。作为用户，我其实更希望看到 Kubernetes 为我内置一个全局的负载均衡器。然后，通过我访问的 URL，把请求转发给不同的后端 Service。</p>
<p><strong>这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 Ingress 服务。</strong></p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> <strong>Kubernetes</strong> 内置一个全局的负载均衡器。然后，通过访问 URL，把请求转发给不同的后端 Service。这就是这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 Ingress 服务。所以，Ingress 的功能其实很容易理解：<strong>所谓 Ingress，就是 Service 的“Service”。</strong></p>
<p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/ingress.png"> </p>
<h1 id="安装-nginx-ingress"><a href="#安装-nginx-ingress" class="headerlink" title="安装 nginx-ingress"></a>安装 nginx-ingress</h1><p>参考: <a href="https://docs.nginx.com/nginx-ingress-controller/installation/installation-with-manifests/">NGINX Ingress Controller</a></p>
<ol>
<li>创建 <code>Nginx Controller</code><ul>
<li>创建 <code>Namespace</code> 与 <code>账号</code></li>
<li>创建角色并绑定账号</li>
<li>创建 default server 的秘钥</li>
<li>创建存放 <code>nginx.conf</code> 的 <code>Config Map</code></li>
<li>创建 <code>ingress-class</code></li>
<li>创建 <code>Nginx Controller Pod</code></li>
</ul>
</li>
<li>暴露 <code>Nginx Controller</code> 服务</li>
<li>创建 <code>Ingress</code> 规则<ul>
<li><code>Host</code> 精准与通配符匹配</li>
<li><code>Path</code> 前缀或精确匹配</li>
<li><code>Backend</code></li>
</ul>
</li>
</ol>
<p>第一步：创建 <code>Nginx Controller</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/nginxinc/kubernetes-ingress/</span><br><span class="line">$ <span class="built_in">cd</span> kubernetes-ingress/deployments</span><br><span class="line">$ git checkout v1.12.0</span><br></pre></td></tr></table></figure>
<p>Namespace 与 账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f common/ns-and-sa.yaml</span><br><span class="line">$ kubectl apply -f rbac/rbac.yaml</span><br></pre></td></tr></table></figure>
<p>default server 秘钥证书 与 Config Map</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f common/default-server-secret.yaml</span><br><span class="line">$ kubectl apply -f common/nginx-config.yaml</span><br><span class="line">$ kubectl apply -f common/ingress-class.yaml</span><br></pre></td></tr></table></figure>
<p>创建 <code>Nginx-Ingress</code> 当一个新的 Ingress 对象由用户创建后，nginx-ingress-controller 就会根据 Ingress 对象里定义的内容，生成一份对应的 Nginx 配置文件（/etc/nginx/nginx.conf），并使用这个配置文件启动一个 Nginx 服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f deployment/nginx-ingress.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了让用户能够用到这个 Nginx，我们就需要创建一个 Service 来把 Nginx Ingress Controller 管理的 Nginx 服务暴露出去。创建 <code>Node Port</code> , 暴露服务。Kubernetes将在集群的每个节点上随机分配两个端口。可以使用 <strong>任意节点</strong> + <strong>分配的特殊端口</strong> 即可访问服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create -f service/nodeport.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl get svc -n nginx-ingress</span><br><span class="line">NAME            TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">nginx-ingress   NodePort   10.80.23.67   &lt;none&gt;        80:30595/TCP,443:30920/TCP   4m32s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个 Service 的唯一工作，就是将所有携带 ingress-nginx 标签的 Pod 的 80 和 433 端口暴露出去。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Nginx 官方 ingress 提供了 cafe 、 tea 的例子，参考: <a href="https://github.com/nginxinc/kubernetes-ingress/tree/master/examples/complete-example">https://github.com/nginxinc/kubernetes-ingress/tree/master/examples/complete-example</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IC_IP=172.16.101.135   <span class="comment"># 宿主机ip</span></span><br><span class="line">IC_HTTPS_PORT=30920    <span class="comment"># nodeport</span></span><br></pre></td></tr></table></figure>
<p>部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f cafe.yaml</span><br><span class="line">kubectl create -f cafe-secret.yaml</span><br><span class="line">kubectl create -f cafe-ingress.yaml</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl --resolve cafe.example.com:<span class="variable">$IC_HTTPS_PORT</span>:<span class="variable">$IC_IP</span> https://cafe.example.com:<span class="variable">$IC_HTTPS_PORT</span>/coffee --insecure</span><br><span class="line">Server address: 10.100.1.37:8080</span><br><span class="line">Server name: coffee-6f4b79b975-59d8f</span><br><span class="line">Date: 04/Sep/2021:15:36:01 +0000</span><br><span class="line">URI: /coffee</span><br><span class="line">Request ID: 1873881292193359134a0619136b2780</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>每次文件变化后，执行 <code>kubectl apply -f cafe-ingress.yaml</code>，实际会对Nginx进行一次reload。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">cafe-secret</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/tea</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">tea-svc</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/coffee</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">coffee-svc</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>执行上述命令后，会生成一个 ingress 规则。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get ingress </span><br><span class="line">NAME           CLASS   HOSTS              ADDRESS   PORTS     AGE</span><br><span class="line">cafe-ingress   nginx   cafe.example.com             80, 443   14h</span><br></pre></td></tr></table></figure>
<p>而这个ingress 规则实质上是在 <code>ingress controller</code> 的 deployment pod 中的 <code>/etc/nginx/conf.d</code> 中生成一个规则。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -it -n nginx-ingress nginx-ingress-c7cd9948d-r8hxz -- /bin/bash</span><br><span class="line">nginx@nginx-ingress-c7cd9948d-r8hxz:/$ <span class="built_in">cd</span> /etc/nginx/conf.d/</span><br><span class="line">nginx@nginx-ingress-c7cd9948d-r8hxz:/etc/nginx/conf.d$ ls</span><br><span class="line">default-cafe-ingress.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>nginx.conf</code> 相关配置遵从 configmap 模板配置, 同样更改会reload。<br>详见：<code>https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/</code></p>
<blockquote>
<p>k8s 官方的 ingress-nginx 是利用 balance by lua 的方式进行负载均衡。nginx 官方是利用 nginx reload 实现。</p>
</blockquote>
<h1 id="ingress-工作原理"><a href="#ingress-工作原理" class="headerlink" title="ingress 工作原理"></a>ingress 工作原理</h1><p>K8S 调度 <code>Nginx Ingress Controller Pod</code>, Go 语言基于Nginx 模板生成的 <code>nginx.conf</code> </p>
<ul>
<li>模板语法 <code>import &quot;text/template&quot;</code></li>
<li>模板位置 Nginx 官方:<ul>
<li><code>/nginx.ingress.tmpl</code> 和 <code>nginx.tmpl</code></li>
</ul>
</li>
<li>填充模板的数据：<ul>
<li><code>ConfigMap</code>, <code>Ingress</code>, <code>Service</code> 和  <code>Secrets</code></li>
</ul>
</li>
</ul>
<p>配置文件改变后，<strong>Nginx 官方的 Ingress (<a href="https://github.com/nginxinc/kubernetes-ingress">https://github.com/nginxinc/kubernetes-ingress</a>) </strong> 的做法是每次 reload。而 <strong>kubernetes 官方的 Ingress </strong>是基于 lua 实现的类似openresty 的 <code>balance by lua</code> 来实现配置重载。</p>
<p>而配置文件本身是全部存在的 ETCD 中的。ETCD 基于 raft 协议实现高可用的一致性。具体可以参考我之前的文章 <a href="https://kiosk007.top/2020/05/30/go-etcd-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">etcd 的基本入门</a></p>
<p>Nginx 官方的Ingress 和 K8S 官方的Ingress 性能对比。</p>
<ul>
<li>静态部署：即 Nginx 配置文件不变, 可以看到开源的Nginx（蓝线）在压力逐渐增加时，时延变高的最慢。</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/ingress_static_stress.png"></p>
<ul>
<li>动态部署: 即 Nginx 配置总是变，如 upstream 变化导致需要配置变化。官方Nginx的性能就拉垮了，压力到90多就时延上升一个台阶，到99.9时时延已经1分钟以上了。</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/ingress_dynamic_stress.png"></p>
<p>参考：<a href="https://www.nginx.org.cn/course/detail/12">K8S Ingress Controller技术细节探讨</a></p>
<h2 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h2><p>Ingress Controller 完成了包含 <code>负载均衡/会话保持</code>、<code>协议转换</code>、<code>TLS 卸载、认证</code>、<code>文本压缩</code>、<code>请求认证</code>、<code>限流限速</code>、<code>Waf</code>、<code>全链路跟踪</code>、<code>日志监控</code> 等等功能。</p>
<h2 id="第三方模块启用"><a href="#第三方模块启用" class="headerlink" title="第三方模块启用"></a><strong>第三方模块启用</strong></h2><p>Nginx 有大量的第三方模块，Ingress 复用 Nginx 时这些大量的第三方模块是用 <code>annotations</code> 的方式加载这些第三方模块。详见 <a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/">K8S官方文档 Annotations</a> 和 <a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-annotations/">Nginx 官方文档</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.org/proxy-connect-timeout:</span> <span class="string">&quot;30s&quot;</span></span><br><span class="line">    <span class="attr">nginx.org/proxy-read-timeout:</span> <span class="string">&quot;20s&quot;</span></span><br><span class="line">    <span class="attr">nginx.org/client-max-body-size:</span> <span class="string">&quot;4m&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># ingressClassName: nginx # use only with k8s version &gt;= 1.18.0</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">cafe-secret</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/tea</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tea-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/coffee</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">coffee-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/ingress_annotations.png"></p>
<ul>
<li>opentrace 全链路追踪</li>
</ul>
<p>Nginx 本身可以遵从全链路追踪 <code>opentracing</code> 架构规范实现（<a href="https://opentracing.io/）。通过为流行的平台提供一致的，富有表现力的，供应商中立的API，OpenTracing使开发人员可以轻松地通过O（1）配置更改添加（或切换）跟踪实现。OpenTracing还为OSS检测和特定于平台的跟踪帮助程序库提供了通用语言。">https://opentracing.io/）。通过为流行的平台提供一致的，富有表现力的，供应商中立的API，OpenTracing使开发人员可以轻松地通过O（1）配置更改添加（或切换）跟踪实现。OpenTracing还为OSS检测和特定于平台的跟踪帮助程序库提供了通用语言。</a></p>
<p>比如全链路追踪的 <code>jaeger trace</code>。jaeger 本身搭建比较简单，但是其数据源需要 ingress Nginx 按照 opentracing 规范导入到 jaeger 中最使用 UI 查看。</p>
<p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/jaeger_trace.png"></p>
<p><code>nginx ingress</code> 中的nginx 支持如 <code>https://github.com/opentracing-contrib/nginx-opentracing.git</code> 等模块。</p>
<p>详见: <a href="https://www.nginx.org.cn/article/detail/517">采用 NGINX Ingress Controller for Kubernetes 支持 OpenTracing</a></p>
<h2 id="nginx-conf-配置加载"><a href="#nginx-conf-配置加载" class="headerlink" title="nginx.conf 配置加载"></a><strong>nginx.conf 配置加载</strong></h2><p>nginx 的 config 配置文件是通过 <code>ConfigMap</code> 搭配 go 语言的 template 模板来更新 <code>nginx.conf</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">nginx-ingress</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">worker-processes:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如下是进入到 <code>nginx ingress controller</code> pod 里看到的内容，<code>ConfigMap</code> 里data中的内容，<code>worker-processes: &quot;2&quot;</code> 会对应到 pod 里的 <code>nginx.tmpl</code> 的 <code>&#123;&#123;.WorkerProcesses&#125;&#125;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx@nginx-ingress-c7cd9948d-r8hxz:/$ ls</span><br><span class="line">bin   dev		   docker-entrypoint.sh  home  lib64  mnt	     nginx.ingress.tmpl  nginx.transportserver.tmpl  opt   root  sbin  sys  usr</span><br><span class="line">boot  docker-entrypoint.d  etc			 lib   media  nginx-ingress  nginx.tmpl		 nginx.virtualserver.tmpl    proc  run	 srv   tmp  var</span><br><span class="line">nginx@nginx-ingress-c7cd9948d-r8hxz:/$ cat nginx.tmpl </span><br><span class="line"></span><br><span class="line">worker_processes  &#123;&#123;.WorkerProcesses&#125;&#125;;</span><br><span class="line">&#123;&#123;- <span class="keyword">if</span> .WorkerRlimitNofile&#125;&#125;</span><br><span class="line">worker_rlimit_nofile &#123;&#123;.WorkerRlimitNofile&#125;&#125;;&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="keyword">if</span> .WorkerCPUAffinity&#125;&#125;</span><br><span class="line">worker_cpu_affinity &#123;&#123;.WorkerCPUAffinity&#125;&#125;;&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="keyword">if</span> .WorkerShutdownTimeout&#125;&#125;</span><br><span class="line">worker_shutdown_timeout &#123;&#123;.WorkerShutdownTimeout&#125;&#125;;&#123;&#123;end&#125;&#125;</span><br><span class="line">daemon off;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="k8s与Nginx-官方-Ingres-区别"><a href="#k8s与Nginx-官方-Ingres-区别" class="headerlink" title="k8s与Nginx 官方 Ingres 区别"></a>k8s与Nginx 官方 Ingres 区别</h2><p>进程架构</p>
<ul>
<li>K8S 官方<ul>
<li>/usr/bin/dumb-init</li>
<li>nginx-ingress-controller</li>
<li>/usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf </li>
</ul>
</li>
<li><p>Nginx 官方</p>
<ul>
<li>nginx-ingress</li>
<li>/usr/sbin/nginx</li>
</ul>
</li>
<li><p><strong>K8S 官方优势</strong></p>
</li>
</ul>
<p>可以看出 K8S 官方是对容器的理解非常深，容器是单进程架构，这并不意味着容器里面只能跑一个进程，而是指容器内只能管理一个进程。K8S 的这一个进程就是 <code>/usr/bin/dumb-init</code> 仿照了操作系统中的 <code>systemd</code> 进程对这个POD容器进行管理。</p>
<p>而Nginx官方的Ingress 是 <code>nginx-ingress</code> 进程。</p>
<p>另一个就是K8S官方的负载均衡配置变更是用的 <code>Balance By Lua</code> ，这个在配置频繁变更时性能会很高。</p>
<ul>
<li><strong>Nginx 官方优势</strong></li>
</ul>
<p>但是 Nginx 官方的 Ingress 明显是对 <code>nginx</code> 的理解更加深刻的。Ingress 默认是不支持正则匹配，Nginx 官方则对此有优化，这个就是 <code>VirtualServer</code>、<code>VirtualServerRoute</code>。</p>
<p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/virtual_server.png"></p>
<p>另外，Nginx 官方还提供了 <code>snippets</code> 。支持更高级的匹配模式，但其实也是一种全局的匹配。 具体参考 <a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-snippets/">Advanced Configuration with Snippets</a></p>
<p>支持添加 302 跳转，支持全局加 Header 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress-with-snippets</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.org/server-snippets:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">          <span class="string">return</span> <span class="number">302</span> <span class="string">/coffee;</span></span><br><span class="line">      &#125;      </span><br><span class="line">    <span class="attr">nginx.org/location-snippets:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">add_header</span> <span class="string">my-test-header</span> <span class="string">test-value;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span></span><br><span class="line">  <span class="string">....</span></span><br></pre></td></tr></table></figure>
<p>另外Nginx官方支持自定义模板。具体参考 <a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/custom-annotations/">Custom Annotations</a></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 架构拓扑</title>
    <url>/2021/08/05/k8s%E6%9E%B6%E6%9E%84%E6%8B%93%E6%89%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章将从K8S的架构、存储、网络及服务暴露等几个方面介绍,记录K8S的学习过程。</p>
<a id="more"></a>
<p>讨论议题：</p>
<ul>
<li>k8s 架构</li>
<li>k8s 存储架构</li>
<li>k8s 容器网络</li>
<li>k8s 服务暴露</li>
</ul>
<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>K8S 集群搭建方式参考, <a href="https://kiosk.io/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/#%E5%AE%89%E8%A3%85-kubernetes">ubuntu20.04 部署 Kubernetes (k8s)</a> </p>
<blockquote>
<p>搭建教程当时基于的环境 1.18 ，参考时注意更改到最新的对应版本。</p>
</blockquote>
<ul>
<li>集群主机（vmware 虚拟机）<ul>
<li>vm-ks0 (master): 172.16.101.135</li>
<li>vm-ks1 (node1):  172.16.101.136</li>
</ul>
</li>
<li>系统版本: ubuntu 20.04 TLS</li>
<li>kubernetes版本： v1.22.0</li>
</ul>
<p><strong>k8s 初始化 <code>ClusterConfiguration</code> yaml</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --config=http://s1.kiosk007.top/static/kubeadm-config.yaml --upload-certs -v 6</span><br></pre></td></tr></table></figure>
<p><strong>网络插件：flannel</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f http://s1.kiosk007.top/static/kube-flannel.yaml</span><br></pre></td></tr></table></figure>
<p><strong>去掉master节点的调度taint</strong></p>
<p>去掉NoSchedule使master节点可以调度pod。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes vm-ks0 node-role.kubernetes.io/master:NoSchedule-</span><br></pre></td></tr></table></figure><br><strong>宿主机安装NFS</strong></p>
<p>NFS 提供远程存储服务，并提供PV，NFS的安装工作参考 <a href="https://cloud.tencent.com/developer/article/1626660">这里</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt install nfs-kernel-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备磁盘目录</span></span><br><span class="line">mkdir -p /data/nfs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># NFS服务配置文件</span></span><br><span class="line">sudo vim /etc/exports</span><br><span class="line">/home/weijiaxiang/data/nfs *(rw,no_root_squash,sync)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启NFS，并保持NFS启动开机</span></span><br><span class="line">systemctl restart nfs-kernel-server</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-kernel-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有Node节点安装NFS客户端</span></span><br><span class="line">apt install nfs-common rpcbind</span><br><span class="line"></span><br><span class="line"><span class="comment"># Node 节点上查看能否 mount</span></span><br><span class="line">showmount -e 172.16.101.1</span><br></pre></td></tr></table></figure>
<h1 id="K8S-架构"><a href="#K8S-架构" class="headerlink" title="K8S 架构"></a>K8S 架构</h1><p>议题：</p>
<ol>
<li>K8S 架构是什么样的</li>
</ol>
<p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_cluster_1.png"></p>
<ul>
<li>CNI: 容器网络接口</li>
<li>CRI：容器运行时接口</li>
<li>OCI：开放容器标准</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_struct.png"></p>
<h1 id="容器持久化存储"><a href="#容器持久化存储" class="headerlink" title="容器持久化存储"></a>容器持久化存储</h1><p>议题：</p>
<ol>
<li>容器的存储是如何实现的</li>
<li>k8s集群如何使用存储</li>
</ol>
<p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes">Kubernetes 内置了20种持久化存储卷的实现</a></p>
<h2 id="PV-amp-PVC"><a href="#PV-amp-PVC" class="headerlink" title="PV &amp; PVC"></a>PV &amp; PVC</h2><p><strong>PV (PersistentVolume) 描述的是持久化存储数据卷。</strong>这个 API 对象主要定义的是一个持久化存储在宿主机上的目录，比如一个 NFS 的挂载目录。</p>
<p><strong>PVC（PersistentVolumeClaim） 描述的是 Pod 所希望使用的持久化存储的属性。</strong>比如，Volume 存储的大小、可读写权限等等。</p>
<p>一般PV由运维人员创建并提供，PVC是由开发人员所创建，以 PVC 模板的方式成为 StatefulSet 的一部分，然后由 StatefulSet 控制器负责创建带编号的 PVC。<strong>PV 和 PVC 的 storageClassName 字段必须一样，才能使用</strong></p>
<p>如一个 NFS 的 PV</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nfs-pv001.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pv001</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">pv:</span> <span class="string">nfs-pv001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/nfs/pv001</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.16</span><span class="number">.101</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>声明一个 1 GiB 大小的 PVC</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nfs-pvc001.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pvc001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">pv:</span> <span class="string">nfs-pv001</span></span><br></pre></td></tr></table></figure>
<p>接下来就可以像 <code>hostPath</code> 等常规类型的 Volume 一样，在自己的 YAML 文件里声明使用。<br>更多例子参考 <a href="http://docs.kubernetes.org.cn/429.html">这里</a></p>
<p>大多数情况下，持久化 Volume 的实现，往往依赖于一个远程存储服务，比如：远程文件存储（比如，NFS、GlusterFS）、远程块存储（比如，公有云提供的远程磁盘）等等。</p>
<p>实际生产环境中，一个大规模的 Kubernetes 集群里很可能有成千上万个 PVC，这就意味着运维人员必须得事先创建出成千上万个 PV。更麻烦的是，随着新的 PVC 不断被提交，运维人员就不得不继续添加新的、能满足条件的 PV。 为了自动化的创建PV，提出了一个 <strong>StorageClass</strong> 的概念。</p>
<p><strong>而 StorageClass 对象的作用，其实就是创建 PV 的模板。</strong><br>具体地说，StorageClass 对象会定义如下两个部分内容：</p>
<ul>
<li>第一，PV 的属性。比如，存储类型、Volume 的大小等等。</li>
<li>第二，创建这种 PV 需要用到的存储插件。比如，Ceph 等等。</li>
</ul>
<p>有了这样两个信息之后，Kubernetes 就能够根据用户提交的 PVC，找到一个对应的 StorageClass 了。然后，Kubernetes 就会调用该 StorageClass 声明的存储插件，创建出需要的 PV。</p>
<p>如开源项目 <a href="https://rook.io/">rook</a>。定义的还是一个名叫 block-service 的 StorageClass。（<a href="https://cloud.tencent.com/developer/article/1470038">Rook &amp; Ceph 简介</a>）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ceph.rook.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pool</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">replicapool</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">rook-ceph</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicated:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">3</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">block-service</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">ceph.rook.io/block</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">pool:</span> <span class="string">replicapool</span></span><br><span class="line">  <span class="comment">#The value of &quot;clusterNamespace&quot; MUST be the same as the one in which your rook cluster exist</span></span><br><span class="line">  <span class="attr">clusterNamespace:</span> <span class="string">rook-ceph</span></span><br></pre></td></tr></table></figure>
<p>作为应用开发者，不必再为难运维人员，上面提到的运维人员创建的PV是运维手工分配的，而 Storage Class 是动态创建的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">claim1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">block-service</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">30Gi</span></span><br></pre></td></tr></table></figure>
<h2 id="动态-NFS-Provision"><a href="#动态-NFS-Provision" class="headerlink" title="动态 NFS Provision"></a>动态 NFS Provision</h2><ul>
<li><strong>什么是 NFS-Subdir-External-Provisioner</strong></li>
</ul>
<p>存储组件 <code>NFS subdir external provisioner</code> 是一个存储资源自动调配器，它可用将现有的 NFS 服务器通过持久卷声明来支持 Kubernetes 持久卷的动态分配。自动新建的文件夹将被命名为 <code>$&#123;namespace&#125;-$&#123;pvcName&#125;-$&#123;pvName&#125;</code> ，由三个资源名称拼合而成。</p>
<blockquote>
<p>此组件是对 nfs-client-provisioner 的扩展，nfs-client-provisioner 已经不提供更新，且 nfs-client-provisioner 的 Github 仓库已经迁移到 <a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">NFS-Subdir-External-Provisioner</a> 的仓库。</p>
</blockquote>
<p>部署需要先将这个项目 <code>clone</code> 下来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner</span><br></pre></td></tr></table></figure>
<p>项目的deployment目录下有我们需要的搭建 yaml 文件。</p>
<ul>
<li><strong>创建 ServiceAccount</strong></li>
</ul>
<p>现在的 Kubernetes 集群大部分是基于 RBAC 的权限控制，所以我们需要创建一个拥有一定权限的 ServiceAccount 与后面要部署的 NFS Subdir Externa Provisioner 组件绑定。</p>
<p>执行 kubectl 命令将 RBAC 文件部署到 Kubernetes 集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f rbac.yaml</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>部署 NFS-Subdir-External-Provisioner</strong></li>
</ul>
<p>设置 <code>NFS-Subdir-External-Provisioner</code> 部署文件。需要对 <code>deployment.yaml</code> 做一些修改。<code>NFS_SERVER</code> 和 <code>NFS_PATH</code> 都需要改成自己的NFS服务器。另外默认镜像地址为 <code>k8s.gcr.io</code>, 我这里找了网上的一个地址 <code>registry.cn-beijing.aliyuncs.com/mydlq/nfs-subdir-external-provisioner:v4.0.0</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f deployment.yaml </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建 NFS SotageClass</strong></li>
</ul>
<p>我们在创建 PVC 时经常需要指定 storageClassName 名称，这个参数配置的就是一个 StorageClass 资源名称，PVC 通过指定该参数来选择使用哪个 StorageClass，并与其关联的 Provisioner 组件来动态创建 PV 资源。所以，这里我们需要提前创建一个 Storagelcass 资源。</p>
<blockquote>
<p>Provisioner 参数用于声明 NFS 动态卷提供者的名称，该参数值要和上面部署 NFS-Subdir-External-Provisioner 部署文件中指定的 PROVISIONER_NAME 参数保持一致，即设置为 nfs-storage。</p>
</blockquote>
<ul>
<li><strong>测试</strong></li>
</ul>
<p>创建一个用于测试的 pvc。并创建一个 pod 使用pvc写文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f test-claim.yaml</span><br><span class="line">$ kubectl apply -f test-pods.yaml</span><br></pre></td></tr></table></figure>
<p>在宿主机的 nfs 共享目录上发现，已经创建出 <code>SUCCESS</code> 文件。</p>
<h1 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h1><p>议题：</p>
<ol>
<li>同一台主机的容器既然被隔离，是怎样互相通信的</li>
<li>为什么跨主机的容器可以互相通信</li>
<li>容器间的网络通信和主机间的网络通信性能相差</li>
<li>k8s的CNI网络实现</li>
<li>K8S网络方案L2和L3的区别</li>
<li>网络隔离方案</li>
</ol>
<p>实验环境，起 2个 pod</p>
<p>flannel 网络通信方式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>通信方式</th>
<th style="text-align:center">概念</th>
<th style="text-align:center">方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>主机内通信</td>
<td style="text-align:center">1台机器内部的</td>
<td style="text-align:center">veth pair</td>
</tr>
<tr>
<td>L2 主机间通信</td>
<td style="text-align:center">2台主机连在同一台交换机的场景</td>
<td style="text-align:center">hostgw</td>
</tr>
<tr>
<td>L3 主机间通信</td>
<td style="text-align:center">2台主机没有连在同一台交换机的场景。</td>
<td style="text-align:center">内核态：vxlan  用户态：udp (性能差)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="主机内POD通信-（cni0-与-veth-pair）"><a href="#主机内POD通信-（cni0-与-veth-pair）" class="headerlink" title="主机内POD通信 （cni0 与 veth pair）"></a>主机内POD通信 （cni0 与 veth pair）</h2><ul>
<li>node: <code>vm-ks1</code>：<code>172.16.101.136/16</code><ul>
<li>pod0: <code>web-0</code> : <code>10.100.1.39  eth0@if6  0a:ff:9f:1b:5c:02</code></li>
<li>pod1: <code>web-1</code> : <code>10.100.1.40  eth0@if7  16:60:24:3d:0f:84</code></li>
</ul>
</li>
</ul>
<p>宿主机 vm-ks1 上的网卡, 除了 flannel和cni0 网卡外，还有一堆veth开头的网卡，每创建一个容器或pod都会在宿主机上生成一个 veth pair，这个veth pair可以理解为容器和宿主机之间拉了一条网线。可参考<a href="https://www.cnblogs.com/bakari/p/10613710.html">这篇文章</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@vm-ks1:~# ip link show</span><br><span class="line">root@vm-ks1:~# ip link show | egrep &quot;veth&quot; | awk -F&quot;:&quot; &#39;&#123;print $1&quot;:&quot;$2&#125;&#39;</span><br><span class="line">6: veth50ce0fb7@if3</span><br><span class="line">7: veth51f9d367@if3</span><br><span class="line">8: veth8b0a5941@if3</span><br><span class="line">9: veth940d7fa4@if3</span><br><span class="line">10: veth12a5546b@if3</span><br><span class="line">11: veth1b7e020f@if3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_cni0_1.png"></p>
<p>同一主机内的pod之间的互相通信流量会经过 <code>cni0</code>，可以看到 pod0 的Mac地址<code>0a:ff:9f:1b:5c:02</code> 可以直接访问 pod1 的Mac地址 <code>16:60:24:3d:0f:84</code><br>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@vm-ks1:~<span class="comment"># tcpdump -i cni0 port 80 -XXe -v</span></span><br><span class="line">tcpdump: listening on cni0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">23:42:29.370870 0a:ff:9f:1b:5c:02 (oui Unknown) &gt; 16:60:24:3d:0f:84 (oui Unknown), ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 64, id 16685, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.100.1.39.52402 &gt; 10.100.1.40.http: Flags [S], cksum 0x1745 (incorrect -&gt; 0x9d01), seq 2993213598, win 64860, options [mss 1410,sackOK,TS val 2243936499 ecr 0,nop,wscale 7], length 0</span><br><span class="line">	0x0000:  1660 243d 0f84 0aff 9f1b 5c02 0800 4500  .`$=......\...E.</span><br><span class="line">	0x0010:  003c 412d 4000 4006 e278 0a64 0127 0a64  .&lt;A-@.@..x.d.<span class="string">&#x27;.d</span></span><br><span class="line"><span class="string">	0x0020:  0128 ccb2 0050 b268 d09e 0000 0000 a002  .(...P.h........</span></span><br><span class="line"><span class="string">	0x0030:  fd5c 1745 0000 0204 0582 0402 080a 85bf  .\.E............</span></span><br><span class="line"><span class="string">	0x0040:  c0f3 0000 0000 0103 0307                 ..........</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>从宿主机的 <code>arp</code> 命令可知 <code>cni0</code> 上的路由表是既有 <code>pod0</code> 的mac地址+ip地址，也有<code>pod1</code>的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@vm-ks1:~<span class="comment"># arp -v</span></span><br><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">10.100.0.0               ether   da:e9:f6:2d:73:b5   CM                    flannel.1</span><br><span class="line">10.100.1.41              ether   5e:82:a8:f9:ab:92   C                     cni0</span><br><span class="line">10.100.1.40              ether   16:60:24:3d:0f:84   C                     cni0</span><br><span class="line">10.100.1.42              ether   ae:85:38:14:2e:3f   C                     cni0</span><br><span class="line">10.100.1.44              ether   56:0c:75:ed:ca:cb   C                     cni0</span><br><span class="line">_gateway                 ether   00:50:56:e3:07:3f   C                     ens33</span><br><span class="line">172.16.101.1             ether   00:50:56:c0:00:08   C                     ens33</span><br><span class="line">vm-ks0                   ether   00:0c:29:ee:ae:5f   C                     ens33</span><br><span class="line">10.100.1.39              ether   0a:ff:9f:1b:5c:02   C                     cni0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="k8s-跨主机ip通信"><a href="#k8s-跨主机ip通信" class="headerlink" title="k8s 跨主机ip通信"></a>k8s 跨主机ip通信</h2><p>跨主机间通信分2种，hostgw: eht0  vxlan: flannel0。我们在初始化k8s 集群时使用的是 flannel的网络cni插件。<a href="https://github.com/coreos/flannel">flannel</a>通过给每台宿主机分配一个子网的方式为容器提供虚拟网络，它基于Linux TUN/TAP，使用UDP封装IP包来创建overlay网络，并借助etcd维护网络的分配情况。</p>
<blockquote>
<p>udp：使用用户态udp封装，默认使用8285端口。由于是在用户态封装和解包，性能上有较大的损失<br>vxlan：vxlan封装，需要配置VNI，Port（默认8472）和GBP<br>host-gw：直接路由的方式，将容器网络的路由信息直接更新到主机的路由表中，仅适用于二层直接可达的网络</p>
</blockquote>
<ul>
<li><p>node: <code>vm-ks1</code>：<code>172.16.101.136/16</code></p>
<ul>
<li>pod0: <code>web-0</code> : <code>10.100.1.39  eth0@if6  0a:ff:9f:1b:5c:02</code></li>
<li>flannel.1: <code>10.100.0.0  da:e9:f6:2d:73:b5</code></li>
</ul>
</li>
<li><p>node: <code>vm-ks0</code>: <code>172.16.101.135/16</code></p>
<ul>
<li>pod2: <code>web-2</code> : <code>10.100.0.22  eth0@if8  66:14:4c:b9:74:13</code></li>
<li>flannel.1: <code>10.100.1.0  fe:ca:1a:3e:42:41</code></li>
</ul>
</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_flannel.png"></p>
<p>vm-ks0 的 <code>flannel</code> 设备收到“原始 IP 包”后，就要想办法把“原始 IP 包”加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 flannel” 设备。vm-ks0 和 vm-ks1 上的 flannel 设备组成了一个虚拟的2层网络，即：通过二层数据帧进行通信。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@vm-ks0:~<span class="comment"># ifconfig flannel.1</span></span><br><span class="line">flannel.1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        inet 10.100.0.0  netmask 255.255.255.255  broadcast 10.100.0.0</span><br><span class="line">        inet6 fe80::d8e9:f6ff:fe2d:73b5  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether da:e9:f6:2d:73:b5  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 4387  bytes 777102 (777.1 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8578  bytes 1684583 (1.6 MB)</span><br><span class="line">        TX errors 19  dropped 49 overruns 0  carrier 19  collisions 0</span><br><span class="line">        </span><br><span class="line">root@vm-ks0:~<span class="comment"># ip neigh show dev flannel.1</span></span><br><span class="line">10.100.1.0 lladdr fe:ca:1a:3e:42:41 PERMANENT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在vm-ks0上执行 <code>ip neigh show dev flannel.1</code><br>这条记录的意思非常明确，即：IP 地址 10.100.1.0，对应的 MAC 地址是 fe:ca:1a:3e:42:41。</p>
<p>一个 flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对应的宿主机地址是什么。</p>
<p>也就是说，这个 UDP 包该发给哪台宿主机呢？</p>
<p>在这种场景下，flannel.1 设备实际上要扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而在 Linux 内核里面，“网桥”设备进行转发的依据，来自于一个叫作 FDB（Forwarding Database）的转发数据库。</p>
<p>这个 flannel.1“网桥”对应的 FDB 信息，也是 flanneld 进程负责维护的。它的内容可以通过 bridge fdb 命令查看到，如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@vm-ks0:~<span class="comment"># bridge fdb show flannel.1 | grep fe:ca:1a:3e:42:41</span></span><br><span class="line">fe:ca:1a:3e:42:41 dev flannel.1 dst 172.16.101.136 self permanent</span><br></pre></td></tr></table></figure>
<p>这下整个转发过程就清楚了，参考下图的封装过程。</p>
<p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_vxlan_packet.webp"></p>
<p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_vxlan.png"></p>
<p>从上面的 wireshark 抓包可以看到，跨主机访问的报文是UDP的VXLAN协议，使用 8472 端口。<br>VXLAN 上的二层Mac地址分别是两台node节点的flannel网卡的Mac地址。<br>再向上就如同pod0 和 pod2 直接通信的效果了。</p>
<p>3 层主机之间的通信UDP模式已经废弃。<br>我们在进行系统级编程的时候，有一个非常重要的优化原则，就是要减少用户态到内核态的切换次数，并且把核心的处理逻辑都放在内核态进行。这也是为什么，Flannel 后来支持的VXLAN 模式，逐渐成为了主流的容器网络方案的原因。</p>
<h2 id="CNI-插件的部署和实现"><a href="#CNI-插件的部署和实现" class="headerlink" title="CNI 插件的部署和实现"></a>CNI 插件的部署和实现</h2><p>我们在部署 Kubernetes 的时候，有一个步骤是安装 kubernetes-cni 包，它的目的就是在宿主机上安装 <strong>CNI 插件所需的基础可执行文件</strong>。</p>
<p>在安装完成后，你可以在宿主机的 /opt/cni/bin 目录下看到它们，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@vm-ks0:~<span class="comment"># ls -al /opt/cni/bin/</span></span><br><span class="line">total 70504</span><br><span class="line">drwxrwxr-x 2 root root     4096 Aug 15 10:07 .</span><br><span class="line">drwxr-xr-x 3 root root     4096 Aug 15 10:07 ..</span><br><span class="line">-rwxr-xr-x 1 root root  4159518 May 14  2020 bandwidth</span><br><span class="line">-rwxr-xr-x 1 root root  4671647 May 14  2020 bridge</span><br><span class="line">-rwxr-xr-x 1 root root 12124326 May 14  2020 dhcp</span><br><span class="line">-rwxr-xr-x 1 root root  5945760 May 14  2020 firewall</span><br><span class="line">-rwxr-xr-x 1 root root  3069556 May 14  2020 flannel</span><br><span class="line">-rwxr-xr-x 1 root root  4174394 May 14  2020 host-device</span><br><span class="line">-rwxr-xr-x 1 root root  3614480 May 14  2020 host-local</span><br><span class="line">-rwxr-xr-x 1 root root  4314598 May 14  2020 ipvlan</span><br><span class="line">-rwxr-xr-x 1 root root  3209463 May 14  2020 loopback</span><br><span class="line">-rwxr-xr-x 1 root root  4389622 May 14  2020 macvlan</span><br><span class="line">-rwxr-xr-x 1 root root  3939867 May 14  2020 portmap</span><br><span class="line">-rwxr-xr-x 1 root root  4590277 May 14  2020 ptp</span><br><span class="line">-rwxr-xr-x 1 root root  3392826 May 14  2020 sbr</span><br><span class="line">-rwxr-xr-x 1 root root  2885430 May 14  2020 static</span><br><span class="line">-rwxr-xr-x 1 root root  3356587 May 14  2020 tuning</span><br><span class="line">-rwxr-xr-x 1 root root  4314446 May 14  2020 vlan</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些 CNI 的基础可执行文件，按照功能可以分为三类:</p>
<ul>
<li><strong>第一类，叫作 Main 插件，它是用来创建具体网络设备的二进制文件</strong>。比如，bridge（网桥设备）、ipvlan、loopback（lo 设备）、macvlan、ptp（Veth Pair 设备），以及 vlan。我在前面提到过的 Flannel、Weave 等项目，都属于“网桥”类型的 CNI 插件。所以在具体的实现中，它们往往会调用 bridge 这个二进制文件。</li>
<li><strong>第二类，叫作 IPAM（IP Address Management）插件</strong>，它是负责分配 IP 地址的二进制文件。比如，dhcp，这个文件会向 DHCP 服务器发起请求；host-local，则会使用预先配置的 IP 地址段来进行分配。</li>
<li><strong>第三类，是由 CNI 社区维护的内置 CNI 插件</strong>。比如：flannel，就是专门为 Flannel 项目提供的 CNI 插件；tuning，是一个通过 sysctl 调整网络设备参数的二进制文件；portmap，是一个通过 iptables 配置端口映射的二进制文件；bandwidth，是一个使用 Token Bucket Filter (TBF) 来进行限流的二进制文件。</li>
</ul>
<p><strong>首先，实现这个网络方案本身</strong>。这一部分需要编写的，其实就是 flanneld 进程里的主要逻辑。比如，创建和配置 flannel.1 设备、配置宿主机路由、配置 ARP 和 FDB 表里的信息等等。</p>
<p><strong>然后，实现该网络方案对应的 CNI 插件</strong>。这一部分主要需要做的，就是配置 Infra 容器里面的网络栈，并把它连接在 CNI 网桥上。</p>
<p>其启动和配置原理如下,首先，CNI bridge 插件会在宿主机上检查 CNI 网桥是否存在。如果没有的话，那就创建它。这相当于在宿主机上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在宿主机上</span></span><br><span class="line">$ ip link add cni0 <span class="built_in">type</span> bridge</span><br><span class="line">$ ip link <span class="built_in">set</span> cni0 up</span><br></pre></td></tr></table></figure>
<p>接下来，CNI bridge 插件会通过 Infra 容器的 Network Namespace 文件，进入到这个 Network Namespace 里面，然后创建一对 Veth Pair 设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一对Veth Pair设备。其中一个叫作eth0，另一个叫作vethb4963f3</span></span><br><span class="line">$ ip link add eth0 <span class="built_in">type</span> veth peer name vethb4963f3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动eth0设备</span></span><br><span class="line">$ ip link <span class="built_in">set</span> eth0 up </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将Veth Pair设备的另一端（也就是vethb4963f3设备）放到宿主机（也就是Host Namespace）里</span></span><br><span class="line">$ ip link <span class="built_in">set</span> vethb4963f3 netns <span class="variable">$HOST_NS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Host Namespace，启动宿主机上的vethb4963f3设备</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$HOST_NS</span> ip link <span class="built_in">set</span> vethb4963f3 up </span><br></pre></td></tr></table></figure>
<p>这样，vethb4963f3 就出现在了宿主机上，而且这个 Veth Pair 设备的另一端，就是容器里面的 eth0。(在宿主机上操作也可以，原理都一样)</p>
<p>接下来，CNI bridge 插件就可以把 vethb4963f3 设备连接在 CNI 网桥上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在宿主机上</span></span><br><span class="line">$ ip link <span class="built_in">set</span> vethb4963f3 master cni0</span><br></pre></td></tr></table></figure>
<p>所有容器都可以直接使用 IP 地址与其他容器通信，而无需使用 NAT。</p>
<p>容器自己“看到”的自己的 IP 地址，和别人（宿主机或者容器）看到的地址是完全一样的。</p>
<h2 id="三层网络方案"><a href="#三层网络方案" class="headerlink" title="三层网络方案"></a>三层网络方案</h2><p>除了网桥类型的 Flannel 插件，还有一种纯三层（Pure Layer 3）网络方案，典型例子包括 Flannel 的 host-gw 模式和 Calico 项目。</p>
<p>当你设置 Flannel 使用 host-gw 模式之后，flanneld 会在宿主机上创建这样一条规则，以 vm-ks0 为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ ip route</span><br><span class="line">...</span><br><span class="line">10.100.1.0/24 via 172.16.101.136 dev eth0</span><br></pre></td></tr></table></figure>
<p>这条路由规则的含义是：目的 IP 地址属于 10.100.1.0/24 网段的 IP 包，应该经过本机的 eth0 设备发出去（即：dev eth0）；并且，它下一跳地址（next-hop）是 172.16.101.136（即：via 172.16.101.136）。</p>
<p><strong>host-gw 模式的工作原理，其实就是将每个 Flannel 子网（Flannel Subnet，比如：10.100.1.0/24）的“下一跳”，设置成了该子网对应的宿主机的 IP 地址。</strong></p>
<p>也就是说，这台“主机”（Host）会充当这条容器通信路径里的“网关”（Gateway）。这也正是“host-gw”的含义。<strong>所以说，Flannel host-gw 模式必须要求集群宿主机之间是二层连通的。</strong></p>
<p><strong>不同于 Flannel 通过 Etcd 和宿主机上的 flanneld 来维护路由信息的做法，Calico 项目使用了一个BGP(Border Gateway Protocol，即：边界网关协议) 来自动地在整个集群中分发路由信息。</strong></p>
<p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_l3_bgp.webp"></p>
<p>比如上述，有2个自治系统（Autonomous System，简称为 AS）：AS 1 和 AS 2。在正常情况下，自治系统之间不会有任何“来往”。</p>
<p>比如，AS 1 里面的主机 10.10.0.2，要访问 AS 2 里面的主机 172.17.0.3 的话。它发出的 IP 包，就会先到达自治系统 AS 1 上的路由器 Router 1。</p>
<p>而在此时，Router 1 的路由表里，有这样一条规则，即：目的地址是 172.17.0.2 包，应该经过 Router 1 的 C 接口，发往网关 Router 2（即：自治系统 AS 2 上的路由器）。至此Router 2 就会把数据包交付到真正的目的主机上。</p>
<p>我们就把它形象地称为：<strong>边界网关</strong>。它跟普通路由器的不同之处在于，它的路由表里拥有其他自治系统里的主机路由信息。</p>
<p>而 BGP 的这个能力，正好可以取代 Flannel 维护主机上路由表的功能。而且，BGP 这种原生就是为大规模网络环境而实现的协议，其可靠性和可扩展性，远非 Flannel 自己的方案可比。</p>
<ul>
<li><strong>三层网络和二层隧道的区别</strong><ul>
<li>三层和隧道的异同：<br>相同之处是都实现了跨主机容器的三层互通，而且都是通过对目的 MAC 地址的操作来实现的；不同之处是三层通过配置下一条主机的路由规则来实现互通，隧道则是通过通过在 IP 包外再封装一层 MAC 包头来实现。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>三层的优点：少了封包和解包的过程，性能肯定是更高的。</li>
<li>三层的缺点：需要自己想办法维护路由规则。</li>
<li>隧道的优点：简单，原因是大部分工作都是由 Linux 内核的模块实现了，应用层面工作量较少。</li>
<li>隧道的缺点：主要的问题就是性能低。</li>
</ul>
</blockquote>
<p>根据实际的测试，host-gw 的性能损失大约在 10% 左右，而其他所有基于 VXLAN“隧道”机制的网络方案，性能损失都在 20%~30% 左右。</p>
<h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h2><p>在 Kubernetes 里，网络隔离能力的定义，是依靠一种专门的 API 对象来描述的，即：NetworkPolicy。</p>
<p><strong>Kubernetes 里的 Pod 默认都是“允许所有”（Accept All）的</strong>，即：Pod 可以接收来自任何发送方的请求；或者，向任何接收方发送请求。而如果你要对这个情况作出限制，就必须通过 NetworkPolicy 对象来指定。</p>
<p>如下例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">        <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">project:</span> <span class="string">myproject</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5978</span></span><br></pre></td></tr></table></figure>
<p>这个 NetworkPolicy 对象，指定的隔离规则如下所示：</p>
<ol>
<li>该隔离规则只对 default Namespace 下的，携带了 role=db 标签的 Pod 有效。限制的请求类型包括 ingress（流入）和 egress（流出）。</li>
<li>Kubernetes 会拒绝任何访问被隔离 Pod 的请求，除非这个请求来自于以下“白名单”里的对象，并且访问的是被隔离 Pod 的 6379 端口。这些“白名单”对象包括：<br>a. default Namespace 里的，携带了 role=fronted 标签的 Pod；<br>b. 携带了 project=myproject 标签的 Namespace 里的任何 Pod；<br>c. 任何源地址属于 172.17.0.0/16 网段，且不属于 172.17.1.0/24 网段的请求。</li>
<li>Kubernetes 会拒绝被隔离 Pod 对外发起任何请求，除非请求的目的地址属于 10.0.0.0/24 网段，并且访问的是该网段地址的 5978 端口。</li>
</ol>
<p>在 Kubernetes 生态里，目前已经实现了 NetworkPolicy 的网络插件包括 Calico、Weave 和 kube-router 等多个项目，但是并不包括 Flannel 项目。</p>
<p>所以说，如果想要在使用 Flannel 的同时还使用 NetworkPolicy 的话，你就需要再额外安装一个网络插件，比如 Calico 项目，来负责执行 NetworkPolicy。<a href="https://docs.projectcalico.org/v3.2/getting-started/kubernetes/installation/flannel">安装方式</a></p>
<h1 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h1><p>我们知道 deployment 是由一堆 pod 组成的。在我们要访问pod 上的服务时有2个问题需要解决。</p>
<ol>
<li>pod 的ip是不固定的，随着调度一直在变</li>
<li>pod之间需要一种负载均衡的访问</li>
</ol>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>一个最典型的 <code>service</code> 定义如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>可以看到这个名为 <code>nginx</code> 的service，后面挂载了3个pod。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe svc nginx</span><br><span class="line">Name:              nginx</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Family Policy:  SingleStack</span><br><span class="line">IP Families:       IPv4</span><br><span class="line">IP:                10.96.60.101</span><br><span class="line">IPs:               10.96.60.101</span><br><span class="line">Port:              default  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.100.1.39:80,10.100.1.40:80,10.100.1.43:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问时可以随机负载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-0</span><br><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-1</span><br><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-1</span><br><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-2</span><br><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上，Service 是由 kube-proxy 组件，加上 iptables 来共同实现的。</p>
<p>对于我们前面创建的名叫 <code>nginx</code> 的 Service 来说，一旦它被提交给 Kubernetes，那么 kube-proxy 就可以通过 Service 的 Informer 感知到这样一个 Service 对象的添加。而作为对这个事件的响应，它就会在宿主机上创建这样一条 iptables 规则（你可以通过 iptables-save 看到它），如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># iptables-save | grep &quot;10.96.60.101&quot;</span></span><br><span class="line">-A KUBE-SERVICES -d 10.96.60.101/32 -p tcp -m comment --comment <span class="string">&quot;default/nginx:default cluster IP&quot;</span> -m tcp --dport 80 -j KUBE-SVC-5JWVWZBQU2R3YJF2</span><br><span class="line">-A KUBE-SVC-5JWVWZBQU2R3YJF2 ! -s 10.100.0.0/16 -d 10.96.60.101/32 -p tcp -m comment --comment <span class="string">&quot;default/nginx:default cluster IP&quot;</span> -m tcp --dport 80 -j KUBE-MARK-MASQ</span><br></pre></td></tr></table></figure>
<p>这条 iptables 规则的含义是：凡是目的地址是 10.96.60.101、目的端口是 80 的 IP 包，都应该跳转到另外一条名叫 KUBE-SVC-5JWVWZBQU2R3YJF2 的 iptables 链进行处理。</p>
<p>那如何做到随机访问，实际上是利用了iptable规则里的random组件里的 <code>--probability</code> 实现的，有33%的概率访问到 <code>web-0</code>, 如果没命中的话，有50%的概率访问到 <code>web-1</code>, 如果还没有命中的话，则必访问到 <code>web-3</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-A KUBE-SVC-5JWVWZBQU2R3YJF2 -m comment --comment <span class="string">&quot;default/nginx:default&quot;</span> -m statistic --mode random --probability 0.33333333349 -j KUBE-SEP-WZ2C5AZQZKHYZFZC</span><br><span class="line">-A KUBE-SVC-5JWVWZBQU2R3YJF2 -m comment --comment <span class="string">&quot;default/nginx:default&quot;</span> -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-VQLGMKAWCVHQEJD4</span><br><span class="line">-A KUBE-SVC-5JWVWZBQU2R3YJF2 -m comment --comment <span class="string">&quot;default/nginx:default&quot;</span> -j KUBE-SEP-W6K7OWILI2KV46KH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不难想到，当你的宿主机上有大量 Pod 的时候，成百上千条 iptables 规则不断地被刷新，会大量占用该宿主机的 CPU 资源，甚至会让宿主机“卡”在这个过程中。所以说，<strong>一直以来，基于 iptables 的 Service 实现，都是制约 Kubernetes 项目承载更多量级的 Pod 的主要障碍。</strong></p>
<p>而 IPVS 模式的 Service，就是解决这个问题的一个行之有效的方法。IPVS 模式的工作原理，其实跟 iptables 模式类似。当我们创建了前面的 Service 之后，kube-proxy 首先会在宿主机上创建一个虚拟网卡（叫作：kube-ipvs0），并为它分配 Service VIP 作为 IP 地址，</p>
<p class="div-border green">所以，在大规模集群里，建议 kube-proxy 设置–proxy-mode=ipvs 来开启这个功能。它为 Kubernetes 集群规模带来的提升，还是非常巨大的。
</p>

<ul>
<li><strong>DNS 服务发现</strong></li>
</ul>
<p>在 Kubernetes 中，Service 和 Pod 都会被分配对应的 DNS A 记录（从域名解析 IP 的记录）。</p>
<p>对于 ClusterIP 模式的 Service 来说（比如我们上面的例子），它的 A 记录的格式是：..svc.cluster.local。当你访问这条 A 记录的时候，它解析到的就是该 Service 的 VIP 地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@web-1:&#x2F;# dig nginx.default.svc.cluster.local +short</span><br><span class="line">10.96.60.101</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，在 Kubernetes 里，/etc/hosts 文件是单独挂载的，这也是为什么 kubelet 能够对 hostname 进行修改并且 Pod 重建后依然有效的原因。这跟 Docker 的 Init 层是一个原理。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>k8s 部署 HTTP3  Nginx </title>
    <url>/2021/08/04/k8s-%E9%83%A8%E7%BD%B2-Nginx-%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前的文章中介绍了如何编译<a href="https://kiosk007.top/2021/07/31/%E5%B0%9D%E8%AF%95-Nginx-%E4%B8%8A%E4%BD%BF%E7%94%A8HTTP3/">支持HTTP3的Nginx</a> 为了一键将H3 Nginx上云，一劳永逸，本文会记录一下容器化Nginx的过程。</p>
<a id="more"></a>
<h1 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h1><p>Docker Image 的制作两种方法，支持 HTTP3 的 Nginx 在上面的文章中已经阐述(不过需要加上 <code>nginx-upstream-dynamic-servers</code> 这个模块，后面会用到)，镜像的制作是将编译好的二进制文件打包放进 Docker 镜像当中，并保证其可运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法 1：docker commit #保存 container 的当前状态到 image 后，然后生成对应的 image</span><br><span class="line">方法 2：docker build #使用 Dockerfile 文件自动化制作 image</span><br></pre></td></tr></table></figure>
<h2 id="方法一-docker-commit"><a href="#方法一-docker-commit" class="headerlink" title="方法一: docker commit"></a>方法一: docker commit</h2><p>获取 ubuntu 镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it ubuntu:latest &#x2F;bin&#x2F;bash</span><br><span class="line"># 进入到容器后，创建 nginx 家目录</span><br><span class="line">mkdir nginx</span><br></pre></td></tr></table></figure>
<p>Nginx 的编译产物会全部放进 ${NGINX_QUIC_PATH}/objs 目录下。所以创建镜像需要将这里面的必要文件copy进镜像中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  nginx-quic ls objs </span><br><span class="line">addon  autoconf.err  Makefile  nginx  nginx.8  ngx_auto_config.h  ngx_auto_headers.h  ngx_modules.c  ngx_modules.o  src</span><br><span class="line"></span><br><span class="line">➜  docker cp ./obj/nginx 9d129eb7c4a6:/nginx/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为Nginx依赖 Lua 动态库所以还需要将 luajit 等动态库拷贝进镜像中。并指明相关的动态库加载地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  docker cp /usr/<span class="built_in">local</span>/include/luajit-2.0/ 9d129eb7c4a6:/usr/<span class="built_in">local</span>/include</span><br><span class="line">➜  docker cp /usr/<span class="built_in">local</span>/lib/libluajit-5.1.a 9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib</span><br><span class="line">➜  docker cp /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2.0.5 9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib</span><br><span class="line"></span><br><span class="line">➜  docker cp /usr/<span class="built_in">local</span>/lib/libpcre.so.1.2.12 9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib/</span><br><span class="line">➜  docker cp /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1  9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib/</span><br><span class="line">➜  docker cp /usr/lib/x86_64-linux-gnu/libprofiler.so.0.4.18 9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到容器中，创建软连</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib</span><br><span class="line">ln -sv libluajit-5.1.so.2.0.5 libluajit-5.1.so</span><br><span class="line">ln -sv libluajit-5.1.so.2.0.5 libluajit-5.1.so.2</span><br><span class="line"></span><br><span class="line">ln -sv libpcre.so.1.2.12 libpcre.so</span><br><span class="line">ln -sv libpcre.so.1.2.12 libpcre.so.1</span><br><span class="line"></span><br><span class="line">ln -sv libprofiler.so.0.4.18 libprofiler.so</span><br><span class="line">ln -sv libprofiler.so.0.4.18 libprofiler.so.0</span><br><span class="line"></span><br><span class="line">ln -sv libunwind.so.8.0.1 libunwind.so</span><br><span class="line">ln -sv libunwind.so.8.0.1 libunwind.so.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器内的 ~/.bashrc 生成环境变量</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LUAJIT_LIB=/usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">export</span> LUAJIT_INC=/usr/<span class="built_in">local</span>/include/luajit-2.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 exit 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>根据容器当前状态做一个 image 镜像</p>
<blockquote>
<p>-m :提交时的说明文字； -a :提交的镜像作者；</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  docker commit -m <span class="string">&quot;nginx http3 quic&quot;</span> -a <span class="string">&quot;kiosk007&quot;</span> 158c3352b0da weijiaxiang007/nginx-http3:v0.1</span><br><span class="line">sha256:322e9c9b5fa886294ca478440ccfe972fcef2416f1d99b3eb9a20552454246fa</span><br><span class="line"></span><br><span class="line">➜  docker images</span><br><span class="line">REPOSITORY                                                    TAG       IMAGE ID       CREATED              SIZE</span><br><span class="line">http3_nginx                                                   v0.1      47f04055cd4e   About a minute ago   201MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="方法二：DockerFile"><a href="#方法二：DockerFile" class="headerlink" title="方法二：DockerFile"></a>方法二：DockerFile</h2><p>使用 docker build 创建镜像时，需要使用 Dockerfile 文件自动化制作 image 镜像<br>Dockerfile 有点像源码编译时./configure 后产生的 Makefile</p>
<ul>
<li>创建工作目录 和 DockerFile 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mkdir nginx-http3</span><br><span class="line">➜  <span class="built_in">cd</span> nginx-http3</span><br><span class="line">➜  touch Dockerfile</span><br></pre></td></tr></table></figure>
<p>将 Nginx-http3 的编译产物和依赖动态库 copy 至该目录中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  cp -rf /usr/<span class="built_in">local</span>/include/luajit-2.0 .</span><br><span class="line">➜  cp -rf /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2.0.5 .</span><br><span class="line">➜  cp -rf /usr/<span class="built_in">local</span>/lib/libluajit-5.1.a .       </span><br><span class="line">➜  cp -rf /usr/<span class="built_in">local</span>/lib/libpcre.so.1.2.12 .</span><br><span class="line">➜  cp -rf /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1 .</span><br><span class="line">➜  cp -rf /usr/lib/x86_64-linux-gnu/libprofiler.so.0.4.18 .</span><br><span class="line">➜  cp -rf ~/Project/Nginx/nginx-quic/objs/nginx .</span><br><span class="line">➜  cp -rf ~/Project/Nginx/nginx-quic/conf/nginx.conf .</span><br><span class="line">➜  cp -rf ~/Project/Nginx/nginx-quic/conf/mime.types . </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>编写DockerFile</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This dockerfile uses the ubuntu image</span></span><br><span class="line"><span class="comment"># VERSION 2 - EDITION 1</span></span><br><span class="line"><span class="comment"># Author: kiosk007</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FROM 基于哪个镜像</span></span><br><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># MAINTAINER 镜像创建者</span></span><br><span class="line">MAINTAINER kiosk007</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">ENV LUAJIT_LIB=/usr/<span class="built_in">local</span>/lib LUAJIT_INC=/usr/<span class="built_in">local</span>/include/luajit-2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY 文件至容器中</span></span><br><span class="line">COPY luajit-2.0 /usr/<span class="built_in">local</span>/include/luajit-2.0</span><br><span class="line">COPY lib* /usr/<span class="built_in">local</span>/lib/</span><br><span class="line">COPY nginx /sbin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN </span></span><br><span class="line">RUN ln -sv /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2.0.5 /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2.0.5 /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2 &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libpcre.so.1.2.12 /usr/<span class="built_in">local</span>/lib/libpcre.so &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libpcre.so.1.2.12 /usr/<span class="built_in">local</span>/lib/libpcre.so.1 &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libprofiler.so.0.4.18 /usr/<span class="built_in">local</span>/lib/libprofiler.so &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libprofiler.so.0.4.18 /usr/<span class="built_in">local</span>/lib/libprofiler.so.0 &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libunwind.so.8.0.1 /usr/<span class="built_in">local</span>/lib/libunwind.so &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libunwind.so.8.0.1 /usr/<span class="built_in">local</span>/lib/libunwind.so.8 &amp;&amp; mkdir -p /nginx/logs &amp;&amp; mkdir -p /nginx/conf &amp;&amp; ldconfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># EXPOSE 暴露端口</span></span><br><span class="line">EXPOSE 80/tcp 443/tcp 443/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置挂载路径 /nginx</span></span><br><span class="line">VOLUME /nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD</span></span><br><span class="line">CMD [<span class="string">&quot;/sbin/nginx&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="string">&quot;/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p class="div-border grey">Dockerfile 的指令每执行一次都会在 docker 上新建一层，所以特别是 RUN 指令尽量通过 && 连在一起</p>

<p>关于Docker CMD 和 ENTRYPOINT ，可参考<a href="https://www.jb51.net/article/136264.htm">这篇文章</a>, Dockerfile 语法参考 <a href="https://www.runoob.com/docker/docker-dockerfile.html">菜鸟</a>，<br>关于为什么 CMD 要写成 <code>daemon off</code> 参考 <a href="https://z.itpub.net/article/detail/45E0117B462C4053A0FA82AC0FBED1FB">Docker，为什么你容器刚启动就停了？</a></p>
<ul>
<li>构建镜像文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  docker build -t kiosk007&#x2F;nginx-quic:v0.2 .</span><br></pre></td></tr></table></figure>
<p>—tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签.</p>
<p>镜像打包好后，通过 <code>docker images</code> 命令可以看到当前的镜像id</p>
<ul>
<li>运行容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  docker run --name http3_nginx -v ~&#x2F;Project&#x2F;Nginx&#x2F;nginx-quic:&#x2F;nginx -p 8080:80 -p 8443:443&#x2F;udp -p 8443:443&#x2F;tcp -d 35edbb5f8be1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p 8443:443 映射端口<br>-d 守护进程运行<br>-name http3_nginx 指定容器的名称<br>-v xxxx:/nginx 将宿主机的Nginx工作目录映射进容器中的工作目录 </p>
</blockquote>
<p>OK, 既然容器已经都起来了，那么访问一下吧，我本地的nginx conf 已经配置了 <code>quic.kiosk007.top 的 quic 配置</code>，使用 quic 客户端访问一下吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_client -H quic.kiosk007.top:8443 -p /ping   </span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">server: nginx/1.21.1</span><br><span class="line">date: Sat, 07 Aug 2021 08:57:50 GMT</span><br><span class="line">content-type: text/html</span><br><span class="line">content-length: 4</span><br><span class="line">strict-transport-security: max-age=63072000; includeSubDomains; preload</span><br><span class="line">alt-svc: h3-27=<span class="string">&quot;:8443&quot;</span>; h3-28=<span class="string">&quot;:8443&quot;</span>; h3-29=<span class="string">&quot;:8443&quot;</span>; ma=86400; quic=<span class="string">&quot;:8443&quot;</span></span><br><span class="line"></span><br><span class="line">pong%                                                  </span><br></pre></td></tr></table></figure>
<h2 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h2><p>登录到 <code>https://hub.docker.com/</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  docker login</span><br></pre></td></tr></table></figure>
<p>上传到 docker hub<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  docker push weijiaxiang007/nginx-http3:v0.1</span><br></pre></td></tr></table></figure><br>在 docker hub 官网上可以找到自己上传上去的镜像。</p>
<p><img src="https://img1.kiosk007.top/static/images/docker/docker_hub.png"></p>
<p>大家如果想要获取我制作的 http3-nginx 镜像，可直接拉取<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push weijiaxiang007/nginx-http3:latest</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container prune  # 删除所有停止的容器</span><br><span class="line">docker image prune -a   # 删除没有用到的镜像</span><br></pre></td></tr></table></figure>
<h1 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h1><h2 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h2><p>Minikube是由Kubernetes社区维护的单机版的Kubernetes集群。并支持Kubernetes的大部分功能，从基础的容器编排管理，到高级特性如负载均衡、Ingress，权限控制等。</p>
<p>安装 minikube ，可参考官方文档 <a href="https://minikube.sigs.k8s.io/docs/start/">minikube start</a>, 另外还需要安装 kubectl 另外做一些配置（如关掉 swap ），具体可参考我之前的<a href="https://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/#%E5%AE%89%E8%A3%85k8s-master">文章</a> 。</p>
<p>minikube 中安装 cni 是有版本依赖，老旧版本没有 —cni 选项，新版本可以支持<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  minikube version</span><br><span class="line">minikube version: v1.22.0</span><br><span class="line">commit: a03fbcf166e6f74ef224d4a63be4277d017bb62e</span><br></pre></td></tr></table></figure><br>cni 插件安装：</p>
<p>flannel 服务在安装运行过程中依赖二进制文件 /opt/cni/bin/portmap ，没有会报错</p>
<p>安装 cni 后会在对应目录生成二进制文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  sudo apt install kubernetes-cni -y</span><br></pre></td></tr></table></figure>
<p>启动 minikube 集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  minikube start --cni=flannel</span><br></pre></td></tr></table></figure>
<p>安装完成后, 查看状态 <code>minikube status</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  minikube status</span><br><span class="line">minikube</span><br><span class="line"><span class="built_in">type</span>: Control Plane</span><br><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line">apiserver: Running</span><br><span class="line">kubeconfig: Configured</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用minikube</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o wide <span class="comment">## 可以查看到有了一个单节点的集群，IP地址</span></span><br><span class="line">kubectl get pods -o wide  <span class="comment">## 可以看到创建的pods，当然现在是空的</span></span><br><span class="line">kubectl cluster-info      <span class="comment">## 查看集群Master信息</span></span><br><span class="line">kubectl get all --namespace=kube-system	<span class="comment">## 查看部署组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##现在我们ssh到我们的master节点</span></span><br><span class="line">ssh -i ~/.minikube/machines/minikube/id_rsa docker@$(minikube ip)</span><br><span class="line"><span class="comment">## 也可以直接执行 minikube ssh</span></span><br></pre></td></tr></table></figure>
<ul>
<li>minikube 网络控制台</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure>
<p>dashboard 是 kubernetes 的一个web UI，提供了友好的图形化界面，和对集群交互的基本操作功能。</p>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><strong>议题</strong></p>
<ol>
<li>K8S集群中为什么需要负载均衡器</li>
<li>在K8S集群的边缘节点运行Nginx</li>
<li>Nginx如何发现K8S中的服务</li>
<li>K8S中的Ingress</li>
</ol>
<p><strong>基础概念介绍：</strong></p>
<ul>
<li><strong>K8S Deployments 介绍</strong></li>
</ul>
<p>为了实现在Kubernetes集群上部署容器化应用程序。需要创建一个Kubernetes Deployment，Deployment负责创建和更新应用。</p>
<p>典型的应用场景包括：</p>
<blockquote>
<p>a. 定义Deployment来创建Pod和ReplicaSet<br>b. 滚动升级和回滚应用<br>c. 扩容和缩容<br>d. 暂停和继续Deployment</p>
</blockquote>
<p>参考：<a href="https://www.kubernetes.org.cn/deployment">https://www.kubernetes.org.cn/deployment</a></p>
<ul>
<li><strong>K8S Service 介绍</strong></li>
</ul>
<p>Kubernetes Service 定义了这样一种抽象：一个 Pod 的逻辑分组，也就是为一组Pod提供统一的访问方式。通常 Pod 通过 Label Selector 实现的与 Service 绑定。</p>
<p>一个 Service 在 Kubernetes 中是一个 REST 对象，和 Pod 类似。 像所有的 REST 对象一样， Service 定义可以基于 POST 方式，请求 apiserver 创建新的实例。 例如，假定有一组 Pod，它们对外暴露了 9376 端口，同时还被打上 “app=MyApp” 标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: MyApp</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br></pre></td></tr></table></figure>
<p>参考: <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a></p>
<h2 id="如何获取K8S集群中的服务"><a href="#如何获取K8S集群中的服务" class="headerlink" title="如何获取K8S集群中的服务?"></a>如何获取K8S集群中的服务?</h2><p>一般来说暴露服务的三种方式</p>
<ul>
<li><p><strong><span class="inline-tag blue">NodePort</span></strong>: 将服务的类型设置成NodePort-每个集群节点都会在节点上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。该服务仅在内部集群 IP 和端口上才可访间， 但也可通过所有节点上的专用端口访问。<strong>缺点是端口一般是奇怪的端口且端口肯定面临不够用的境地</strong></p>
</li>
<li><p><strong><span class="inline-tag blue">LoadBalane</span></strong>: 将服务的类型设置成LoadBalance, NodePort类型的一 种扩展，这使得服务可以通过一个专用的负载均衡器来访问， 这是由Kubernetes中正在运行的云基础设施提供的。 负载均衡器将流量重定向到跨所有节点的节点端口。客户端通过负载均衡器的 IP 连接到服务。<strong>缺点是只是云厂商才能玩得起的（他们有路由器、有SDN）</strong></p>
</li>
<li><p><strong><span class="inline-tag blue">Ingress</span></strong>: 创建一个Ingress资源， 这是一个完全不同的机制， 通过一个IP地址公开多个服务，就是一个网关入口。通过域名即可访问。<strong>推荐！！</strong></p>
</li>
</ul>
<blockquote>
<p>虽然推荐 Ingress 的形式，但是也会先以 Headless Service 的方式搭建一个Nginx集群。</p>
</blockquote>
<p><strong>为何获取K8S中的服务是比较困难的？</strong></p>
<ul>
<li>每一个pod都有一个由网络层提供的私有地址，在K8S集群中的任一节点上可以可达。K8S集群外部不能直接访问。</li>
<li>一组相同功能的pod构成service，K8S赋予每个Service一个cluster IP地址。Service可以从cluster IP地址访问。</li>
<li>Cluster IP地址只在K8S集群内有效，不能从外部直接访问。</li>
</ul>
<p><strong>外部应用如何才能访问K8S中的service?</strong></p>
<ul>
<li>K8S集群中要有一个或者多个public IP边缘节点</li>
<li>外部要访问K8S集群内的Service必须通过边缘节点的public IP地址进行访问</li>
<li>有public IP地址的边缘节点需要部署如Nginx，HAProxy等反向代理将请求转发给K8S中的service</li>
</ul>
<p>参考上图也就是边缘节点（Node）需要部署一台Nginx，Nginx有一个 public ip，用来访问k8s中的 service。那么Nginx的部署方式就有了2种。一种是部署在 K8S 集群内，一种是部署在K8S集群外。</p>
<p><img src="https://img1.kiosk007.top/static/images/k8s/k8s_nginx_deploy.png
"></p>
<p>2种方案有各自的优缺点。</p>
<ol>
<li><p>Nginx 部署在K8S 外需要在Nginx的配置文件中指定nameserver；另外Nginx本身需要自己手动维护。</p>
</li>
<li><p>Nginx 部署在K8S 内则在Nginx的配置文件中不用指定nameserver，nameserver已由K8S配置好；K8S管理Nginx的启停；Nginx监听端口要映射到host的端口上或者使用host网络(hostNetwork:true)。</p>
</li>
</ol>
<blockquote>
<p>所以还是推荐使用部署在K8S内的方式。</p>
</blockquote>
<p> <strong>通过NodePort发现服务</strong></p>
<p>在k8s上可以给Service设置成NodePort类型，这样的话可以让Kubernetes在其所有节点上开放一个端口给外部访问（所有节点上都使用相同的端口号）， 并将传入的连接转发给作为Service服务对象的pod。这样我们的pod就可以被外部请求访问到。至于服务都在哪些节点上，就需要动态更新Nginx的配置文件了（ngx_dynamic_upstream）</p>
<p><img src="https://img1.kiosk007.top/static/images/k8s/service_nodeport_1.png"></p>
<p>Nginx 配置如下<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> my_services &#123;</span><br><span class="line">  <span class="attribute">zone</span> my_zone <span class="number">1m</span>;   <span class="comment"># my_zone 提供有service pod 的节点的 node ip</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">location</span> / &#123;  </span><br><span class="line">    proxy_passhttp://my_services;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不过问题还是因为端口有限，暴露的服务也是有限的。</p>
<p><strong>通过Headless service发现服务(推荐）</strong></p>
<p>Service 是 Kubernetes 项目中用来将一组 Pod 暴露给外界访问的一种机制，如果不是 VIP 的方式访问，那么即是以 DNS 的方式访问，DNS访问又分两种，第一种，DNS的解析是VIP，那后面的访问形式和上述无异，另一种是DNS解析到POD上。</p>
<p>这就是 <strong>Headless Service</strong>，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。</p>
<p>这样的话Nginx需支持upstream动态后端服务器地址注册(nginx-upstream-dynamic-servers）</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> my_services&#123;</span><br><span class="line">   <span class="attribute">server</span> my_services:<span class="number">8080</span> resolve;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">location</span> / &#123;</span><br><span class="line">      proxy_passhttp://my_services;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在K8S中发布hello 服务配置nginx:</span></span><br></pre></td></tr></table></figure>
<p>Nginx 可以部署在一个有外网ip（集群外部可访问ip）上。具体可以给Nginx的编排配置上加 <code>Label Selector</code></p>
<p>当然，我们当前是Minikube单机模式，如果是正式的K8S环境，可以执行以下命令加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectllabel node node3 node-type=edge</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考 <a href="https://www.cnblogs.com/wzs5800/p/13534942.html">deployment 模板</a></p>
</blockquote>
<h2 id="配置-minikube"><a href="#配置-minikube" class="headerlink" title="配置 minikube"></a>配置 minikube</h2><p>minikube 和 标准的 k8s 还是有很多不一样。这里有很多坑其实我还没有踩明白。</p>
<p>搭建访问tunnel ip<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  minikube tunnel</span><br><span class="line"></span><br><span class="line">Status:	</span><br><span class="line">	machine: minikube</span><br><span class="line">	pid: 1158570</span><br><span class="line">	route: 10.96.0.0/12 -&gt; 192.168.49.2</span><br><span class="line">	minikube: Running</span><br><span class="line">	services: []</span><br><span class="line">    errors: </span><br><span class="line">		minikube: no errors</span><br><span class="line">		router: no errors</span><br><span class="line">		loadbalancer emulator: no errors</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>挂载宿主机目录</p>
<p class="div-border red">minikube 需要额外执行这一步，才能将宿主机的目录挂载到Pod中的容器中 </p>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minikube mount /home/weijiaxiang/Project/Nginx/nginx:/host</span><br></pre></td></tr></table></figure>
<h2 id="配置-k8s"><a href="#配置-k8s" class="headerlink" title="配置 k8s"></a>配置 k8s</h2><p>可参考： <a href="https://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/">ubuntu20.04 部署 Kubernetes (k8s)</a></p>
<h2 id="Nginx-depolyment"><a href="#Nginx-depolyment" class="headerlink" title="Nginx depolyment"></a>Nginx depolyment</h2><p>新建文件: <code>nginx_http3-deployment.yaml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-http3-deployment</span><br><span class="line">  namespace: default    #必填，Pod所属的命名空间</span><br><span class="line">  labels:               #自定义标签</span><br><span class="line">    app: nginx        #自定义标签名字&lt;key: value&gt;</span><br><span class="line">  annotations:          #自定义注释列表</span><br><span class="line">    imageregistry: &quot;https:&#x2F;&#x2F;hub.docker.com&#x2F;&quot;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-http3  # 必填，通过此标签匹配对应pod</span><br><span class="line">  replicas: 1           # 副本集个数</span><br><span class="line">  template:             # 必填，应用容器模版定义</span><br><span class="line">    metadata:</span><br><span class="line">      labels:           # 必填，遇上面matchLabels的标签相同</span><br><span class="line">        app: nginx-http3</span><br><span class="line">    spec:</span><br><span class="line">      hostIPC: true  </span><br><span class="line">      hostNetwork: true   # 使用主机网络</span><br><span class="line">      #Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Never表示不再重启该Pod</span><br><span class="line">      restartPolicy: Always   </span><br><span class="line">      shareProcessNamespace: true  # Pod 里的容器共享 PID Namespace</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: weijiaxiang007&#x2F;nginx-http3:v0.2</span><br><span class="line">        imagePullPolicy: IfNotPresent   # [Always | Never | IfNotPresent] 获取镜像的策略 Alawys表示下载镜像;IfnotPresent表示优先使用本地镜像，否则下载镜像;Nerver表示仅使用本地镜像</span><br><span class="line">        workingDir: &quot;&#x2F;nginx&#x2F;&quot;            # 选填，容器的工作目录</span><br><span class="line">        volumeMounts:                   # 挂载到容器内部的存储卷配置</span><br><span class="line">        - mountPath: &quot;&#x2F;nginx&#x2F;&quot;</span><br><span class="line">          name: nginx-vol               # 引用pod定义的共享存储卷的名称</span><br><span class="line">        livenessProbe:                  # 对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket</span><br><span class="line">          httpGet:       </span><br><span class="line">            path: &#x2F;_check_domain_health      </span><br><span class="line">            port: 80</span><br><span class="line">            scheme: HTTP       </span><br><span class="line">          initialDelaySeconds: 30       # 容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">          periodSeconds: 1200             # 对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">          timeoutSeconds: 1            # 对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 50m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 500Mi</span><br><span class="line">        env:</span><br><span class="line">          - name: NGINX_VERSION</span><br><span class="line">            value: &quot;1.21.0&quot;</span><br><span class="line">          - name: RUN_DEV</span><br><span class="line">            value: &quot;boe&quot;</span><br><span class="line">      - name: shell</span><br><span class="line">        image: ubuntu    </span><br><span class="line">        stdin: true    </span><br><span class="line">        tty: true</span><br><span class="line">        workingDir: &quot;&#x2F;nginx&#x2F;&quot;            # 选填，容器的工作目录</span><br><span class="line">        command: [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;sleep 100000000&quot;]</span><br><span class="line">        volumeMounts:                   # 挂载到容器内部的存储卷配置</span><br><span class="line">          - mountPath: &quot;&#x2F;nginx&#x2F;&quot;</span><br><span class="line">            name: nginx-vol               # 引用pod定义的共享存储卷的名称</span><br><span class="line">        lifecycle:      </span><br><span class="line">          postStart:        </span><br><span class="line">            exec:          </span><br><span class="line">              command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo Nginx HTTP3 Server Start from the postStart handler &gt; &#x2F;usr&#x2F;share&#x2F;message&quot;]      </span><br><span class="line">          preStop:        </span><br><span class="line">            exec:          </span><br><span class="line">              command: [&quot;&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]</span><br><span class="line">      volumes:                # 在该pod上定义共享存储卷列表</span><br><span class="line">      - name: nginx-vol       # 共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;host</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建 deployment<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx_http3-deployment.yaml</span><br></pre></td></tr></table></figure><br>查看 deployment 状态<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ kubectl get pods</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-http3-deployment-7cf4c654b5-6km4p   2/2     Running   0          31m</span><br><span class="line">➜  ~ kubectl get deployment</span><br><span class="line">NAME                     READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-http3-deployment   1/1     1            1           32m</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>验证<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  curl https:&#x2F;&#x2F;webtransport.kiosk007.top:443&#x2F;ping --resolve webtransport.kiosk007.top:443:192.168.49.2</span><br><span class="line">pong</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>尝试 Nginx 上使用HTTP3</title>
    <url>/2021/07/31/%E5%B0%9D%E8%AF%95-Nginx-%E4%B8%8A%E4%BD%BF%E7%94%A8HTTP3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前的文章介绍了<a href="https://kiosk007.top/2021/07/24/QUIC-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">QUIC发生了什么</a>, QUIC 已经演变成了一个“传输层”协议。其上可以运行 HTTP 协议。</p>
<a id="more"></a>
<p>在去年6月，Nginx的官方博客发表了<a href="https://www.nginx.com/blog/introducing-technology-preview-nginx-support-for-quic-http-3/">一篇对 HTTP3 技术的支持概览</a>。Nginx 官方宣布了 <code>http_v3_module</code> 的最初版本。但这只是一个技术概览，并不建议就应用到生产环境上。关于HTTP3的支持目前还没有正式合入主线分支。是在 <a href="https://hg.nginx.org/nginx-quic?_ga=2.233412253.2051667104.1627697657-1009067521.1605942879">https://hg.nginx.org/nginx-quic</a> 这个专门的分支上。</p>
<p>今年7月，Nginx又发了<a href="https://www.nginx.com/blog/our-roadmap-quic-http-3-support-nginx/">一篇博客</a>，明确表示，Nginx QUIC 将于今年年底正式合入Nginx 主分支。</p>
<p>另外 QUIC+HTTP/3 的Nginx官方实现是和 CloudFlare 的 <a href="https://blog.cloudflare.com/experiment-with-http-3-using-nginx-and-quiche/">quiche project</a> 并不是一个。</p>
<h1 id="Nginx-QUIC-支持"><a href="#Nginx-QUIC-支持" class="headerlink" title="Nginx QUIC 支持"></a>Nginx QUIC 支持</h1><p>本文是21年7月，这个时候QUIC的第一个正式版本 RFC9000 已经正式面世2个月了，Nginx当然也对其进行了良好的支持。</p>
<p>当然这些都是实验性的。更多可参考 <a href="https://quic.nginx.org/readme.html">https://quic.nginx.org/readme.html</a></p>
<p>由于Nginx当前对QUIC的支持仍尚处于实验阶段。仍存在一些QUIC特性的不支持。 (1.21.x)</p>
<p>比如以下功能在Nginx-QUIC的当前版本中尚不支持。</p>
<ol>
<li>QUIC 的显示拥塞通知（ECN)</li>
<li>结构化日志</li>
<li>HTTP/3 trailers</li>
</ol>
<p>不过QUIC的<a href="https://hg.nginx.org/nginx-quic?_ga=2.221821851.2051667104.1627697657-1009067521.1605942879">相关提交</a>也是在不断的完善当中</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装环境</p>
<ul>
<li>操作系统：Ubuntu 20.04.1 LTS</li>
<li>内核版本：5.4.0-77-generic</li>
</ul>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>我们必须安装mercurial，mercurial 是一个免费的分布式源代码管理工具。Nginx 的源码正是用 mercurial 管理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mercurial</span><br></pre></td></tr></table></figure>
<p>从 <a href="https://hg.nginx.org/nginx-quic">https://hg.nginx.org/nginx-quic</a>. 下载nginx的代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line">hg <span class="built_in">clone</span> -b quic https://hg.nginx.org/nginx-quic</span><br></pre></td></tr></table></figure>
<h3 id="安装-BoringSSL"><a href="#安装-BoringSSL" class="headerlink" title="安装 BoringSSL"></a>安装 BoringSSL</h3><p>QUIC 默认使用的是Boring SSL 来作为QUIC的 SSL 模块。它是来自Google的OpenSSL的分支，添加了quic支持。</p>
<p>但首先，必须安装这些依赖项来编译BoringSSL。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install golang</span><br><span class="line">sudo apt-get install libunwind-dev</span><br></pre></td></tr></table></figure>
<p>拉取 Boring SSL 的代码。注意这个仓库很大，有250M 左右。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/google/boringssl</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> boringssl/</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ../</span><br><span class="line">make -j 16</span><br></pre></td></tr></table></figure>
<h2 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h2><h3 id="Pagespeed"><a href="#Pagespeed" class="headerlink" title="Pagespeed"></a>Pagespeed</h3><p>ngx_pagespeed 是Google 推出的一个 Nginx 的扩展模块，可以加速网站，减少页面加载时间，自动将一些提升web性能的实践应用到网页和相关的资源（CSS、JS和图片）上，无需修改内容和流程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir module</span><br><span class="line"><span class="built_in">cd</span> module</span><br><span class="line">wget https://github.com/apache/incubator-pagespeed-ngx/archive/v1.13.35.2-stable.zip</span><br><span class="line">unzip v1.13.35.2-stable.zip</span><br><span class="line">mv incubator-pagespeed-ngx-1.13.35.2-stable ngx_pagespeed</span><br></pre></td></tr></table></figure>
<p>然后在ngx_pagespeed文件夹中，我们必须添加pagespeed的库PSOL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ngx_pagespeed</span><br><span class="line">sudo wget https://dl.google.com/dl/page-speed/psol/1.13.35.2-x64.tar.gz</span><br><span class="line">sudo tar -xzvf 1.13.35.2-x64.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="Brotli"><a href="#Brotli" class="headerlink" title="Brotli"></a>Brotli</h3><p>Brotli是一种全新的数据格式，可以提供比Zopfli高20-26%的压缩比。据谷歌研究，Brotli压缩速度同zlib的Deflate实现大致相同，而在Canterbury语料库上的压缩密度比LZMA和bzip2略大。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd module</span><br><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;ngx_brotli</span><br></pre></td></tr></table></figure>
<h3 id="gperftool"><a href="#gperftool" class="headerlink" title="gperftool"></a>gperftool</h3><p>gperftools是Google开源的一款非常使用的性能分析工具集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y google-perftools libgoogle-perftools-dev libgoogle-perftools4</span><br></pre></td></tr></table></figure>
<h3 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h3><p>ngx_lua是Nginx的一个模块，将Lua嵌入到Nginx中，从而可以使用Lua来编写脚本，这样就可以使用Lua编写应用脚本，部署到Nginx中运行，即Nginx变成了一个Web容器；这样开发人员就可以使用Lua语言开发高性能Web应用了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module.git</span><br><span class="line">$ wget http:&#x2F;&#x2F;luajit.org&#x2F;download&#x2F;LuaJIT-2.0.5.tar.gz</span><br><span class="line">$ tar -zxvf  LuaJIT-2.0.5.tar.gz</span><br><span class="line">$ cd LuaJIT-2.0.5</span><br><span class="line">$ make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;luajit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装成功最后一行输出会提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D; Successfully installed LuaJIT 2.0.5 to &#x2F;usr&#x2F;local&#x2F;LuaJIT &#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile.d/lua.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LUAJIT_LIB=/usr/<span class="built_in">local</span>/luajit/lib</span><br><span class="line"><span class="built_in">export</span> LUAJIT_INC=/usr/<span class="built_in">local</span>/luajit/include/luajit-2.0</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/lib/:<span class="variable">$LUAJIT_LIB</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>目前lua-nginx-module的最新release版本是v0.10.19，使用该版本在测试过程中遇到报错如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx: [alert] failed to load the <span class="string">&#x27;resty.core&#x27;</span> module (https://github.com/openresty/lua-resty-core); ensure you are using an OpenResty release from https://openresty.org/en/download.html (reason: module <span class="string">&#x27;resty.core&#x27;</span> not found:</span><br><span class="line">	no field package.preload[<span class="string">&#x27;resty.core&#x27;</span>]</span><br><span class="line">	no file <span class="string">&#x27;./resty/core.lua&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;/usr/local/share/luajit-2.1.0-beta3/resty/core.lua&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;/usr/local/share/lua/5.1/resty/core.lua&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;/usr/local/share/lua/5.1/resty/core/init.lua&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;./resty/core.so&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;/usr/local/lib/lua/5.1/resty/core.so&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;/usr/local/lib/lua/5.1/loadall.so&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;./resty.so&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;/usr/local/lib/lua/5.1/resty.so&#x27;</span></span><br><span class="line">	no file <span class="string">&#x27;/usr/local/lib/lua/5.1/loadall.so&#x27;</span>) <span class="keyword">in</span> /usr/<span class="built_in">local</span>/src/nginx/conf/nginx.conf:117</span><br></pre></td></tr></table></figure>
<p>在下面的链接中找到了答案，使用v0.10.14版本即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/openresty/lua-resty-core/issues/248</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="编写编译脚本"><a href="#编写编译脚本" class="headerlink" title="编写编译脚本"></a>编写编译脚本</h2><p>以下的编译脚本包含了很多其他Nginx模块，实际安装时可以按需安装。创建一个 <code>build.sh</code><br> 脚本文件。填写以下内容。（模块可按需添加）</p>
<p class="div-border green">Lua 模块安装可参考<a src="https://www.cnblogs.com/52fhy/p/10164553.html">该文</a> ，因为我之前安装过，所以很多依赖没有在本文中体现</p>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># set -x</span><br><span class="line"># set -e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.&#x2F;auto&#x2F;configure \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_cache_purge \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_devel_kit \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_brotli \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;nginx-rtmp-module \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_devel_kit \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;echo-nginx-module \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;headers-more-nginx-module \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;lua-nginx-module \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_pagespeed \</span><br><span class="line">--with-ld-opt&#x3D;-Wl,-rpath,&#x2F;usr&#x2F;local&#x2F;luajit&#x2F;lib  \</span><br><span class="line">--with-cc-opt&#x3D;&quot;-I..&#x2F;boringssl&#x2F;include&quot; --with-ld-opt&#x3D;&quot;-L..&#x2F;boringssl&#x2F;build&#x2F;ssl -L..&#x2F;boringssl&#x2F;build&#x2F;crypto&quot; \</span><br><span class="line">--with-file-aio \</span><br><span class="line">--with-http_flv_module \</span><br><span class="line">--with-http_gunzip_module \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_v2_module \</span><br><span class="line">--with-http_realip_module \</span><br><span class="line">--with-http_addition_module \</span><br><span class="line">--without-mail_pop3_module \</span><br><span class="line">--without-mail_imap_module \</span><br><span class="line">--without-mail_smtp_module \</span><br><span class="line">--with-http_sub_module \</span><br><span class="line">--with-http_auth_request_module \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-google_perftools_module \</span><br><span class="line">--with-http_secure_link_module \</span><br><span class="line">--with-http_mp4_module \</span><br><span class="line">--with-stream \</span><br><span class="line">--with-http_v3_module</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash build.sh</span><br><span class="line">make -j 16</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译产物在 objs 目录中，将 nginx 二进制可执行文件copy到指定 <code>/usr/local/sbin</code> 下。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>提供基础的配置文件如下。配置文件可按实际情况进行调整。需要使用<code>add_header alt svc</code>来确保web浏览器知道服务器支持http/3。</p>
<ul>
<li>由于HTTP/3需要使用udp协议端口，请注意开放对应的防火墙</li>
<li>http2监听的是443的tcp端口，而http3监听的是udp端口</li>
<li>nginx中添加了$http3和$quic变量，可以添加到日志中，这样就可以看到是否使用了HTTP/3来进行访问了</li>
<li>如果有多个server_name，在不指定IP的情况下，只需要在任意一个配置了listen 443 http3 quic reuseport;那么其他所有server_name都会开启HTTP3，并且不需要再添加该配置否则会报错（不知道后续会不会把报错去掉），如果需要部分server_name开启HTTP/3，请指定监听IP。</li>
</ul>
<p>http3增加了<code>http3_max_table_capacity</code>、<code>http3_max_blocked_streams</code>、<code>http3_max_concurrent_pushes</code>、 <code>http3_push</code>、<code>http3_push_preload</code>这六个变量来控制http3的性能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 443 http3 quic reuseport;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    server_name kiosk007.top;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 该选项用于开启address validation，但是会和0-RTT冲突</span></span><br><span class="line">    <span class="comment"># quic_retry on;</span></span><br><span class="line">    ssl_early_data on;</span><br><span class="line"></span><br><span class="line">    http3_max_field_size 5000;</span><br><span class="line">    http3_max_table_capacity 50;</span><br><span class="line">    http3_max_blocked_streams 30;</span><br><span class="line">    http3_max_concurrent_pushes 30;</span><br><span class="line">    http3_push 10;</span><br><span class="line">    http3_push_preload on;</span><br><span class="line"></span><br><span class="line">    add_header Alt-Svc <span class="string">&#x27;h3=&quot;:8443&quot;; ma=86400&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/kiosk007.top/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/kiosk007.top/privkey.pem;</span><br><span class="line">    include /etc/letsencrypt/options-ssl-nginx.conf;</span><br><span class="line">    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    location /ping &#123;</span><br><span class="line">            default_type text/html;</span><br><span class="line">            <span class="built_in">return</span> 200 <span class="string">&quot;pong&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p class="div-border red"> 本地测试的时候不要开 quic_retry on; (路径验证) 。否则连不上 </p>

<p>目前的主流浏览器Firefox和Chrome都支持了HTTP/3协议。</p>
<ul>
<li>Chrome</li>
</ul>
<p>nginx 的官网提示说Chrome需要83+版本才支持HTTP/3，实测在部分网站（如google.com）确实可以使用HTTP/3的某些草案版本，但是Chrome目前来说默认还是不支持h3-27协议，我们需要手动开启。对于Linux系统而言，我们使用命令行+指定参数的方式开启h3-27的支持：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;google-chrome-stable --enable-quic --quic-version&#x3D;h3-27 --origin-to-force-quic-on&#x3D;webtransport.kiosk007.top:443</span><br></pre></td></tr></table></figure></p>
<p>还可以如下网站去验证测试。</p>
<ul>
<li><a href="https://www.http3check.net/">https://www.http3check.net/</a></li>
<li><a href="https://gf.dev/http3-test">https://gf.dev/http3-test</a></li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_http3_check.png"></p>
]]></content>
      <categories>
        <category>QUIC</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark解析器Lua脚本</title>
    <url>/2021/07/10/Wireshark%E8%A7%A3%E6%9E%90%E5%99%A8Lua%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Wireshark集成了Lua解释器，以支持Lua脚本（自己编译的话根据编译配置决定是否支持Lua）。</p>
<p>启动wireshark，依次点击“Help”，”About Wireshark“菜单，在打开的对话框中的”Wireshark”标签页上观察版本信息，如果如下图一样显示With Lua，说明此版本支持Lua插件。</p>
<p>然后打开wireshark主目录下的init.lua文件，确保disable_lua的值为false，即开启了lua：</p>
<a id="more"></a>
<p><img src="https://img1.kiosk007.top/static/images/wireshark/R-C.jpeg" style="height:400px"></p>
<p>因实际工作中需要对一种非官方的自研协议进行解析，每次可能需要对传输的内容进行对比，为了方便需要利用wireshark工具进行分析。恰好，Wireshark 可以利用其暴露的 <a href="https://wiki.wireshark.org/Lua">Lua API</a> 对抓包数据进行分析。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>Lua是一种轻量级的脚本语言，解释执行，不需要编译器之类的。基本语法可参考 <a href="https://www.w3cschool.cn/lua/lua-tutorial.html">Lua W3CSchool</a></p>
<p>Wireshark内置了对Lua脚本的支持，可以直接编写Lua脚本，无需配置额外的环境。使用起来方便。<br> <a href="https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html">Wireshark Developer’s Guide</a>里的第10章和第11章都是关于Lua支持的文档。</p>
<p>使用Lua编写Wireshark协议解析插件，有几个比较重要的概念:</p>
<ul>
<li><code>Dissector</code>: 中文直译是解剖器，就是用来解析包的类，为了解析一个新协议，我们需要编写的也是一个Dissector。</li>
<li><code>DissectorTable</code>: 解析器表是Wireshark中解析器的组织形式，是某一种协议的子解析器的一个列表，其作用是把所有的解析器组织成一种树状结构，便于Wireshark在解析包的时候自动选择对应的解析器。例如TCP协议的子解析器 http, smtp, sip等都被加在了”tcp.port”这个解析器表中，可以根据抓到的包的不同的tcp端口号，自动选择对应的解析器。</li>
</ul>
<p>Wireshark是用C编写的，Wireshark的剖析器通常也是用C编写的。然而，Wireshark有一个Lua实现，这使得不熟悉C的人很容易编写剖析器。对于那些不熟悉Lua的人来说，它是一种非常轻量级的编程语言，旨在作为脚本语言在应用程序中实现，以扩展其功能。</p>
<h2 id="Wireshark-支持"><a href="#Wireshark-支持" class="headerlink" title="Wireshark 支持"></a>Wireshark 支持</h2><p>Wireshark 天然对 Lua 有良好的支持性，且Lua在Wireshark中可以做的事情也有很多，详见<a href="https://wiki.wireshark.org/Lua/Examples">Wireshark Lua Example</a></p>
<p>网上的教程是点击 Help –&gt; About Wireshark –&gt; Folders，查找 Wireshark 的lua脚本存放目录。</p>
<p>但是实际上我找到的敌方有些不同，不过亲测有效。该目录下有一个 <code>init.lua</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux </span></span><br><span class="line">/usr/share/wireshark</span><br><span class="line"><span class="comment"># Mac</span></span><br><span class="line">/Applications/Wireshark.app/Contents/Resources/share/wireshark</span><br></pre></td></tr></table></figure><br>将<code>init.lua</code> 文件末加上， <code>dofile(DATA_DIR..&quot;your_lua_script&quot;)</code></p>
<p><img src="https://img1.kiosk007.top/static/images/wireshark/init_lua.png"></p>
<p>当 Wireshark 启动时，该脚本将处于激活状态。当脚本修改后，必须重启 Wireshark， 或者按 <code>Ctrl+Shift+L</code> （Mac 下<code>Shift+Command+L</code>） 重载 Lua 脚本。</p>
<h1 id="Lua-API"><a href="#Lua-API" class="headerlink" title="Lua API"></a>Lua API</h1><p>在 Lua API 之前先看一个Lua 解析脚本的示例。参考 <a href="https://zhuanlan.zhihu.com/p/114669991">自己动手编写Wireshark Lua插件解析自定义协议</a></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">--协议名称为DT，在Packet Details窗格显示为Nselab.Zachary DT</span></span><br><span class="line">    <span class="keyword">local</span> p_DT = Proto(<span class="string">&quot;DT&quot;</span>,<span class="string">&quot;Nselab.Zachary DT&quot;</span>)</span><br><span class="line">    <span class="comment">--协议的各个字段</span></span><br><span class="line">    <span class="keyword">local</span> f_identifier = ProtoField.uint8(<span class="string">&quot;DT.identifier&quot;</span>,<span class="string">&quot;Identifier&quot;</span>, base.HEX)</span><br><span class="line">    <span class="comment">--这里的base是显示的时候的进制，详细可参考https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html#lua_class_ProtoField</span></span><br><span class="line">    <span class="keyword">local</span> f_speed = ProtoField.uint8(<span class="string">&quot;DT.speed&quot;</span>, <span class="string">&quot;Speed&quot;</span>, base.HEX)</span><br><span class="line"></span><br><span class="line">    <span class="comment">--这里把DT协议的全部字段都加到p_DT这个变量的fields字段里</span></span><br><span class="line">    p_DT.fields = &#123;f_identifier, f_speed&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--这里是获取data这个解析器</span></span><br><span class="line">    <span class="keyword">local</span> data_dis = Dissector.get(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">DT_dissector</span><span class="params">(buf,pkt,root)</span></span></span><br><span class="line">        <span class="keyword">local</span> buf_len = buf:<span class="built_in">len</span>();</span><br><span class="line">        <span class="comment">--先检查报文长度，太短的不是我的协议</span></span><br><span class="line">        <span class="keyword">if</span> buf_len &lt; <span class="number">16</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">--验证一下identifier这个字段是不是0x12,如果不是的话，认为不是我要解析的packet</span></span><br><span class="line">        <span class="keyword">local</span> v_identifier = buf(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (v_identifier:uint() ~= <span class="number">0x12</span>)</span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">--取出其他字段的值</span></span><br><span class="line">        <span class="keyword">local</span> v_speed = buf(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">--现在知道是我的协议了，放心大胆添加Packet Details</span></span><br><span class="line">        <span class="keyword">local</span> t = root:add(p_DT,buf)</span><br><span class="line">        <span class="comment">--在Packet List窗格的Protocol列可以展示出协议的名称</span></span><br><span class="line">        pkt.cols.protocol = <span class="string">&quot;DT&quot;</span></span><br><span class="line">        <span class="comment">--这里是把对应的字段的值填写正确，只有t:add过的才会显示在Packet Details信息里. 所以在之前定义fields的时候要把所有可能出现的都写上，但是实际解析的时候，如果某些字段没出现，就不要在这里add</span></span><br><span class="line">        t:add(f_identifier,v_identifier)</span><br><span class="line">        t:add(f_speed,v_speed)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">--这段代码是目的Packet符合条件时，被Wireshark自动调用的，是p_DT的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">p_DT.dissector</span><span class="params">(buf,pkt,root)</span></span> </span><br><span class="line">        <span class="keyword">if</span> DT_dissector(buf,pkt,root) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">--valid DT diagram</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">--data这个dissector几乎是必不可少的；当发现不是我的协议时，就应该调用data</span></span><br><span class="line">            data_dis:call(buf,pkt,root)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">local</span> udp_encap_table = DissectorTable.get(<span class="string">&quot;udp.port&quot;</span>)</span><br><span class="line">    <span class="comment">--因为我们的DT协议的接受端口肯定是50002，所以这里只需要添加到&quot;udp.port&quot;这个DissectorTable里，并且指定值为50002即可。</span></span><br><span class="line">    udp_encap_table:add(<span class="number">50002</span>, p_DT)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如上图就是一个标准的协议解析流程。下面我们做一个详细的流程梳理。</p>
<h2 id="1-Proto"><a href="#1-Proto" class="headerlink" title="1. Proto"></a>1. Proto</h2><p>官方文档：<a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html#lua_class_Proto">11.6.5. Proto
</a>:</p>
<p>表示一个新的Protocol，在Wireshark中Protocol对象有很多用处，解析器是其中主要的一个。主要接口有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>proto:__call(name, desc)</td>
<td style="text-align:right">创建Proto对象。name和desc分别是对象的名称和描述，前者可用于过滤器等</td>
</tr>
<tr>
<td>Proto.new(name, desc)</td>
<td style="text-align:right">创建一个Proto对象</td>
</tr>
<tr>
<td>proto:register_heuristic(listname, func)</td>
<td style="text-align:right">创建一个启发式解析器（<a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/30/creating-port-independent-wireshark-dissectors-in-lua.html">启发式解析器</a>）</td>
</tr>
<tr>
<td>proto.dissector</td>
<td style="text-align:right">解析函数，3个参数tvb,pinfo,tree，分别是报文内容，报文信息和解析树结构</td>
</tr>
<tr>
<td>proto.prefs</td>
<td style="text-align:right">解析器的首选项</td>
</tr>
<tr>
<td>proto.init</td>
<td style="text-align:right">初始化</td>
</tr>
<tr>
<td>proto.name</td>
<td style="text-align:right">该解析器的名字</td>
</tr>
<tr>
<td>proto.description</td>
<td style="text-align:right">该解析器的描述</td>
</tr>
<tr>
<td>proto.fields</td>
<td style="text-align:right">该解析器的内容（返回 ProtoFeild 表）</td>
</tr>
<tr>
<td>proto.experts</td>
<td style="text-align:right">该解析器的专家信息</td>
</tr>
</tbody>
</table>
</div>
<p>举例：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> NAME = <span class="string">&quot;bvc_srt&quot;</span></span><br><span class="line"><span class="keyword">local</span> bvc_srt = Proto(NAME, <span class="string">&quot;BVC_SRT Protocol&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 bvc_srt 协议首选项</span></span><br><span class="line">srt_dev.prefs[<span class="string">&quot;srt_udp_port&quot;</span>] = Pref.uint(<span class="string">&quot;SRT UDP Port&quot;</span>, <span class="number">1935</span>, <span class="string">&quot;SRT UDP Port&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注册解析器, 将 bvc_srt 自定义协议挂载到 udp 1935 端口上 </span></span><br><span class="line">DissectorTable.get(<span class="string">&quot;udp.port&quot;</span>):add(<span class="number">1935</span>, bvc_srt)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 也可以直接调用下面函数，每个数据包都会用该 bvc_srt 去解析</span></span><br><span class="line"><span class="comment">-- register_postdissector(bvc_srt)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="2-ProtoField"><a href="#2-ProtoField" class="headerlink" title="2.ProtoField"></a>2.ProtoField</h2><p>表示协议字段，一般用于解析字段后往解析树上添加节点。根据字段类型不同，其接口可以分为两大类。</p>
<p>这些接口都会返回一个新的字段对象。方括号内是可选字段，花括号内是可替换的类型字段。</p>
<p>字段可以是 uin8\uin16\uin64\string\char 等等</p>
<p>如下所示：<br><code>ProtoField.uint8(abbr, [name], [base], [valuestring], [mask], [desc])</code></p>
<ul>
<li>abbr: 协议字段缩写，比如 <code>bvc_srt.time_stamp</code>、<code>http.port</code></li>
<li>name: 字段的实际名字，比如 <code>Time Stamp</code>、<code>HTTP Port</code></li>
<li>base: 展示的形式，比如时间戳、端口号 是一个int64的十进制数字就可以填 <code>base.DEC</code>,再或者魔术值是一个 16进制数，可以填 <code>base.HEX</code> , 或者是HTTP的Header是字符串，可以填 <code>base.STRING</code></li>
<li>valuestring: 与值对应的文本表，比如TCP的Flag有 9 位，每一位的对应关系就在这里体现。</li>
<li>mask: 掩码，与valuestring配合，主要解决的是TCP Flag 的那种情况。</li>
<li>desc: 描述</li>
</ul>
<p>举例：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fields.peer_ipaddr = ProtoField.ipv4(<span class="string">&quot;bvc_srt.peer_ipaddr&quot;</span>, <span class="string">&quot;Peer IP address&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加到树的时候要注意</span></span><br><span class="line"><span class="comment">-- 如果是网络序，要使用add_le，而不是add</span></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/proto_field.png"><br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> flag_select = &#123;[<span class="number">0</span>]=<span class="string">&quot;[Not Set]&quot;</span>,[<span class="number">1</span>]=<span class="string">&quot;[Set]&quot;</span>&#125;</span><br><span class="line">fields.tcp_flag_reserved = ProtoField.uint16(<span class="string">&quot;tcp.flag.reserved&quot;</span>, <span class="string">&quot;Reserved&quot;</span>, base.HEX, flag_select, <span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- TCP Flag 需要 3 字节，这样处理解析器即可, 0b00010000000 做掩码。</span></span><br><span class="line">data_flag_info_tree:add(fields.tcp_flag_reserved, tvb(offset, <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/proto_field_tcp.png"></p>
<h2 id="3-TVB"><a href="#3-TVB" class="headerlink" title="3.TVB"></a>3.TVB</h2><p>TVB 是 <code>proto.dissector(tvb, pinfo, treeitem)</code> 的第一个参数，我们将在 <code>proto.dissector</code> 函数里做我们的协议解析。</p>
<p><a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Tvb.html#lua_class_Tvb">Tvb（Testy Virtual Buffer）</a>表示报文缓存，也就是实际的报文数据，可以通过下面介绍的TvbRange从报文数据中解出信息。主要接口有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tvb:__tostring()</td>
<td style="text-align:right">将报文数据转化为字符串，可用于调试</td>
</tr>
<tr>
<td>tvb:reported_len()</td>
<td style="text-align:right">get tvb的(not captured)长度</td>
</tr>
<tr>
<td>tvb:len()</td>
<td style="text-align:right">get tvb的(captured)长度</td>
</tr>
<tr>
<td>tvb:reported_length_remaining()</td>
<td style="text-align:right">获取当前tvb的剩余长度，如果偏移值大于报文长度，则返回-1</td>
</tr>
<tr>
<td>tvb:offset()</td>
<td style="text-align:right">返回原始偏移</td>
</tr>
<tr>
<td>tvb:raw()</td>
<td style="text-align:right">获取tvb中二进制字节的Lua字符串</td>
</tr>
</tbody>
</table>
</div>
<p>用法举例：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- tvb(offset, 4)表示从offset开始之后的4个字节</span></span><br><span class="line">subtree:add_le(fields.peer_ipaddr, tvb(offset, <span class="number">4</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="4-TvbRange"><a href="#4-TvbRange" class="headerlink" title="4.TvbRange"></a>4.TvbRange</h2><p>表示Tvb的可用范围，常用来从Tvb中解出信息。主要接口有</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tvb:range([offset], [length])</td>
<td style="text-align:right">从tvb创建TvbRange，可选参数分别是偏移和长度，默认值分别是0和总长度</td>
</tr>
<tr>
<td>tvbrange:{type}()</td>
<td style="text-align:right">将tvbrange所表示范围内的数据转换成type类型的值，type包括但不限于：uint,uint64,int,int64,float,ipv4,ether,nstime,string,ustring,bytes,bitfield等，其中某些类型的方法可以带一些参数</td>
</tr>
</tbody>
</table>
</div>
<p>很少在实际使用中用到，大多数会取整个 tvb 进行运算位移。</p>
<h2 id="5-ByteArray"><a href="#5-ByteArray" class="headerlink" title="5. ByteArray"></a>5. ByteArray</h2><p>字节数组，可与Tvb互相转换。另外字符串也可以换成 <a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Tvb.html#lua_class_ByteArray">ByteArray</a> ，进而换成 Tvb。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArray.new([hexbytes], [separator])</td>
<td style="text-align:right">创建一个新 ByteArray 对象</td>
</tr>
<tr>
<td>bytearray:__concat(first, second)</td>
<td style="text-align:right">连接两个 ByteArray</td>
</tr>
<tr>
<td>bytearray:append(appended)</td>
<td style="text-align:right">将 ByteArray 追加到此 ByteArray</td>
</tr>
<tr>
<td>bytearray:len()</td>
<td style="text-align:right">获取 ByteArray 的长度</td>
</tr>
<tr>
<td>bytearray:subset(offset, length)</td>
<td style="text-align:right">获取 ByteArray 的一段，作为新的 ByteArray</td>
</tr>
<tr>
<td>bytearray:base64_decode()</td>
<td style="text-align:right">获取 Base64 解码的 ByteArray</td>
</tr>
<tr>
<td>bytearray:__tostring()</td>
<td style="text-align:right">获取包含 ByteArray 中的字节的 Lua 字符串，以便可以在显示过滤器中使用它 (例如 “01FE456789AB”)</td>
</tr>
<tr>
<td>bytearray:tvb(name)</td>
<td style="text-align:right">ByteArray 转Tvb</td>
</tr>
<tr>
<td>bytearray:raw([offset], [length])</td>
<td style="text-align:right">获取 ByteArray 中的二进制字节的 Lua 字符串</td>
</tr>
</tbody>
</table>
</div>
<p>用法举例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proto_foo.dissector</span><span class="params">(buf, pinfo, tree)</span></span></span><br><span class="line">            <span class="comment">-- Create a new tab named &quot;My Tvb&quot; and add some data to it</span></span><br><span class="line">            <span class="keyword">local</span> b = ByteArray.new(<span class="string">&quot;11223344&quot;</span>)</span><br><span class="line">            <span class="keyword">local</span> tvb = ByteArray.tvb(b, <span class="string">&quot;My Tvb&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- Create a tree item that, when clicked, automatically shows the tab we just created</span></span><br><span class="line">            tree:add( tvb(<span class="number">1</span>,<span class="number">2</span>), <span class="string">&quot;Foo&quot;</span> )</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="6-Pinfo"><a href="#6-Pinfo" class="headerlink" title="6. Pinfo"></a>6. Pinfo</h2><p>报文信息(packet information)。主要接口有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pinfo.len pinfo.caplen</td>
<td style="text-align:right">get报文长度</td>
</tr>
<tr>
<td>pinfo.abs_ts</td>
<td style="text-align:right">get报文捕获时间</td>
</tr>
<tr>
<td>pinfo.number</td>
<td style="text-align:right">get报文编号</td>
</tr>
<tr>
<td>pinfo.src pinfo.dst</td>
<td style="text-align:right">get/set报文的源地址、目的地址</td>
</tr>
<tr>
<td>pinfo.columns pinfo.cols</td>
<td style="text-align:right">get报文列表列（界面）</td>
</tr>
</tbody>
</table>
</div>
<p>用法举例：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改协议名称（效果见下图）</span></span><br><span class="line">pinfo.cols.protocol = bvc_srt.name</span><br><span class="line"><span class="comment">-- 为报文的信息尾部添加字符串（效果见下图）</span></span><br><span class="line">pinfo.cols.info:append(<span class="string">&quot; [ACK]&quot;</span>)</span><br><span class="line"><span class="comment">-- 还有一种便是直接覆盖</span></span><br><span class="line">pinfo.cols.info = <span class="string">&quot;[ACK]&quot;</span></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_pinfo.png"></p>
<h2 id="7-TreeItem"><a href="#7-TreeItem" class="headerlink" title="7. TreeItem"></a>7. TreeItem</h2><p>表示报文解析树中的一个树节点。主要接口有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>treeitem:add([protofield], [tvbrange], [value], [label])</td>
<td style="text-align:right">向当前树节点添加一个子节点</td>
</tr>
<tr>
<td>treeitem:set_text(text)</td>
<td style="text-align:right">设置当前树节点的文本</td>
</tr>
<tr>
<td>treeitem:prepend_text(text)</td>
<td style="text-align:right">在当前树节点文本的前面加上text</td>
</tr>
<tr>
<td>treeitem:append_text(text)</td>
<td style="text-align:right">在当前树节点文本的后面加上text</td>
</tr>
</tbody>
</table>
</div>
<p>还有注意一下网络字节序的问题，如果是网络字节序需要用add_le添加节点~<br>添加节点举例<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">subtree:add(fields.dst_sock, tvb(offset, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><br>实现协议里面添加子树例子</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 子树其实也是一个节点，因此也需要在fields里面添加字段</span></span><br><span class="line">fields.pack_type_tree = ProtoField.uint32(NAME .. <span class="string">&quot;.pack_type_tree&quot;</span>, <span class="string">&quot;Packet Type&quot;</span>, base.HEX)</span><br><span class="line"><span class="comment">-- 创建子树</span></span><br><span class="line">pack_type_tree = subtree:add(fields.pack_type_tree, tvb(offset, <span class="number">4</span>))</span><br><span class="line">pack_type_tree:add(fields.msg_type, tvb(offset, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_treeitem.png"></p>
<h2 id="8-Fields"><a href="#8-Fields" class="headerlink" title="8. Fields"></a>8. Fields</h2><p>获得Wireshark已有协议字段。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Field.new(fieldname)</td>
<td style="text-align:right">获得一个字段</td>
</tr>
<tr>
<td>all_field_infos()</td>
<td style="text-align:right">获取当前packet的 field 信息</td>
</tr>
</tbody>
</table>
</div>
<p>wireshark 本身已有大量的字段，比如我们想要获取 http2 的data 帧的内容，即可用 <code>http2.data.data</code> 获取。具体的fields 可以通过以下方式获得。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = Field.list()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, name <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_fields.png" style="height:400px"></p>
<p>可以为tap定义一个回调函数packet，每当有http协议的报文时wireshark将调用这个函数，参数tvb是报文的二进制缓冲区。在该函数中调用Field变量可以取得分析好的字段，如果不存在返回nil。</p>
<p>我们要截获的http协议包就包括这几层协议Frame,IP,TCP,HTTP,data-text-lines（这个是http内容）,这些上层协议的字段你都可以通过Field字段取得。<br>下面这一个截获框架，你可以使用tshark -X lua_script:tap.lua来执行这个例子</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> tap = Listener.new(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> http = Field.new(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> host = Field.new(<span class="string">&quot;http.host&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> location = Field.new(<span class="string">&quot;http.location&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dst_ip = Field.new(<span class="string">&quot;ip.dst&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> src_ip = Field.new(<span class="string">&quot;ip.src&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dst_port = Field.new(<span class="string">&quot;tcp.dstport&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> src_port = Field.new(<span class="string">&quot;tcp.srcport&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> text = Field.new(<span class="string">&quot;data-text-lines&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.packet</span><span class="params">(pinfo,tvb,tapinfo)</span></span></span><br><span class="line">    <span class="comment">--获取对应的字段</span></span><br><span class="line">    <span class="keyword">local</span> dst = dst_ip()</span><br><span class="line">    <span class="keyword">local</span> src = src_ip()</span><br><span class="line">    <span class="keyword">local</span> h = host()</span><br><span class="line">    <span class="keyword">local</span> dstp = dst_port()</span><br><span class="line">    <span class="keyword">local</span> srcp = src_port()</span><br><span class="line">    <span class="comment">--这里可以对截获的数据做存储打印等处理</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">tostring</span>(dst))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;host : &quot;</span>..<span class="built_in">tostring</span>(h))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.draw</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;draw called&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.reset</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;reset called&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>也可以调用 <code>all_field_infos</code> 获取当前 packet 中的信息，比如说以下这个 <code>MQTT Over Websocket</code> 的例子。</p>
<p><a href="https://cloud.tencent.com/developer/article/1093536">https://cloud.tencent.com/developer/article/1093536</a></p>
<h1 id="创建-Lua-解析器"><a href="#创建-Lua-解析器" class="headerlink" title="创建 Lua 解析器"></a>创建 Lua 解析器</h1><p>以下会的内容是搜集网上的一些优秀的介绍关于如何使用。</p>
<h2 id="MongoDB-dissector"><a href="#MongoDB-dissector" class="headerlink" title="MongoDB dissector"></a>MongoDB dissector</h2><p>以下的5篇文章是我从全网找到的最详尽的 lua 自定义协议解析脚本的教程。<br>从Lua基础到协议解析的全过程进行了阐述，从TCP Data 中解析 MongoDB 协议。</p>
<p>原文地址：</p>
<ul>
<li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/04/creating-a-wireshark-dissector-in-lua-1.html">Creating a Wireshark dissector in Lua - part 1 (the basics)</a></li>
<li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/06/creating-a-wireshark-dissector-in-lua-2.html">Creating a Wireshark dissector in Lua - part 2 (debugging and a more advanced dissector)</a></li>
<li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/08/creating-a-wireshark-dissector-in-lua-3.html">Creating a Wireshark dissector in Lua - part 3 (parsing the payload)</a></li>
<li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/16/creating-a-wireshark-dissector-in-lua-4.html">Creating a Wireshark dissector in Lua - part 4 (separate subtrees)
</a></li>
<li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/18/creating-a-wireshark-dissector-in-lua-5.html">Creating a Wireshark dissector in Lua - part 5 (modularization)</a></li>
</ul>
<p>Other</p>
<ul>
<li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/30/creating-port-independent-wireshark-dissectors-in-lua.html">Creating port-independent (heuristic) Wireshark dissectors in Lua</a></li>
</ul>
<h2 id="SRT协议的Wireshark解析器编写"><a href="#SRT协议的Wireshark解析器编写" class="headerlink" title="SRT协议的Wireshark解析器编写"></a>SRT协议的Wireshark解析器编写</h2><p>该文章也详细介绍了如何使用wireshark解析一个自定义协议，本文的内容也有一些参考了本文章。 github 上的 <code>srt-dev.lua</code> 也是 比较全的例子。</p>
<p>原文地址：</p>
<ul>
<li><a href="https://blog.csdn.net/Boring_Wednesday/article/details/99695507">SRT协议的Wireshark解析器编写</a></li>
</ul>
<p>wireshark 解析脚本示例：</p>
<ul>
<li><a href="https://github.com/Haivision/srt/blob/master/scripts/srt-dev.lua">https://github.com/Haivision/srt/blob/master/scripts/srt-dev.lua</a></li>
</ul>
<h2 id="解析Websocket上的MQTT协议"><a href="#解析Websocket上的MQTT协议" class="headerlink" title="解析Websocket上的MQTT协议"></a>解析Websocket上的MQTT协议</h2><p>这篇文章被我单独列出的一个重要原因是，这个文章列举了如何实现，在已有协议之上的 payload 接着解析协议。比如本例中的在 websocket 的payload 之上解析 MQTT 协议。</p>
<p>原文地址:</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1093536">Lua编写wireshark插件初探——解析Websocket上的MQTT协议</a></li>
</ul>
<p>github 地址：</p>
<ul>
<li><a href="https://github.com/a3135134/Wireshark-Plugin-MQTToverWebSocket/blob/master/mqttoverwebsocket.lua">https://github.com/a3135134/Wireshark-Plugin-MQTToverWebSocket/blob/master/mqttoverwebsocket.lua</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP/2 特性概览</title>
    <url>/2021/06/07/HTTP-2-%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HTTP的第一个文档版本于1991年发布，名称为HTTP0.9，后来导致1996年正式引入并认可HTTP1.0。HTTP1.1于1997年问世，此后几乎没有迭代改进。2015年2月，互联网工程任务组（IETF）HTTP工作组修订了HTTP，并以HTTP / 2的形式开发了应用协议的第二个主要版本。</p>
<blockquote>
<p>参考 kinsta.com 上 <a href="https://kinsta.com/learn/what-is-http2/">what-is-http2</a> 这篇文章。<br><a href="https://httpwg.org/specs/rfc7540.html">HTTP RFC 7540</a></p>
</blockquote>
<a id="more"></a>
<hr>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http-timeline.png"></p>
<h1 id="为什么要H2"><a href="#为什么要H2" class="headerlink" title="为什么要H2"></a>为什么要H2</h1><p>要解答这个问题，首先就需要知道HTTP1.x 出了什么问题。HTTP协议自1991年诞生依赖，很少有过大修大改。在H2之前最新版本的HTTP1.1已经为网络世界服务了15多年。随着互联网的发展速度越发的迅速，大量的消息充斥，而我们又对信息加载速度的一再苛刻要求。急需改变当前状况。</p>
<h2 id="HTTP1-1-PipeLine"><a href="#HTTP1-1-PipeLine" class="headerlink" title="HTTP1.1 PipeLine"></a>HTTP1.1 PipeLine</h2><p>HTTP1.1被限制为每个TCP连接仅处理一个未完成的请求，从而迫使浏览器使用多个TCP连接来同时处理多个请求。</p>
<p>但是，并行使用太多TCP连接会导致TCP拥塞，从而导致网络资源的不公平垄断。Web浏览器在使用多个连接来处理请求可能造成网络请求的大幅度占用，因此降低了其他用户的网络性能。</p>
<p>为了解决这个问题。互联网行业自然被迫采用诸如域分片，串联，数据内联和拼写之类的做法来破解这些约束。<br><img src="/images/network/HTTP2/http-requests.png"></p>
<h2 id="HTTP1-1-Bigger-Header"><a href="#HTTP1-1-Bigger-Header" class="headerlink" title="HTTP1.1 Bigger Header"></a>HTTP1.1 Bigger Header</h2><p>在HTTP1.x 中，可以用“Content-Encoding” 指定Body的编码方式，比如用 gzip 压缩来节约带宽资源，但是Header是一直没有考虑到的，Header中其实也存在大量的固定头部字段，多达上百上前字节，一些大型站点，功能复杂的，每次通信需要带上 “User Agent”、”Cookie”、”Accept” 或者一些自定义字段，这些字段都是重复的，非常浪费。”长尾效应”导致大量的带宽消耗在极度冗余的字段上。</p>
<h1 id="H2-特性"><a href="#H2-特性" class="headerlink" title="H2 特性"></a>H2 特性</h1><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p><img src="/images/network/HTTP2/http2-streams.png" style="height:450px"></p>
<p>“流”是在HTTP/2连接中客户端和服务器之间交换的独立的双向帧传输队列。流有几个重要特征：</p>
<ul>
<li>单个HTTP/2连接可以包含多个并发打开的流，其中任一端点从多个流交错发送多个Frame数据帧</li>
<li>流可以单方向的从客户端或者服务端建立</li>
<li>流可以被任意一方关闭</li>
<li>在流之上发送数据帧的顺序是必须的，一条流之上的Header帧在DATA帧之前。必须按照顺序</li>
<li>每一条流都一个流ID，流ID由发起方携带</li>
<li>客户端发起的流是单数递增，服务端发起的流是双数递增。</li>
</ul>
<blockquote>
<p>more: <a href="https://httpwg.org/specs/rfc7540.html#StreamsLayer">https://httpwg.org/specs/rfc7540.html#StreamsLayer</a></p>
</blockquote>
<p>在 HTTP2 的golang实现中可以看到<code>Framer</code>这个结构体，这个结构体规定了帧的读取和发送。在创建新的 <code>ClientConn</code> 时，会对一个<code>ClientConn</code> 通过调用 <code>cc.fr = NewFramer(cc.bw, cc.br)</code> 创建一个 <code>Framer</code> ,并且将整个 <code>net.Conn</code> 当做了 <code>io.Reader</code> 和 <code>io.Writer</code> 参数传给了 <code>Framer</code> 。<br>在<code>Framer</code>内部，会维护一个 <code>wbuf</code> 的字节队列，新写入的 Frame  会源源不断的写入到队列中。每写入的Frame的所携带的 <strong>Stream ID</strong> 并不一样。但是相同 <strong>Stream ID</strong> 会严格保持顺序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Framer reads and writes Frames.</span></span><br><span class="line"><span class="keyword">type</span> Framer <span class="keyword">struct</span> &#123;</span><br><span class="line">    r    io.Reader</span><br><span class="line">    w    io.Writer</span><br><span class="line">	wbuf []<span class="keyword">byte</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">newClientConn</span><span class="params">(c net.Conn, singleUse <span class="keyword">bool</span>)</span> <span class="params">(*ClientConn, error)</span></span> &#123;</span><br><span class="line">	cc := &amp;ClientConn&#123;</span><br><span class="line">		t:                     t,</span><br><span class="line">		tconn:                 c,</span><br><span class="line">		readerDone:            <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		nextStreamID:          <span class="number">1</span>,</span><br><span class="line">		maxFrameSize:          <span class="number">16</span> &lt;&lt; <span class="number">10</span>,           <span class="comment">// spec default</span></span><br><span class="line">		initialWindowSize:     <span class="number">65535</span>,              <span class="comment">// spec default</span></span><br><span class="line">		maxConcurrentStreams:  <span class="number">1000</span>,               <span class="comment">// &quot;infinite&quot;, per spec. 1000 seems good enough.</span></span><br><span class="line">		peerMaxHeaderListSize: <span class="number">0xffffffffffffffff</span>, <span class="comment">// &quot;infinite&quot;, per spec. Use 2^64-1 instead.</span></span><br><span class="line">		streams:               <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint32</span>]*clientStream),</span><br><span class="line">		singleUse:             singleUse,</span><br><span class="line">		wantSettingsAck:       <span class="literal">true</span>,</span><br><span class="line">		pings:                 <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">8</span>]<span class="keyword">byte</span>]<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> d := t.idleConnTimeout(); d != <span class="number">0</span> &#123;</span><br><span class="line">		cc.idleTimeout = d</span><br><span class="line">		cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> VerboseLogs &#123;</span><br><span class="line">		t.vlogf(<span class="string">&quot;http2: Transport creating client conn %p to %v&quot;</span>, cc, c.RemoteAddr())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cc.cond = sync.NewCond(&amp;cc.mu)</span><br><span class="line">	cc.flow.add(<span class="keyword">int32</span>(initialWindowSize))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> adjust this writer size to account for frame size +</span></span><br><span class="line">	<span class="comment">// MTU + crypto/tls record padding.</span></span><br><span class="line">	cc.bw = bufio.NewWriter(stickyErrWriter&#123;c, &amp;cc.werr&#125;)</span><br><span class="line">	cc.br = bufio.NewReader(c)</span><br><span class="line">	cc.fr = NewFramer(cc.bw, cc.br)</span><br><span class="line">	cc.fr.ReadMetaHeaders = hpack.NewDecoder(initialHeaderTableSize, <span class="literal">nil</span>)</span><br><span class="line">	cc.fr.MaxHeaderListSize = t.maxHeaderListSize()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> SetMaxDynamicTableSize, SetMaxDynamicTableSizeLimit on</span></span><br><span class="line">	<span class="comment">// henc in response to SETTINGS frames?</span></span><br><span class="line">	cc.henc = hpack.NewEncoder(&amp;cc.hbuf)</span><br><span class="line">        <span class="keyword">if</span> t.AllowHTTP &#123;</span><br><span class="line">		cc.nextStreamID = <span class="number">3</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cs, ok := c.(connectionStater); ok &#123;</span><br><span class="line">		state := cs.ConnectionState()</span><br><span class="line">		cc.tlsState = &amp;state</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	initialSettings := []Setting&#123;</span><br><span class="line">		&#123;ID: SettingEnablePush, Val: <span class="number">0</span>&#125;,</span><br><span class="line">		&#123;ID: SettingInitialWindowSize, Val: transportDefaultStreamFlow&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> max := t.maxHeaderListSize(); max != <span class="number">0</span> &#123;</span><br><span class="line">		initialSettings = <span class="built_in">append</span>(initialSettings, Setting&#123;ID: SettingMaxHeaderListSize, Val: max&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cc.bw.Write(clientPreface)</span><br><span class="line">	cc.fr.WriteSettings(initialSettings...)</span><br><span class="line">	cc.fr.WriteWindowUpdate(<span class="number">0</span>, transportDefaultConnFlow)</span><br><span class="line">	cc.inflow.add(transportDefaultConnFlow + initialWindowSize)</span><br><span class="line">	cc.bw.Flush()</span><br><span class="line">	<span class="keyword">if</span> cc.werr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, cc.werr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> cc.readLoop()</span><br><span class="line">	<span class="keyword">return</span> cc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到。63 行的 <code>cc.bw</code> 可以任意写入非Frame的字符串，如果需要写入 <code>Frame</code> 的话，会通过 64 行的<code>cc.fr.WriteXXXX</code> 写入。如下面的 <code>Setting 帧的写入</code> 。HTTP2 发送一个帧的实现就是将该帧结构完完整整的塞入 wbuf 中, 由 <code>startWrite</code> 写入wbuf, 再由<code>endWrite</code> 函数将wbuf 写入 <code>io.Writer</code>中，刚才在 <code>NewFramer(cc.bw, cc.br)</code> 函数中已经看到了，<code>io.Writer</code> 就是 net.Conn, 也就是这个 Frame 被发出去了。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteSettings writes a SETTINGS frame with zero or more settings</span></span><br><span class="line"><span class="comment">// specified and the ACK bit not set.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It will perform exactly one Write to the underlying Writer.</span></span><br><span class="line"><span class="comment">// It is the caller&#x27;s responsibility to not call other Write methods concurrently.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Framer)</span> <span class="title">WriteSettings</span><span class="params">(settings ...Setting)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f.startWrite(FrameSettings, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> settings &#123;</span><br><span class="line">		f.writeUint16(<span class="keyword">uint16</span>(s.ID))</span><br><span class="line">		f.writeUint32(s.Val)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f.endWrite()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Framer)</span> <span class="title">startWrite</span><span class="params">(ftype FrameType, flags Flags, streamID <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Write the FrameHeader.</span></span><br><span class="line">	f.wbuf = <span class="built_in">append</span>(f.wbuf[:<span class="number">0</span>],</span><br><span class="line">		<span class="number">0</span>, <span class="comment">// 3 bytes of length, filled in in endWrite</span></span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="keyword">byte</span>(ftype),</span><br><span class="line">		<span class="keyword">byte</span>(flags),</span><br><span class="line">		<span class="keyword">byte</span>(streamID&gt;&gt;<span class="number">24</span>),</span><br><span class="line">		<span class="keyword">byte</span>(streamID&gt;&gt;<span class="number">16</span>),</span><br><span class="line">		<span class="keyword">byte</span>(streamID&gt;&gt;<span class="number">8</span>),</span><br><span class="line">		<span class="keyword">byte</span>(streamID))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Framer)</span> <span class="title">endWrite</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Now that we know the final size, fill in the FrameHeader in</span></span><br><span class="line">	<span class="comment">// the space previously reserved for it. Abuse append.</span></span><br><span class="line">	length := <span class="built_in">len</span>(f.wbuf) - frameHeaderLen</span><br><span class="line">	<span class="keyword">if</span> length &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrFrameTooLarge</span><br><span class="line">	&#125;</span><br><span class="line">	_ = <span class="built_in">append</span>(f.wbuf[:<span class="number">0</span>],</span><br><span class="line">		<span class="keyword">byte</span>(length&gt;&gt;<span class="number">16</span>),</span><br><span class="line">		<span class="keyword">byte</span>(length&gt;&gt;<span class="number">8</span>),</span><br><span class="line">		<span class="keyword">byte</span>(length))</span><br><span class="line">	<span class="keyword">if</span> f.logWrites &#123;</span><br><span class="line">		f.logWrite()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n, err := f.w.Write(f.wbuf)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; n != <span class="built_in">len</span>(f.wbuf) &#123;</span><br><span class="line">		err = io.ErrShortWrite</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么由此就得知了流的组成，和流多路复用的原理。以及流之间的帧是有顺序的。<strong>（这个例子足够简单，以至于没有实现流优先级的概念，也没有流控之类的概念，后面我们再介绍）</strong><br>但是我们帧可以任意交织在一起。实现一套逻辑层面的流的概念。</p>
<p>更多帧格式参见：<a href="https://httpwg.org/specs/rfc7540.html#FrameTypes">https://httpwg.org/specs/rfc7540.html#FrameTypes</a></p>
<h2 id="HPACK"><a href="#HPACK" class="headerlink" title="HPACK"></a>HPACK</h2><p><img src="/images/network/HTTP2/http2-hpack-compression.png" style="height:130px"></p>
<p>在 HTTP1.1 中，每一个请求都携带着沉重的 header，包含 cookie 、trace-link、<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server-Timing">server-timing</a>、X-FF 信息。</p>
<p>在网站提供丰富媒体内容的情况下，客户端发送多个几乎相同的HTTP头部，会导致延迟和有限的网络资源的不必要消耗。HTTP2 正是针对这点进行了优化，</p>
<p>HPACK 正是HTTP2 减少HTTP请求header的秘诀，HPACK 由 <a href="https://httpwg.org/specs/rfc7541.html">RFC7541</a> 规定。</p>
<p>而HPACK 的压缩方式分 3 种</p>
<ul>
<li>静态字典</li>
<li>动态字典</li>
<li>压缩算法：Huffman 压缩 （最高压缩比 8:5）</li>
</ul>
<h3 id="静态字典"><a href="#静态字典" class="headerlink" title="静态字典"></a>静态字典</h3><p><a href="https://httpwg.org/specs/rfc7541.html#static.table.definition">https://httpwg.org/specs/rfc7541.html#static.table.definition</a></p>
<p>静态字典由 <code>index</code>、<code>header name</code>、<code>header value</code> 组成，比如字符2就可以直接代表 <code>:method : GET</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Index	Header Name	Header Value</span><br><span class="line">1	:authority	</span><br><span class="line">2	:method	GET</span><br><span class="line">3	:method	POST</span><br><span class="line">4	:path	&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/hpack.jpeg"></p>
<p>可以在静态表字典里查到的会直接引用，无法查到的会进行 <code>Huffman</code> 编码。</p>
<p>静态表一共有61项，动态表采用先入先出的淘汰策略，大小由 <code>SETTINGS_HEADER_TABLE_SIZE</code> 控制。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack-table.png"></p>
<h3 id="Huffman-编码原理"><a href="#Huffman-编码原理" class="headerlink" title="Huffman 编码原理"></a>Huffman 编码原理</h3><p>出现概率较大的字符串用较短的数字编码，出现概率较小的字符串用比较长的数字编码。</p>
<p>huffman 编码分两种，一种是<strong>静态 huffman</strong>，一种是<strong>动态huffman</strong>，静态huffman编码是对当前已有的字符的一个出现概率的统计。<code>0</code>、<code>1</code>、<code>.</code>、<code>a</code>、<code>c</code>、<code>e</code> 等字符串出现概率较高，所以就用较短的字符做映射从而统计生成了一套<a href="https://httpwg.org/specs/rfc7541.html#huffman.code">静态 huffmane 编码表</a>。早先的 spdy 使用的动态huffman编码，但是容易被攻击，所以HTTP2使用的都是静态 huffman 编码，</p>
<ul>
<li>Huffman 树的构造过程</li>
</ul>
<ol>
<li>计算各字母的出现概率</li>
<li>将出现概率较小的两个字母相加构成子树，左小右大</li>
<li>重复步骤二完成树的构建</li>
<li>给树的左链接编码0.右链接编码1</li>
<li>每个字母的编码即从根节点至叶节点的串联和</li>
</ol>
<p><a href="https://www.geeksforgeeks.org/huffman-decoding/">huffman 树编码(Huffman Decoding)</a></p>
<p><strong>举例</strong></p>
<p>有一串字符</p>
<p>A 出现 25 次 、 B 出现 15 次、C 出现 14 次、 D 出现 20 次、 E 出现 17 次、F 出现9 次</p>
<p>按照左小右大的规则。 F 与 C 组成一组, 加起来是 23 ，以此类推。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/huffman_tree.png"></p>
<p>从 Golang 的 hpack 实现中可以调取 http2/hpack 来做header编解码。核心代码只有2部分，<code>NewEncoder</code> 创建一个编码<code>Encoder</code>对象。通过 <code>WriteFeild</code> 来实现header内容的写入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewEncoder returns a new Encoder which performs HPACK encoding. An</span></span><br><span class="line"><span class="comment">// encoded data is written to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> *<span class="title">Encoder</span></span> &#123;</span><br><span class="line">	e := &amp;Encoder&#123;</span><br><span class="line">		minSize:         uint32Max,</span><br><span class="line">		maxSizeLimit:    initialHeaderTableSize,</span><br><span class="line">		tableSizeUpdate: <span class="literal">false</span>,</span><br><span class="line">		w:               w,</span><br><span class="line">	&#125;</span><br><span class="line">	e.dynTab.table.init()</span><br><span class="line">	e.dynTab.setMaxSize(initialHeaderTableSize)</span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteField encodes f into a single Write to e&#x27;s underlying Writer.</span></span><br><span class="line"><span class="comment">// This function may also produce bytes for &quot;Header Table Size Update&quot;</span></span><br><span class="line"><span class="comment">// if necessary. If produced, it is done before encoding f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encoder)</span> <span class="title">WriteField</span><span class="params">(f HeaderField)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	e.buf = e.buf[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e.tableSizeUpdate &#123;</span><br><span class="line">		e.tableSizeUpdate = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> e.minSize &lt; e.dynTab.maxSize &#123;</span><br><span class="line">			e.buf = appendTableSize(e.buf, e.minSize)</span><br><span class="line">		&#125;</span><br><span class="line">		e.minSize = uint32Max</span><br><span class="line">		e.buf = appendTableSize(e.buf, e.dynTab.maxSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	idx, nameValueMatch := e.searchTable(f)</span><br><span class="line">	<span class="keyword">if</span> nameValueMatch &#123;</span><br><span class="line">		e.buf = appendIndexed(e.buf, idx)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		indexing := e.shouldIndex(f)</span><br><span class="line">		<span class="keyword">if</span> indexing &#123;</span><br><span class="line">			e.dynTab.add(f)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> idx == <span class="number">0</span> &#123;</span><br><span class="line">			e.buf = appendNewName(e.buf, f, indexing)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			e.buf = appendIndexedName(e.buf, f, idx, indexing)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n, err := e.w.Write(e.buf)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; n != <span class="built_in">len</span>(e.buf) &#123;</span><br><span class="line">		err = io.ErrShortWrite</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>代码第21行，更新增大动态表size，这个不用关心，只有SETTING帧协商时才会变大，正常是走不到21行的这个if语句。</li>
<li>代码第30行，在hpack表（静态表+动态表）中搜索，如果能搜到（name+value）则在第32行将索引写入buffer中，否则在第34行判断一下是否可以索引，可以索引的话就加入到动态表，如果 idx 为0（name和value都没有查到）则对整个header kv进行索引，如果有idx，证明只是value没有被索引，只对value 索引即可</li>
</ul>
<p>下面以 <code>appendNewName(dst []byte, f HeaderField, indexing bool)</code> 为例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// appendNewName appends f, as encoded in one of &quot;Literal Header field</span></span><br><span class="line"><span class="comment">// - New Name&quot; representation variants, to dst and returns the</span></span><br><span class="line"><span class="comment">// extended buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f.Sensitive is true, &quot;Never Indexed&quot; representation is used. If</span></span><br><span class="line"><span class="comment">// f.Sensitive is false and indexing is true, &quot;Incremental Indexing&quot;</span></span><br><span class="line"><span class="comment">// representation is used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendNewName</span><span class="params">(dst []<span class="keyword">byte</span>, f HeaderField, indexing <span class="keyword">bool</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	dst = <span class="built_in">append</span>(dst, encodeTypeByte(indexing, f.Sensitive))</span><br><span class="line">	dst = appendHpackString(dst, f.Name)</span><br><span class="line">	<span class="keyword">return</span> appendHpackString(dst, f.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第9行代码，表示加一个前缀，表示该字段是否可以被索引，sensitive如果为true的话表示不能被索引，比如一些每次请求绝对会变化的value，如<code>server-timing</code>就不能被索引。</li>
<li>第10行代码，将Header Name 进行动态表索引。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// appendHpackString appends s, as encoded in &quot;String Literal&quot;</span></span><br><span class="line"><span class="comment">// representation, to dst and returns the extended buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// s will be encoded in Huffman codes only when it produces strictly</span></span><br><span class="line"><span class="comment">// shorter byte string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendHpackString</span><span class="params">(dst []<span class="keyword">byte</span>, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	huffmanLength := HuffmanEncodeLength(s)</span><br><span class="line">	<span class="keyword">if</span> huffmanLength &lt; <span class="keyword">uint64</span>(<span class="built_in">len</span>(s)) &#123;</span><br><span class="line">		first := <span class="built_in">len</span>(dst)</span><br><span class="line">		dst = appendVarInt(dst, <span class="number">7</span>, huffmanLength)</span><br><span class="line">		dst = AppendHuffmanString(dst, s)</span><br><span class="line">		dst[first] |= <span class="number">0x80</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dst = appendVarInt(dst, <span class="number">7</span>, <span class="keyword">uint64</span>(<span class="built_in">len</span>(s)))</span><br><span class="line">		dst = <span class="built_in">append</span>(dst, s...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第7行代码获取huffman编码后的长度， string 的每一位被编码后的长度之和会由<code>HuffmanEncodeLength</code>提供，如果Huffman编码后有字节节省才会真正编码。负责直接将原数据直接加入到 dst buffer 中。</li>
<li>第8行证明了Huffman 编码更有优势。在buffer开始或等于 0x80 表示 Huffman编码。并由 <code>AppendHuffmanString(dst, s)</code> 真正开始Huffman编码。由于是静态Huffman编码，所以接下来要做的事情就是查表了。</li>
</ul>
<blockquote>
<p>实际上可供编码的只有7位，最高位置1表示是huffman 编码。<br>例如：method: GET 在静态表中为 2，则最终编码为 1000 0010 hex 表示为82</p>
</blockquote>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack1.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">名字和值都在索引表中</div>
</center>


<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack2.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">名字在索引表中，值进行编码</div>
</center>

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack3.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">名字和值都不在索引表中，2个都进行huffman编码</div>
</center>


<p>HPACK 压缩比检测：<br><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack.png"></p>
<blockquote>
<p>空间节省了 71.44% , 访问的次数越多，节约的空间越多，访问一次只会发挥 静态表和huffman 算法的作用。</p>
</blockquote>
<h2 id="流优先级-amp-amp-流控"><a href="#流优先级-amp-amp-流控" class="headerlink" title="流优先级 &amp;&amp; 流控"></a>流优先级 &amp;&amp; 流控</h2><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-weight.png" style="height:140px"></p>
<p>这里就先说流控吧。</p>
<p>HTTP2 一般 Connection 和 Stream 的初始 flow-control window 大小都是 65535 bytes （如果一切顺利不丢包的情况下，RTT为 100ms，则每秒最多能发送65535*(1000/100)的数据，大约就是600KB/s）。通过发送 SETTINGS Frame，携带 <a href="http://httpwg.org/specs/rfc7540.html#SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE</a> ，修改初始窗口大小。如果当前窗口已存在，会做delta 更新，这个值即为新的 stream flow-control window 初始大小。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control0.png"></p>
<p>通过对官方代码按照 RFC 实现的http2库分析：</p>
<p>首先服务端视角，入向流量每收到一个 <code>DataFrame</code> 都会在自身链接级别和流级别更新当前的 <strong>flow-control</strong>，而每创建一个新stream时，其入向 <strong>sc.inflow</strong> 是继承当前连接级别的 <strong>flow-control</strong> 。<strong>即所有 stream 级别的窗口之和等于 Connection 级别的窗口。</strong></p>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control1.png"></p>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control2.png"></p>
<p>整个发送过程会遵从流控限制，如果窗口 &gt; 0 但是 窗口 &lt; 客户端要发送的数据，客户端要发送的数据会被分成2部分，其中流控内的数据会被发送</p>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control3.png"></p>
<p>在一次实际的上传过程中，观察到如下的一次上传的 netlog。服务端的窗口经常因为耗尽而等待，等待时长约 70ms + ，与akamai 的 ping 延迟基本也在 30-60ms 。每次窗口恢复和挤牙膏一样非常缓慢。<br><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control4.png"></p>
<h2 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h2><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-push.png" style="height:150px"></p>
<p><a href="https://httpwg.org/specs/rfc7540.html#PUSH_PROMISE">Push Promise</a> 是HTTP2 与 HTTP1.1 最大的一个区别，它是指在客户端在发起一个请求时，服务端在返回该请求响应之前，返回一个 PushPromise 表示有资源要推送，并且会再新开一个偶数流，推送内容，在客户端发起请求之前让客户端拿到数据。如下是 push promise 的服务端实现。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-serverpush.png" style="height:400px"></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushHandler</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> path, handler := <span class="keyword">range</span> pushResources &#123;</span><br><span class="line">			<span class="keyword">if</span> r.URL.Path == path &#123;</span><br><span class="line">				handler.ServeHTTP(w, r)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cacheBust := time.Now().UnixNano()</span><br><span class="line">		<span class="keyword">if</span> pusher, ok := w.(http.Pusher); ok &#123;</span><br><span class="line">			<span class="keyword">for</span> path := <span class="keyword">range</span> pushResources &#123;</span><br><span class="line">				url := fmt.Sprintf(<span class="string">&quot;%s?%d&quot;</span>, path, cacheBust)</span><br><span class="line">				<span class="keyword">if</span> err := pusher.Push(url, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Printf(<span class="string">&quot;Failed to push %v: %v&quot;</span>, path, err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// fake network latency + parsing time</span></span><br><span class="line">		<span class="keyword">if</span> err := PushTmpl.Execute(w, <span class="keyword">struct</span> &#123;</span><br><span class="line">			CacheBust   <span class="keyword">int64</span></span><br><span class="line">			HTTPSHost   <span class="keyword">string</span></span><br><span class="line">			HTTP1Prefix <span class="keyword">string</span></span><br><span class="line">		&#125;&#123;</span><br><span class="line">			CacheBust:   cacheBust,</span><br><span class="line">			HTTPSHost:   HttpsHost(),</span><br><span class="line">			HTTP1Prefix: Http1Prefix(),</span><br><span class="line">		&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Executing server push template: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连接前言"><a href="#连接前言" class="headerlink" title="连接前言"></a>连接前言</h2><p>TLS 握手成功之后，客户端需要发送一个”连接前言”（connection preface），用来确认HTTP/2的连接。Magic被称为H2不可知的魔法。而PRISM，其实就是在暗讽2013年斯诺登事件爆出的“棱镜计划”。</p>
<p>参考：<a href="https://blog.jgc.org/2015/11/the-secret-message-hidden-in-every.html">https://blog.jgc.org/2015/11/the-secret-message-hidden-in-every.html</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Magic: PRI * HTTP&#x2F;2.0\r\n\r\nSM\r\n\r\n</span><br></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li>[0]: <a href="https://kinsta.com/learn/what-is-http2/">https://kinsta.com/learn/what-is-http2/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>如何减少TTFB以提升WordPress加载性能</title>
    <url>/2021/06/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91TTFB%E4%BB%A5%E6%8F%90%E9%AB%98%E7%BD%91%E9%A1%B5%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当谈论到你的 <a href="What Is WordPress? Explained for Beginners">WordPress Site</a> 加载性能时，大多数我们都是在关注前端的性能优化来提升页面加载速度。然而我们有时候应该从服务端视角来看待这个问题。今天我们来讨论一下 <strong>TTFB (time to first byte)</strong> 是怎么影响你的网站加载速度，另外我们如何去降低他。TTFB是一个经常会被忽略的重要性能因素，但是我们在网站性能优化是必须考虑进来。</p>
<p><img src="http://img1.kiosk007.top/static/images/network/performance/ttfb.png" style="height:300px"></p>
<p>— 译 <a href="https://kinsta.com/blog/ttfb/">How to Reduce TTFB to Improve WordPress Page Load Times</a></p>
<a id="more"></a>
<ul>
<li><a href>什么是TTFB?</a></li>
<li><a href>TTFB 重要吗？</a></li>
<li><a href>如何测量TTFB？</a></li>
<li><a href>4种方法来减少Wordpress站点的TTFB</a></li>
</ul>
<h1 id="什么是TTFB？"><a href="#什么是TTFB？" class="headerlink" title="什么是TTFB？"></a>什么是TTFB？</h1><p>TTFB 表示”首字节时间”, 简单的说，表示从浏览器收到服务端的第一个字节所需要的时间。TTFB时间越长、那么页面加载显示的时间就越长。一个常见的误解是，这个时间主要是DNS查找时间计算的。然而，真正的 <a href="https://en.wikipedia.org/wiki/Time_To_First_Byte">TTFB</a> 其实包含整个网络期间的时延。并且以下三个步骤之和才是总的TTFB。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/performance/waiting-ttfb.jpg" style="height:300px"></p>
<h2 id="1-请求服务"><a href="#1-请求服务" class="headerlink" title="1. 请求服务"></a>1. 请求服务</h2><p>当有用户访问你的网站时。发生的第一件事是客户端（浏览器）会先发送一个HTTP请求。在此步骤中，可能有多种因素导致延迟、<strong>缓慢的DNS</strong> 查找时间可能会增加请求的时间。如果服务器在地理上很远，这可能会导致数据传输距离的延迟。此外，如果您有复杂的防火墙规则，这可能会增加路由时间。并且不要忘记客户端的互联网速度。</p>
<h2 id="2-服务端处理耗时"><a href="#2-服务端处理耗时" class="headerlink" title="2. 服务端处理耗时"></a>2. 服务端处理耗时</h2><p>发送请求后，服务器现在必须处理它并生成响应。这可能会引入许多不同的延迟，例如<strong>缓慢的数据库调用</strong>、过多的第三方脚本、<strong>未缓存</strong>第一个响应、糟糕的代码或 WordPress 主题以及低效的服务器资源，例如<strong>磁盘 I/O</strong> 或<strong>内存</strong>。</p>
<h2 id="3-响应"><a href="#3-响应" class="headerlink" title="3. 响应"></a>3. 响应</h2><p>服务器处理完请求后，必须将其发送回客户端（或者更确切地说是发送回第一个字节）。这受到服务器和客户端网络速度的影响。如果客户端的 Wi-Fi 热点速度较慢，这将反映在 TTFB 中。</p>
<h1 id="TTFB-重要吗？"><a href="#TTFB-重要吗？" class="headerlink" title="TTFB 重要吗？"></a>TTFB 重要吗？</h1><p>重要的是要了解 TTFB（到第一个字节的时间）与网站速度不同。这实际上是对响应能力的衡量。网络上有很多关于 TTFB 是否重要的​​讨论。有人说它毫无意义（<a href="https://blog.cloudflare.com/ttfb-time-to-first-byte-considered-meaningles/">Cloudflare</a>、<a href>LittleBizzy</a>），而另一些人说它很重要（<a href="https://plus.google.com/+IlyaGrigorik/posts/GTWYbYWP6xP">Ilya Grigorik</a>，Google 的 Web 性能工程师）。双方都提出了一些关于为什么或为什么不重要的有效观点，以及关于它如何实际计算的一些问题。</p>
<p>Moz 甚至对<a href="https://moz.com/blog/improving-search-rank-by-optimizing-your-time-to-first-byte">搜索排名与第一个字节的时间之间的相关性</a>进行了深入研究。 但是，很难知道搜索排名是否是和TTFB相关的 。或者 TTFB 较低的网站是否也只是总体上更快。</p>
<p>然而，与其花时间讨论是否重要，我们宁愿专注于可以做的优化来改进这个指标。在我们具有更大 TTFB 的测试站点中，只需加载并感觉更慢。</p>
<p>通常，<strong>低于 100 毫秒的TTFB 都很棒</strong>。<a href="https://kinsta.com/blog/google-pagespeed-insights/">Google PageSpeed Insights</a> 建议服务器响应时间小于 200 毫秒。如果您在 300-500 毫秒范围内，这是非常标准的。如果超过 600 毫秒，您的服务或者链路可能有问题，或者可能是时候升级到更好的 Web 服务了。或者按照我们下面有关如何减少 TTFB 的建议进行操作。SSL/TLS 协商也可能是一个点。</p>
<h1 id="如何测量TTFB"><a href="#如何测量TTFB" class="headerlink" title="如何测量TTFB"></a>如何测量TTFB</h1><p>可以通过多种不同的方式来测试你站点的 TTFB。下面将探索一些。但请记住，每种工具都会给出略有不同的结果，因此重要的是只使用一种工具并坚持使用它作为基线。</p>
<h2 id="使用-Google-Chrome-DevTools-测量-TTFB"><a href="#使用-Google-Chrome-DevTools-测量-TTFB" class="headerlink" title="使用 Google Chrome DevTools 测量 TTFB"></a>使用 Google Chrome DevTools 测量 TTFB</h2><p>可以通过启动DevTools在 Google Chrome 中测量 TTFB 。但请记住，如果您在计算机上测试 TTFB 会受到网络延迟和 Internet 连接的影响。因此，使用从数据中心进行测试的第 3 方工具（如下所示）可能更有效。</p>
<ul>
<li>从 Chrome 菜单中选择更多工具 &gt; 开发者工具。</li>
<li>右键单击页面元素并选择检查</li>
<li>使用键盘快捷键Ctrl+ Shift+ I(Windows) 或Cmd+ Opt+ I(Mac)</li>
<li>您可以启动网络窗口并查看站点的性能。</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/performance/google-chrome-devtools-ttfb.jpg" style="height:300px"></p>
<h2 id="使用-Geekflare-的工具测量-TTFB"><a href="#使用-Geekflare-的工具测量-TTFB" class="headerlink" title="使用 Geekflare 的工具测量 TTFB"></a>使用 Geekflare 的工具测量 TTFB</h2><p>Geekflare 拥有一系列很棒的免费工具，您可以使用它们来测试和排除网站上的问题。<a href="https://gf.dev/ttfb-test">Geekflare</a> 的 TTFB 工具简单、快速，可让您查看从全球三个位置获取第一个字节的时间有多快（低）</p>
<p><img src="https://img1.kiosk007.top/static/images/network/performance/geekflare.png" style="height:300px"></p>
<h2 id="使用-WebPageTest-测量-TTFB"><a href="#使用-WebPageTest-测量-TTFB" class="headerlink" title="使用 WebPageTest 测量 TTFB"></a>使用 WebPageTest 测量 TTFB</h2><p>您还可以使用 <a href="https://www.webpagetest.org/">WebPageTest</a> 测量您的 TTFB 。根据他们的术语表，目标时间是 DNS、套接字和 SSL 协商所需的时间 + 100 毫秒。超出目标每100ms扣除一个字母等级。正如您在下面的测试中所见，该站点的 TTFB 为 0.256 秒或 256 毫秒。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/performance/webpagetest-ttfb.jpg" style="height:300px"></p>
<h2 id="用-Pingdom-测量-TTFB"><a href="#用-Pingdom-测量-TTFB" class="headerlink" title="用 Pingdom 测量 TTFB"></a>用 Pingdom 测量 TTFB</h2><p>Chrome 和 WebPageTest 将其称为 TTFB。但是，如果您使用Pingdom，它实际上被称为“等待”时间。请务必查看我们关于如何使用 Pingdom的深入指南。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/performance/wait-time-pingdom.jpg" style="height:300px"></p>
<h2 id="使用-GTmetrix-测量-TTFB"><a href="#使用-GTmetrix-测量-TTFB" class="headerlink" title="使用 GTmetrix 测量 TTFB"></a>使用 GTmetrix 测量 TTFB</h2><p>在 GTmetrix 中，就像 Pingdom 一样，TTFB 被称为等待时间。请务必查看我们关于如何使用 <a href="https://kinsta.com/blog/gtmetrix-speed-test/">GTmetrix的深入指南</a> 。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/performance/gtmetrix-waiting.png" style="height:300px"></p>
<h2 id="使用-KeyCDN-的工具测量-TTFB"><a href="#使用-KeyCDN-的工具测量-TTFB" class="headerlink" title="使用 KeyCDN 的工具测量 TTFB"></a>使用 KeyCDN 的工具测量 TTFB</h2><p>KeyCDN 有一个很棒的 <a href="https://tools.keycdn.com/performance">网络性能测试工具</a> ，您可以在其中同时从 14 个不同的位置测量您的 TTFB。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/performance/keycdn-ttfb-test.jpg" style="height:300px"></p>
<p>还有一些其他各种工具可以测量 TTFB，例如<a href="https://performance.sucuri.net/">Sucuri Performance Tool</a>和<a href="http://www.bytecheck.com/">ByteCheck</a>。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/performance/google-analytics-ttfb.jpg" style="height:300px"></p>
<h1 id="减少-WordPress-网站上-TTFB-的-4-种方法"><a href="#减少-WordPress-网站上-TTFB-的-4-种方法" class="headerlink" title="减少 WordPress 网站上 TTFB 的 4 种方法"></a>减少 WordPress 网站上 TTFB 的 4 种方法</h1><blockquote>
<p>现在让我们深入探讨如何减少 WordPress 网站上的 TTFB。</p>
</blockquote>
<h2 id="1-使用快速的-WordPress-主机"><a href="#1-使用快速的-WordPress-主机" class="headerlink" title="1. 使用快速的 WordPress 主机"></a>1. 使用快速的 WordPress 主机</h2><p>减少 TTFB 的第一种方法是确保您使用的是快速的 WordPress 主机。我们比较了第三方云服务器的 TTFB（位于亚利桑那州凤凰城）和 Kinsta 的 TTFB（位于爱荷华州康瑟尔布拉夫斯）。我们使用了完全相同的设置，运行默认的 27 主题。Kinsta 现在拥有所有 25 个可用的Google Cloud Platform 节点，因此战略性地将您的 WordPress 站点放置在离访问者更近的位置非常重要。</p>
<p>切换到更快的主机可以将您网站的 TTFB 减少多达 200%。</p>
<p>Kinsta 还在 所有托管计划中使用了 Google Cloud Platform 的高级网络。许多其他托管服务提供商使用 Google Cloud 的标准层网络，这会导致速度变慢。</p>
<p>在所有地区，平均 TTFB 为 520 毫秒。在美国和加拿大，平均 TTFB 为 240 毫秒。</p>
<p>因此，仅通过使用更快的主机，可以显著降低 TTFB </p>
<h2 id="2-CDN-or-DSA"><a href="#2-CDN-or-DSA" class="headerlink" title="2. CDN or DSA"></a>2. CDN or DSA</h2><p>另一种减少 TTFB 的简单方法是利用 <strong><a href="https://kinsta.com/blog/wordpress-cdn/">内容交付网络</a></strong> (CDN)。如果您的网站为该国不同地区或全球的访问者提供服务，这会大大降低您的 TTFB。正如我们在上面看到的，位置非常重要。我们进行了一个小测试，以显示 KeyCDN 作为我们的 CDN 提供商的不同之处。每个测试运行 5 次并取平均值。</p>
<ul>
<li>没有 CDN 的 TTFB</li>
</ul>
<p>我们首先在禁用 CDN 的情况下运行测试，我们的总加载时间为 1.45 秒，资产的平均 TTFB 约为 136 毫秒。</p>
<ul>
<li>带 CDN 的 TTFB<br>我们的总加载时间下降到 788 毫秒，我们的平均 TTFB 现在是 37 毫秒！CDN 可以带来多大的不同</li>
</ul>
<p>注意：如果您使用 Cloudflare，您的TTFB可能略高。这很可能是由于运行完全代理服务的额外开销和复杂性。Cloudflare 具有某些 CDN 提供商没有的其他防火墙和其他功能。</p>
<h2 id="3-WordPress-缓存"><a href="#3-WordPress-缓存" class="headerlink" title="3. WordPress 缓存"></a>3. WordPress 缓存</h2><p>减少 TTFB 的第三种方法，也可能是最简单的方法之一，就是在 WordPress 网站上使用缓存。许多人只认为缓存可以帮助减少加载时间，但实际上，它也有助于减少 TTFB，因为它有助于减少服务器处理时间。</p>
<h2 id="4-使用高级-DNS-提供商"><a href="#4-使用高级-DNS-提供商" class="headerlink" title="4. 使用高级 DNS 提供商"></a>4. 使用高级 DNS 提供商</h2><p>DNS 也在 TTFB 中发挥作用。很难准确计算它受到的影响有多大，但您仍然可以看到总体 DNS 查找时间，并看到那里有越来越快的提供商。</p>
<p><a href="http://www.solvedns.com/dnsspeedtest/">SolveDNS 速度测试工具</a> 可以帮我们测试DNS解析速度。 大的云厂商，如 AWS 会比一些免费的DNS提供商的质量要好很多。</p>
<p>更多内容可以查看 [Why Premium DNS is No Longer Optional][<a href="https://kinsta.com/blog/premium-dns/">https://kinsta.com/blog/premium-dns/</a>)</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
  </entry>
  <entry>
    <title>curl 命令小结</title>
    <url>/2021/05/29/curl-%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>curl 命令是我日常工作中最常用的命令之一，所以很有必要总结一下curl命令的一些用法。如统计耗时、以指定的ip访问某个域名。添加携带某些Header等。curl命令绝对是日常debug之神。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/curl/curl-command.png" style="height:200px"></p>
<a id="more"></a>
<ul>
<li>curl 官网：<a href="https://curl.se">https://curl.se</a></li>
<li>curl 支持：<br>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP. curl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, HTTP/2, HTTP/3, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, SCRAM-SHA, NTLM, Negotiate and Kerberos), file transfer resume, proxy tunneling and more.</li>
</ul>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><ul>
<li>指定解析：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://github.com --resolve github.com:443:13.229.188.59 -v -o /dev/null</span><br></pre></td></tr></table></figure>
<ul>
<li>POST请求携带json数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X POST -d <span class="string">&#x27;&#123;&quot;abc&quot;:123,&quot;bcd&quot;:&quot;nihao&quot;&#125;&#x27;</span> URL</span><br></pre></td></tr></table></figure>
<ul>
<li>修改请求头</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;host: www.baidu.com&quot;</span> https://127.0.0.1</span><br></pre></td></tr></table></figure>
<ul>
<li>限速</li>
</ul>
<p>限制curl使用的最大带宽；如果未指定单位，默认单位为“bytes/秒”，你也可以指定单位为“K”、“M”、“G”等单位，如：“—limit-rate 1m”为限制最大使用带宽为“1m字节/秒”；<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://www.baidu.com --limit-rate 10k</span><br></pre></td></tr></table></figure></p>
<ul>
<li>下载</li>
</ul>
<p>显示进度条(option：-#)或不显示进度条(option：-s)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -O https://img1.kiosk007.top/static/images/network/curl/curl-command.png</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p>curl 命令提供了 -w 参数，这个参数在 manpage 是这样解释的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-w, --write-out &lt;format&gt;</span><br><span class="line">              Make curl display information on stdout after a completed transfer. The format is a string that may contain plain text mixed with any number of variables. The</span><br><span class="line">              format can be specified as a literal <span class="string">&quot;string&quot;</span>, or you can have curl <span class="built_in">read</span> the format from a file with <span class="string">&quot;@filename&quot;</span> and to tell curl  to  <span class="built_in">read</span>  the  format  from</span><br><span class="line">              stdin you write <span class="string">&quot;@-&quot;</span>.</span><br><span class="line"></span><br><span class="line">              The  variables  present <span class="keyword">in</span> the output format will be substituted by the value or text that curl thinks fit, as described below. All variables are specified as</span><br><span class="line">              %&#123;variable_name&#125; and to output a normal % you just write them as %%. You can output a newline by using \n, a carriage <span class="built_in">return</span> with \r and a tab space with \t.</span><br><span class="line"></span><br><span class="line">              The output will be written to standard output, but this can be switched to standard error by using %&#123;stderr&#125;.</span><br><span class="line"></span><br><span class="line">              NOTE: The %-symbol is a special symbol <span class="keyword">in</span> the win32-environment, <span class="built_in">where</span> all occurrences of % must be doubled when using this option.</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>它能够按照指定的格式打印某些信息，里面可以使用某些特定的变量，而且支持 \n、\t和 \r 转义字符。提供的变量很多，比如 status<em>code、local_port、size_download 等等，这篇文章我们只关注和请求时间有关的变量（以 time</em> 开头的变量）。</p>
<p>具体支持的变量如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% content_type   The Content-Type of the requested document, <span class="keyword">if</span> there was any.</span><br><span class="line"></span><br><span class="line">% filename_effective   The ultimate filename that curl writes out to. This is only meaningful <span class="keyword">if</span> curl is told to write to a file with the  -O,  --remote-name  or  -o, --output option. It<span class="string">&#x27;s most useful in combination with the -J, --remote-header-name option. (Added in 7.26.0)&#x27;</span></span><br><span class="line"></span><br><span class="line">% ftp_entry_path The initial path curl ended up <span class="keyword">in</span> when logging on to the remote FTP server. (Added <span class="keyword">in</span> 7.15.4)</span><br><span class="line"></span><br><span class="line">% http_code      The  numerical  response  code  that was found <span class="keyword">in</span> the last retrieved HTTP(S) or FTP(s) transfer. In 7.18.2 the <span class="built_in">alias</span> response_code was added to show the same info.</span><br><span class="line"></span><br><span class="line">% http_connect   The numerical code that was found <span class="keyword">in</span> the last response (from a proxy) to a curl CONNECT request. (Added <span class="keyword">in</span> 7.12.4)</span><br><span class="line"></span><br><span class="line">% http_version   The http version that was effectively used. (Added <span class="keyword">in</span> 7.50.0)</span><br><span class="line"></span><br><span class="line">% local_ip       The IP address of the <span class="built_in">local</span> end of the most recently <span class="keyword">done</span> connection - can be either IPv4 or IPv6 (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% local_port     The <span class="built_in">local</span> port number of the most recently <span class="keyword">done</span> connection (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% num_connects   Number of new connects made <span class="keyword">in</span> the recent transfer. (Added <span class="keyword">in</span> 7.12.3)</span><br><span class="line"></span><br><span class="line">% num_redirects  Number of redirects that were followed <span class="keyword">in</span> the request. (Added <span class="keyword">in</span> 7.12.3)</span><br><span class="line"></span><br><span class="line">% proxy_ssl_verify_result   The result of the HTTPS proxy<span class="string">&#x27;s SSL peer certificate verification that was requested. 0  means  the  verification  was  successful.  (Added  in 7.52.0)&#x27;</span></span><br><span class="line"></span><br><span class="line">% redirect_url   When an HTTP request was made without -L, --location to follow redirects (or when --max-redir is met), this variable will show the actual URL a redirect would have gone to. (Added <span class="keyword">in</span> 7.18.2)</span><br><span class="line"></span><br><span class="line">% remote_ip      The remote IP address of the most recently <span class="keyword">done</span> connection - can be either IPv4 or IPv6 (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% remote_port    The remote port number of the most recently <span class="keyword">done</span> connection (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>先往文本文件 curl-format.txt 写入下面的内容：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ cat curl-format.txt</span><br><span class="line">time_namelookup:  %&#123;time_namelookup&#125;\n</span><br><span class="line">time_connect:  %&#123;time_connect&#125;\n</span><br><span class="line">time_appconnect:  %&#123;time_appconnect&#125;\n</span><br><span class="line">time_pretransfer:  %&#123;time_pretransfer&#125;\n</span><br><span class="line">time_redirect:  %&#123;time_redirect&#125;\n</span><br><span class="line">time_starttransfer:  %&#123;time_starttransfer&#125;\n</span><br><span class="line">----------\n</span><br><span class="line">time_total:  %&#123;time_total&#125;\n</span><br><span class="line">http_code:  %&#123;http_code&#125;\n</span><br><span class="line">----------\n</span><br><span class="line">local_ip:  %&#123;local_ip&#125;\n</span><br><span class="line">size_download:  %&#123;size_download&#125;\n</span><br><span class="line">size_header:  %&#123;size_header&#125;\n</span><br><span class="line">size_request:  %&#123;size_request&#125;\n</span><br><span class="line">size_upload:  %&#123;size_upload&#125;\n</span><br><span class="line">speed_download:  %&#123;speed_download&#125;\n</span><br><span class="line">speed_upload:  %&#123;speed_upload&#125;\n</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>ime_namelookup：DNS 域名解析的时候，就是把 <a href="https://zhihu.com">https://zhihu.com</a> 转换成 ip 地址的过程</li>
<li>time_connect：TCP 连接建立的时间，就是三次握手的时间</li>
<li>time_appconnect：SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间</li>
<li>time_redirect：从开始到最后一个请求事务的时间</li>
<li>time_pretransfer：从请求开始到响应开始传输的时间</li>
<li>time_starttransfer：从请求开始到第一个字节将要传输的时间</li>
<li>time_total：这次请求花费的全部时间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% curl -w<span class="string">&quot;@curl-format.txt&quot;</span> -o /dev/null -s -L https://kiosk007.top/   </span><br><span class="line">time_namelookup:  0.011032</span><br><span class="line">time_connect:  0.103585</span><br><span class="line">time_appconnect:  0.235695</span><br><span class="line">time_pretransfer:  0.235911</span><br><span class="line">time_redirect:  0.000000</span><br><span class="line">time_starttransfer:  0.375289</span><br><span class="line">----------</span><br><span class="line">time_total:  0.657439</span><br><span class="line">http_code:  200</span><br><span class="line">----------</span><br><span class="line">local_ip:  192.168.0.112</span><br><span class="line">size_download:  18180</span><br><span class="line">size_header:  661</span><br><span class="line">size_request:  74</span><br><span class="line">size_upload:  0</span><br><span class="line">speed_download:  27671.000</span><br><span class="line">speed_upload:  0.000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="HTTP3-新特性"><a href="#HTTP3-新特性" class="headerlink" title="HTTP3 新特性"></a>HTTP3 新特性</h1><p><a href="https://curl.se/docs/http3.html">https://curl.se/docs/http3.html</a></p>
<p>curl 可以基于 <a href="https://github.com/cloudflare/quiche">quiche</a> 实现HTTP3 的能力，当前H3的草案还没有完全定稿，所以curl 的quic不一定能够访问成功所有的QUIC服务端实现。</p>
<p>通过以下方式编译支持H3特性的curl</p>
<p>Build quiche and BoringSSL:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% git <span class="built_in">clone</span> --recursive https://github.com/cloudflare/quiche</span><br><span class="line">% <span class="built_in">cd</span> quiche</span><br><span class="line">% cargo build --release --features ffi,pkg-config-meta,qlog</span><br><span class="line">% mkdir deps/boringssl/src/lib</span><br><span class="line">% ln -vnf $(find target/release -name libcrypto.a -o -name libssl.a) deps/boringssl/src/lib/</span><br></pre></td></tr></table></figure><br>Build curl:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">cd</span> ..</span><br><span class="line">% git <span class="built_in">clone</span> https://github.com/curl/curl</span><br><span class="line">% <span class="built_in">cd</span> curl</span><br><span class="line">% ./buildconf</span><br><span class="line">% ./configure LDFLAGS=<span class="string">&quot;-Wl,-rpath,<span class="variable">$PWD</span>/../quiche/target/release&quot;</span> --with-openssl=<span class="variable">$PWD</span>/../quiche/deps/boringssl/src --with-quiche=<span class="variable">$PWD</span>/../quiche/target/release</span><br><span class="line">% make</span><br></pre></td></tr></table></figure><br>Use HTTP/3 directly:</p>
<p><code>curl --http3 https://nghttp2.org:4433/</code><br>Upgrade via Alt-Svc:</p>
<p><code>curl --alt-svc altsvc.cache https://quic.aiortc.org/</code></p>
<p>See this list of <a href="https://bagder.github.io/HTTP3-test/">public HTTP/3 servers</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>ops</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 测试框架 stretchr/testify</title>
    <url>/2021/04/29/Go-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-stretchr-testify/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>golang的测试框架stretchr/testify 简单的API去检验你的GoLang代码按照你的意愿运行。</p>
<p>项目地址： <code>https://github.com/stretchr/testify</code></p>
<a id="more"></a>
<p><strong>特性：</strong></p>
<ul>
<li>易用的断言接口 (<a href="https://github.com/stretchr/testify#assert-package">Easy assertions</a>)</li>
<li>接口模拟 (<a href="https://github.com/stretchr/testify#mock-package">Mocking</a>)</li>
<li>测试套件接口与性能 (<a href="https://github.com/stretchr/testify#suite-package">Testing suite interfaces and functions</a>)</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用 <code>go get</code> 安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get github.com/stretchr/testify</span><br></pre></td></tr></table></figure><br>安装后获得以下包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">github.com/stretchr/testify/assert</span><br><span class="line">github.com/stretchr/testify/require</span><br><span class="line">github.com/stretchr/testify/mock</span><br><span class="line">github.com/stretchr/testify/suite</span><br><span class="line">github.com/stretchr/testify/http (deprecated</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>assert package</li>
<li>require package</li>
<li>mock package</li>
<li>suite package</li>
</ul>
<p><strong>这里面最常用的是前两个 package，他们的唯一差别就是require的函数会直接导致case结束，而assert虽然也标记为case失败，但case不会退出，而是继续往下执行
</strong></p>
<h2 id="assert-package"><a href="#assert-package" class="headerlink" title="assert package"></a>assert package</h2><p><code>assert</code> 包提供了一些有用的方法，允许您在Go中编写更好的测试代码。</p>
<ul>
<li>友好输出，更详细的问题描述</li>
<li>代码可读性强</li>
<li>可以选择用消息注释断言</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCase1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	name := <span class="string">&quot;Bob&quot;</span></span><br><span class="line">	age := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	assert.Equal(t, <span class="string">&quot;Bob&quot;</span>, name)</span><br><span class="line">	assert.Equal(t, <span class="number">20</span>, age,<span class="string">&quot;年龄不相等&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=== RUN   TestCase1</span><br><span class="line">    TestCase1: abc_test.go:18: </span><br><span class="line">        	Error Trace:	abc_test.go:18</span><br><span class="line">        	Error:      	Not equal: </span><br><span class="line">        	            	expected: 20</span><br><span class="line">        	            	actual  : 10</span><br><span class="line">        	Test:       	TestCase1</span><br><span class="line">        	Messages:   	年龄不相等</span><br><span class="line">--- FAIL: TestCase1 (0.00s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Expected :20</span><br><span class="line">Actual   :10</span><br><span class="line">&lt;Click to see difference&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FAIL</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="require-package"><a href="#require-package" class="headerlink" title="require package"></a>require package</h2><p><code>require</code>包提供与assert包相同的全局函数，但它们不会返回布尔结果，而是终止当前测试。</p>
<h2 id="mock-package"><a href="#mock-package" class="headerlink" title="mock package"></a>mock package</h2><p><code>mock</code>包提供了一种机制，可以方便地编写mock对象，在编写测试代码时可以用它代替真实对象。</p>
<p>如下一个示例测试函数，它测试依赖外部对象<code>testObj</code>的一段代码，可以设置期望（证明）并断言它们确实发生了。</p>
<p>例如，一个是消息服务或电子邮件服务，无论何时被调用，都会向客户端发送电子邮件。如果我们正在积极地开发我们的代码库，可能每天会运行数百次测试，但我们不希望每天向客户发送数百封电子邮件或消息，因为那样他们可能会不高兴。</p>
<blockquote>
<p>那么，我们要如何使用 testify 包来模拟呢？</p>
</blockquote>
<p>让我们来看一下如何将 <code>mocks</code> 应用到一个相当简单的例子中。在这个例子中，我们有一个系统会尝试向客户收取产品或服务的费用。当 <code>ChargeCustomer()</code> 被调用时，它将随后调用 <code>Message Service</code>，向客户发送 SMS 文本消息来通知他们已经被收取的金额。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MessageService 通知客户被收取的费用</span></span><br><span class="line"><span class="keyword">type</span> MessageService <span class="keyword">interface</span> &#123;</span><br><span class="line">	SendChargeNotification(<span class="keyword">int</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SMSService 是 MessageService 的实现</span></span><br><span class="line"><span class="keyword">type</span> SMSService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyService 使用 MessageService 来通知客户</span></span><br><span class="line"><span class="keyword">type</span> MyService <span class="keyword">struct</span> &#123;</span><br><span class="line">	messageService MessageService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SendChargeNotification 通过 SMS 来告知客户他们被收取费用</span></span><br><span class="line"><span class="comment">// 这就是我们将要模拟的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sms SMSService)</span> <span class="title">SendChargeNotification</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sending Production Charge Notification&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChargeCustomer 向客户收取费用</span></span><br><span class="line"><span class="comment">// 在真实系统中，我们会模拟这个</span></span><br><span class="line"><span class="comment">// 但是在这里，我想在每次运行时都赚点钱</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a MyService)</span> <span class="title">ChargeCustomer</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	a.messageService.SendChargeNotification(value)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Charging Customer For the value of %d\n&quot;</span>, value)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 &quot;Production&quot; 例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">	smsService := SMSService&#123;&#125;</span><br><span class="line">	myService := MyService&#123;smsService&#125;</span><br><span class="line">	myService.ChargeCustomer(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，我们如何进行测试以确保我们不会让客户疯掉？好吧，我们通过创建一个新的 struct 称之为 <code>smsServiceMock</code> ，用来模拟我们的 <code>SMSService</code>，并且将 <code>mock.Mock</code> 添加到它的字段列表中。</p>
<p>然后我们将改写 <code>SendChargeNotification</code> 方法，这样它就不会向我们的客户发送通知并返回 nil 错误。</p>
<p>最后，我们创建 <code>TestChargeCustomer</code> 测试函数，接着实例化一个新的类型实例 <code>smsServiceMock</code> 并指定 <code>SendChargeNotification</code>在被调用时应该做什么。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// smsServiceMock</span></span><br><span class="line"><span class="keyword">type</span> smsServiceMock <span class="keyword">struct</span> &#123;</span><br><span class="line">	mock.Mock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们模拟的 smsService 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m smsServiceMock)</span> <span class="title">SendChargeNotification</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Mocked charge notification function&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Value passed in: %d\n&quot;</span>, value)</span><br><span class="line">	<span class="comment">// 这将记录方法被调用以及被调用时传进来的参数值</span></span><br><span class="line">	args := m.Called(value)</span><br><span class="line">	<span class="comment">// 它将返回任何我需要返回的</span></span><br><span class="line">	<span class="comment">// 这种情况下模拟一个 SMS Service Notification 被发送出去</span></span><br><span class="line">	args.Bool(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestChargeCustomer 是个奇迹发生的地方</span></span><br><span class="line"><span class="comment">// 在这里我们将创建 SMSService mock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChargeCustomer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> smsService smsServiceMock</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后我们将定义当 100 传递给 SendChargeNotification 时，需要返回什么</span></span><br><span class="line">	<span class="comment">// 在这里，我们希望它在成功发送通知后返回 true</span></span><br><span class="line">	smsService.On(<span class="string">&quot;SendChargeNotification&quot;</span>, <span class="number">100</span>).Return(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来，我们要定义要测试的服务</span></span><br><span class="line">	myService := MyService&#123;smsService&#125;</span><br><span class="line">	<span class="comment">// 然后调用方法</span></span><br><span class="line">	myService.ChargeCustomer(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后，我们验证 myService.ChargeCustomer 调用了我们模拟的 SendChargeNotification 方法</span></span><br><span class="line">	smsService.AssertExpectations(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当我们运行 <code>go test ./... -v</code>时，我们应该看到以下输出：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test ./... -v</span><br><span class="line">=== RUN   TestChargeCustomer</span><br><span class="line">Mocked charge notification function</span><br><span class="line">Value passed in: <span class="number">100</span></span><br><span class="line">Charging Customer For the value of <span class="number">100</span></span><br><span class="line">--- PASS: TestChargeCustomer (<span class="number">0.00</span>s)</span><br><span class="line">    main_test.<span class="keyword">go</span>:<span class="number">33</span>: PASS:      SendChargeNotification(<span class="keyword">int</span>)</span><br><span class="line">PASS</span><br><span class="line">ok      _/Users/elliot/Documents/Projects/tutorials/golang/<span class="keyword">go</span>-testify-tutorial  <span class="number">0.012</span>s</span><br></pre></td></tr></table></figure>
<p>这证明我们的 myService.ChargeCustomer() 方法按照我们所期望的方式在运行！</p>
<p>我们现在已经能够使用模拟的方法来全面测试更复杂的项目。值得注意的是，此技术可用于各种不同的系统，例如模拟数据库查询或者是如何与其他 API 交互。总的来说，模拟是非常强大的手段</p>
<h2 id="suite-package"><a href="#suite-package" class="headerlink" title="suite package"></a>suite package</h2><p>这个包不太常用</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建我的ELK 7.12</title>
    <url>/2021/03/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84ELK-7-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。</p>
<p>“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。</p>
<p>引用官网的一句话：</p>
<blockquote>
<p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="https://img1.kiosk007.top/static/images/elk/elk.png" style="height:500px"></p>
<p><strong>ElasticSearch 的目录结构</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th style="text-align:right">配置文件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bin</td>
<td style="text-align:right"></td>
<td style="text-align:center">脚本文件，包括启动elasticsearch，安装插件，运行统计数据等 </td>
</tr>
<tr>
<td>config</td>
<td style="text-align:right">elasticsearch.yml</td>
<td style="text-align:center">集群配置文件，user，role based 相关配置</td>
</tr>
<tr>
<td>JDK</td>
<td style="text-align:right"></td>
<td style="text-align:center">java 运行环境</td>
</tr>
<tr>
<td>data</td>
<td style="text-align:right">path.data</td>
<td style="text-align:center">数据文件</td>
</tr>
<tr>
<td>lib</td>
<td style="text-align:right"></td>
<td style="text-align:center">java 类库</td>
</tr>
<tr>
<td>logs</td>
<td style="text-align:right">path.log</td>
<td style="text-align:center">日志文件</td>
</tr>
<tr>
<td>modules</td>
<td style="text-align:right"></td>
<td style="text-align:center">包含所有ES模块</td>
</tr>
<tr>
<td>plugins</td>
<td style="text-align:right"></td>
<td style="text-align:center">包含所有已经安装的插件</td>
</tr>
</tbody>
</table>
</div>
<h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><p>官方文档 Set up Elasticsearch 有各个 OS 的安装指导，页面 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/install-elasticsearch.html">Installing Elasticsearch</a> 中提供了多种安装包对应的指导链接！</p>
<p>本文选择绿色安装包的的方式（tar.gz）安装。</p>
<ul>
<li>安装环境： ubuntu 20.04</li>
<li>下载链接： <a href="https://mirrors.huaweicloud.com/elasticsearch/">华为镜像站</a> 速度能快一点</li>
</ul>
<p>说明：ElasticSearch使用java语言开发，所以默认需要安装并配置JDK，设置 JAVA_HOME, 但是从 7.0 开始，ElasticSearch 内置了Java环境，无需再安装。另外ES启动不能使用root用户</p>
<p>内核参数修改（32C + 128G参考）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改文件描述符数量</span></span><br><span class="line">grep <span class="string">&quot;* - nofile 512000&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span>  <span class="string">&quot;* - nofile 512000&quot;</span>  &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改最大打开进程数数量</span></span><br><span class="line">grep <span class="string">&quot;work - nproc unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;elasticsearch - nproc unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"><span class="comment">#配合es mem lock，centos6无须添加</span></span><br><span class="line">grep <span class="string">&quot;* soft memlock unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;* soft memlock unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#配合es mem lock，centos6无须添加</span></span><br><span class="line">grep <span class="string">&quot;* hard memlock unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;* hard memlock unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改系统文件描述符</span></span><br><span class="line">grep <span class="string">&quot;fs.file-max = 1024000&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;fs.file-max = 1024000&quot;</span>  &gt;&gt; /etc/sysctl.conf </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改程序最大管理的vm</span></span><br><span class="line">grep <span class="string">&quot;vm.max_map_count = 262144&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.max_map_count = 262144&quot;</span>  &gt;&gt;  /etc/sysctl.conf  </span><br><span class="line"></span><br><span class="line">grep  <span class="string">&quot;vm.min_free_kbytes = 2097152&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.min_free_kbytes = 2097152&quot;</span>  &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">grep  <span class="string">&quot;vm.zone_reclaim_mode = 0&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.zone_reclaim_mode = 0&quot;</span>  &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">swapoff -a   <span class="comment">#关闭虚拟内存</span></span><br></pre></td></tr></table></figure>
<h2 id="1-安装-elasticsearch"><a href="#1-安装-elasticsearch" class="headerlink" title="1. 安装 elasticsearch"></a>1. 安装 elasticsearch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xf elasticsearch-7.12.0-linux-x86_64.tar.gz -C ~</span><br><span class="line"><span class="built_in">cd</span> ~/elasticsearch-7.12.0</span><br><span class="line">./bin/elasticsearch  <span class="comment"># 启动</span></span><br></pre></td></tr></table></figure>
<p>启动成功后访问本地的 9200 端口，可以看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl 127.0.0.1:9200</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;k8s-master&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;sEn3TgEVSnW4kHpIAU1-5Q&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : <span class="string">&quot;7.12.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_type&quot;</span> : <span class="string">&quot;tar&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_hash&quot;</span> : <span class="string">&quot;78722783c38caa25a70982b5b042074cde5d3b3a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_date&quot;</span> : <span class="string">&quot;2021-03-18T06:17:15.410153305Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;lucene_version&quot;</span> : <span class="string">&quot;8.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;6.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p class="div-border red">如果有安装的错误，参考：</p>

<ul>
<li><strong>seccomp unavailable 错误</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方法：elasticsearch.yml 配置</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure></li>
<li><strong>max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方法：修改 &#x2F;etc&#x2F;security&#x2F;limits.conf，配置：</span><br><span class="line">hard nofile 80000</span><br><span class="line">soft nofile 80000</span><br></pre></td></tr></table></figure></li>
<li><strong>max virtual memory areas vm.max_map_count [65530] is too low</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方法：修改 &#x2F;etc&#x2F;sysctl.conf，添加 ：</span><br><span class="line">vm.max_map_count &#x3D; 262144</span><br><span class="line">然后 sysctl -p 生效</span><br></pre></td></tr></table></figure>
<blockquote>
<p>安装插件方式：./bin/elasticsearch-plugin install analysis-icu</p>
</blockquote>
</li>
</ul>
<p><strong>ES 相关配置</strong></p>
<ul>
<li>官网关于配置的内容主要有两处：<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html">Configuring Elasticsearch</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">Important Elasticsearch configuration</a></li>
</ul>
</li>
<li>Elasticsearch 主要有三个配置文件：<ul>
<li><code>elasticsearch.yml</code>：ES的配置文件 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">more</a></li>
<li><code>jvm.options</code>: ES JVM 参数 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/jvm-options.html#jvm-options">more</a></li>
<li><code>log4j2.properties</code>: ES log 配置 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/logging.html#logging">more</a></li>
</ul>
</li>
</ul>
<p>默认情况，ES 告诉 JVM 使用一个最小和最大都为 4GB 的堆。但是到了生产环境，这个配置就比较重要了，确保 ES 有足够堆空间可用。</p>
<blockquote>
<p>但是我的XPS 16G内存。不改堆内存大小的只能起一个实例，再起其他实例，旧的实例总显示 Killed。<br>修复方式，更改 <code>./config/jvm.options</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms1g </span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>运行多个Elasticsearch 实例</strong></p>
<p>每个实例的配置文件需要不同，这里降低复杂度，不修改配置文件，而是直接用命令行的形式启动一个集群。</p>
<ul>
<li>启动实例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动实例1</span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -Enode.name=node0 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">false</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9200 -E transport.tcp.port=9300 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-E cluster.initial_master_nodes=<span class="string">&quot;node0&quot;</span> -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动实例2 </span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -E node.name=node1 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">true</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E path.data=./data/data_node1 -E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9201 -E transport.tcp.port=9301 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动实例3 </span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -E node.name=node2 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">true</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E path.data=./data/data_node2 -E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9202 -E transport.tcp.port=9302 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-d</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>9300端口： ES节点之间通讯使用</li>
<li>9200端口： ES节点 和 外部 通讯使用</li>
<li><code>discovery.seed_hosts</code>: 发现设置。有两种重要的发现和集群形成配置，以便集群中的节点能够彼此发现并且选择一个主节点.其中 <code>discovery.seed_hosts</code> 是组件集群时比较重要的配置，用于启动当前节点时，发现其他节点的初始列表。<br>当一个已经加入过集群的节点重启时，如果他无法与之前集群中的节点通信，很可能就会报这个错误 master not discovered or elected yet, an election requires at least 2 nodes with ids from。必须至少配置 [discovery.seed_hosts，discovery.seed_providers，cluster.initial_master_nodes] 中的一个。</li>
<li><code>cluster.initial_master_nodes</code>: 初始的候选 master 节点列表。初始主节点应通过其 node.name 标识，默认为其主机名。确保 cluster.initial_master_nodes 中的值与 node.name 完全匹配。<p class="div-border red">`cluster.initial_master_nodes` 该配置项并不是需要每个节点设置保持一致，设置需谨慎，如果其中的主节点关闭了，可能会导致其他主节点也会关闭。因为一旦节点初始启动时设置了这个参数，它下次启动时还是会尝试和当初指定的主节点链接，当链接失败时，自己也会关闭！
因此，为了保证可用性，预备做主节点的节点不用每个上面都配置该配置项！保证有的主节点上就不设置该配置项，这样当有主节点故障时，还有可用的主节点不会一定要去寻找初始节点中的主节点！</p></li>
<li>详细资料参考：<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-discovery-bootstrap-cluster.html">Bootstrapping a cluster</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-settings.html">Discovery and cluster formation settings</a></li>
</ul>
</li>
</ul>
<p>在新版 7.x 的 ES 中，对 ES 的集群发现系统做了调整，不再有 discovery.zen.minimum_master_nodes 这个控制集群脑裂的配置，转而由集群自主控制，并且新版在启动一个新的集群的时候需要有cluster.initial_master_nodes 初始化集群主节点列表。如果一个集群一旦形成，你不该再设置该配置项，应该移除它。该配置项仅仅是集群第一次创建时设置的！集群形成之后，这个配置也会被忽略的！</p>
<ul>
<li><code>discovery.seed_hosts</code>: 提供群集中符合master节点资格的地址列表</li>
</ul>
</blockquote>
<p>node0 节点仅仅是一个 master 节点，它不是一个数据节点。</p>
<p>先启动 node0 节点，因为它设置了初始主节点的列表。这时候就可以使用 <code>http://&lt;host IP&gt;:9200/</code> 看到结果了。然后逐一启动 node1 和 node2。通过访问 <code>http://127.0.0.1:9200/_cat/nodes</code> 查看集群是否 OK。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl 127.0.0.1:9200/_cat/nodes</span><br><span class="line">127.0.0.1 42 49 58 4.45 2.09 1.37 lmr        * node0</span><br><span class="line">127.0.0.1 42 49 54 4.45 2.09 1.37 cdfhlmrstw - node1</span><br><span class="line">127.0.0.1 42 49 45 4.45 2.09 1.37 cdfhlmrstw - node2</span><br></pre></td></tr></table></figure></p>
<h2 id="2-安装-Kibana"><a href="#2-安装-Kibana" class="headerlink" title="2. 安装 Kibana"></a>2. 安装 Kibana</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xf kibana-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kibana-7.12.0-linux-x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>启动kibana</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将kibana改成中文</span></span><br><span class="line">vim config/kibana.yml</span><br><span class="line">     i18n.locale: <span class="string">&quot;zh-CN&quot;</span>   <span class="comment">## 最后一行</span></span><br><span class="line">./bin/kibana</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问本地的5601端口<br>查看样例。点击右下角的 <code>try out sample data</code> ，可以导入kibana的测试数据。分别是电商网站报表、航空数据、日志<br><img src="https://img1.kiosk007.top/static/images/elk/kinana_home.png"><br>这里分 <a href="https://www.elastic.co/cn/enterprise-search?elektra=home&amp;storm=river1">Enterprise Search(企业搜索)</a>、<a href="https://www.elastic.co/guide/en/observability/7.9/observability-introduction.html">Observability(监控)</a>、<a href="https://www.elastic.co/guide/en/security/7.9/es-overview.html">Security(安全)</a></p>
<ul>
<li>Enterprise Search(企业搜索)：可建立强大的搜索体验，当然是付费滴。</li>
<li>Observability(监控)：日志、APM、站点SLA监控、指标打点。（支持Nginx、MySQL、Redis等日志）</li>
<li>Security(安全): 安全相关的解决方案</li>
</ul>
<p>另外还开以打开 <code>http://127.0.0.1:5601/app/dev_tools#/console</code> 控制台，这个是直接对接 ES 的。可在这里直接使用查询语句。</p>
<h2 id="3-安装-Logstash"><a href="#3-安装-Logstash" class="headerlink" title="3. 安装 Logstash"></a>3. 安装 Logstash</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-安装-cerebro"><a href="#4-安装-cerebro" class="headerlink" title="4. 安装 cerebro"></a>4. 安装 cerebro</h2><p>cerebro是专业化项目管理系统，提供一个协作工作环境和项目管理软件，用于处理复杂的视觉材料。它<br>专为 CGI 和动画工作室、广告公司、电视公司和建筑设计公司而开发。也可以说它是一款Elasticsearch监控工具。</p>
<p>安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/lmenezes/cerebro/releases/download/v0.9.3/cerebro-0.9.3.tgz</span><br><span class="line">tar -xf cerebro-0.9.3.tgz </span><br><span class="line"><span class="built_in">cd</span> cerebro-0.9.3 </span><br><span class="line">./bin/cerebro   <span class="comment"># 启动</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>cerebro 需要 java 才能运行，没有java环境的化，可以执行 <code>sudo apt install openjdk-11-jdk</code> 。 Java 11 是 Java 的一个长期支持版本（LTS）。它同时也是 Ubuntu 20.04的默认 Java 开发和运行环境。</p>
</blockquote>
<p>访问 <code>http://127.0.0.1:9000</code> 浏览器打开。</p>
<p><img src="https://img1.kiosk007.top/static/images/elk/cerebro.png
 "></p>
<p>点击左上方 node，可查看节点情况。</p>
<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>下载测试样本 movielens<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://files.grouplens.org/datasets/movielens/ml-20m.zip</span><br><span class="line">unzip ml-20m.zip</span><br></pre></td></tr></table></figure><br>开始配置文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">&quot;/home/work/logs/ml-20m/movies.csv&quot;</span></span><br><span class="line">    start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">    sincedb_path =&gt; <span class="string">&quot;/dev/null&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  csv &#123;</span><br><span class="line">    separator =&gt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    columns =&gt; [<span class="string">&quot;id&quot;</span>,<span class="string">&quot;content&quot;</span>,<span class="string">&quot;genre&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123; <span class="string">&quot;genre&quot;</span> =&gt; <span class="string">&quot;|&quot;</span> &#125;</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;path&quot;</span>, <span class="string">&quot;host&quot;</span>,<span class="string">&quot;@timestamp&quot;</span>,<span class="string">&quot;message&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line"></span><br><span class="line">    split =&gt; [<span class="string">&quot;content&quot;</span>, <span class="string">&quot;(&quot;</span>]</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;title&quot;</span> =&gt; <span class="string">&quot;%&#123;[content][0]&#125;&quot;</span>&#125;</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;year&quot;</span> =&gt; <span class="string">&quot;%&#123;[content][1]&#125;&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    convert =&gt; &#123;</span><br><span class="line">      <span class="string">&quot;year&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    strip =&gt; [<span class="string">&quot;title&quot;</span>]</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;path&quot;</span>, <span class="string">&quot;host&quot;</span>,<span class="string">&quot;@timestamp&quot;</span>,<span class="string">&quot;message&quot;</span>,<span class="string">&quot;content&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch &#123;</span><br><span class="line">     hosts =&gt; <span class="string">&quot;http://localhost:9200&quot;</span></span><br><span class="line">     index =&gt; <span class="string">&quot;movies&quot;</span></span><br><span class="line">     document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>导入测试数据到ES中<br><code>logstash -f log.conf</code></p>
]]></content>
  </entry>
  <entry>
    <title>Worker Pool in Golang</title>
    <url>/2021/03/21/Worker-Pool-in-Golang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。但是，如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响</p>
<a id="more"></a>
<h1 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h1><p>Pool 的出现，可以避免反复的创建一些对象，比如 TCP链接、数据库链接等等，这些对象创建都比较耗时，如果将创建好的对象放入到池子中，需要的时候取，不需要的时候归还池子，将是一个非常不错的实现方式。</p>
<p>通过创建一个 Worker Pool 来减少 goroutine 的使用。比如，我们实现一个 TCP 服务器，如果每一个连接都要由一个独立的 goroutine 去处理的话，在大量连接的情况下，就会创建大量的 goroutine，这个时候，我们就可以创建一个固定数量的 goroutine（Worker），由这一组 Worker 去处理连接，比如 fasthttp 中的<a href="https://github.com/valyala/fasthttp/blob/9f11af296864153ee45341d3f2fe0f5178fd6210/workerpool.go#L16">Worker Pool</a>。</p>
<ul>
<li><p>著名的TCP连接池实现：fatih 开发的 <a href="https://github.com/fatih/pool">fatih/pool</a>, 虽然已经归档，但是这是由于这个项目已经足够稳定。</p>
</li>
<li><p>数据库连接池实现：database/sql 可以参考这篇分析 <a href="https://blog.csdn.net/qq_39384184/article/details/103954821">Golang 侧数据库连接池原理和参数调优</a>，同样使用方式直接参考 <a href="https://www.jianshu.com/p/2d58243fae22">这篇文章</a></p>
</li>
</ul>
<p><strong>一句话总结：保存和复用临时对象，减少内存分配，降低 GC 压力。</strong></p>
<p>举例：<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Age    <span class="keyword">int32</span></span><br><span class="line">	Remark [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf, _ = json.Marshal(Student&#123;Name: <span class="string">&quot;Geektutu&quot;</span>, Age: <span class="number">25</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarsh</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stu := &amp;Student&#123;&#125;</span><br><span class="line">	json.Unmarshal(buf, stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>json 的反序列化在文本解析和网络通信过程中非常常见，当程序并发度非常高的情况下，短时间内需要创建大量的临时对象。而这些对象是都是分配在堆上的，会给 GC 造成很大压力，严重影响程序的性能。</p>
<p><strong>声明对象池</strong></p>
<p>只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> studentPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(Student) </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Get &amp;&amp; Put </strong><br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">stu := studentPool.Get().(*Student)</span><br><span class="line">json.Unmarshal(buf, stu)</span><br><span class="line">studentPool.Put(stu)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。</li>
<li>Put() 则是在对象使用完毕后，返回对象池。</li>
</ul>
<h1 id="gammazero-workerpool"><a href="#gammazero-workerpool" class="headerlink" title="gammazero/workerpool"></a>gammazero/workerpool</h1><p><a href="https://pkg.go.dev/github.com/gammazero/workerpool">gammazero/workerpool</a> gammazero/workerpool 可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</p>
<p>下面做一些介绍</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gammazero/workerpool&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wp := workerpool.New(<span class="number">2</span>)</span><br><span class="line">	requests := []<span class="keyword">string</span>&#123;<span class="string">&quot;alpha&quot;</span>, <span class="string">&quot;beta&quot;</span>, <span class="string">&quot;gamma&quot;</span>, <span class="string">&quot;delta&quot;</span>, <span class="string">&quot;epsilon&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> requests &#123;</span><br><span class="line">		r := r</span><br><span class="line">		wp.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Handling request:&quot;</span>, r)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wp.StopWait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用提示</strong></li>
</ul>
<p>排队的任务数没有上限，只有系统资源的限制。如果入站任务的数量太多，以至于无法排队等待处理那么解决方案就超出了workerpool的处理范围，应该通过在多个系统上分配负载来解决</p>
<h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h2 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h2><p>用户通过 <code>Submit(task func())</code> 方法提交一个 task 到 task 队列中。<br>task 函数默认没有返回值，如果想要有返回值，可以用管道将task 的返回值传到管道中。</p>
<p>提交的 task 会立即开启一个可用的worker或者新创建一个worker。如果没有可用的worker或者worker数已经达到最大，task会被放入到 task 等待队列中。当worker空闲时会从task 等待队列中取出task。</p>
<p>一个Worker长时间闲置时可以删除并释放资源。</p>
<p>这个函数非常简单，就是将收到的待执行任务放入到 task等待队列中。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">Submit</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> task != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.taskQueue &lt;- task</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有一个变种, 支持同步等待结果<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">SubmitWait</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> task == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	doneChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	p.taskQueue &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		task()</span><br><span class="line">		<span class="built_in">close</span>(doneChan)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-doneChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="New"><a href="#New" class="headerlink" title="New"></a>New</h2><p><code>New()</code> 函数创建了一个 worker goroutines pool 。 Max 指定了最大的worker数量，也就是最大并发的执行数，当没有新到来的 task 时，worker会逐渐减少至0.这里注意 taskQueue 是一个只有1个buffer的缓冲，task等待队列是 <code>waitingQueue()</code> 。dispatch 里实现派发任务的逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxWorkers <span class="keyword">int</span>)</span> *<span class="title">WorkerPool</span></span> &#123;</span><br><span class="line">	<span class="comment">// There must be at least one worker.</span></span><br><span class="line">	<span class="keyword">if</span> maxWorkers &lt; <span class="number">1</span> &#123;</span><br><span class="line">		maxWorkers = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pool := &amp;WorkerPool&#123;</span><br><span class="line">		maxWorkers:  maxWorkers,</span><br><span class="line">		taskQueue:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>, 1),</span></span><br><span class="line">		workerQueue: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>),</span></span><br><span class="line">		stopSignal:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		stoppedChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the task dispatcher.</span></span><br><span class="line">	<span class="keyword">go</span> pool.dispatch()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dispatch 任务派发</strong> 通过设置 idleTimer ，超过这个时间还没有task，就会杀掉一个worker。这个函数刚开始判断等待队列是否为 0，如果不为0，说明任务已经积压，需要将新的task传到等待队列中 ，<code>processWaitingQueue</code>函数内将 task 传给 waitQueue，并在workerQueue有buffer时将任务传给 worker Queue。</p>
<p>如果 waitQueue 不存在（长度为0），说明还不存在任务排队情况，会将task传给 workerQueue（如果workerQueue能把task塞进去的话），如果塞不进去<br>就创建一个新worker，要么worker刚好又不够了（达到最大worker数量），任务扔进 waitQueue。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dispatch sends the next queued task to an available worker.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(p.stoppedChan)</span><br><span class="line">	timeout := time.NewTimer(idleTimeout)</span><br><span class="line">	<span class="keyword">var</span> workerCount <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> idle <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p.waitingQueue.Len() != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !p.processWaitingQueue() &#123;</span><br><span class="line">				<span class="keyword">break</span> Loop</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> task, ok := &lt;-p.taskQueue:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">break</span> Loop</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Got a task to do.</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> p.workerQueue &lt;- task:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// Create a new worker, if not at max.</span></span><br><span class="line">				<span class="keyword">if</span> workerCount &lt; p.maxWorkers &#123;</span><br><span class="line">					<span class="keyword">go</span> startWorker(task, p.workerQueue)</span><br><span class="line">					workerCount++</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// Enqueue task to be executed by next available worker.</span></span><br><span class="line">					p.waitingQueue.PushBack(task)</span><br><span class="line">					atomic.StoreInt32(&amp;p.waiting, <span class="keyword">int32</span>(p.waitingQueue.Len()))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			idle = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">			<span class="comment">// Timed out waiting for work to arrive.  Kill a ready worker if</span></span><br><span class="line">			<span class="comment">// pool has been idle for a whole timeout.</span></span><br><span class="line">			<span class="keyword">if</span> idle &amp;&amp; workerCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> p.killIdleWorker() &#123;</span><br><span class="line">					workerCount--</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			idle = <span class="literal">true</span></span><br><span class="line">			timeout.Reset(idleTimeout)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If instructed to wait, then run tasks that are already queued.</span></span><br><span class="line">	<span class="keyword">if</span> p.wait &#123;</span><br><span class="line">		p.runQueuedTasks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop all remaining workers as they become ready.</span></span><br><span class="line">	<span class="keyword">for</span> workerCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		p.workerQueue &lt;- <span class="literal">nil</span></span><br><span class="line">		workerCount--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timeout.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>waitingQueue</code> 的目的是讲一个新的task放入到等待 task 队列。或者等待工人队列中有可用的工人时将 task 等待队列中取出 task 交给 worker 队列。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">processWaitingQueue</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task, ok := &lt;-p.taskQueue:</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.waitingQueue.PushBack(task)</span><br><span class="line">	<span class="keyword">case</span> p.workerQueue &lt;- p.waitingQueue.Front().(<span class="function"><span class="keyword">func</span><span class="params">()</span>):</span></span><br><span class="line">		<span class="comment">// A worker was ready, so gave task to worker.</span></span><br><span class="line">		p.waitingQueue.PopFront()</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.StoreInt32(&amp;p.waiting, <span class="keyword">int32</span>(p.waitingQueue.Len()))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP/3</title>
    <url>/2021/02/21/HTTP3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不得不说国外的很多文章写的都十分优秀，将技术的历史背景和细节都讲得十分出色。下面是转自 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> ，这里有很多对外国优秀文章的翻译。关于<strong>HTTP/3</strong>相关的知识。下面做一些简短的记录。</p>
<a id="more"></a>
<blockquote>
<ul>
<li>原文地址：HTTP/3: From root to tip</li>
<li>原文作者：Lucas Pardue</li>
<li>译文出自：掘金翻译计划</li>
<li>译者：Starrier</li>
</ul>
</blockquote>
<h1 id="HTTP-3-起源"><a href="#HTTP-3-起源" class="headerlink" title="HTTP/3 起源"></a>HTTP/3 起源</h1><p>HTTP/3 是 QUIC 传输层的 HTTP 应用程序映射。该名称在最近（2018 年 10 月底）草案的第 17 个版本中被正式提出（<a href="https://tools.ietf.org/html/draft-ietf-quic-http-17">draft-ietf-quic-http-17</a>），在 11 月举行的 IETF 103 会议中进行了讨论并形成了初步的共识。HTTP/3 以前被称为 QUIC（以前被称为 HTTP/2）。在此之前，我们已经有了 gQUIC，而在更早之前，我们还有 SPDY。事实是，HTTP/3 只是一种适用于 IETF QUIC 的新 HTTP 语法 —— 基于 UDP 的多路复用和安全传输。</p>
<p>这篇文章将讲述 HTTP/3 的发展历史。详细发展图见 <a href="https://blog.cloudflare.com/content/images/2019/01/web_timeline_large1.svg">Cloudflare Secure Web Timeline</a></p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/gquic-stack.png" style="height:400px"></p>
<p>HTTP/3 分层模型（蛋糕模型）</p>
<h2 id="HTTP-演进"><a href="#HTTP-演进" class="headerlink" title="HTTP 演进"></a>HTTP 演进</h2><p>在我们关注 HTTP 之前，值得回忆的是两个共享 QUIC 的名称。就像我们之前解释得那样，gQUIC 通常是指 Google QUIC（协议起源），QUIC 通常用于表示与 gQUIC 不同的 IETF 标准（正在开发的版本）。</p>
<h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP/1"></a><strong>HTTP/1</strong></h3><p>HTTP/1.1 是非常成功的协议，时间线显示 1999 年以后 IETF 并不活跃。然而，事实是，多年的积极使用，为 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 研究潜在问题提供了实战经验，但这也导致了一些交互操作的问题。此外，RFC（像 2817 和 2818）还对该协议进行了扩展。2007 年决定启动一项改进 HTTP 协议规范的新活动 —— HTTPbis（”bis” 源自拉丁语，意为“二”、“两次”或“重复”），它还采用了新的工作组形式。最初的<a href="https://tools.ietf.org/wg/httpbis/charters?item=charter-httpbis-2007-10-23.txt">章程</a>详细描述了尝试解决的问题。</p>
<p>简而言之，HTTPbis 决定重构 RFC 2616。它将纳入勘误修订，合并在此期间发布的其他规范的一些内容。文件将被分为几个部分，这导致 2017 年 12 月发布了 6 个 I-D：</p>
<ol>
<li>draft-ietf-httpbis-p1-messaging</li>
<li>draft-ietf-httpbis-p2-semantics</li>
<li>draft-ietf-httpbis-p4-conditional</li>
<li>draft-ietf-httpbis-p5-range</li>
<li>draft-ietf-httpbis-p6-cache</li>
<li>draft-ietf-httpbis-p7-auth</li>
</ol>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/http1_refactor.png" style="height:400px"></p>
<p>图表显示了这项工作是如何在长达 7 年的草案过程中取得进展的，在最终被标准化之前，已经发布了 27 份草案。2014 年 6 月，发布了 RFC 723x 系列（x 范围在 0-5）。HTTPbis 工作组的主席以 “<a href="https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead">RFC2616 is Dead</a>“ 来庆祝这一成果。如果它不够清楚，这些新文档就会弃用旧的 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>。</p>
<h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a><strong>SPDY</strong></h3><p>尽管 IETF 的 RFC 723x 系列的工作繁忙，但是技术的进步并未停止。人们继续加强、扩展和测试因特网上的 HTTP。而 Google 已率先开始尝试名为 SPDY（发音同 Speedy）的技术。该协议宣称可以提高 Web 浏览性能，一个使用 HTTP 原则的用例。2009 年底，SPDY v1 发布，2010 年 SPDY v2 紧随其后。</p>
<p>Google 对 SPDY 实验表明，改变 HTTP 语法是有希望的，维持现有 HTTP 语义是有意义的。比如，保留 URL 的使用格式 —— <code>https://</code>，可以避免许多可能影响采用的问题。看到一些积极的结果后，IETF 决定考虑 HTTP/2.0。2012 年 3 月 IETF 83 期间举行的 HTTPbis 会议的 slides显示了请求、目标和成功标准。它还明确指出 “HTTP/2.0 与 HTTP/1.x 连线格式不兼容”。</p>
<h3 id="gQUIC-横空出世"><a href="#gQUIC-横空出世" class="headerlink" title="gQUIC 横空出世"></a><strong>gQUIC 横空出世</strong></h3><p>2012 - 2015 之间，Google 继续进行试验，他们发布了 SPDY v3 和 v3.1。他们还开始研究 gQUIC(当时的发音类似于 quick），在 2012 年年初，发布了初始的公共规范。gQUIC 的早期版本使用 SPDY v3 形式的 HTTP 语法。这个选择是有意义的，因为 HTTP/2 尚未完成。SPDY 二进制语法被打包到可以用 UDP 数据报发送数据的 QUIC 包中。</p>
<p>gQUIC 使用巧妙的设计来实现性能优化。其中一个是破坏应用程序与传输层之间清晰的分层。这也意味着 gQUIC 只支持 HTTP。因此，gQUIC 最后被称为 “QUIC”。它是 HTTP 下一个候选版本的同义词。QUIC 从过去的几年到现在，一直在持续更新，QUIC 也被人们理解为是初始 HTTP 的变体。不幸的是，这正是我们在讨论协议时，经常出现混乱的原因。</p>
<p>gQUIC 继续在实验中摸索，最后选择了更接近 HTTP/2 的语法。也正因为如此，它才被称为 “HTTP/2 over QUIC”。但因为技术上的限制，所有存在一些非常微妙的差别。一个示例是，HTTP 头是如何序列化并交换的。这是一个细微的差别，但实际上，这意味着 HTTP/2 式 gQUIC 与 IETF’s HTTP/2 并不兼容。</p>
<p class="div-border yellow">17年-20年市面上大多商用的QUIC均是gQuic，客户端一般为cronet（chromium的网络库），服务端接入层的Nginx一般经过chromium 的封装 </p>


<p>最后，同样重要的是，我们总是需要考虑互联网协议的安全方面。gQUIC 选择不使用 TLS 来提供安全性。转而使用 Google 开发的另一种称为 QUIC Crypto 的方法。其中一个有趣的方面是有一种加速安全握手的新方法。以前与服务器建立了安全会话的客户端可以重用信息来进行“零延迟往返握手”或 0-RTT 握手。0-RTT 后来被纳入 TLS 1.3。</p>
<h3 id="什么是HTTP-3"><a href="#什么是HTTP-3" class="headerlink" title="什么是HTTP/3"></a>什么是HTTP/3</h3><p>当然，现在可以说什么是HTTP/3 了，gQUIC 并非与众不同。在2015 年 6 月的 draft-tsvwg-quic-protocol-00 中，写有 “QUIC：基于 UDP 的安全可靠的 HTTP/2 传输” 已经提交。请记住我之前提过的，几乎都是 HTTP/2 的语法。</p>
<p>Google <a href="https://groups.google.com/a/chromium.org/forum/#!topic/proto-quic/otGKB4ytAyc">宣布</a>将在布拉格举行一次 Bar BoF IETF 93 会议。如有疑问，请参阅 <a href="https://tools.ietf.org/html/rfc6771">RFC 6771</a>。提示：BoF 是物以类聚（Birds of a Feather）的缩写。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_adoption.png" style="height:400px"></p>
<p>总之，与 IETF 的合作结果是 QUIC 在传输层提供了许多优势，而且它应该与 HTTP 分离。应该重新引入层与层之间清楚的隔离。此外，还有返回基于 TLS 握手的优先级</p>
<p>大约是一年后，在 2016 年，一组新的 I-D 集合被提交：</p>
<ul>
<li><a href="https://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-00">draft-hamilton-quic-transport-protocol-00</a></li>
<li><a href="https://tools.ietf.org/html/draft-thomson-quic-tls-00">draft-thomson-quic-tls-00</a></li>
<li><a href="https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00">draft-iyengar-quic-loss-recovery-00</a></li>
<li><a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a></li>
</ul>
<p>这里是关于 HTTP 和 QUIC 的另一个困惑的来源。<a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a> 题为 “HTTP/2 使用 QUIC 传输协议的语义”，对于自己的描述是 “HTTP/2 式 QUIC 的另一种语义映射”。但这个解释并不正确。HTTP/2 在维护语义的同时，改变了语法。而且，我很早之前就说过了，”HTTP/2 式 gQUIC” 从未对语法进行确切的描述，记住这个概念。</p>
<p>2016 年在柏林举行 IETF 96 会议决定了有数百人参加了这次会议。会议结束时，达成了一致的共识：<strong>QUIC 将被 IETF 采用并标准化。</strong></p>
<p class="div-border green">之后的QUIC必将全面IETF化</p>


<p>将 HTTP 映射到 QUIC 的第一个 IETF QUIC I-D —— <a href="https://tools.ietf.org/html/draft-ietf-quic-http-00">draft-ietf-quic-http-00</a>，采用了 Ronseal 方法来简化命名 —— “HTTP over QUIC”。不幸的是，它并没有达到预期效果，整个内容中都残留有 HTTP/2 术语的实例。Mike Bishop —— I-D 的新编辑，发现并修复了 HTTP/2 的错误名称。在 01 草案中，将描述修改为 “a mapping of HTTP semantics over QUIC”。</p>
<p>随着时间和版本的推进，”HTTP/2” 的使用逐渐减少，实例部分仅仅是对 <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> 部分的引用。从 2018 年 10 月开始向前回退两年的时间开始计算，I-D 如今已经是第 16 版本。虽然 HTTP over QUIC 与 HTTP/2 有相似内容，但始终是独立的（非向后兼容的 HTTP 语法）。然而，对那些不密切关注 IETF 发展的人来说（人数众多），他们并不能从名称中发现一些细微的差异。标准化的重点之一是帮助通信和互操作性。但像命名这样的简单事件，才是导致社区相对混乱的主要原因。<br>回顾 2012 年的内容，”HTTP/2.0 意味着 wire 格式与 HTTP/1.x 格式不兼容”。IETF 遵循现有线索。IETF 103 是经过深思熟虑才最终达成一致的，即：”HTTP over QUIC” 命名为 HTTP/3。互联网正在促使世界变得更加美好，我们可以继续进行更加重要的的探讨。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>概况来说就是：HTTP/3 只是一种适用于 IETF QUIC 的新 HTTP 语法 —— 一种基于 UDP 多路复用的安全传输层。仍有许多有趣的领域需要深入探索。</p>
<blockquote>
<p>参考文章</p>
<ul>
<li>：<a href="https://juejin.cn/post/6914561963393548295#heading-11">揭秘QUIC的性能与安全</a></li>
<li>：<a href="https://juejin.cn/post/6908522467107536903#heading-3">Google、Facebook等均开始支持的HTTP3到底是个什么鬼？</a></li>
</ul>
</blockquote>
<h1 id="QUIC的实现"><a href="#QUIC的实现" class="headerlink" title="QUIC的实现"></a>QUIC的实现</h1><h2 id="QUIC-握手"><a href="#QUIC-握手" class="headerlink" title="QUIC 握手"></a>QUIC 握手</h2><p>在2016年11月国际互联网工程任务组(IETF)召开的第一次QUIC工作组会议，受到了业界的广泛关注。这也意味着QUIC开始了它的标准化过程，成为新一代传输层协议，形成了最新的iQUIC。<strong>IETF在QUIC的加密协议上就放弃了google的加密协议使用了标准的TLS1.3。</strong></p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_struct.png"></p>
<p><strong>QUIC 握手</strong></p>
<p>QUIC 连接的建立整体流程大致为：QUIC在握手过程中使用Diffie-Hellman算法协商初始密钥，初始密钥依赖于服务器存储的一组配置参数，该参数会周期性的更新。初始密钥协商成功后，服务器会提供一个临时随机数，双方根据这个数再生成会话密钥。客户端和服务器会使用新生的的密钥进行数据加解密。</p>
<p>以上过程主要分为两个步骤：<span class="inline-tag grey">初始握手（Initial handshake）</span>、<span class="inline-tag grey">最终 与重复 握手（Final (and repeat) handshake）</span> ，分别介绍下这两个过程。</p>
<h3 id="初始握手（Initial-handshake）"><a href="#初始握手（Initial-handshake）" class="headerlink" title="初始握手（Initial handshake）"></a>初始握手（Initial handshake）</h3><p>在连接开始建立时，客户端会向服务端发送一个打招呼信息，（inchoate client hello (CHLO)），因为是初次建立，所以，服务端会返回一个拒绝消息（REJ），表明握手未建立或者密钥已过期。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake1.jpeg"></p>
<p>但是，这个拒绝消息中还会包含更多的信息（配置参数），主要有：</p>
<ol>
<li>Server Config：一个服务器配置，包括服务器端的Diffie-Hellman算法的长期公钥（long term Diffie-Hellman public value）</li>
<li>Certificate Chain：用来对服务器进行认证的信任链</li>
<li>Signature of the Server Config：将Server Config使用信任链的叶子证书的public key加密后的签名</li>
<li>Source-Address Token：一个经过身份验证的加密块，包含客户端公开可见的IP地址和服务器的时间戳。</li>
</ol>
<p>在客户端接收到拒绝消息（REJ）之后，客户端会进行数据解析，签名验证等操作，之后会将必要的配置缓存下来。<br>同时，在接收到REJ之后，客户端会为这次连接随机产生一对自己的短期密钥（ephemeral Diffie-Hellman private value） 和 短期公钥（ephemeral Diffie-Hellman public value）。</p>
<p>之后，客户端会将自己刚刚产生的短期公钥打包一个Complete CHLO的消息包中，发送给服务端。这个请求的目的是将自己的短期密钥传输给服务端，方便做前向保密。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake2.jpeg"></p>
<p>在发送了Complete CHLO消息给到服务器之后，为了减少RTT，客户端并不会等到服务器的响应，而是立刻会进行数据传输。</p>
<p>为了保证数据的安全性，客户端会自己的短期密钥和服务器返回的长期公钥进行运算，得到一个初始密钥（initial keys）。接下来他接收到客户端使用初始密钥加密的数据之后，就可以使用这个初识密钥进行解密了，并且可以将自己的响应再通过这个初始密钥进行加密后返回给客户端。</p>
<h3 id="最终（与重复）握手"><a href="#最终（与重复）握手" class="headerlink" title="最终（与重复）握手"></a>最终（与重复）握手</h3><p>那么，之后的数据传输就可以使用初始密钥（initial keys）加密了吗？<br>其实并不完全是，因为初始密钥毕竟是基于服务器的长期公钥产生的，而在公钥失效前，几乎多有的连接使用的都是同一把公钥，所以，这其实存在着一定的危险性。<br>所以，为了达到前向保密 (Forward Secrecy) 的安全性，客户端和服务端需要使用彼此的短期公钥和自己的短期密钥来进行运算。</p>
<p>那么现在问题是，客户端的短期密钥已经发送给服务端，而服务端只把自己的长期密钥给了客户端，并没有给到自己的短期密钥。<br>所以，服务端在收到Complete CHLO之后，会给到服务器一个server hello(SHLO)消息，这个消息会使用初始密钥（initial keys）进行加密。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake4.jpeg"></p>
<p>这个CHLO消息包中，会包含一个服务端重新生成的短期公钥。<br>这样客户端和服务端就都有了对方的短期公钥（ephemeral Diffie-Hellman public value）。<br>这样，客户端和服务端都可以基于自己的短期密钥和对方的短期公钥做运算，产生一个仅限于本次连接使用的前向保密密钥 (Forward-Secure Key)，后续的请求发送，都基于这个密钥进行加解密就可以了。<br>这样，双方就完成了最终的密钥交换、连接的握手并且建立了QUIC连接。<br>当下一次要重新创建连接的时候，客户端会从缓存中取出自己之前缓存下来的服务器的长期公钥，并重新创建一个短期密钥，重新生成一个初识密钥，再使用这个初始密钥对想要传输的数据进行加密，向服务器发送一个Complete CHLO 请求即可。这样就达到了0 RTT的数据传输。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake5.jpeg"></p>
<p>所以，如果是有缓存的长期公钥，那么数据传输就会直接进行，准备时间是0 RTT</p>
<p><strong>以上，通过使用Diffie-Hellman算法协商密钥，并且对加密和握手过程进行合并，大大减小连接过程的RTT ，使得基于QUIC的连接建立可以少到1 RTT甚至0 RTT。</strong></p>
<p>下面是建立握手的完整过程</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake6.jpeg"></p>
<p><strong>小结</strong>：</p>
<p>QUIC的通讯过程在初次没有建立过连接时使用1-RTT的握手机制，同时保证连接的建立和达到安全的保障。以下是QUIC的1-RTT的握手过程：</p>
<ol>
<li>Server端会持有0-RTT公私钥对，并且生成SCFG（服务端的配置信息对象），把公钥放入SCFG中；</li>
<li>客户端初次请求时，需要向服务端获取0-RTT公钥，这个需要消耗一个RTT，这也QUIC的1-RTT的所在；</li>
<li>客户端在收到0-RTT公钥以后会缓存起来，同时生成自己的临时公私钥对，经过前面的一个RTT后客户端把自己的临时私钥与服务端发过来的0-RTT的公钥根据DH算法生成一个加密密钥K1，同时使用K1加密数据同时附送自己的临时公钥一起发送服务端，此时已有用户数据发送；</li>
<li>在服务端收到用户使用K1加密的用户数据和客户端发来的临时公钥以后，会做如下几件事：<ul>
<li>使用0-RTT私钥与客户端发来的临时公钥通过DH算法生成K1解密用户数据并递交到应用；</li>
<li>生成服务端临时公私钥对，使用临时公私钥对的私钥，与客户端发来的客户端临时公钥，生成K2加密服务端要传输的数据</li>
<li>把服务端的临时公钥和使用K2加密的应用数据发送到客户端</li>
</ul>
</li>
<li>客户端收到服务端发送的服务端临时公钥和使用K2加密的应用数据后会再次使用DH算法把服务端的临时公钥和客户端原来的临时私钥重新生成K2解密数据，并且从此以后使用K2进行数据层的加解密</li>
</ol>
<ul>
<li><strong>1RTT握手</strong></li>
</ul>
<p>0-RTT是QUIC一个很关键的属性，能够在连接的第一个数据报文就可以携带用户数据。但是我们也可以看到如果客户端和服务端从来没有通讯过，那么是不存在0-RTT的，需要一个完成的RTT之后才能承载用户数据。<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_1rtt.png" style="height:400px"></p>
<ul>
<li><strong>0RTT握手</strong></li>
</ul>
<p>这个流程是gQUIC的流程，iQUIC由于使用的是TLS1.3，握手阶段报文的细节会有些不一样，例如首个请求的是证书、PSK等信息。在0-RTT阶段使用的是session复用的ticket方式。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_0rtt.png" style="height:400px"></p>
<p class="div-border yellow">gQUIC使用的是gQUIC Crypto，并不是TLS1.3</p>

<ul>
<li><strong>安全考虑</strong></li>
</ul>
<p>UDP的安全性存在的几个关键的地方，源地址欺骗攻击，UDP放大攻击等。在QUIC中有设计了源地址TOKEN（STK）验证的安全机制来解决源地址的欺骗攻击，在通讯过程中服务器要求确认客户端的源地址TOKEN，这个源地址TOKEN根据数据包的源地址和服务器的时间戳等因子生成STK，随后和响应数据包一起发送到客户端，而在后续的数据传输过程中客户端需要透传这个STK到服务端，从而服务端可以进行校验。当服务端发现连接对应的源地址发送变化时会主动发送RETRY报文进行服务端主动源地址验证。客户端也可以主动发起源地址验证信息。源地址验证可以保护两类攻击问题，源地址欺骗攻击和UDP放大攻击。</p>
<ol>
<li><p>连接建立时，为了验证客户端的地址是否是攻击者伪造的，服务端会生成一个令牌（token）并通过重试包（Retry packet）响应给客户端。客户端需要在后续的初始包（Initial packet）带上这个令牌，以便服务端进行地址验证。</p>
</li>
<li><p>服务端可以在当前连接中通过 NEW_TOKEN 帧预先发布令牌，以便客户端在后续的新连接使用，这是 QUIC 实现 0-RTT 很重要的一个功能。</p>
</li>
<li><p>当我们的网络路径变化时（比如从蜂窝网络切换到 WIFI），QUIC 提供了连接迁移（connection migration）的功能来避免连接中断。QUIC 通过路径验证（Path Validation）验证网络新地址的可达性（reachability），防止在连接迁移中的地址是攻击者伪造的。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>GoLang 编程技巧 (一)</title>
    <url>/2021/01/30/GoLang-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为了巩固一下 Go 的基础，主要涉及 Slice、Interface、函数式编程等。</p>
<a id="more"></a>
<p>也是读了<a href="https://coolshell.cn/" style>左耳朵耗子</a> 叔的 <a href="https://coolshell.cn/articles/21128.html">Go编程模式</a> 的系列文章发现有的细节确实之前也有遗漏，刚好也趁机复习巩固一下。</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">//指向存放数据的数组指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span>            <span class="comment">//长度有多大</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span>            <span class="comment">//容量有多大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Slicce标头的<strong>array</strong>字段是底层真正指向数组的指针。</p>
<p><img src="https://i0.wp.com/golangbyexample.com/wp-content/uploads/2020/05/slice.jpg?w=391&amp;ssl=1" alt></p>
<p>Golang 的切片是子集。切片可以是数组、列表或字符串的子集。可以从一个字符串中提取多个片段，每个片段作为一个新变量。</p>
<h3 id="与数组的不同："><a href="#与数组的不同：" class="headerlink" title="与数组的不同："></a><strong>与数组的不同</strong>：</h3><p>数组在声明为一定大小后，不能调整大小，而切片可以调整大小。切片是引用类型，而数组是值类型。</p>
<h3 id="在Golang中创建切片"><a href="#在Golang中创建切片" class="headerlink" title="在Golang中创建切片"></a><strong>在Golang中创建切片</strong></h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stringSlice = []<span class="keyword">string</span>&#123;<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;slice&quot;</span>&#125;</span><br><span class="line">	fmt.Println(stringSlice)  <span class="comment">// prints [This is a string slice]</span></span><br><span class="line">	<span class="comment">// res:  [This is a string slice]</span></span><br><span class="line"></span><br><span class="line">	myset := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* take slice */</span></span><br><span class="line">	s1 := myset[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	<span class="comment">// res:  [0 1 2 3]</span></span><br><span class="line"></span><br><span class="line">	mystring := <span class="string">&quot;Go programming&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* take slice */</span></span><br><span class="line">	s2 := mystring[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	<span class="comment">// res:  Go</span></span><br><span class="line"></span><br><span class="line">	numbers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;numbers=%v\n&quot;</span>, numbers)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;length=%d\n&quot;</span>, <span class="built_in">len</span>(numbers))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;capacity=%d\n&quot;</span>, <span class="built_in">cap</span>(numbers))</span><br><span class="line">	<span class="comment">// res:</span></span><br><span class="line">	<span class="comment">//numbers=[0 0 0]</span></span><br><span class="line">	<span class="comment">//length=3</span></span><br><span class="line">	<span class="comment">//capacity=5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片引用"><a href="#切片引用" class="headerlink" title="切片引用"></a><strong>切片引用</strong></h3><p>切片是引用类型，那么就意味着数组指针的问题——数据会发生共享！下面我们来看看 Slice 的一些操作：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">foo[<span class="number">3</span>] = <span class="number">42</span></span><br><span class="line">foo[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">bar  := foo[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">bar[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 foo</span></span><br><span class="line"><span class="comment">// 打印 bar</span></span><br></pre></td></tr></table></figure>
<ol>
<li>首先，创建一个 foo 的 Slice，其中的长度和容量都是 5；</li>
<li>然后，开始对 foo 所指向的数组中的索引为 3 和 4 的元素进行赋值；</li>
<li>最后，对 foo 做切片后赋值给 bar，再修改 bar[1]。</li>
</ol>
<p>最终的foo和bar的结果是什么呢? 是不是和想象的不太一样，这是因为切片操作的底层数组是同一个数组。foo 和 bar 的内存是共享的，所以，foo 和 bar 对数组内容的修改都会影响到对方。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(foo)  &#x2F;&#x2F; res: [0 0 99 42 100]</span><br><span class="line">fmt.Println(bar)  &#x2F;&#x2F; res: [0 99 42]</span><br></pre></td></tr></table></figure></p>
<p>再来看一个 <code>append</code> 的例子。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">16</span>]</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印a</span></span><br><span class="line"><span class="comment">// 打印b</span></span><br></pre></td></tr></table></figure><br>在这段代码中，把 <code>a[1:16]</code> 的切片赋给 b ，此时，a 和 b 的内存空间是共享的，然后，对 a 做了一个 append()的操作，这个操作会让 a 重新分配内存，这就会导致 a 和 b 不再共享，如下图所示：<br><img src="https://static001.geekbang.org/resource/image/9a/13/9a29d71d309616f6092f6bea23f30013.png" style="max-width: 70%;border-radius: 6px"></p>
<p>这时 a 和 b 的值是多少？append()操作让 a 的容量变成了 64，而长度是 33。这里你需要重点注意一下，<strong>append()这个函数在 cap 不够用的时候，就会重新分配内存以扩大容量，如果够用，就不会重新分配内存了！</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(a)  &#x2F;&#x2F; res: [0 0 42 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]</span><br><span class="line">fmt.Println(b)  &#x2F;&#x2F; res: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>那既然这样相同的例子我们再来一遍，如果让a不要重新分配内存(比如初始化a的时候使用<code>a := make([]int, 33))</code>，那么b的结果就会变成 <code>[0 42 0 0 0 0 0 0 0 0 0 0 0 0 0]</code> <strong>注意</strong>：这时的b会因为<code>a[2]</code> 的变化而变化。</p>
<p>同样的例子如下，只要没有发生<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path := []<span class="keyword">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">	sepIndex := bytes.IndexByte(path,<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	dir1 := path[:sepIndex]</span><br><span class="line">	dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir1),<span class="built_in">cap</span>(dir1)) <span class="comment">// prints: len: 4 cap: 14</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir2),<span class="built_in">cap</span>(dir2)) <span class="comment">// prints: len: 9 cap: 14</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">	dir1 = <span class="built_in">append</span>(dir1,<span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; uffixBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子中，dir1 和 dir2 共享内存，虽然 dir1 有一个 append() 操作，但是因为 cap 足够，于是数据扩展到了dir2 的空间。下面是相关的图示（注意上图中 dir1 和 dir2 结构体中的 cap 和 len 的变化）：</p>
<p><img src="https://static001.geekbang.org/resource/image/17/aa/1727ca49dfe2e6a73627a52a899535aa.png" style="max-width: 70%;border-radius: 6px"></p>
<p>这里的 <code>dir1:=path[:sepIndex]</code> 没有触发重新分配内存，如果想要强行重新分配内存的话可以使用<code>dir1 := path[:sepIndex:sepIndex]</code> 最后一个参数叫“Limited Capacity”，于是，后续的 append() 操作会导致重新分配内存。</p>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface 接口是一个抽象概念，它支持Go中的<strong>多态</strong>。该接口的变量可以保存实现该类型的值。类型断言用于获取底层的具体值。接口也是给Go语言带来了无限扩展空间。其中 <code>io.Reader</code> 接口就是一个典型的例子，<strong>io.Reader</strong> 表示读取设备数据流的能力，可以从<a href="https://golang.cafe/blog/golang-reader-example.html">网络、文件、字符串</a>等等。先简单介绍下 <code>io.Reader</code> 接口 ，后面会介绍如何使用接口式编程的方式封装 Reader 。</p>
<h3 id="接口式编程"><a href="#接口式编程" class="headerlink" title="接口式编程"></a>接口式编程</h3><p><a href="https://golang.org/pkg/io/#Reader">io.Reader</a> interface 可以表示从实体中读取字节流。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即只要实现了 <code>Read(buf []byte) (n int, err error)</code> 方法便就是 <code>io.Reader</code> 接口。Read最多将 <code>len(buf)</code> 字节读入buf并返回读取的字节, 直到读到 <code>io.EOF</code> 时返回。标准库中实现了很多Reader的实现。并且很多应用程序都接受 <code>Reader</code> 作为输入。</p>
<ul>
<li><strong>直接从字节流中读取</strong></li>
</ul>
<p>这里分为 <code>Read</code>、 <code>io.ReadFull</code>、 <code>ioutil.ReadAll</code> 三种方法。每种方法都有一些区别。</p>
<ol>
<li>直接使用 Read 方法</li>
</ol>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">r := strings.NewReader(<span class="string">&quot;abcde&quot;</span>)</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	n, err := r.Read(buf)</span><br><span class="line">	fmt.Println(n, err, buf[:n])</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个字节流 <code>r</code>, 在循环从r中读取出数据。循环会执行3次，第一次读取4个字节，第二次读取1个字节，第三次读到 <code>io.EOF</code> 返回跳出循环。注意，Read方法读取时会清空 <code>buf</code> 里的数据，所以这里需要每次读完打印一下。再次读时，<code>buf</code> 里的数据会被重新覆盖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 &lt;nil&gt; [97 98 99 100]</span><br><span class="line">1 &lt;nil&gt; [101]</span><br><span class="line">0 EOF []</span><br></pre></td></tr></table></figure>
<p>另外还可以使用 <code>io.ReadFull</code> 或者 <code>ioutil.ReadAll</code> 取读取字节流,<code>io.ReadFull</code>用法和<code>Read</code>差不多，<code>ioutil.ReadAll</code>不需要设置buf可直接返回buf。更多可参考：<a href="https://yourbasic.org/golang/io-reader-interface-explained/">How to use the io.Reader interface
</a></p>
<ul>
<li><strong>利用接口特性</strong></li>
</ul>
<p>下面的代码是一个实时统计标准输入字符个数的代码。用户每次按下回车都可以看到当前输入的字符以及历史上已经输入的字符的个数。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountNumber</span><span class="params">(input <span class="keyword">chan</span> []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> data := <span class="keyword">range</span> input &#123;</span><br><span class="line">		count += <span class="built_in">len</span>(data)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> 	bytes := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>)</span><br><span class="line"> 	fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line"> 	<span class="keyword">go</span> CountNumber(bytes)</span><br><span class="line"> 	<span class="keyword">for</span> &#123;</span><br><span class="line">    	<span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">		_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">		bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，但是似乎和我们要讲到的接口式编程没什么关系。下面我们用接口封装一下。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCountReader</span><span class="params">()</span> *<span class="title">CountReader</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;CountReader&#123;</span><br><span class="line">		bytes: <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>),</span><br><span class="line">		data:  <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountReader <span class="keyword">struct</span> &#123;     <span class="comment">// 声明CountReader对象</span></span><br><span class="line">	bytes    <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line">	data     []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123; <span class="comment">// 实现Read方法</span></span><br><span class="line">	ok := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> ok &amp;&amp; <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line">		h.data, ok = &lt;-h.bytes   <span class="comment">// 将bytes里的数据全部传给 data</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !ok || <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, io.EOF    <span class="comment">// 可能读到了结尾</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l := <span class="built_in">copy</span>(p, h.data)</span><br><span class="line">	h.data = h.data[l:]</span><br><span class="line">	<span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := bufio.NewReader(h)</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">		n,err := b.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		count += <span class="built_in">len</span>(buf[:n])</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, buf)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先声明了一个结构体 <code>CountReader</code>, 再实现了一个 <code>Read()</code> 方法调用，我们知道实现了<code>Read()</code>即可以成为 <code>io.Reader</code> 接口的实现。也就是说 <code>CountReader</code> 就是一个 <code>io.Reader</code> ，那么 <code>io.Reader</code> 可以使用的方法，也可以给 <code>CountReader</code> 使用。这时就可以使用 <code>bufio</code> 这个库了。使用 <code>bufio.NewReader</code> 的函数对输入数据进行读取和计算。</p>
<p class="div-border yellow"><code>bufio.NewReader()</code> 方法提供一个缓存buf, 默认缓存4k buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。</p>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line">	Counter := NewCountReader()</span><br><span class="line">	<span class="keyword">go</span> Counter.run()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">		_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">		Counter.bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来通过上述代码即可完成相同的操作，这只是一个简单的例子，如果换成文件io、网络io就会有非常可观的收益。带来业务性能的提升。</p>
<h1 id="Functional-Option"><a href="#Functional-Option" class="headerlink" title="Functional Option"></a>Functional Option</h1><p>Functional Options 这个编程模式是一个函数式编程的应用案例，编程技巧也很好，是目前 Go 语言中最流行的一种编程模式。</p>
<p>假设实际编程中需要针对业务对象设置很多属性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr     <span class="keyword">string</span></span><br><span class="line">    Port     <span class="keyword">int</span></span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    MaxConns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 Server 对象中，我们可以看到：</p>
<ul>
<li>要设置侦听的 IP 地址 Addr 和端口号 Port。（必填）</li>
<li>协议、超时时间、最大链接数、TLS选项等属性需要配置。（非必填）</li>
</ul>
<p>那么如何让调用方实现这个必填参数和非必填参数呢？一个方法是将非必填参数设成 <code>...interface&#123;&#125;</code> 但这样肯定不好，因为不同的参数类型都不一样。另一种方式就是将 必填参数和非必填参数分开了。</p>
<p>如非必填参数搞成一个结构体</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    Maxconns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必填参数和这个 <code>Config</code> 直接传给初始化函数，如果没有要填的参数可以将 <code>Config</code> 设为 <code>nil</code> 。</p>
<p>这样一来 <code>Server</code> 结构体便成了这样, 初始化</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Conf *Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, conf *Config)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using the default configuratrion</span></span><br><span class="line">srv1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="literal">nil</span>) </span><br><span class="line"></span><br><span class="line">conf := ServerConfig&#123;Protocol:<span class="string">&quot;tcp&quot;</span>, Timeout: <span class="number">60</span>*time.Duration&#125;</span><br><span class="line">srv2, _ := NewServer(<span class="string">&quot;locahost&quot;</span>, <span class="number">9000</span>, &amp;conf)</span><br></pre></td></tr></table></figure>
<p>这样便已经是大多数人的作法了。但是不是没有修改空间，下面介绍一下 Functional Option 方式。</p>
<h2 id="初始化-Server-示例"><a href="#初始化-Server-示例" class="headerlink" title="初始化 Server 示例"></a><strong>初始化 Server 示例</strong></h2><p>首先我们定义一个 <code>Option</code> 类型:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span></span></span><br></pre></td></tr></table></figure>
<p>用函数式方式定义一组函数。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Protocol = p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Timeout = timeout</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxConns</span><span class="params">(maxconns <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.MaxConns = maxconns</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TLS</span><span class="params">(tls *tls.Config)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.TLS = tls</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这组代码的含义是传入一个参数，返回一个函数，函数会将 <code>Server</code> 结构的对应参数值进行设置。例如，当我们调用其中的一个函数 MaxConns(30) 时，其返回值是一个 func(s* Server) { s.MaxConns = 30 } 的函数。</p>
<p>这下，我们可以定义一个 <code>NewServer</code> 函数，其中有一个可变参数 <code>option</code> ,用一个循环来设置 Server 的属性。不仅提供了默认值，还提供将默认值改成可修改选项进行修改。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...<span class="keyword">func</span>(*Server)</span>) <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  srv := Server&#123;</span><br><span class="line">    Addr:     addr,</span><br><span class="line">    Port:     port,</span><br><span class="line">    Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">    Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">    MaxConns: <span class="number">1000</span>,</span><br><span class="line">    TLS:      <span class="literal">nil</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">    option(&amp;srv)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，我们在创建 Server 对象的时候，就可以像下面这样：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">1024</span>)</span><br><span class="line">s2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">2048</span>, Protocol(<span class="string">&quot;udp&quot;</span>))</span><br><span class="line">s3, _ := NewServer(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8080</span>, Timeout(<span class="number">300</span>*time.Second), MaxConns(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<p>这下对 Server 的封装就像搭积木一样简单容易并且可视化很好。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>探索 Webtransport</title>
    <url>/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://wicg.github.io/web-transport/">WebTransport</a> 是一个新一代的浏览器API，提供客户端-服务端之间的双向低延迟交互，并在顶部使用常见 API 来实现其下的可插拔协议（<font style="color:#FF7F50">尤其是基于<a style="color:#FF7F50" href=" https://www.chromium.org/quic">QUIC</a></font>）。该 API 与 WebSocket 相似，也是客户端和服务器的双向连接，但允许进一步减少客户端和服务器之间的网络通信延迟，并且还支持多个流、单向流、乱序和不可靠传输。基于QUIC的Webtransport (Quictransport)即支持通过 datagram API 发送不可靠的数据，也支持通过 stream API 实现可靠数据传输。</p>
<p>使用场景包括使用不可靠且乱序的消息向服务器重复发送低延迟的游戏状态、从服务器到客户端的媒体片段的低延迟传输以及大多数逻辑在服务器上运行的云场景。</p>
<p>WebTransport 提案详细介绍：<font style="color:#FF7F50"> <a href="https://wicg.github.io/web-transport/">https://wicg.github.io/web-transport/</a> </font></p>
<p><strong>重点</strong></p>
<ol>
<li>Webtransport 支持不可靠传输，通过轻量级、低延迟的UDP协议传输。</li>
<li>Webtransport 可基于 QUIC 实现 Client-Server 可靠的流式传输。</li>
<li>可支持多条流的相互独立 + QUIC 多路复用\非队头阻塞特性 完美代替当前的 Websocket。Webtransport 提供了一些当前websocket规范不可能提供的功能。可消除当前多个数据包之间的队头阻塞。</li>
</ol>
<p><strong>标准规范</strong></p>
<ol>
<li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-overview-01"> WebTransport overview </a> : Webtransport 的概述及对传输层的要求。</li>
<li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-quic"> WebTransport over QUIC</a> : 定义了基于QUIC的 Webtransport</li>
<li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-http3-02"> WebTransport over HTTP/3 </a>: 定义了基于HTTP/3的 Webtransport （实际上 HTTP/3 也是基于QUIC的）</li>
</ol>
<p>当前 Chrome 团队只实现了基于 QUIC 的 Webtransport 。然而目前也仅仅是实验性的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transport = <span class="keyword">new</span> QuicTransport(<span class="string">&#x27;quic-transport://localhost:4433/path&#x27;</span>);</span><br></pre></td></tr></table></figure><br>Webtransport draft 标明是支持TCP的， 但显然目前大家都在UDP上了投入了大量精力，也主要是以UDP去实现的。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/WebTransport/common_transport_requirements.png"></p>
<h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>当前的Webtransport 必须基于 QUIC draft-29 或更高版本。客户端主要以 chrome 浏览器为主，版本必须 &gt;= 85 。服务端我们将基于 <a href="github.com/lucas-clemente/quic-go" style="color:#FF7F50"> github.com/lucas-clemente/quic-go </a>  go library 。因为是本地测试，我们还需要签发一个自签名证书。</p>
<h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>因为当前Webtransport的底层实现是基于 QUIC or HTTP/3 ，所以我们必须要实现自签名证书，确保通信过程的安全性。这里我们使用的是 <code>openssl</code> </p>
<p>首先需要确保你的 <code>openssl</code> 安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ <span class="built_in">which</span> openssl</span><br><span class="line">/usr/bin/openssl</span><br><span class="line">➜ openssl version</span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>创建证书和私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ openssl req -newkey rsa:2048 -nodes -keyout certificate.key \</span><br><span class="line">-x509 -out certificate.pem -subj <span class="string">&#x27;/CN=Test Certificate&#x27;</span> \</span><br><span class="line">-addext <span class="string">&quot;subjectAltName = DNS:localhost&quot;</span></span><br></pre></td></tr></table></figure>
<p>计算证书的指纹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ openssl x509 -pubkey -noout -<span class="keyword">in</span> certificate.pem |</span><br><span class="line">openssl rsa -pubin -outform der |</span><br><span class="line">openssl dgst -sha256 -binary | base64</span><br><span class="line"><span class="comment">#      The result should be a base64-encoded blob that looks like this:</span></span><br><span class="line"><span class="comment">#          &quot;Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=&quot;</span></span><br></pre></td></tr></table></figure>
<p>向chrome传入参数指明允许使用自签证书的服务端地址+端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--origin-to-force-quic-on=localhost:4433</span><br></pre></td></tr></table></figure>
<p>使用如下参数以信任证书<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--ignore-certificate-errors-spki-list=Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=</span><br></pre></td></tr></table></figure><br>更多可以参考： <a href="https://www.chromium.org/developers/how-tos/run-chromium-with-flags">docs on how to run Chrome/Chromium with custom flags.</a></p>
<p>最后打开 <a style="color:#FF7F50" href="https://googlechrome.github.io/samples/webtransport/client.html">https://googlechrome.github.io/samples/webtransport/client.html</a></p>
<p><img src="https://img1.kiosk007.top/static/images/network/WebTransport/webtransport_client.png" style="height:550px"></p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>我们使用 github.com/lucas-clemente/quic-go 来实现QUIC。</p>
<p>Run 方法来实现接受客户端的连接请求。quic.ListenAddr 创建一个监听器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   listener, err := quic.ListenAddr(s.config.ListenAddr, s.generateTLSConfig(), s.generateQUICConfig())</span><br><span class="line">   utils.Logging.Info().Err(err)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;WebTransport Engine v0.1 Start ...&quot;</span>)</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;Listening for %s connections on %s&quot;</span>,<span class="string">&quot;udp&quot;</span>, s.config.ListenAddr)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      session, err := listener.Accept(context.Background())</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      utils.Logging.Info().Msgf(<span class="string">&quot;session accepted: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _ = session.CloseWithError(<span class="number">0</span>, <span class="string">&quot;bye&quot;</span>)</span><br><span class="line">            utils.Logging.Info().Msgf(<span class="string">&quot;close session: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line">         &#125;()</span><br><span class="line">         s.handleSession(session)</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端需要在 ALPN 中携带 alpnQuicTransport = “wq-vvv-01” 服务端读取后就会针对开始Webtransport 传输。<br><img src="https://img1.kiosk007.top/static/images/network/WebTransport/wq-vvv-01_alpn.png" style="height:550px"></p>
<p>代码参见：<a href="https://github.com/weijiaxiang007/webtransport/" style="color:#FF7F50"> https://github.com/weijiaxiang007/webtransport/ </a></p>
<h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p><font style="color:#6495ED">QUIC使用流ID的最低两位指示流标识以下信息</font></p>
<ol>
<li>单向 or 双向流</li>
<li>由客户端 or 服务端发起。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+------+----------------------------------+</span><br><span class="line">| Bits | Stream Type                      |</span><br><span class="line">+======+==================================+</span><br><span class="line">| 0x0  | Client-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x1  | Server-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x2  | Client-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x3  | Server-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>对于每一个双向流，流的发起方和流的接收方均可以在一条双向流上传输数据。</li>
<li>对于每一条单向流，只能是流的发起方向流的接收方发送数据。接收方可以在一条新的单向流上回复数据。</li>
<li>对于数据报格式的数据，由于 quic-go 底层不支持，这里不再赘述。不过已经有相关的提交去支持 <a href="https://github.com/lucas-clemente/quic-go/pull/2162" style="color:#FF7F50"> https://github.com/lucas-clemente/quic-go/pull/2162 </a></li>
</ul>
<p>更多信息参见：<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1" style="color:#FF7F50">https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1</a></p>
<p><font style="color:#6495ED">客户端请求</font><br>客户端请求一般 按照 Key — Value 的方式携带请求的资源标识。如下是请求的 Origin 和 Path。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> clientIndicationKey <span class="keyword">int16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   clientIndicationKeyOrigin clientIndicationKey = <span class="number">0</span></span><br><span class="line">   clientIndicationKeyPath                       = <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Key (16)            |          Length (16)          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Value (*)                         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>这里只实现了双向流，可以看到双向流建立之前会先建立一个单向流用于认证信息。之后的数据会在双向流上传递</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">handleSession</span><span class="params">(sess quic.Session)</span></span> &#123;</span><br><span class="line">	stream, err := sess.AcceptUniStream(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utils.Logging.Error().Err(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	utils.Logging.Info().Msgf(<span class="string">&quot;unidirectional stream accepted, id: %d&quot;</span>, stream.StreamID())</span><br><span class="line">	indication, err := receiveClientIndication(stream)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utils.Logging.Error().Err(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	utils.Logging.Info().Msgf(<span class="string">&quot;client indication: %+v&quot;</span>, indication)</span><br><span class="line">	<span class="keyword">if</span> err := s.validateClientIndication(indication); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utils.Logging.Error().Err(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = s.communicate(sess)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utils.Logging.Error().Err(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>QUIC</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Reflect </title>
    <url>/2021/01/18/Go-Reflect/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言标准库 <a href="https://golang.org/pkg/reflect/">reflect</a> 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。</p>
<a id="more"></a>
<h1 id="类型和接口-Types-and-interfaces"><a href="#类型和接口-Types-and-interfaces" class="headerlink" title="类型和接口 (Types and interfaces)"></a>类型和接口 (Types and interfaces)</h1><p>因为反射是建立在类型之上的，所以想要了解反射必须先知道Go 语言中所有的变量都有一个静态类型。例如 <code>int</code>、<code>[]byte</code>、<code>float32</code>、<code>*MyType</code>等等。<br>如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure><br>接口是一种特殊的类型，它表示固定的方法集。接口变量可以存储任何具体（非接口）值,只要该值实现接口的方法。最经典的例子便是 io.Reader \ io.Writer 。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有人说Go的接口是动态类型的，但这是误导。它们是静态类型。一个特殊的例子是空接口，即 <code>interface&#123;&#125;</code>。</p>
<p>在这个例子中。<font style="color:#00008B">os.OpenFile</font> 的返回参数tty的类型是 <code>*os.File</code>，由于 <code>*os.File</code> 实现了 <font style="color:#00008B">Read()</font> 方法，所以该类型可以被赋于类型 io.Reader (io.Reader是一个interface)。尽管 <code> *os.File</code> 实现了很多方法，但是变量r仅有一个方法Read。但内部的值仍包含有关该值的所有类型信息。这就是为什么我们可以做 <code>w=r.(io.Writer)</code> 的原因。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r io.Reader</span><br><span class="line">	tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>) <span class="comment">// tty *os.File</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> &#125;</span><br><span class="line">	r = tty</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> w io.Writer    </span><br><span class="line">	w = r.(io.Writer)  <span class="comment">// 由于r实际内部是有Write方法的，所以r可以被断言成 io.Writer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;12345&quot;</span>));err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">	_ = tty.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以继续执行下面的操作。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br><span class="line">fmt.Println(reflect.TypeOf(empty))</span><br></pre></td></tr></table></figure></p>
<h2 id="反射基本用法"><a href="#反射基本用法" class="headerlink" title="反射基本用法"></a>反射基本用法</h2><h3 id="从接口值到反射对象"><a href="#从接口值到反射对象" class="headerlink" title="从接口值到反射对象"></a><font style="color:#483D8B"><strong>从接口值到反射对象</strong></font></h3><p>ValueOf用来获取输入参数接口中的数据的值。如果是空接口则返回 invalid 。<br>TypeOf用来动态获取输入参数接口中的值的类型，如果空接口则返回nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>,reflect.TypeOf(num))     <span class="comment">// type:  float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>,reflect.ValueOf(num))   <span class="comment">// value:  1.2345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以判断类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(v)</span><br><span class="line">	<span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Float64:</span><br><span class="line">		fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> reflect.Int:</span><br><span class="line">		fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;   <span class="comment">// 方法二</span></span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从反射对象到接口值"><a href="#从反射对象到接口值" class="headerlink" title="从反射对象到接口值"></a><font style="color:#483D8B"><strong>从反射对象到接口值</strong></font></h3><p>go 提供了反射和反射的逆，可以通过 <code>.(type)</code> 断言的方式将一个Interface()转成他真正的类型。如果断言的类型不匹配，会发生panic。</p>
<p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Interface() interface{}</td>
<td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td>
</tr>
<tr>
<td>Int() int64</td>
<td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Uint() uint64</td>
<td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Float() float64</td>
<td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td>
</tr>
<tr>
<td>Bool() bool</td>
<td>将值以 bool 类型返回</td>
</tr>
<tr>
<td>Bytes() []bytes</td>
<td>将值以字节数组 []bytes 类型返回</td>
</tr>
<tr>
<td>String() string</td>
<td>将值以字符串类型返回</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pi <span class="keyword">float64</span></span><br><span class="line">pi = <span class="number">3.1415926</span></span><br><span class="line">v := reflect.ValueOf(pi)</span><br><span class="line">y := v.Interface().(<span class="keyword">float64</span>) <span class="comment">// y will have type float64.</span></span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></table></figure>
<h3 id="要修改反射对象，该值必须可设置"><a href="#要修改反射对象，该值必须可设置" class="headerlink" title="要修改反射对象，该值必须可设置"></a><font style="color:#483D8B"><strong>要修改反射对象，该值必须可设置</strong></font></h3><p>如果运行下面的代码将会 <font style="color:#8B0000"> panic </font> ，这时因为 v 是不可设置的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>备  注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Elem() Value</td>
<td>取值指向的元素值，类似于语言层*操作</td>
</tr>
<tr>
<td>Addr() Value</td>
<td>对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机</td>
</tr>
<tr>
<td>CanAddr() bool</td>
<td>表示值是否可寻址</td>
</tr>
<tr>
<td>CanSet() bool</td>
<td>返回值能否被修改。要求值可寻址且是导出的字段</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>CanSet()</code> 即可判断，<code>CanSet()</code> 报告 v 的值是否可以改变。值只能在可寻址的情况下更改，并且不能通过使用未导出的结构字段获取。如果 CanSet 返回 false ，则调用 Set 或任何类型特定的 setter （例如 SetBool ，SetInt ）将会发生panic。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><br>v 不可寻址，因为 v 只是 x 的拷贝，即便把 x 换成 &amp;x,还是不可寻址，因为 <code>reflect.ValueOf(&amp;x)</code> 也仅仅是 x 指针的拷贝。实际上，所有通过 <code>reflect.ValueOf(x)</code> 返回的 reflect.Value 都是不可取地址的。但是通过调用 <code>reflect.ValueOf(&amp;x).Elem()</code>，来获取任意变量x对应的可取地址的 Value</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span></span><br><span class="line">x = <span class="number">3.1415</span></span><br><span class="line">pv := reflect.ValueOf(&amp;x)</span><br><span class="line">pv = pv.Elem()</span><br><span class="line">pv.SetFloat(<span class="number">7.1</span>) </span><br><span class="line"></span><br><span class="line">fmt.Println(x)   <span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure>
<h2 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Field(i int) StructField</td>
<td>根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生panic</td>
</tr>
<tr>
<td>NumField() int</td>
<td>返回结构体成员字段数量。当类型不是结构体或索引超界时发生panic</td>
</tr>
<tr>
<td>FieldByName(name string) (StructField, bool)</td>
<td>根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生 panic</td>
</tr>
<tr>
<td>FieldByIndex(index []int) StructField</td>
<td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时发生 panic</td>
</tr>
<tr>
<td>FieldByNameFunc( match func(string) bool) (StructField,bool)</td>
<td>根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生panic</td>
</tr>
</tbody>
</table>
</div>
<h3 id="普通结构体"><a href="#普通结构体" class="headerlink" title="普通结构体"></a>普通结构体</h3><ol>
<li>先获取interface的reflect.Type，然后通过NumField进行遍历</li>
<li>再通过reflect.Type的Field获取其Field</li>
<li>最后通过Field的Interface()得到对应的value</li>
</ol>
<p>假设有以下 <code>User struct</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id      <span class="keyword">int</span></span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Work    Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id           <span class="keyword">int</span></span><br><span class="line">	Occupation   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;My Id :%d ,My Name :%s ,My Occupation :%s&quot;</span>,u.Id,u.Name,u.Work.Occupation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFuncHasArgs</span><span class="params">(foo <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;This is number %d \n&quot;</span>, foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接下来演示的是如何通过反射区打印结构体中的所有对象、打印结构体中的所有字段、调用方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user := User&#123;</span><br><span class="line">		Id:   <span class="number">1</span>,</span><br><span class="line">		Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">		Work: Worker&#123;</span><br><span class="line">			Id: <span class="number">1</span>,</span><br><span class="line">			Occupation: <span class="string">&quot;farmer&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getType := reflect.TypeOf(user)</span><br><span class="line">	fmt.Println(<span class="string">&quot;get type is: &quot;</span>,getType.Name())  <span class="comment">// get type is:  User</span></span><br><span class="line"></span><br><span class="line">	getValue := reflect.ValueOf(user)</span><br><span class="line">	fmt.Println(<span class="string">&quot;get all Fields is &quot;</span>, getValue) <span class="comment">// get all Fields is  &#123;1 Kiosk &#123;1 farmer&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对字段进行遍历 获取方法的字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumField();i++ &#123;</span><br><span class="line">		field := getType.Field(i)</span><br><span class="line">		value := getValue.Field(i).Interface()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %v = %v \n&quot;</span>,field.Name,field.Type,value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	   	Id: int = 1</span></span><br><span class="line"><span class="comment">		Name: string = Kiosk</span></span><br><span class="line"><span class="comment">		Work: main.Worker = &#123;1 farmer&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取方法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumMethod();i++ &#123;</span><br><span class="line">		m := getType.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s : %v\n&quot;</span>,m.Name,m.Type)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	   ReflectCallFunc : func(main.User)</span></span><br><span class="line"><span class="comment">	   ReflectCallFuncHasArgs : func(main.User, int)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用方法</span></span><br><span class="line">	<span class="comment">// 有参数调用</span></span><br><span class="line">	methodValue := getValue.MethodByName(<span class="string">&quot;ReflectCallFuncHasArgs&quot;</span>)</span><br><span class="line">	args := []reflect.Value&#123;reflect.ValueOf(<span class="number">2</span>)&#125;</span><br><span class="line">	methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		This is number 2</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无参数调用</span></span><br><span class="line">	methodValue = getValue.MethodByName(<span class="string">&quot;ReflectCallFunc&quot;</span>)</span><br><span class="line">	args = <span class="built_in">make</span>([]reflect.Value,<span class="number">0</span>)</span><br><span class="line">	methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		My Id :1 ,My Name :Kiosk ,My Occupation :farmer</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带tag的struct"><a href="#带tag的struct" class="headerlink" title="带tag的struct"></a>带tag的struct</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id      <span class="keyword">int</span> 		<span class="string">`json:&quot;id&quot;   bson:&quot;id&quot;`</span></span><br><span class="line">	Name    <span class="keyword">string</span>		<span class="string">`json:&quot;name&quot; bson:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user := User&#123;</span><br><span class="line">		Id:   <span class="number">1</span>,</span><br><span class="line">		Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getType := reflect.TypeOf(user)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get type is: %v \n&quot;</span>,getType.String())  <span class="comment">// get type is:  main.User</span></span><br><span class="line"></span><br><span class="line">	getValue := reflect.ValueOf(user)</span><br><span class="line">	fmt.Println(getValue) <span class="comment">// &#123;1 Kiosk&#125;</span></span><br><span class="line"></span><br><span class="line">	name := getValue.FieldByName(getType.Field(<span class="number">1</span>).Name).String()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name is %s \n&quot;</span>, name)  <span class="comment">// name is Kiosk</span></span><br><span class="line"></span><br><span class="line">	tag := getType.Field(<span class="number">0</span>).Tag</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name: %v  tag: &#x27;%v&#x27;\n&quot;</span>, getType.Field(<span class="number">0</span>).Name, tag) <span class="comment">// name: Id  tag: &#x27;json:&quot;id&quot;   bson:&quot;id&quot;&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;tag is %s, %s \n&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), tag.Get(<span class="string">&quot;bson&quot;</span>)) <span class="comment">//  tag is id, id </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断反射值的有效性和空"><a href="#判断反射值的有效性和空" class="headerlink" title="判断反射值的有效性和空"></a>判断反射值的有效性和空</h2><p>IsNil()和IsValid() — 判断反射值的空和有效性</p>
<p>反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方 法</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>IsNil() bool</td>
<td>返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的v== nil操作</td>
</tr>
<tr>
<td>IsValid() bool</td>
<td>判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//*int的空指针</span></span><br><span class="line">	<span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;var a *int:&quot;</span>, reflect.ValueOf(a).IsNil())  </span><br><span class="line">    <span class="comment">// var a *int: true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//nil值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;nil:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid()) </span><br><span class="line">    <span class="comment">// nil: false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//*int类型的空指针</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;(*int)(nil):&quot;</span>, reflect.ValueOf((*<span class="keyword">int</span>)(<span class="literal">nil</span>)).Elem().IsValid()) </span><br><span class="line">    <span class="comment">// (*int)(nil): false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//实例化一个结构体</span></span><br><span class="line">	s := <span class="keyword">struct</span> &#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尝试从结构体中查找一个不存在的字段</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(s).FieldByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的结构体成员: false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//尝试从结构体中查找一个不存在的方法</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;不存在的方法:&quot;</span>, reflect.ValueOf(s).MethodByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的方法: false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//实例化一个map</span></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尝试从map中查找一个不存在的键</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;不存在的键:&quot;</span>, reflect.ValueOf(m).MapIndex(reflect.ValueOf(<span class="number">3</span>)).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的键: false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将-chan-反射为-slices"><a href="#将-chan-反射为-slices" class="headerlink" title="将 chan 反射为 slices"></a>将 chan 反射为 slices</h2><p>假设一个chan会返回出1、2、3 三个数字，我们可以通过<code>range</code>读出chan中的数字。如下</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outputInt</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">			a &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(a)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过反射将chan中的内容反射为切片。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">chs := CovertChanToSlice(outputInt())</span><br><span class="line">fmt.Println(chs)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS详解（三）</title>
    <url>/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。</p>
<a id="more"></a>
<ul>
<li><a href="https://www.kiosk007.top/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/">TLS 详解一</a></li>
<li><a href="https://www.kiosk007.top/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/">TLS 详解二</a></li>
</ul>
<h1 id="TLS1-3-Feature"><a href="#TLS1-3-Feature" class="headerlink" title="TLS1.3 Feature"></a>TLS1.3 Feature</h1><ul>
<li><font color="#7B68EE">Speed Benefits of TLS 1.3</font>

</li>
</ul>
<p>TLS1.3 可以使用1RTT建立握手，比1.2版本能节约一个网络来回。</p>
<p><img style="height:300px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-performance.png"></p>
<ul>
<li><font color="#7B68EE">Improved Security With TLS 1.3</font>

</li>
</ul>
<p>TLS1.3 移除了RC4、DES、MD5 等诸多脆弱不安全的算法，目前仅保持了支持AEAD的ECDH类等算法。</p>
<ul>
<li><font color="#7B68EE"> 1.3 Browser Support</font>

</li>
</ul>
<p>从 Chrome65 开始，Google公司就可以支持 <a href="http://www.chromium.org/Home/tls13">draft version of TLS 1.3 </a> , 2018年10月的 Chrome70 就完全支持了TLS1.3。同样Firefox63也在同年10月支持了TLS1.3。Microsoft Edge version 76 及 Safari 12.1 on macOS 10.14.4. 也都支持了TLS1.3 。</p>
<h1 id="The-TLS-handshake"><a href="#The-TLS-handshake" class="headerlink" title="The TLS handshake"></a>The TLS handshake</h1><p>总体握手流程如下<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">handshake</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c := hs.c</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For an overview of the TLS 1.3 handshake, see RFC 8446, Section 2.</span></span><br><span class="line">	<span class="keyword">if</span> err := hs.processClientHello(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	<span class="keyword">if</span> err := hs.checkForResumption(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	<span class="keyword">if</span> err := hs.pickCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	c.buffering = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> err := hs.sendServerParameters(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	<span class="keyword">if</span> err := hs.sendServerCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	<span class="keyword">if</span> err := hs.sendServerFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	<span class="comment">// Note that at this point we could start sending application data without</span></span><br><span class="line">	<span class="comment">// waiting for the client&#x27;s second flight, but the application might not</span></span><br><span class="line">	<span class="comment">// expect the lack of replay protection of the ClientHello parameters.</span></span><br><span class="line">	<span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err  &#125;</span><br><span class="line">	<span class="keyword">if</span> err := hs.readClientCertificate(); err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> err  &#125;</span><br><span class="line">	<span class="keyword">if</span> err := hs.readClientFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"></span><br><span class="line">	atomic.StoreUint32(&amp;c.handshakeStatus, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/network/TLSDetailAnalysis/tls-1.3.png"></p>
<h2 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a><font style="color:#4682B4">Client Hello</font></h2><p>由于TLS1.2已经在互联网上存在了10年。网络中大量的网络中间设备都十分老旧，这些网络设备会识别中间的TLS握手头部，所以TLS1.3的出现如果引入了未知的TLS Version 必然会存在大量的握手失败，为了解决这一点，TLS1.3 的握手头部默认是TLS1.2。</p>
<p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-clienthello.png"></p>
<p>如果客户端支持TLS1.3 则在 <strong><font style="color:#483D8B">Client Hello</font></strong> 发出时在Extensions中携带 supported_versions 并标明客户端是支持TLS1.3的，同样为了1RTT快速握手，会将客户端Key_share 发送给服务端。Key_Share是客户端提前生成好的公钥信息。其密钥派生过程依赖于密码套件的 HKDF Extract 和 HKDF Expand 函数以及 Hash函数。</p>
<p>在密钥交换之前，客户端和服务端使用HKDF生成密钥。（它取代了基于HMAC的伪随机密钥生成函数PRF。</p>
<p>下面用代码过一遍客户端的Client Hello流程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> params ecdheParameters</span><br><span class="line"><span class="keyword">if</span> hello.supportedVersions[<span class="number">0</span>] == VersionTLS13 &#123;</span><br><span class="line">	hello.cipherSuites = <span class="built_in">append</span>(hello.cipherSuites, defaultCipherSuitesTLS13()...)</span><br><span class="line"></span><br><span class="line">	curveID := config.curvePreferences()[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">if</span> _, ok := curveForCurveID(curveID); curveID != X25519 &amp;&amp; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;tls: CurvePreferences includes unsupported curve&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	params, err = generateECDHEParameters(config.rand(), curveID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	hello.keyShares = []keyShare&#123;&#123;group: curveID, data: params.PublicKey()&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，如果客户端是支持  <font style="color:#483D8B">VersionTLS13</font>, 则在创建 <font style="color:#483D8B"> Client Hello </font> 时,添加TLS1.3支持的秘钥套件，并使用 x25519 曲线和随机数生成 <font style="color:#483D8B"> PublickKey </font>放入 <font style="color:#483D8B"> Client Hello Extension</font> 中的 <font style="color:#483D8B"> KeyShares </font> 中。</p>
<h2 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a><font style="color:#4682B4">Server Hello</font></h2><p>服务端的TLS Version仍为TLS1.2（实际上后续的TLS版本均为1.2），如果服务端支持TLS1.3，则会在  <font style="color:#483D8B">supported_versions</font> 中的携带TLS1.3，这样后续的会话便均在TLS1.3下通信。</p>
<p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-serverhello.png"></p>
<p>服务端会在<font style="color:#483D8B"> Server Hello </font> 中的 <font style="color:#483D8B"> key_share </font> 中携带公钥信息。</p>
<p>下面是完整的握手过程，BTW <font style="color:red">虽然0RTT是各大博客都吹嘘的TLS1.3亮点，但是0RTT 当前大多数的官方库都还没有实现（Nginx似乎是支持了）</font> ，比如看这里<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hs.clientHello.earlyData &#123;</span><br><span class="line">	<span class="comment">// See RFC 8446, Section 4.2.10 for the complicated behavior required</span></span><br><span class="line">	<span class="comment">// here. The scenario is that a different server at our address offered</span></span><br><span class="line">	<span class="comment">// to accept early data in the past, which we can&#x27;t handle. For now, all</span></span><br><span class="line">	<span class="comment">// 0-RTT enabled session tickets need to expire before a Go server can</span></span><br><span class="line">	<span class="comment">// replace a server or join a pool. That&#x27;s the same requirement that</span></span><br><span class="line">	<span class="comment">// applies to mixing or replacing with any TLS 1.2 server.</span></span><br><span class="line">	c.sendAlert(alertUnsupportedExtension)</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;tls: client sent unexpected early data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>服务端选择和客户端同样支持的 <font style="color:#483D8B"> CurveID </font>(代码中的 selectedGroup，并且是Client支持的Key Share)。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">params, err := generateECDHEParameters(c.config.rand(), selectedGroup)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	c.sendAlert(alertInternalError)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">hs.hello.serverShare = keyShare&#123;group: selectedGroup, data: params.PublicKey()&#125;</span><br><span class="line">hs.sharedKey = params.SharedKey(clientKeyShare.data)</span><br><span class="line"><span class="keyword">if</span> hs.sharedKey == <span class="literal">nil</span> &#123;</span><br><span class="line">	c.sendAlert(alertIllegalParameter)</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;tls: invalid client key share&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样以来，客户端和服务端便直接完成了 <font style="color:#483D8B">ECDHE</font> 密钥交换</p>
<ul>
<li>客户端生成随机数x，确定了曲线类型如Golang TLS SDK只支持的 <font style="color:#483D8B"> x25519曲线</font> 即可得方程系数a、b，再调用<code>generateECDHEParameters</code> 获得 <font style="color:#483D8B"> PublicKey Q<sub>1</sub> </font>。客户端将 Q<sub>1</sub> 、a、 b、 P 传给服务端。</li>
<li>服务端生成随机数y，解析客户端传来的曲线和 Key_Share 对，得到曲线类型 <font style="color:#483D8B"> x25519 </font>既得方程系数a、b，再使用 selectedGroup 和 y 调用<code>generateECDHEParameters</code> 生成 <font style="color:#483D8B"> PublicKey Q<sub>2</sub> </font> ,传给客户端</li>
<li>这时客户端和服务端可以计算出一个公共的值 <font style="color:#483D8B"> <strong>K</strong> </font></li>
</ul>
<p>如下图</p>
<p><img src="/images/network/TLSDetailAnalysis/ECDHE.png"></p>
<h3 id="PSK-Pre-Shared-Key"><a href="#PSK-Pre-Shared-Key" class="headerlink" title=" PSK (Pre-Shared Key)"></a><font style="color:#87CEEB"> PSK (Pre-Shared Key)</font></h3><p>这里在接着解析代码之前，先插播一个 TLS1.3 的feature 0RTT是如何实现的。这里介绍一下实现的原理 — <font style="color:#483D8B"> <strong>PSK</strong> </font></p>
<p>一旦一次握手完成，server 就能给 client 发送一个与一个独特密钥对应的 PSK 密钥，这个密钥来自初次握手。然后 client 能够使用这个 PSK 密钥在将来的握手中协商相关 PSK 的使用。如果 server 接受它，新连接的安全上下文在密码学上就与初始连接关联在一起，从初次握手中得到的密钥就会用于装载密码状态来替代完整的握手。在 TLS 1.2 以及更低的版本中，这个功能由 “session IDs” 和 “session tickets” [RFC5077]来提供。这两个机制在 TLS 1.3 中都被废除了。</p>
<p>PSK 可以与 (EC)DHE 密钥交换算法一同使用以便使共享密钥具备前向安全，或者 PSK 可以被单独使用，这样是以丢失了应用数据的前向安全为代价。</p>
<p>下图显示了两次握手，第一次建立了一个 PSK，第二次时使用它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">       Client                                               Server</span><br><span class="line"></span><br><span class="line">Initial Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share               --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                       + key_share</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                             &#123;CertificateRequest*&#125;</span><br><span class="line">                                                    &#123;Certificate*&#125;</span><br><span class="line">                                              &#123;CertificateVerify*&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Certificate*&#125;</span><br><span class="line">       &#123;CertificateVerify*&#125;</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">                                 &lt;--------      [NewSessionTicket]</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subsequent Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share*</span><br><span class="line">       + pre_shared_key          --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                  + pre_shared_key</span><br><span class="line">                                                      + key_share*</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当 server 通过一个 PSK 进行认证时，它不会发送一个 Certificate 或一个 CertificateVerify 消息。当一个 client 通过 PSK 想恢复会话的时候，它也应当提供一个 “key_share” 给 server，以允许 server 拒绝恢复会话的时候降级到重新回答一个完整的握手流程中。Server 响应 “pre_shared_key” 扩展，使用 PSK 密钥协商建立连接，同时响应 “key_share” 扩展来进行 (EC)DHE 密钥建立，由此提供前向安全。</p>
<p>当 PKS 在带外提供时，PSK 密钥和与 PSK 一起使用的 KDF hash 算法也必须被提供。</p>
<h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0 RTT"></a><font style="color:#87CEEB">0 RTT</font></h3><p>当 client 和 server 共享一个 PSK（从外部获得或通过一个以前的握手获得）时，TLS 1.3 允许 client 在第一个发送出去的消息中携带数据（”application data”）。Client 使用这个 PSK 来认证 server 并加密 early data 信息，最终实现Application数据的0RTT发送。</p>
<p>如下图所示，0-RTT 数据在第一个发送的消息中被加入到 1-RTT 握手过程中。握手的其余消息与带 PSK 会话恢复的 1-RTT 握手消息相同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">+ early_data</span><br><span class="line">+ key_share*</span><br><span class="line">+ psk_key_exchange_modes</span><br><span class="line">+ pre_shared_key</span><br><span class="line">(Application Data*)     --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                           + pre_shared_key</span><br><span class="line">                                               + key_share*</span><br><span class="line">                                      &#123;EncryptedExtensions&#125;</span><br><span class="line">                                              + early_data*</span><br><span class="line">                                                 &#123;Finished&#125;</span><br><span class="line">                        &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;              --------&gt;</span><br><span class="line">[Application Data]      &lt;-------&gt;        [Application Data]</span><br></pre></td></tr></table></figure>
<p>上图是 0-RTT 的信息流</p>
<p>0-RTT 数组安全性比其他类型的 TLS 数据要弱一些，特别是：</p>
<ol>
<li>0-RTT 的数据是没有前向安全性的，它使用的是被提供的 PSK 中导出的密钥进行加密的。</li>
<li>在多个连接之间不能保证不存在重放攻击。普通的 TLS 1.3 1-RTT 数据为了防止重放攻击的保护方法是使用 server 下发的随机数，现在 0-RTT 不依赖于 ServerHello 消息，因此保护措施更差。如果数据与 TLS client 认证或与应用协议里一起验证，这一点安全性的考虑尤其重要。这个警告适用于任何使用 early_exporter_master_secret 的情况。</li>
</ol>
<p>参考 <strong><a href="https://halfrost.com/tls_1-3_introduction/">TLS 1.3 Introduction</a></strong> — Halfrost’s Field | 冰霜之地</p>
<h3 id="checkForResumption-—-Go"><a href="#checkForResumption-—-Go" class="headerlink" title=" checkForResumption — Go"></a><font style="color:#87CEEB"> checkForResumption — Go</font></h3><p>上面2个小节其实就是在介绍 <a href="https://golang.org/src/crypto/tls/handshake_server_tls13.go#226"><code>checkForResumption()</code></a> 这个函数的作用。</p>
<p>在Client Hello 包的扩展里如果有 <strong>psk_key_exchange_modes</strong> 和  <strong>pre_shared_key</strong> 就表示客户端想要会话复用，即类似TLS1.2的 <strong>Session Ticket</strong> or <strong>Session Id</strong> 的概念。</p>
<p>如下所示：</p>
<p><img src="/images/network/TLSDetailAnalysis/tls-1.3-psk_key_exchange_modes.png"></p>
<font style="color:#483D8B"> **psk_key_exchange_modes**</font>是 psk 密钥交互模式选择. 此处的PSK模式为(EC)DHE下的PSK，客户端和服务器必须提供KeyShare, 如果是仅PSK模式，则服务器不需要提供KeyShare。


<img src="/images/network/TLSDetailAnalysis/tls-1.3-pre_shared_key.png">

<font style="color:#483D8B"> **pre_shared_key**</font> 是预共享密钥认证机制，相当于session ticket再加一些检验的东西.
Identity中包含的是客户端愿意进行协商的服务器身份列表。PSK binder表示已经构建当前PSK与当前握手之间的绑定。


下面函数中，服务端会将 <font style="color:#483D8B">identity</font> 解析成 <font style="color:#483D8B">plaintext</font>，<font style="color:#483D8B">plaintext</font>中包含TLS版本、证书、复用秘钥、超时时间 等多个信息，如果unmarshal成功，即可以会话复用，继续向下。


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, identity := <span class="keyword">range</span> hs.clientHello.pskIdentities &#123;</span><br><span class="line">	<span class="keyword">if</span> i &gt;= maxClientPSKIdentities &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">	plaintext, _ := c.decryptTicket(identity.label)</span><br><span class="line">	<span class="keyword">if</span> plaintext == <span class="literal">nil</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">	sessionState := <span class="built_in">new</span>(sessionStateTLS13)</span><br><span class="line">       </span><br><span class="line">	<span class="keyword">if</span> ok := sessionState.unmarshal(plaintext); !ok &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">       </span><br><span class="line">       createdAt := time.Unix(<span class="keyword">int64</span>(sessionState.createdAt), <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> c.config.time().Sub(createdAt) &gt; maxSessionTicketLifetime &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We don&#x27;t check the obfuscated ticket age because it&#x27;s affected by</span></span><br><span class="line">	<span class="comment">// clock skew and it&#x27;s only a freshness signal useful for shrinking the</span></span><br><span class="line">	<span class="comment">// window for replay attacks, which don&#x27;t affect us as we don&#x27;t do 0-RTT.</span></span><br><span class="line"></span><br><span class="line">	pskSuite := cipherSuiteTLS13ByID(sessionState.cipherSuite)</span><br><span class="line">	<span class="keyword">if</span> pskSuite == <span class="literal">nil</span> || pskSuite.hash != hs.suite.hash &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">	...</span><br><span class="line">	psk := hs.suite.expandLabel(sessionState.resumptionSecret, <span class="string">&quot;resumption&quot;</span>,</span><br><span class="line">		<span class="literal">nil</span>, hs.suite.hash.Size())</span><br><span class="line">	hs.earlySecret = hs.suite.extract(psk, <span class="literal">nil</span>)</span><br><span class="line">	binderKey := hs.suite.deriveSecret(hs.earlySecret, resumptionBinderLabel, <span class="literal">nil</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>


## <font style="color:#4682B4"> Change Cipher Space</font>

<p>发送一个 <font style="color:#483D8B"><strong>ChangeCipherSpec record</strong></font> 报文，之后的加密方式将会改变。详见 See RFC 8446, Appendix D.4.</p>
<h2 id="EncryptedExtensions"><a href="#EncryptedExtensions" class="headerlink" title=" EncryptedExtensions "></a><font style="color:#4682B4"> EncryptedExtensions </font></h2><p>随后 Server 会发来建立 EncryptedExtensions Server 参数: 对 ClientHello 扩展的响应，不需要确定加密参数，而不是特定于各个证书的加密参数。一般ALPN会在这里添加。</p>
<h2 id="Certificate-amp-amp-Certificate-Verify-amp-amp-Finished"><a href="#Certificate-amp-amp-Certificate-Verify-amp-amp-Finished" class="headerlink" title=" Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished "></a><font style="color:#4682B4"> Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished </font></h2><p>最后，Client 和 Server 交换认证消息。TLS 在每次基于证书的认证时使用相同的消息集，(基于 PSK 的认证是密钥交换中的一个副作用)特别是：</p>
<ul>
<li><p><font style="color:#483D8B">Certificate</font>: 终端的证书和每个证书的扩展。 服务器如果不通过证书进行身份验证，并且如果服务器没有发送CertificateRequest（由此指示客户端不应该使用证书进行身份验证），客户端将忽略此消息。 请注意，如果使用原始公钥 [RFC7250] 或缓存信息扩展 [RFC7924]，则此消息将不包含证书，而是包含与服务器长期密钥相对应的其他值。</p>
</li>
<li><p><font style="color:#483D8B">CertificateVerify</font>: 使用与证书消息中的公钥配对的私钥对整个握手消息进行签名。如果终端没有使用证书进行验证则此消息会被忽略。</p>
</li>
<li><p><font style="color:#483D8B">Finished</font>: 对整个握手消息的 MAC(消息认证码)。这个消息提供了密钥确认，将终端身份与交换的密钥绑定在一起，这样在 PSK 模式下也能认证握手。</p>
</li>
</ul>
<p>接收到 Server 的消息之后，Client 会响应它的认证消息，即 Certificate，CertificateVerify (如果需要), 和 Finished。</p>
<p>这时握手已经完成，client 和 server 会提取出密钥用于记录层交换应用层数据，这些数据需要通过认证的加密来保护。应用层数据不能在 Finished 消息之前发送数据，必须等到记录层开始使用加密密钥之后才可以发送。需要注意的是 server 可以在收到 client 的认证消息之前发送应用数据，任何在这个时间点发送的数据，当然都是在发送给一个未被认证的对端。</p>
<h2 id="New-Session-Ticket"><a href="#New-Session-Ticket" class="headerlink" title=" New Session Ticket "></a><font style="color:#4682B4"> New Session Ticket </font></h2><p>实际等同于发送 PSK 数据。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">shouldSendSessionTickets</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> hs.c.config.SessionTicketsDisabled &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don&#x27;t send tickets the client wouldn&#x27;t use. See RFC 8446, Section 4.2.9.</span></span><br><span class="line">	<span class="keyword">for</span> _, pskMode := <span class="keyword">range</span> hs.clientHello.pskModes &#123;</span><br><span class="line">		<span class="keyword">if</span> pskMode == pskModeDHE &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tls</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Quick Start</title>
    <url>/2020/12/19/Git-Quick-Start/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>只是git入门的简单指南。没什么大不了的 :)</p>
<a id="more"></a>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br><img src="https://img1.kiosk007.top/static/images/git/git.png" style="height:340px"></p>
<p>参考: <a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>
<h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><p><a href="https://git-scm.com/download/linux">安装 Git Linux 版</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install git</span><br><span class="line">$ apt-get install gitk</span><br></pre></td></tr></table></figure><br>gitk 是可以可视化的git客户端工具，更多工具参考 <a href="https://git-scm.com/download/gui/linux">git-gui</a> ，如 <a href="https://juejin.cn/post/6844903904451231757">Gitkraken (小章鱼)</a>、 <a href="https://magit.vc/manual/magit/Installing-from-the-Git-Repository.html#Installing-from-the-Git-Repository">magit</a> 等等</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li><strong>配置 user 信息</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name  <span class="string">&quot;your_name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;your_name@domain.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --local 只对某个分支有效</span></span><br><span class="line"><span class="comment"># --global 对当前用户所有仓库有效</span></span><br><span class="line"><span class="comment"># --system 对系统所有用户有效</span></span><br><span class="line"></span><br><span class="line">$ git config --global core.editor <span class="string">&quot;vim&quot;</span>    <span class="comment"># git 交互改为vim</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>查看config的配置</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>区域划分</p>
<ul>
<li><strong>工作区(Working Area)</strong>：当前工作目录</li>
<li><strong>暂存区(Staging Area)</strong> ：下次会被提交的部分</li>
<li><strong>本地仓库(Local Repository)</strong>：本地代码仓库，维护本地已提交的部分</li>
<li><strong>远程仓库本地镜像(Remote/Origin Repository)</strong>：远程仓库的一份本地副本，用于跟踪远程</li>
<li><strong>远程仓库(Remote Repository)</strong>：远程代码仓库</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/git/git_workfull.png"></p>
<p>改动操作使得文件处于不同状态，git status可以查看改动的文件所处于的状态</p>
<ul>
<li><strong>未跟踪状态(Untracked)</strong>:  尚未被仓库管理的文件，即仓库里没有的文件</li>
<li><strong>已修改状态(Modified)</strong>：仓库里有，本地修改</li>
<li><strong>已暂存状态(Staged)</strong>:  仓库里有，本地修改并加入暂存，改动会被提交</li>
<li><strong>未修改状态(Unmodified)</strong>: 文件提交后由仓库管理，本地无修改</li>
</ul>
<h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><ul>
<li><font color="#EEB422"> 新建仓库 </font>

</li>
</ul>
<p>远程项目不存在时，本地初始化后上传</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;项目目录&gt;</span><br><span class="line">git init  //初始化，生成.git子目录</span><br><span class="line">git remote add origin &lt;项目git地址&gt;</span><br><span class="line">git add .  //当前目录下所有内容加入暂存区</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>远程项目已存在时，直接从远程下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;项目git地址&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;项目目录&gt;</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;add README&quot;</span>  //参数m表示提交信息</span><br><span class="line">git push -u origin master   //参数u表示关联远程分支</span><br></pre></td></tr></table></figure>
<h2 id="基本工作流"><a href="#基本工作流" class="headerlink" title="基本工作流"></a>基本工作流</h2><p><img src="https://img1.kiosk007.top/static/images/git/git_base_workflow.png"></p>
<ul>
<li><font color="#EEB422"> 添加和推送 </font>

</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 使用如下命令：git add &lt;filename&gt; 或者 git add *</span><br><span class="line">2. 使用如下命令以实际提交改动：git commit -m <span class="string">&quot;代码提交信息&quot;</span></span><br><span class="line">3. 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#EEB422"> 添加和推送 </font>

</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 通过git fetch把远程改动拉取到本地</span><br><span class="line">2. 将远程修改与本地融合merge/rebase</span><br><span class="line">- 基于merge: 合并远程和本地改动</span><br><span class="line">  - git pull等价于git fetch+git merge</span><br><span class="line">- 基于rebase: 以远程为基准，将本地修改操作重放</span><br><span class="line">  - git pull --rebase等价于git fetch+git rebase</span><br></pre></td></tr></table></figure>
<h2 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p><img src="https://img1.kiosk007.top/static/images/git/branches.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 创建一个叫做“feature_x”的分支，并切换过去： git checkout -b feature_x</span><br><span class="line">- 切换回主分支： git checkout master</span><br><span class="line">- 删除分支： git branch -d feature_x</span><br><span class="line">- 将自己的分支推送到远端： git push origin &lt;branch&gt;</span><br><span class="line">- 删除远程分支：git push origin --delete &lt;分支名&gt; </span><br><span class="line">- 列出本地分支：git branch</span><br><span class="line">- 列出远程分支：git branch --remotes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h2><ul>
<li><font color="#EEB422"> 删除文件 </font>

</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 本地删除文件，删除动作不加入暂存区，此时提交库内文件不会被删除：rm &lt;文件&gt;</span><br><span class="line">- 本地删除文件，同时把删除动作加入暂存区: git rm，相当于rm &lt;文件&gt;+ git add &lt;文件&gt;</span><br><span class="line">- 希望删除仓库文件，但是本地文件依然保留，成为未跟踪状态：git rm --cached &lt;文件&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#FF8247">**基本命令**</font>

</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line">$ git mv old_filename new_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">$ git rm filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作区的状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为软件发布创建标签, 如v1.0.0</span></span><br><span class="line">$ git tag v1.0.0 1b2e1d63ff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看git提交后日志</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline     <span class="comment"># 一行显示</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 4          <span class="comment"># 查看最近的几次</span></span><br><span class="line">$ git <span class="built_in">log</span> --all --graph <span class="comment"># 以图形化方式显示所有的提交日志</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline --decorate --all  <span class="comment"># 通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签 </span></span><br><span class="line">$ git <span class="built_in">log</span> --author=bob  <span class="comment"># 只看某一个人的提交记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看 diff</span></span><br><span class="line">$ git diff              <span class="comment"># 对比工作区和暂存区的差异</span></span><br><span class="line">$ git diff --cached  	<span class="comment"># 对比暂存区和HEAD所含文件(commit)的差异</span></span><br><span class="line">$ git diff -- style.css <span class="comment"># 只查看对某个文件的 diff 差异 (工作区和暂存区)</span></span><br><span class="line">$ git diff tmp master -- &lt;file&gt; <span class="comment"># 比较 tmp 和 master 分支的文件差异(也可以将branch改成commit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 取消提交</span></span><br><span class="line">$ git reset HEAD        <span class="comment"># 取消暂存 （取消 git add）</span></span><br><span class="line">$ git restore --staged &lt;file&gt;  <span class="comment"># 功能同上, 取消暂存 （可以 git status 查看当前的暂存状态）</span></span><br><span class="line"></span><br><span class="line">$ git checkout -- &lt;file&gt;      <span class="comment"># 在工作区的修改撤销到最近一次git add 或 git commit时的内容</span></span><br><span class="line">$ git reset --hard c04b46549  <span class="comment"># 恢复到历史上的某个 commit (工作区和暂存区都会清空)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#FF8247"> 版本管理 </font>

</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">$ git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于某个历史版本创建分支(基于 ac886ae 创建一个tmp分支)</span></span><br><span class="line">$ git checkout -b tmp ac886ae </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个分支</span></span><br><span class="line">$ git checkout -d ac886ae  <span class="comment"># 没有merge的分支不能通过 -d 删除</span></span><br><span class="line">$ git checkout -D ac886ae</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###################### commit 相关 ###########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最近一次提交的 commit 信息</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改前几次提交的 commit 信息</span></span><br><span class="line">$ git rebase -i ac224ct   <span class="comment"># 交互式操作，ac224ct 是要修改的commit的父commit</span></span><br><span class="line">将pick改为r  :wq退出，</span><br><span class="line">变更内容     :wq退出</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="git常见使用"><a href="#git常见使用" class="headerlink" title="git常见使用"></a>git常见使用</h1><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a><font color="#FF4500"><strong>分离头指针</strong></font></h2><p>通常，我们工作在某一个分支上，比如 master 分支。这个时候 master 指针和 HEAD 指针是一起前进的，每做一次提交，这两个指针就会一起向前挪一步。但是在某种情况下（例如 checkout 了某个具体的 commit），master 指针 和 HEAD 指针这种「绑定」的状态就被打破了，变成了分离头指针状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ git checkout fb7d808</span><br><span class="line">注意：正在切换到 <span class="string">&#x27;fb7d808&#x27;</span>。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 <span class="literal">false</span> 来关闭此建议</span><br><span class="line"></span><br><span class="line">HEAD 目前位于 fb7d808 Learn CSS demo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>git 在对于这种没有 branch 的变更会被清除掉。所以如果想要变更最好跟着分支进行变更。</p>
<h2 id="git-stash-命令实用指南"><a href="#git-stash-命令实用指南" class="headerlink" title="git stash 命令实用指南"></a>git stash 命令实用指南</h2><p>为什么 git stash 很重要，假设Git没有暂存变更命令，当你在有2个分支（A和B）的仓库上工作时，假设这两个分支已经分叉很长时间，并且有不同的头，当你处理A的时候，团队要求修复B分支的一个错误，你迅速将你的修改保存到A分支(但没有提交 commit),并且尝试用 <code>git checkout B</code> 来切到B分支，git 会立即终止这个操作，并报错。“你对以下文件的本地修改会被签出覆盖… …请在切换分之前提交你的修改或者将他们暂存起来”</p>
<p>在这种情况下有几种方法来分支切换。</p>
<ul>
<li>在分支A中创建一个提交（git switch -c），提交并推送你的修改，以修复 B 中的错误。然后签出A，并运行 <code>git reset HEAD</code>, 来恢复修改。</li>
<li>手动保留不被Git 追踪文件中的改动。</li>
</ul>
<p>第二种就不说了，一点也不极客。第一种方法虽然看起来很传统，但是不灵活，因为保存未完成工作的修改会被当做一个检查点，而不是一个仍在进行中的补丁。这就是 <code>git stash</code> 的场景。</p>
<p><code>git stash</code> 将未提交的改动保存在本地，让你可以进行修改，切换分支及其他的操作。然后当你需要的时候，你可以重新应用这些存储的改动。暂存是本地范围的，不会被<code>git push</code> 推送的远端。</p>
<p>以下是一次 <code>git stash</code> 的操作顺序</p>
<ol>
<li>将修改保存到分支A</li>
<li>运行 <code>git stash</code></li>
<li>签出分支B</li>
<li>修正B分支的错误</li>
<li>提交并推送到远程</li>
<li>查看分支A</li>
<li>运行 <code>git stash pop</code> 来取回暂存的改动。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 现将工作区的内容保存到暂存区</span></span><br><span class="line">$ git add *</span><br><span class="line"><span class="comment"># 将暂存区的内容 暂时保存</span></span><br><span class="line">$ git stash   </span><br><span class="line">$ git stash save <span class="string">&quot;message&quot;</span>   <span class="comment"># 功能同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切到历史版本修复bug ... </span></span><br><span class="line"></span><br><span class="line">$ git stash apply  <span class="comment"># 将临时保存区的内容恢复，但不会删除记录，pop会删除。</span></span><br><span class="line">$ git stash pop </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title=" cherry pick "></a><font color="#FF4500"> cherry pick </font></h2><p>假设你在一个分支上已经做了很多次提交，但你意识到这个分支是错误的，该怎么办。<br>要么切换到正确的分支重复所有的变更。然后重新提交。要么呢就要用到 <code>cherry pick</code> 这个工具。</p>
<p><code>git cherry-pick</code> 可以将相同的commit提交复制到另一个分支上。就没有必要在不同的分支上做相同的操作。</p>
<blockquote>
<p>注意：<code>cherry-pick</code> 出来的提交会在另一个分支中创建带有新hash的提交，</p>
</blockquote>
<ul>
<li>它是如何工作的</li>
</ul>
<p>假设有2个分支，<code>toC</code> 和 <code>toB</code>, 现在有个bug在2个版本上都存在。我们在<code>toC</code> 分支上已经修复了这个bug。在 <code>toC</code>分支上运行<code>git log</code>命令，获取这次提交的 hash 值, 简单起见复制 25560 即可<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 255604842840febb7e11bbb443013fa584e76219 (HEAD -&gt; master, tag: v1.0.1, origin/master, origin/HEAD)</span><br><span class="line">Author: igolaizola &lt;11333576+igolaizola@users.noreply.github.com&gt;</span><br><span class="line">Date:   Thu Sep 26 09:31:17 2019 +0200</span><br></pre></td></tr></table></figure><br>然后切换到<code>toB</code>分支上，将刚刚的bugfix提交合入。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout toB</span><br><span class="line">$ git cherry-pick 25560</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>如果遇到了 “nothing to commit,working tree clean The previous cherry-pick is now empty,possibly due to conflict resolution” 不要惊慌，按照建议运行 <code>git commit --allow-empty</code> 即可。这个将打开你的编辑器，编辑提交信息即可。</p>
</li>
<li><p>如果遇到了合并重提，解决冲突后，输入 <code>git cherry-pick --continue</code> 恢复。</p>
</li>
</ul>
<p>参考: <a href="https://mp.weixin.qq.com/s/J7sVxIoIVClEirClBQoUtA">https://mp.weixin.qq.com/s/J7sVxIoIVClEirClBQoUtA</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/156726632">https://zhuanlan.zhihu.com/p/156726632</a></p>
<h2 id="指定文件不需要git管理"><a href="#指定文件不需要git管理" class="headerlink" title="指定文件不需要git管理"></a><font color="#FF4500"><strong>指定文件不需要git管理</strong></font></h2><p>在项目根目录下创建 <strong><code>.gitignore</code></strong> ,写入不需管理的文件名即可</p>
<h2 id="Git创建本地分支并关联远程分支"><a href="#Git创建本地分支并关联远程分支" class="headerlink" title="Git创建本地分支并关联远程分支"></a><font color="#FF4500"><strong><code>Git创建本地分支并关联远程分支</code></strong></font></h2><p>当我想从远程仓库里拉取一条本地不存在的分支时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure>
<p>如果出现以下报错<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#39;dev2&#39; at the same time.</span><br><span class="line">Did you intend to checkout &#39;origin&#x2F;dev2&#39; which can not be resolved as commit?</span><br></pre></td></tr></table></figure><br>表示拉取不成功。我们需要先执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch</span><br></pre></td></tr></table></figure><br>再执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure>
<p>修改之后再推送的话，可以执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --set-upstream origin 远程分支名</span><br></pre></td></tr></table></figure></p>
<h1 id="git目录功能"><a href="#git目录功能" class="headerlink" title=".git目录功能"></a>.git目录功能</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ .git git:(master) ls   </span><br><span class="line">branches  COMMIT_EDITMSG  config  description  gitk.cache  HEAD  hooks  index  info  logs  objects  refs</span><br></pre></td></tr></table></figure>
<ul>
<li><code>HEAD</code>: 当前工作的分支</li>
<li><code>config</code>: 配置信息，包含着 repository 的配置，包括 remote 的地址，提交时的 email、 username 等等.</li>
<li><code>refs</code>: 这个目录一般包括三个子文件夹：heads、remotes和tags，heads中的文件标识了项目中的各个分支指向的当前commit</li>
<li><code>info</code>: 包含仓库的一些信息</li>
<li><code>hooks</code>: 这个目录存放一些shell脚本，可以设置特定的git命令后出发相应的脚本；在搭建gitweb系统或其他git托管系统会经常用到hook script</li>
<li><code>logs</code>: 保存所有更新的引用记录</li>
<li><code>index</code>: 这个文件就是暂存区（stage），是一个二进制文件</li>
<li><code>description</code>: 仓库的描述信息，主要给gitweb等git托管系统使用</li>
<li><code>objects</code>: 所有的Git对象都会存放在这个目录中，对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名</li>
</ul>
<p>git 中的对象如下图所示，每一个 commit 提交都会包含 tree、committer、blob。其中committer是提交者，tree可粗略理解为目录，blob为文件。<br><img src="https://img1.kiosk007.top/static/images/git/git_commit_tree_blob.png" style="height:350px"></p>
<p>比如查看一次 commit<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看一次 commit</span></span><br><span class="line">$ git cat-file -p ac886ae797a9ee60962461b50993bc2bd09920fd</span><br><span class="line">tree 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">parent 4f41c2512ce8fcfbde05622c4d0cd75f14708a84</span><br><span class="line">author orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line">committer orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line"></span><br><span class="line">Add CS JS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该commit中的 tree</span></span><br><span class="line">$ git cat-file -p 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">100644 blob dac138d9e013a2e9a10e67d793bd4703c1b86bd1	index.css</span><br><span class="line">100644 blob e1d99bb43375f52095059d6d79a9c6d3045c048b	index.html</span><br><span class="line">100644 blob 7b4dcb5b597195d0469fec0787c2a7b7a4656d81	index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该tree中的blob</span></span><br><span class="line">$ git cat-file -p 7b4dcb5b597195d0469fec0787c2a7b7a4656d81</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">&quot;My First JavaScript&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="git-备份"><a href="#git-备份" class="headerlink" title="git 备份"></a>git 备份</h1><p><img src="https://img1.kiosk007.top/static/images/git/git_transport.webp" style="height:400px"></p>
<p>前两个协议是本地协议，后两个是远端托管平台。<br>哑协议传输进度不可见，智能协议传输可见。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将一个文件仓库 clone</span></span><br><span class="line"><span class="comment"># 哑协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare /home/kiosk/Project/Git/kiosk_demo/.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 智能协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare file:///home/kiosk/Project/Git/kiosk_demo/.git</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#FF8C00">**创建远程**</font>

</li>
</ul>
<p>可以使用 git remote add 命令将远程 URL 与名称匹配，例如<br><strong><code>git remote add origin  &lt;REMOTE_URL&gt;</code></strong><br>这会将名称 origin 与 REMOTE_URL 关联。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://github.com/user/repo.git</span><br><span class="line"><span class="comment"># Set a new remote</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># Verify new remote</span></span><br><span class="line">&gt; origin  https://github.com/user/repo.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/user/repo.git (push)</span><br></pre></td></tr></table></figure>
<p>远程 name 已存在,此错误消息表示您尝试添加的远程与本地仓库中的远程名称相同。可以尝试修改远程名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 查看现有远程</span></span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote rename origin destination</span><br><span class="line"><span class="comment"># 将远程名称从 &#x27;origin&#x27; 更改为 &#x27;destination&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 验证远程的新名称</span></span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (push)</span><br></pre></td></tr></table></figure>
<p>若远程的url发生了变化，可以通过<br><strong><code>git remote set-url origin https://github.com/USERNAME/REPOSITORY.git</code></strong><br>修改</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>gRPC Quick Start </title>
    <url>/2020/11/25/gRPC-Quick-Start/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RPC 全称 (Remote Procedure Call)，远程过程调用，指的是一台计算机通过网络请求另一台计算机的上服务，从而不需要了解底层网络细节，RPC 是构建在已经存在的协议（TCP/IP，HTTP 等）之上的。<code>gRPC</code> 是云原生计算基金会（CNCF）项目，gRPC 一开始由 google 开发，是一款语言中立、平台中立的服务间通信框架，使用 gRPC 可以使得客户端像调用本地方法一样，调用远程主机提供的服务。可以在任何地方运行，它使客户端和服务器应用程序能够透明地进行通信，并使构建连接系统变得更加容易。</p>
<a id="more"></a>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><ul>
<li>gRPC 默认采用 protocol buffer 作为 IDL (Interface Description Lanage) 接口描述语言，服务之间通信的数据序列化和反序列化也是基于 protocol buffer 的，因为 protocol buffer 的特殊性，所以 gRPC 框架是跨语言的通信框架（与编程语言无关性）</li>
<li>gRPC 是基于 http2 协议实现,多路复用支持通过同一连接发送多个并行请求,双向全双工通信，用于同时发送客户端请求和服务器响应,内置流式传输使请求和响应能够异步流式传输大数据集</li>
<li>gRPC 并没有直接实现负载均衡和服务发现的功能，但是已经提供了自己的设计思路。已经为命名解析和负载均衡提供了接口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service Greeter &#123;</span><br><span class="line">   &#x2F;*</span><br><span class="line">   以下 分别是 服务端 推送流， 客户端 推送流 ，双向流。</span><br><span class="line">   *&#x2F;</span><br><span class="line">  rpc GetStream (StreamReqData) returns (stream StreamResData)&#123;&#125;</span><br><span class="line">  rpc PutStream (stream StreamReqData) returns (StreamResData)&#123;&#125;</span><br><span class="line">  rpc AllStream (stream StreamReqData) returns (stream StreamResData)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Protocal-Buffer"><a href="#Protocal-Buffer" class="headerlink" title="Protocal Buffer"></a>Protocal Buffer</h1><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p><a href="https://developers.google.cn/protocol-buffers">Protocol buffers</a> 是一个灵活的、高效的、自动化的用于对结构化数据进行序列化的协议，与XML相比，Protocol buffers序列化后的码流更小、速度更快、操作更简单。</p>
<p><code>序列化(serialization、marshalling)</code>的过程是指将数据结构或者对象的状态转换成可以存储(比如文件、内存)或者传输的格式(比如网络)。反向操作就是反序列化<code>(deserialization、unmarshalling)</code>的过程。</p>
<ul>
<li>二十世纪九十年代后期，XML开始流行，它是一种人类易读的基于文本的编码方式，易于阅读和理解，但是失去了紧凑的基于字节流的编码的优势。</li>
<li>JSON是一种更轻量级的基于文本的编码方式，经常用在client/server端的通讯中。</li>
<li>YAML类似JSON，新的特性更强大，更适合人类阅读，也更紧凑。</li>
</ul>
<p>除了上面这些和Protobuf，还有许许多多的序列化格式，比如Thrift、Avro、BSON、CBOR、MessagePack, 还有很多非跨语言的编码格式。项目<a href="https://github.com/smallnest/gosercomp">gosercomp</a>对比了各种go的序列化库，包括序列化和反序列的性能，以及序列化后的数据大小。总体来说Protobuf序列化和反序列的性能都是比较高的，编码后的数据大小也不错。</p>
<font color="blue">如果你并不希望一定要在传输过程中消息数据可读，那么可以用 Protocal Buffer 来代替 Json 。</font>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;      &#x2F;&#x2F; 版本定义</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  int32  id &#x3D; 1;</span><br><span class="line">  string name &#x3D; 2;</span><br><span class="line">  bool   rich &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行指定<code>protobuf</code>的版本，这里是以proto3格式定义。</p>
<p>第三行 <code>message</code> 表示定义了一个结构体，在这个结构体里，最常见的类型有以下几种</p>
<ol>
<li><font color="#FFB90F">数值型</font> ，如 double, float, int32, int64 …</li>
<li><font color="#FFB90F">布尔型</font>，bool 只有True和False</li>
<li><font color="#FFB90F">字符型</font>，string 表示任意字符，但是长度不可超过2的32次方</li>
<li><font color="#FFB90F">字节型</font>，bytes表示任意的byte数组序列，但是长度也不可以超过2的32次方，比如可以用来传递一个图片。</li>
<li><font color="#FFB90F">枚举型</font>，enum 表示枚举。可独立在 message 之外。可通过 <code>option allow_alias = true;</code> 给枚举定义别名。</li>
<li>字典型，map类型需要设置键和值的类型。</li>
<li><font color="#FFB90F">Well-Known类型</font>, Protobuf也提供了定义，比如Timestamp和Duration。这些定义被放在<code>github.com/golang/protobuf/ptypes/</code>。</li>
</ol>
<p><strong>引入其它proto文件</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  &quot;other.proto&quot;;</span><br><span class="line">import public &quot;other2.proto&quot;;</span><br><span class="line">import weak &quot;other.proto&quot;;</span><br></pre></td></tr></table></figure><br>比较少使用的是public和weak关键字。默认情况下weak引入的文件允许不存在(missing)，只为了google内部使用。public具有传递性，如果你在文件中通过public引入第三方的proto文件，那么引入你这个文件同时也会引入第三方的proto。</p>
<p><strong>关键字：</strong></p>
<ol>
<li><font color="#FFB90F"> option</font> ：option可以用在proto的scope中，或者message、enum、service的定义中。一般常用的就是定义某语言生成后的package名，最常见的用法，如 <code>option go_package = &quot;xxx&quot;;</code></li>
<li><font color="#FFB90F">repeated</font> : 指定某一个字段可以存放同一个类型的多个数据, 相当于golang里的slice。可采用<code>[packed=true]</code>以实现更高<br>效的编码。<code>repeated int32 samples = 4 [packed=true];</code></li>
<li><font color="#FFB90F"> reserved</font> : 保护某字段或定义，如在message中指定 数字1 被保护，或变量名 person 被保护。一般用来保护废弃的数字定义。如<code>reserved 5;
reserved &quot;salary&quot;;</code> 如果再使用5 或者 salary 则会报错。</li>
</ol>
<p><strong>demo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package my.project; </span><br><span class="line"></span><br><span class="line">import &quot;google&#x2F;protobuf&#x2F;timestamp.proto&quot;;</span><br><span class="line"></span><br><span class="line">option go_package &#x3D; &quot;pb&quot;;</span><br><span class="line"></span><br><span class="line">message PersonMessage &#123;</span><br><span class="line">  int32   id &#x3D; 1;</span><br><span class="line">  bool    is_adult &#x3D;2;</span><br><span class="line">  string  name &#x3D; 3;</span><br><span class="line">  float   height &#x3D; 4;</span><br><span class="line">  float   weight &#x3D; 5;</span><br><span class="line">  bytes   avatar &#x3D; 6;</span><br><span class="line">  string  email &#x3D; 7;</span><br><span class="line">  bool    email_verified &#x3D; 8;</span><br><span class="line">  repeated string phone_numbers &#x3D; 9;  &#x2F;&#x2F; packed</span><br><span class="line">  Gender  gender &#x3D; 11;</span><br><span class="line">  Date    birthday &#x3D; 12;</span><br><span class="line">  repeated Address addresses &#x3D; 13;</span><br><span class="line">  google.protobuf.Timestamp lastModified &#x3D; 14;</span><br><span class="line"></span><br><span class="line">  enum Gender &#123;</span><br><span class="line">    option allow_alias &#x3D; true;</span><br><span class="line">    Not_SPECIFIED &#x3D; 0;</span><br><span class="line">    MALE &#x3D; 1;</span><br><span class="line">    FEMALE &#x3D; 2;</span><br><span class="line">    MAN &#x3D; 1;</span><br><span class="line">    WOMAN &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message Address &#123;</span><br><span class="line">    string province &#x3D; 1;</span><br><span class="line">    string city &#x3D; 2;</span><br><span class="line">    string zip_code &#x3D; 3;</span><br><span class="line">    string street &#x3D; 4;</span><br><span class="line">    string number &#x3D; 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reserved 10, 20 to 100, 200 to max;</span><br><span class="line">  reserved &quot;foo&quot;,&quot;bar&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Date &#123;</span><br><span class="line">  int32 year &#x3D; 1;</span><br><span class="line">  int32 month &#x3D; 2;</span><br><span class="line">  int32 day &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Golang-protocol-buffer"><a href="#Golang-protocol-buffer" class="headerlink" title="Golang protocol buffer"></a>Golang protocol buffer</h2><p>定义 <code>.proto</code> 文件后，使用命令<br><code>protoc --protoc_path src/ -go_out=src/ src/person.proto</code> 生成golang 文件</p>
<p><strong>定义一个pb</strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonMessage</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">PersonMessage</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.PersonMessage&#123;</span><br><span class="line">		Id: <span class="number">1</span>,</span><br><span class="line">		IsAdult: <span class="literal">true</span>,</span><br><span class="line">		Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">		Height: <span class="number">177</span>,</span><br><span class="line">		Weight: <span class="number">140</span>,</span><br><span class="line">		Gender: pb.PersonMessage_MALE,</span><br><span class="line">		PhoneNumbers: []<span class="keyword">string</span>&#123;<span class="string">&quot;15667026708&quot;</span>,<span class="string">&quot;17610660213&quot;</span>&#125;,</span><br><span class="line">		Email: <span class="string">&quot;weijiaxiang007@foxmail.com&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong> 将 pb 写入文件 </strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToFile</span><span class="params">(filename <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	dataBytes, err := proto.Marshal(pb)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;无法序列化&quot;</span>) &#125;</span><br><span class="line">	<span class="keyword">if</span> err := ioutil.WriteFile(filename, dataBytes, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;无法写入文件&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;成功写入到文件&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pm := NewPersonMessage()</span><br><span class="line">	_ = writeToFile(<span class="string">&quot;person.bin&quot;</span>,pm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong> 从文件读出 pb </strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromFile</span><span class="params">(filename <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	dataBytes, err := ioutil.ReadFile(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;读取文件错误&quot;</span>,err.Error()) &#125;</span><br><span class="line">	<span class="keyword">if</span> err := proto.Unmarshal(dataBytes, pb); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;反序列化失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pm := &amp;demo.PersonMessage&#123;&#125;</span><br><span class="line">	_ = readFromFile(<span class="string">&quot;person.bin&quot;</span>, pm)</span><br><span class="line">	fmt.Println(pm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>pb 转 json &amp;&amp; json 转 pb</strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toJson</span><span class="params">(pb proto.Message)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	marshaler := jsonpb.Marshaler&#123;Indent: <span class="string">&quot;    &quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	str ,err := marshaler.MarshalToString(pb)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;转换为JSON时发生错误&quot;</span>,err.Error()) &#125;</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fromJson</span><span class="params">(in <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> jsonpb.UnmarshalString(in, pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>gogo库</strong></p>
<p>虽然官方库 <font color="#68228B"><a href="https://github.com/golang/protobuf">golang/protobu</a> </font>提供了对Protobuf的支持，但是使用最多还是第三方实现的库<a href="https://github.com/gogo/protobuf">gogo/protobuf</a>。</p>
<p>gogo库基于官方库开发，增加了很多的功能，包括：</p>
<ol>
<li>快速的序列化和反序列化</li>
<li>更规范的Go数据结构</li>
<li>goprotobuf兼容</li>
<li>可选择的产生一些辅助方法，减少使用中的代码输入</li>
<li>可以选择产生测试代码和benchmark代码</li>
<li>其它序列化格式</li>
</ol>
<blockquote>
<p>更多参考github： <a href="http://github.com/gogo/protobuf">http://github.com/gogo/protobuf</a></p>
</blockquote>
<h1 id="gRPC-Start"><a href="#gRPC-Start" class="headerlink" title="gRPC Start"></a>gRPC Start</h1><p>进入主题了, gRPC 是Google发布的基于HTTP 2.0传输层协议承载的高性能开源软件框架。提供了支持多种编程语言的、对网络设备进行配置和纳管的方法。</p>
<p>RPC是远程函数调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间。因此传统的RPC方法调用对于上传和下载较大数据量场景并不适合。同时传统RPC模式也不适用于对时间不确定的订阅和发布模式。为此，gRPC框架针对服务器端和客户端分别提供了流特性。</p>
<font color="#483D8B">支持 服务端 推送流， 客户端 推送流 ，双向流。</font>


<p><img alt="Smiley face" height="420" src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_concept_diagram.png"></p>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>gRPC要求 Go 版本 &gt;= 1.6</p>
<ol>
<li>安装grpc<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get -u -v google.golang.org/grpc</span><br></pre></td></tr></table></figure></li>
<li>安装 Protocol Buffers v3、protoc-gen-go:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get -v -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure></li>
<li>生成grpc代码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ protoc -I. --go_out=plugins=grpc:. helloworld.proto</span><br></pre></td></tr></table></figure>
<h2 id="define-proto"><a href="#define-proto" class="headerlink" title="define proto"></a>define proto</h2></li>
</ol>
<p>gRPC需要事先定义proto文件，如下所示。定义完成后需要执行命令 <code>protoc --go_out=plugins=grpc:. message.proto</code> 生成相关的go语言代码。更多详细的操作参考官方例子 <a href="https://grpc.io/docs/languages/go/quickstart/">Quick start - gRPC</a></p>
<p><a href="/images/network/gRPC/message.proto">点击查看</a></p>
<h2 id="gRPC-server"><a href="#gRPC-server" class="headerlink" title="gRPC server"></a>gRPC server</h2><p>gRPC服务的启动流程和标准库的RPC服务启动流程类似：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> port  = <span class="string">&quot;:5001&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  log.Fatalln(err.Error() &#125;</span><br><span class="line">	<span class="keyword">var</span> options []grpc.ServerOption</span><br><span class="line">	options = <span class="built_in">append</span>(options, grpc.HeaderTableSize(<span class="number">2048</span>))</span><br><span class="line"></span><br><span class="line">	server := grpc.NewServer(options...)</span><br><span class="line">	pb.RegisterEmployeeServiceServer(server, <span class="built_in">new</span>(example.EmployeeService))</span><br><span class="line">	log.Printf(<span class="string">&quot;gRPC Server started ...\n Listen on port %s&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">	_ = server.Serve(listen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里设置监听在 tcp 的 5001 端口.</li>
<li><code>grpc.ServerOption</code> 可以设置gRPC的服务端监听参数， 这里我仅设置了 H2 的 header 动态表大小。除此之外，如设置 TLS证书载入：<code>grpc.Creds(c credentials.TransportCredentials)</code>。<br>最大并发数、收发最大消息Size等等，详见 <a href="https://godoc.org/google.golang.org/grpc#ServerOption">https://godoc.org/google.golang.org/grpc#ServerOption</a></li>
<li><code>pb.RegisterEmployeeServiceServer</code> 是proto生成的 message.pb.go 提供的服务端注册方法。<code>example.EmployeeService</code> 是我们后面手动创建的空结构，后面的函数方法都需要基于这个空结构实现。</li>
<li>server.Serve 将监听套接字传入。</li>
</ul>
<p><strong>实现 EmployeeService</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service EmployeeService &#123;</span><br><span class="line">  rpc GetByNo(GetByNoRequest) returns (EmployeeResponse);         &#x2F;&#x2F; 一元请求</span><br><span class="line">  rpc GetAll(GetAllRequest) returns (stream EmployeeResponse);    &#x2F;&#x2F; 客户端推送流</span><br><span class="line">  rpc AddPhoto(stream AddPhotoRequest) returns (AddPhotoResponse); &#x2F;&#x2F; 服务端推送流</span><br><span class="line">  rpc SaveAll(stream EmployeeRequest) returns (stream EmployeeResponse); &#x2F;&#x2F; 双向流</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对应的pb生成代码</span><br><span class="line">&#x2F;&#x2F; EmployeeServiceServer is the server API for EmployeeService service.</span><br><span class="line">type EmployeeServiceServer interface &#123;</span><br><span class="line">	GetByNo(context.Context, *GetByNoRequest) (*EmployeeResponse, error)</span><br><span class="line">	GetAll(*GetAllRequest, EmployeeService_GetAllServer) error</span><br><span class="line">	AddPhoto(EmployeeService_AddPhotoServer) error</span><br><span class="line">	SaveAll(EmployeeService_SaveAllServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先需要定义 <code>type EmployeeService struct &#123;&#125;</code> 后面的所有方法都需要基于这个实现，这个也是服务端注册的参数。</p>
<ul>
<li><strong>一元请求 <code>GetByNo()</code> </strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">GetByNo</span><span class="params">(ctx context.Context, request *pb.GetByNoRequest)</span> <span class="params">(*pb.EmployeeResponse, error)</span></span> &#123;</span><br><span class="line">	log.Println(request.No)</span><br><span class="line">	<span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">		<span class="keyword">if</span> request.No == e.No &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;pb.EmployeeResponse&#123;</span><br><span class="line">				Employee:           &amp;e,</span><br><span class="line">			&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;the employee does not exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
请求参数是 <code>GetByNoRequest</code>， 通过上面的pb定义得知，这个message是有一个No参数。所以可以取出来当请求参数。返回的参数是<code>EmployeeResponse</code>，通过pb定义得知，其返回参数是 <code>Employee</code> 对象。</li>
</ul>
<ul>
<li><strong>服务端返回流 <code>GetAll()</code></strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">GetAll</span><span class="params">(request *pb.GetAllRequest, stream pb.EmployeeService_GetAllServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">		err := stream.Send(&amp;pb.EmployeeResponse&#123;</span><br><span class="line">			Employee: &amp;e,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意，返回的参数是一条流，其流发送的方法也可以使用Send函数，这里是一个循环，将employee对象循环写入这条流中。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type EmployeeService_GetAllServer interface &#123;</span><br><span class="line">	Send(*EmployeeResponse) error</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>客户端推送流 <code>AddPhoto()</code></strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">AddPhoto</span><span class="params">(stream pb.EmployeeService_AddPhotoServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	md, ok := metadata.FromIncomingContext(stream.Context())</span><br><span class="line">	<span class="keyword">if</span> ok &#123; fmt.Printf(<span class="string">&quot;employee: %s&quot;</span>, md[<span class="string">&quot;no&quot;</span>][<span class="number">0</span>]) &#125;</span><br><span class="line">	<span class="keyword">var</span> images []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		data, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;File Size %d\n&quot;</span>, <span class="built_in">len</span>(images))</span><br><span class="line">			<span class="keyword">return</span> stream.SendAndClose(&amp;pb.AddPhotoResponse&#123;IsOk: <span class="literal">true</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;File received: %d\n&quot;</span>, <span class="built_in">len</span>(data.Data))</span><br><span class="line">		images = <span class="built_in">append</span>(images, data.Data...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数实现了客户端将一张图片拆分成 bytes 再一点一点发送给服务端的demo。读到EOF表示成功读完。Data正是在 pb 里定义的<code>AddPhotoRequest</code>的客户端请求内容。</p>
</li>
<li><p><strong>双向流 <code>SaveAll()</code></strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">SaveAll</span><span class="params">(stream pb.EmployeeService_SaveAllServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		empReq, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		employees = <span class="built_in">append</span>(employees, *empReq.Employee)</span><br><span class="line">		time.Sleep(<span class="number">1000</span> * time.Microsecond)</span><br><span class="line">		_ = stream.Send(&amp;pb.EmployeeResponse&#123;Employee: empReq.Employee&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _ , emp := <span class="keyword">range</span> employees &#123;</span><br><span class="line">		fmt.Println(emp)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，服务端每读一份数据，休眠100ms，再将读入的数据原封不动的返回给客户端。</p>
</li>
</ul>
<h2 id="gRPC-client"><a href="#gRPC-client" class="headerlink" title="gRPC client"></a>gRPC client</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> options []grpc.DialOption</span><br><span class="line">	options = <span class="built_in">append</span>(options, grpc.WithInsecure())</span><br><span class="line"></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost&quot;</span> + port, options...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;can&#x27;t dial server &quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	client := pb.NewEmployeeServiceClient(conn)</span><br><span class="line">	<span class="comment">// GetByNo(client)</span></span><br><span class="line">	<span class="comment">// getAll(client)</span></span><br><span class="line">	<span class="comment">//addPhoto(client)</span></span><br><span class="line">	saveAll(client)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端也有一个类似Server端的<code>grpc.DialOption</code>, 这里因为服务端没有使用证书，所以客户端必须添加 <code>WithInsecure</code> 选项。调用 <code>pb.NewEmployeeServiceClient(conn)</code> 会返回一个 Client <code>employeeServiceClient</code>。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> employeeServiceClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	cc grpc.ClientConnInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个client拥有之前定义的客户端可调用的 RPC 方法。如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; For semantics around ctx use and closing&#x2F;ending streaming RPCs, please refer to https:&#x2F;&#x2F;godoc.org&#x2F;google.golang.org&#x2F;grpc#ClientConn.NewStream.</span><br><span class="line">type EmployeeServiceClient interface &#123;</span><br><span class="line">	GetByNo(ctx context.Context, in *GetByNoRequest, opts ...grpc.CallOption) (*EmployeeResponse, error)</span><br><span class="line">	GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (EmployeeService_GetAllClient, error)</span><br><span class="line">	AddPhoto(ctx context.Context, opts ...grpc.CallOption) (EmployeeService_AddPhotoClient, error)</span><br><span class="line">	SaveAll(ctx context.Context, opts ...grpc.CallOption) (EmployeeService_SaveAllClient, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>实现 Client 调用</strong></p>
<ul>
<li><strong>一元请求 <code>GetByNo()</code></strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetByNo</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">	res, err := client.GetByNo(context.Background(), &amp;pb.GetByNoRequest&#123;No: <span class="number">1996</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
传入的参数拥有 <code>GetByNo()</code> 这个方法，直接调用即可。</li>
</ul>
<p>抓包可以看到，整个gRPC的调用过程是基于HTTP2的, 本质是发起了一个H2的POST请求, 和传统H2不同的是，response 的 Header帧有2个，结尾处还有一个。第2个表示调用结束。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Stream: HEADERS, Stream ID: 1, Length 80, POST /employee.EmployeeService/GetByNo</span><br><span class="line">    Length: 80</span><br><span class="line">    Type: HEADERS (1)</span><br><span class="line">    Flags: 0x04</span><br><span class="line">    0... .... .... .... .... .... .... .... = Reserved: 0x0</span><br><span class="line">    .000 0000 0000 0000 0000 0000 0000 0001 = Stream Identifier: 1</span><br><span class="line">    [Pad Length: 0]</span><br><span class="line">    Header Block Fragment: 3fe10f8386459960b4d741fd14abe0a6ba0fe8a5dc5b3b98…</span><br><span class="line">    [Header Length: 202]</span><br><span class="line">    [Header Count: 8]</span><br><span class="line">    Header table size update</span><br><span class="line">    Header: :method: POST</span><br><span class="line">    Header: :scheme: http</span><br><span class="line">    Header: :path: /employee.EmployeeService/GetByNo</span><br><span class="line">    Header: :authority: localhost:5001</span><br><span class="line">    Header: content-type: application/grpc</span><br><span class="line">    Header: user-agent: grpc-go/1.33.2</span><br><span class="line">    Header: te: trailers</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_v1.png" alt></p>
<ul>
<li><strong>服务端返回流 <code>GetAll()</code></strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAll</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">	stream, err := client.GetAll(context.Background(), &amp;pb.GetAllRequest&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(res.Employee)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
服务端返回的流可以使用 <code>stream.Recv()</code> 循环接收。<br><img src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_v2.png" alt></li>
</ul>
<ul>
<li><strong>客户端推送流 <code>AddPhoto()</code></strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">	imgFile,err := os.Open(<span class="string">&quot;/home/kiosk007/Pictures/2020-09-22_00-15.png&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> imgFile.Close()</span><br><span class="line"></span><br><span class="line">	md := metadata.New(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;no&quot;</span>: <span class="string">&quot;1996&quot;</span>&#125;)</span><br><span class="line">	context := context.Background()</span><br><span class="line">	context = metadata.NewOutgoingContext(context, md)</span><br><span class="line">	stream,err := client.AddPhoto(context)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		chunk := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>*<span class="number">24</span>)</span><br><span class="line">		chunkSize,err := imgFile.Read(chunk)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> chunkSize &lt; <span class="built_in">len</span>(chunk) &#123;</span><br><span class="line">			chunk = chunk[:chunkSize]</span><br><span class="line">		&#125;</span><br><span class="line">		_ = stream.Send(&amp;pb.AddPhotoRequest&#123;Data: chunk&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	res, err := stream.CloseAndRecv()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(res.IsOk)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
客户端推送流实现了一个照片流式上传的功能。每次发送 3072字节 (128*24)。</li>
</ul>
<ul>
<li><strong>双向流 <code>SaveAll()</code></strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveAll</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">	employees := []pb.Employee&#123;</span><br><span class="line">		pb.Employee&#123;</span><br><span class="line">			Id:                   <span class="number">300</span>,</span><br><span class="line">			No:                   <span class="number">5001</span>,</span><br><span class="line">			FirstName:            <span class="string">&quot;Monica&quot;</span>,</span><br><span class="line">			LastName:             <span class="string">&quot;Geller&quot;</span>,</span><br><span class="line">			MonthSalary:          <span class="number">15500</span>,</span><br><span class="line">			Status:               pb.EmployeeStatus_RETIRED,</span><br><span class="line">			LastModified:         &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix() &#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		pb.Employee&#123;</span><br><span class="line">			Id:                   <span class="number">301</span>,</span><br><span class="line">			No:                   <span class="number">5002</span>,</span><br><span class="line">			FirstName:            <span class="string">&quot;Joey&quot;</span>,</span><br><span class="line">			LastName:             <span class="string">&quot;Green&quot;</span>,</span><br><span class="line">			MonthSalary:          <span class="number">200</span>,</span><br><span class="line">			Status:               pb.EmployeeStatus_RESIGNED,</span><br><span class="line">			LastModified:         &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix() &#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	stream, err := client.SaveAll(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	finishChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			res,err := stream.Recv()</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				finishChannel &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalln(err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(res.Employee)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">		err := stream.Send(&amp;pb.EmployeeRequest&#123;Employee: &amp;e&#125;)</span><br><span class="line">		time.Sleep(<span class="number">500</span> * time.Microsecond)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_ = stream.CloseSend()</span><br><span class="line">	&lt;- finishChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>参考：</strong></p>
<ol>
<li><a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go">Protobuf 终极教程  — 鸟窝</a></li>
</ol>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Nginx的实时音频直播服务</title>
    <url>/2020/11/16/%E5%9F%BA%E4%BA%8ENginx%E5%AE%9E%E7%8E%B0%E7%9A%84RTMP%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在百度云上下了一些学习视频（别想歪..），苦于一台笔记本不方便同时跟着操作变播放，那么既然都有笔记本了，何不搭建一个视频播放服务呢？笔记本使用Nginx搭建一个视频服务器，iPad上使用播放器（Aplayer），不仅是播放还可以直播，这不正契合了当前的高热话题“实时音视频直播技术”么，最近也找了一部分资料，趁着直播的热度在这里总结一下。</p>
<a id="more"></a>
<p>  随着互联网用户消费内容和交互方式的升级，支撑这些内容和交互方式的基础设施也正在悄悄发生变革。手机设备拍摄视频能力和网络的升级催生了大家对视频直播领域的关注，吸引了很多互联网创业者或者成熟企业进入该领域。</p>
<h1 id="直播中的各个环节"><a href="#直播中的各个环节" class="headerlink" title="直播中的各个环节"></a>直播中的各个环节</h1><h2 id="完整的直播流程"><a href="#完整的直播流程" class="headerlink" title="完整的直播流程"></a>完整的直播流程</h2><p><img src="https://img1.kiosk007.top/static/images/live/live.jpg" alt></p>
<ul>
<li><font color="red"><code>音视频采集</code></font>: 采集是播放环节中的第一环，iOS 系统因为软硬件种类不多，硬件适配性较好，所以比较简单。Android 则不同，市面上硬件机型非常多，难以做到一个库适配所有硬件。PC 端的采集也跟各种摄像头驱动有关，推荐使用目前市面上最好用的 PC 端开源免费软件 OBS。</li>
<li><code>音视频处理</code>: 美颜、水印等也都是在这个环节做。目前 iOS 端比较知名的是 GPUImage 这个库，提供了丰富端预处理效果，还可以基于这个库自己写算法实现更丰富端效果。Android 也有 GPUImage 这个库的移植，叫做 android-gpuimage。</li>
<li><code>音视频编码</code>: iOS 端硬件兼容性较好，可以直接采用硬编。而 Android 的硬编的支持则难得多，需要支持各种硬件机型，推荐使用软编。</li>
<li><code>推流和传输</code>: 涉及 1、从主播端到服务端 2、从收流服务端到边缘节点 3、从边缘节点到观众端 。推流端和分发端理论上需要支持的并发用户数应该都是亿级的，不过毕竟产生内容的推流端在少数，和消费内容端播放端不是一个量级。对推流稳定性和速度的要求比播放端高很多，这涉及到所有播放端能否看到直播，以及直播端质量如何。</li>
<li><code>实时音视频转码</code>: 为了让主播推上来的流适配各个平台端各种不同协议，需要在服务端做一些流处理工作，比如转码成不同格式支持不同协议如 RTMP、HLS 和 FLV，一路转多路流来适配各种不同的网络状况和不同分辨率的终端设备。</li>
<li><code>解码和渲染</code>: 解码和渲染，也即音视频的播放，目前 iOS 端的播放兼容性较好，在延迟可接受的情况下使用 HLS 协议是最好的选择，市面上也提供了能够播放 RTMP 和 HLS 的播放器 SDK。</li>
</ul>
<p>参考：<a href="http://www.52im.net/thread-853-1-1.html">《移动端实时音视频直播技术详解》</a></p>
<p>编码器的介绍可以参考 <a href="http://www.52im.net/thread-965-1-1.html">编码与封装</a>，下面主要说一说“推流和拉流”</p>
<h2 id="推流和拉流"><a href="#推流和拉流" class="headerlink" title="推流和拉流"></a>推流和拉流</h2><h3 id="推送协议"><a href="#推送协议" class="headerlink" title="推送协议"></a><strong>推送协议</strong></h3><p>推流，指的是把采集阶段封包好的内容传输到服务器的过程。其实就是将现场的视频信号传到网络的过程。</p>
<p>“推流”对网络要求比较高，如果网络不稳定，直播效果就会很差，观众观看直播时就会发生卡顿等现象，观看体验很是糟糕。</p>
<p>要想用于推流还必须把音视频数据使用传输协议进行封装，变成流数据。常用的流传输协议有RTSP、RTMP、WebRTC、HLS等，使用RTMP传输的延时通常在1–3秒，对于手机直播这种实时性要求非常高的场景，RTMP也成为手机直播中最常用的流传输协议。</p>
<p>下面介绍一下以下协议以及他们在直播领域的现状和优缺点：<strong>1、RTMP 2、WebRTC</strong></p>
<h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a><strong>RTMP</strong></h4><p>RTMP 是 Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash/AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media Server/red5 等。<br>RTMP 是目前主流的流媒体传输协议，广泛用于直播领域，可以说市面上绝大多数的直播产品都采用了这个协议。<br>另外，RTMPT封装在HTTP请求之上，可穿透防火墙；</p>
<p><strong>优点:</strong></p>
<blockquote>
<p>CDN 支持良好，主流的 CDN 厂商都支持；<br>协议简单，在各平台上实现容易。</p>
</blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<p>基于 TCP ，传输成本高，在弱网环境丢包率高的情况下问题显著；<br>不支持浏览器推送；<br>Adobe 私有协议，Adobe 已经不再更新。</p>
</blockquote>
<h4 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a><strong>WebRTC</strong></h4><p>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的 API。它于 2011 年 6 月 1 日开源并在 Google、Mozilla、Opera 支持下被纳入万维网联盟的 W3C 推荐标准<br><a href="https://webrtc.org.cn/">WebRTC</a> </p>
<p><strong>目前主要应用于视频会议和连麦中</strong></p>
<p><strong>优点：</strong></p>
<blockquote>
<p>W3C 标准，主流浏览器支持程度高，Google 在背后支撑，并在各平台有参考实现；<br>底层基于 SRTP 和 UDP，弱网情况优化空间大；<br>可以实现点对点通信，通信双方延时低。</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>ICE、STUN、TURN 传统 CDN 没有类似的服务提供</p>
</blockquote>
<h3 id="拉流协议"><a href="#拉流协议" class="headerlink" title="拉流协议"></a><strong>拉流协议</strong></h3><p>拉流是指服务器已有直播内容，根据协议类型（如RTMP、RTP、RTSP、HTTP等），与服务器建立连接并接收数据，进行拉取的过程。</p>
<p>拉流端的核心处理在播放器端的解码和渲染，在互动直播中还需集成聊天室、点赞和礼物系统等功能。下面介绍几个常见的拉流协议。</p>
<h4 id="RTMP-1"><a href="#RTMP-1" class="headerlink" title="RTMP"></a><strong>RTMP</strong></h4><p>没错，推流和拉流都是RTMP所擅长的。现在 PC 市场巨大，PC 主要是 Windows，Windows 的浏览器基本上都支持 Flash。另外RTMP适合长时间播放，曾经有过测试，联系 100 万秒，即 10 天多连续播放没有出现问题。最后 RTMP 的延迟相对较低，一般延时在 1-3s 之间，一般的视频会议，互动式直播，完全是够用的。</p>
<p>不过，在移动端上，Flash Player 已经被杀绝了，那为啥还会出现这个呢？<br>因为它主要是针对 PC 端的。现在推流协议各大云厂商基本都是直接支持 rtmp 。</p>
<p><strong>拉流用 rtmp 的话就不太现实了，现在对 flash 支持都不友好了。</strong></p>
<h4 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a><strong>HLS</strong></h4><p>HLS 是苹果提出的基于HTTP的流媒体传输协议，优点是跨平台性比较好，HTML5可以直接打开播放，移动端兼容性良好，但是缺点是延迟比较高。</p>
<p>HLS 主要的两块内容是 .m3u8 文件和 .ts 播放文件。接受服务器会将接受到的视频流进行缓存，然后缓存到一定程度后，会将这些视频流进行编码格式化，同时会生成一份 .m3u8 文件和其它很多的 .ts 文件。</p>
<p>HLS 支持的功能，并不只是分片播放（专门适用于直播），它还包括其他应有的功能。</p>
<blockquote>
<p>使用 HTTPS 加密 ts 文件<br>快/倒放<br>广告插入<br>不同分辨率视频切换</p>
</blockquote>
<p><strong>HLS 之所以能这么流行，关键在于它的支持度是真的广，所以，对于一般 H5 直播来说，应该是非常友好的。</strong></p>
<h4 id="HDL-HTTP-FLV"><a href="#HDL-HTTP-FLV" class="headerlink" title="HDL(HTTP-FLV)"></a><strong>HDL(HTTP-FLV)</strong></h4><p>HTTP-FLV 和 RTMPT 类似，都是针对于 FLV 视频格式做的直播分发流。<br>但，两者有着很大的区别：</p>
<p><strong>相同点：</strong></p>
<blockquote>
<p>两者都是针对 FLV 格式<br>两者延时都很低<br>两者都走的 HTTP 通道</p>
</blockquote>
<p><strong>不同点：</strong></p>
<blockquote>
<p>HTTP-FLV直接发起长连接，下载对应的 FLV 文件<br>头部信息简单</p>
</blockquote>
<p>RTMPT握手协议过于复杂。分包，组包过程耗费精力大，因为 RTMP 发的包很容易处理，通常 RTMP 协议会作为视频上传端来处理，然后经由服务器转换为 FLV 文件，通过 HTTP-FLV 下发给用户。</p>
<p>参考：<a href="https://driverzhang.github.io/post/%E7%9B%B4%E6%92%AD%E5%8D%8F%E8%AE%AErtmphlshttp-flv/">直播协议RTMP、HLS、HTTP FLV</a></p>
<h1 id="基于Nginx搭建视频服务"><a href="#基于Nginx搭建视频服务" class="headerlink" title="基于Nginx搭建视频服务"></a>基于Nginx搭建视频服务</h1><blockquote>
<p>系统版本: Ubuntu 20.04 focal<br>Nginx版本:1.17.3<br>Nginx Rtmp模块: nginx-rtmp-module</p>
</blockquote>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><strong>Nginx</strong></h2><p>我是基于 XPS 上的Ubuntu搭建的，搭建过程之前在 <a href="https://kiosk007.top/2020/04/18/%E8%87%AA%E5%BB%BA-Nginx-%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2/">自建 Nginx 部署
</a> 文章中已经提过，这里需要注意的是需要安装 <code>nginx-rtmp-module</code> 模块。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx -m</span></span><br><span class="line">KServer version: KServer/2.3.2</span><br><span class="line">nginx version: nginx/1.17.3</span><br><span class="line">nginx: loaded modules:</span><br><span class="line">nginx:     ngx_core_module (static)</span><br><span class="line">...</span><br><span class="line">nginx:     ngx_rtmp_module (static)</span><br><span class="line">nginx:     ngx_rtmp_core_module (static)</span><br><span class="line">nginx:     ngx_rtmp_cmd_module (static)</span><br><span class="line">nginx:     ngx_rtmp_codec_module (static)</span><br><span class="line">nginx:     ngx_rtmp_access_module (static)</span><br><span class="line">nginx:     ngx_rtmp_record_module (static)</span><br><span class="line">nginx:     ngx_rtmp_live_module (static)</span><br><span class="line">nginx:     ngx_rtmp_play_module (static)</span><br><span class="line">nginx:     ngx_rtmp_flv_module (static)</span><br><span class="line">nginx:     ngx_rtmp_mp4_module (static)</span><br><span class="line">nginx:     ngx_rtmp_netcall_module (static)</span><br><span class="line">nginx:     ngx_rtmp_relay_module (static)</span><br><span class="line">nginx:     ngx_rtmp_exec_module (static)</span><br><span class="line">nginx:     ngx_rtmp_auto_push_module (static)</span><br><span class="line">nginx:     ngx_rtmp_auto_push_index_module (static)</span><br><span class="line">nginx:     ngx_rtmp_notify_module (static)</span><br><span class="line">nginx:     ngx_rtmp_log_module (static)</span><br><span class="line">nginx:     ngx_rtmp_limit_module (static)</span><br><span class="line">nginx:     ngx_rtmp_hls_module (static)</span><br><span class="line">nginx:     ngx_rtmp_dash_module (static)</span><br><span class="line">nginx:     ngx_openssl_module (static)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="视频直播服务"><a href="#视频直播服务" class="headerlink" title="视频直播服务"></a>视频直播服务</h2><p>Nginx本身是一个非常出色的HTTP服务器,FFMPEG是非常好的音视频解决方案.这两个东西通过一个Nginx的模块nginx-rtmp-module,组合在一起即可以搭建一个功能相对比较完善的流媒体服务器. 这个流媒体服务器可以支持RTMP和HLS(Live Http Stream)。</p>
<p>配置时需要在Nginx的主配置加上一句<code>include /home/work/nginx/rtmp/*.conf;</code>，因为 rtmp 是单独一个块，等价于 http 块。再创建目录 <code>/home/work/nginx/rtmp/</code>，之后 rtmp 的配置会放在该目录下。</p>
<h3 id="安装FFmpeg"><a href="#安装FFmpeg" class="headerlink" title="安装FFmpeg"></a><strong>安装FFmpeg</strong></h3><p>FFmpeg 是视频处理最常用的开源软件。名称来自MPEG视频编码标准，前面的“FF”代表“Fast Forward”，FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。可以轻易地实现多种视频格式之间的相互转换，FFmpeg的用户有Google，Facebook，Youtube，优酷，爱奇艺，土豆等。可参考阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">FFmpeg 视频处理</a> 这篇文章。</p>
<p>安装方式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure></p>
<h3 id="RTMP-直播"><a href="#RTMP-直播" class="headerlink" title="RTMP 直播"></a>RTMP 直播</h3><p>在 <code>/home/work/nginx/rtmp/live.conf</code> 里创建如下内容。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">notify_method</span> get;</span><br><span class="line">        <span class="attribute">access_log</span>  /home/work/log/nginx/http_rtmp.log;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line">        <span class="attribute">application</span> rtmplive &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;                <span class="comment"># 开启直播模式</span></span><br><span class="line">            <span class="attribute">allow</span> publish all;      <span class="comment"># 允许从任何源push流</span></span><br><span class="line">            <span class="attribute">allow</span> play all;         <span class="comment"># 允许从任何地方来播放流</span></span><br><span class="line">            <span class="attribute">drop_idle_publisher</span> <span class="number">20s</span>; <span class="comment"># 20秒内没有push，就断开链接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查nginx配置后reload nginx,使之生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /home/work/nginx/sbin/nginx -t</span></span><br><span class="line"><span class="comment"># /home/work/nginx/sbin/nginx -s reload</span></span><br></pre></td></tr></table></figure>
<p><strong>试验</strong></p>
<p>使用 ffmpeg 推流<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i .&#x2F;Golang从入门到癫狂.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv &#39;rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;room&#39;</span><br></pre></td></tr></table></figure><br>ipad 上去App Store下载 <strong>Aplyer</strong><br><img src="https://img1.kiosk007.top/static/images/live/aplyer.jpeg" style="height:350px"></p>
<p>打开Aplayer，选择最下方的“网络”，在输入框中输入<code>rtmp://192.168.1.10/live/room</code> 即可观看直播了。</p>
<h3 id="HLS直播"><a href="#HLS直播" class="headerlink" title="HLS直播"></a>HLS直播</h3><p>配置hls需要有两个步骤</p>
<ol>
<li>配置rtmp流产生hls文件</li>
<li>设置nginx来访问hls文件</li>
</ol>
<p><strong>配置rtmp流产生hls文件</strong><br>创建存放hls文件的目录, 确保 Nginx worker 用户可以读写该目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;work&#x2F;data&#x2F;hls</span><br><span class="line">chown work:work &#x2F;home&#x2F;work&#x2F;data&#x2F;hls</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改配置，增加hls相关配置<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>; <span class="comment"># Listen on standard RTMP port</span></span><br><span class="line">        <span class="attribute">notify_method</span> get;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">application</span> hlslive &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;   <span class="comment"># Turn on HLS</span></span><br><span class="line">            <span class="attribute">hls</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">hls_path</span> /home/work/data/hls;</span><br><span class="line">            </span><br><span class="line">            <span class="attribute">allow</span> publish all;          <span class="comment"># 允许从任何源push流</span></span><br><span class="line">            <span class="attribute">allow</span> play all;             <span class="comment"># 允许从任何地方来播放流</span></span><br><span class="line">            <span class="attribute">drop_idle_publisher</span> <span class="number">20s</span>;    <span class="comment"># 20秒内没有push，就断开链接。</span></span><br><span class="line">            <span class="attribute">hls_fragment</span> <span class="number">3</span>;</span><br><span class="line">            <span class="attribute">hls_playlist_length</span> <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>添加了如下两个配置:</p>
<ul>
<li><code>hls on</code> : 开启HLS</li>
<li><code>hls_path /home/work/data/hls</code> : 设置hls目录</li>
</ul>
<p>此时使用ffmpeg进行推流后，在/home/work/data/hls目录下，就会有HLS要用到的m3u8和ts文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ls</span><br><span class="line">room1-0.ts  room1-1.ts  room1.m3u8</span><br></pre></td></tr></table></figure>
<p>设置nginx来访问hls文件<br>配置nginx通过http访问hls文件, 在server中添加如下location。<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /hls &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Cache-Control&#x27;</span> <span class="string">&#x27;no-cache&#x27;</span>;   <span class="comment"># Disable cache</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># CORS setup</span></span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span> always;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="string">&#x27;Content-Length&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># allow CORS preflight requests</span></span><br><span class="line">        <span class="attribute">if</span> ($request_method = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain charset=UTF-8&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">types</span> &#123;</span><br><span class="line">            application/dash+xml mpd;</span><br><span class="line">            application/vnd.apple.mpegurl m3u8;</span><br><span class="line">            video/mp2t ts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /home/work/data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>然后使用支持 HLS 拉流的播放器输入 <code>http://192.168.1.8:8081/hls/room1.m3u8</code></p>
<p>参考：<a href="https://www.vultr.com/docs/setup-nginx-rtmp-on-centos-7#Security_Note">Setup Nginx-RTMP on CentOS 7</a></p>
<h2 id="视频播放服务"><a href="#视频播放服务" class="headerlink" title="视频播放服务"></a>视频播放服务</h2><p>毕竟是已经下载好的视频，这里是不存在直播推流的，那么可以直接播放已经存在的视频。视频的格式最好是 mp4 格式，Nginx 配置文件如下即可：</p>
<h3 id="mp4"><a href="#mp4" class="headerlink" title="mp4"></a>mp4</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">8088</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#错误日志和访问日志的路径配置</span></span><br><span class="line">   <span class="attribute">access_log</span>  /home/work/log/nginx/http_video.log  jxjson;</span><br><span class="line">   <span class="attribute">error_log</span>   /home/work/log/nginx/video-<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">#项目的路径 </span></span><br><span class="line">   <span class="attribute">root</span> /home/work/data/mp4;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#所有的mp4文件的自动解析</span></span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~ \.mp4$</span> &#123;</span><br><span class="line">      mp4;</span><br><span class="line">      <span class="attribute">mp4_buffer_size</span>     <span class="number">1m</span>;</span><br><span class="line">      <span class="attribute">mp4_max_buffer_size</span> <span class="number">5m</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浏览器输入 <code>192.168.1.8:8088/2-1.mp4</code></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>点播</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转 tshark 命令行工具</title>
    <url>/2020/11/07/%E7%8E%A9%E8%BD%AC-tshark-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>玩转TShark（Wireshark的命令行版）<br>wireshark 是一个伟大的网络问题分析工具，当然它也是有终端命令行工具的。<strong>tshark</strong>就是wireshark的命令行之一。WireShark的功能基本都有，还能组合grep/awk等编程处理分析抓包文件。</p>
<a id="more"></a>
<h1 id="wireshark-自带命令集"><a href="#wireshark-自带命令集" class="headerlink" title="wireshark 自带命令集"></a>wireshark 自带命令集</h1><p>Wireshark除了能够手动的分析报文之外，还额外的提供了几个命令行工具，方便开发者日常的报文处理需求，比如批量的合并以及编辑报文。这几个命令都是安装wireshark之后能够直接使用的，同时有的有对应的wireshark GUI 的操作。这些命令分别有<code>tshark</code>、<code>tcpdump</code>、<code>capinfos</code>、<code>dumpcap</code>、<code>text2cap</code>、<code>editcap</code>、<code>reordercap</code>、<code>rawshark</code>、<code>mergecap</code>、<code>pcapfix(需单独安装)</code>。</p>
<ul>
<li>tshark：基于终端的Wireshark</li>
<li>tcpdump：使用“tcpdump”捕获以便使用Wireshark查看</li>
<li>dumpcap：捕获“dumpcap”以便使用Wireshark查看</li>
<li>capinfos：打印有关捕获文件的信息</li>
<li>rawshark：转储和分析网络流量。</li>
<li>editcap：编辑捕获文件</li>
<li>mergecap：将多个捕获文件合并为一个</li>
<li>text2pcap：将ASCII hexdumps转换为网络捕获</li>
<li>reordercap：重新排序捕获文件</li>
<li>pcapfix: 修复pcap文件</li>
</ul>
<h1 id="pcap"><a href="#pcap" class="headerlink" title="pcap"></a>pcap</h1><h2 id="认识-pcap"><a href="#认识-pcap" class="headerlink" title="认识 pcap"></a>认识 pcap</h2><p>尝试查找网络问题的根源时，有助于查看可能是症状的数据包。为了查看这些数据包，必须首先捕获它们。</p>
<p>Wireshark默认的存储方式是pcap格式，最新版本的wireshark默认存储方式是pcapng。ng是next generation 的缩写，pcap和pcapng格式文件有是存在一定的差异。</p>
<p>pcap报文文件结构示意图<br><img src="https://img1.kiosk007.top/static/images/tshark/pcap_file_format.png" alt="pcap_format"></p>
<ol>
<li>Global Header是整个文件的文件头，包含文件格式标识，pcap格式版本号等文件指示信息。</li>
<li>Packet Header是每一片数据报文的头部信息，这些信息都是在形成pcap 报文的过程中由抓包软件wireshark添加的额外信息，例如报文捕获时间等。</li>
<li>Packet Data是抓取通信过程中的实际数据，包括协议数据和内容数据。</li>
</ol>
<p>Wireshark 中对 Global Header 的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcap_hdr_s</span> &#123;</span></span><br><span class="line">        guint32 magic_number;   <span class="comment">/* magic number */</span></span><br><span class="line">        guint16 version_major;  <span class="comment">/* major version number */</span></span><br><span class="line">        guint16 version_minor;  <span class="comment">/* minor version number */</span></span><br><span class="line">        gint32  thiszone;       <span class="comment">/* GMT to local correction */</span></span><br><span class="line">        guint32 sigfigs;        <span class="comment">/* accuracy of timestamps */</span></span><br><span class="line">        guint32 snaplen;        <span class="comment">/* max length of captured packets, in octets */</span></span><br><span class="line">        guint32 network;        <span class="comment">/* data link type */</span></span><br><span class="line">&#125; <span class="keyword">pcap_hdr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Wireshark 中对 Packet Header 的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcaprec_hdr_s</span> &#123;</span></span><br><span class="line">        guint32 ts_sec;         <span class="comment">/* timestamp seconds */</span></span><br><span class="line">        guint32 ts_usec;        <span class="comment">/* timestamp microseconds */</span></span><br><span class="line">        guint32 incl_len;       <span class="comment">/* number of octets of packet saved in file */</span></span><br><span class="line">        guint32 orig_len;       <span class="comment">/* actual length of packet */</span></span><br><span class="line">&#125; <span class="keyword">pcaprec_hdr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="获取-pcap"><a href="#获取-pcap" class="headerlink" title="获取 pcap"></a>获取 pcap</h2><ul>
<li><strong>服务器</strong> :推荐使用 tcpdump or tshark (tshark —color 可以染色哦) 命令行</li>
<li><strong>个人电脑</strong>: 推荐使用 wireshark </li>
<li><strong>Android 移动设备</strong>: 推荐使用 <a href="https://github.com/egorovandreyrm/pcap-remote">Pcap Remote</a> (需要在 Google Play 下载) </li>
<li><strong>iOS 移动设备</strong>: 推荐使用 <code>rvictl -s [设备udid]</code> 方式抓包，参考 <a href="https://www.jianshu.com/p/c67baf5fce6d">Wireshark 抓包iOS设备</a></li>
</ul>
<p>更多获取 pcap 方法参考 <a href="https://tshark.dev/capture/">捕获pcap</a></p>
<h1 id="tshark"><a href="#tshark" class="headerlink" title="tshark"></a>tshark</h1><p><a href="https://www.wireshark.org/docs/man-pages/tshark.html">tshark官方文档</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TShark是一个网络分析工具。它能帮你在实时网络中捕获数据包，或是从预先保存好的捕获文件中读取数据包，或是打印出这些数据包的解码形式到标准输出，再或是把数据包写入到一个文件中。TShark的本地捕获文件格式是pcapng格式，这种pcapng格式也被wireshark和多种其他工具使用。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><a href="https://tshark.dev/packetcraft/arcana/profiles/#-o-keyvalue">-o ${key:value} </a> : 配置首选项中的settings, 一般可配置显示时间戳、是否相关seq number，或者TLS、WPA 解密等。</li>
</ul>
<p><img src="/images/tshark/tshark_o.png" style="height:200px"></p>
<ul>
<li><a href="https://www.wireshark.org/docs/man-pages/tshark.html">-z ${statistics} </a> : 集各种类型的统计信息, 这里面有一些信息是很有用的，如专家信息、时序统计飞行中的报文、时序丢包都需要这个参数来</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_z.png" style="height:350px"></p>
<p><strong>其余参数如下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 抓包接口类</span></span><br><span class="line">-i 设置抓包的网络接口，不设置则默认为第一个非自环接口。</span><br><span class="line">-D 列出当前存在的网络接口。在不了解OS所控制的网络设备时，一般先用“tshark -D”查看网络接口的编号以供-i参数使用。</span><br><span class="line">-f 设定抓包过滤表达式（capture filter expression）。抓包过滤表达式的写法雷同于tcpdump</span><br><span class="line">-s 设置每个抓包的大小，默认为65535，多于这个大小的数据将不会被程序记入内存、写入文件</span><br><span class="line">-p 设置网络接口以非混合模式工作，即只关心和本机有关的流量</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止抓包参数</span></span><br><span class="line">-c 抓取的packet数，在处理一定数量的packet后，停止抓取，程序退出。</span><br><span class="line">-a 设置tshark抓包停止向文件书写的条件，事实上是tshark在正常启动之后停止工作并返回的条件。条件写为<span class="built_in">test</span>:value的形式，如“-a duration:5”表示tshark启动后在5秒内抓包然后停止；“-a filesize:10”表示tshark在输出文件达到10kB后停止；“-a files:n”表示tshark在写满n个文件后停止。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理类</span></span><br><span class="line">-R 设置读取（显示）过滤表达式（<span class="built_in">read</span> filter expression）。不符合此表达式的流量同样不会被写入文件。</span><br><span class="line">-n 禁止所有地址名字解析（默认为允许所有）。</span><br><span class="line">-N 启用某一层的地址名字解析。“m”代表MAC层，“n”代表网络层，“t”代表传输层，“C”代表当前异步DNS查找。如果-n和-N参数同时存在，-n将被忽略。如果-n和-N参数都不写，则默认打开所有地址名字解析。</span><br><span class="line">-d 将指定的数据按有关协议解包输出。如要将tcp 8888端口的流量按http解包，应该写为“-d tcp.port==8888,http”。注意选择子和解包协议之间不能留空格。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类</span></span><br><span class="line">-w 设置raw数据的输出文件。这个参数不设置，tshark将会把解码结果输出到stdout。“-w-”表示把raw输出到stdout。如果要把解码结果输出到文件，使用重定向“&gt;”而不要-w参数。</span><br><span class="line">-F 设置输出raw数据的格式，默认为libpcap。“tshark -F”会列出所有支持的raw格式。</span><br><span class="line">-V 设置将解码结果的细节输出，否则解码结果仅显示一个packet一行的summary。</span><br><span class="line">-x 设置在解码输出结果中，每个packet后面以HEX dump的方式显示具体数据。</span><br><span class="line">-T 设置解码结果输出的格式，包括text,ps,psml和pdml，默认为text。</span><br><span class="line">-E: -E &lt;fieldsoption&gt;=&lt;value&gt;如果-T fields选项指定，使用-E来设置一些属性，比如</span><br><span class="line">　　　　header=y|n</span><br><span class="line">　　　　separator=/t|/s|&lt;char&gt;</span><br><span class="line">　　　　occurrence=f|l|a</span><br><span class="line">　　　　aggregator=,|/s|&lt;char&gt;</span><br><span class="line">-t 设置解码结果的时间格式。“ad”表示带日期的绝对时间，“a”表示不带日期的绝对时间，“r”表示从第一个包到现在的相对时间，“d”表示两个相邻包之间的增量时间（delta）。</span><br><span class="line">-S 在向raw文件输出的同时，将解码结果打印到控制台。</span><br><span class="line">-l 在处理每个包时即时刷新输出。</span><br><span class="line">-X 扩展项。</span><br><span class="line">-q 设置安静的stdout输出（例如做统计时）</span><br><span class="line">-z 设置统计参数。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line">-h 显示命令行帮助。</span><br><span class="line">-v 显示tshark的版本信息。</span><br><span class="line">-o 重载选项</span><br></pre></td></tr></table></figure>
<h2 id="利用-tshark-打印pcap"><a href="#利用-tshark-打印pcap" class="headerlink" title="利用 tshark 打印pcap"></a>利用 tshark 打印pcap</h2><p>我们通过tcpdump或者wireshark抓到 pcap 文件，接下来就可以利用 <code>tshark</code> 这个强大的命令行工具进行抓包。其中 <code>-o</code>的几个选项可以指定 ssl 解密（需要sslkeylog），<code>-T</code> 指定输出格式，<code>-e</code> 指定都需要输出哪些字段（字段列表参考 <a href="https://www.wireshark.org/docs/dfref/）。输出是将每个Package中指定的字段输出。">https://www.wireshark.org/docs/dfref/）。输出是将每个Package中指定的字段输出。</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -o ssl.keylog_file:./sslkeylog.txt \</span><br><span class="line">-o <span class="string">&quot;ssl.desegment_ssl_records: TRUE&quot;</span> \</span><br><span class="line">-o <span class="string">&quot;ssl.desegment_ssl_application_data: TRUE&quot;</span> \</span><br><span class="line">-e ssl.handshake.ciphersuite \  </span><br><span class="line">-e tcp.analysis.zero_window \</span><br><span class="line">-e http.host \</span><br><span class="line">-e dns.time \</span><br><span class="line">-e tcp.flags.urg \</span><br><span class="line">-e http.request.line \</span><br><span class="line">-e dns.qry.name \</span><br><span class="line">-e ip.version \</span><br><span class="line">-e tcp.analysis.window_full \</span><br><span class="line">-e ipv6.dst \</span><br><span class="line">-e http.request.version \</span><br><span class="line">-e udp.dstport \</span><br><span class="line">-e dns.flags.response \</span><br><span class="line">.... \</span><br><span class="line">-T json -r <span class="string">&quot;./capturedump.pcap&quot;</span></span><br></pre></td></tr></table></figure><br>其余更多的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//打印http协议流相关信息</span><br><span class="line">tshark -s 512 -i eth0 -n -f <span class="string">&#x27;tcp dst port 80&#x27;</span> -Y <span class="string">&#x27;http.host and http.request.uri&#x27;</span> -T fields -e http.host -e http.request.uri -l</span><br><span class="line"></span><br><span class="line">//实时打印当前mysql查询语句</span><br><span class="line">tshark -s 512 -i eth0 -n -f <span class="string">&#x27;tcp dst port 3306&#x27;</span> -Y <span class="string">&#x27;mysql.query&#x27;</span> -T fields -e mysql.query</span><br><span class="line"></span><br><span class="line">//解析MySQL协议</span><br><span class="line">tshark -r ./mysql-compress.cap -o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields -e mysql.caps.cp -e frame.number \</span><br><span class="line">-e frame.time_epoch  -e frame.time_delta_displayed  \</span><br><span class="line">-e ip.src -e tcp.srcport -e tcp.dstport -e ip.dst \</span><br><span class="line">-e tcp.time_delta -e frame.time_delta_displayed \</span><br><span class="line">-e tcp.stream -e tcp.len -e mysql.query</span><br><span class="line"></span><br><span class="line">//抓取详细SQL语句, 快速确认client发过来的具体SQL内容：</span><br><span class="line">sudo tshark -i any -f <span class="string">&#x27;port 3306&#x27;</span> -s 0 -l -w - |strings</span><br><span class="line">sudo tshark -i eth0 -d tcp.port==3306,mysql -T fields -e mysql.query <span class="string">&#x27;port 3306&#x27;</span></span><br><span class="line">sudo tshark -i eth0 -Y <span class="string">&quot;ip.addr==11.163.182.137&quot;</span> -d tcp.port==3306,mysql -T fields -e mysql.query <span class="string">&#x27;port 3306&#x27;</span></span><br><span class="line">sudo tshark -i eth0 -Y <span class="string">&quot;tcp.srcport==62877&quot;</span> -d tcp.port==3001,mysql -T fields -e tcp.srcport -e mysql.query <span class="string">&#x27;port 3001&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看请求目标信息"><a href="#查看请求目标信息" class="headerlink" title="查看请求目标信息"></a>查看请求目标信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tshark -r wechat.pcap -o <span class="string">&#x27;gui.column.format:&quot;Source Net Addr&quot;,&quot;%uns&quot;,&quot;Dest Net Addr&quot;, &quot;%und&quot;&#x27;</span> -Y <span class="string">&quot;ip&quot;</span> | sort | uniq</span><br><span class="line">111.206.101.25 → 192.168.100.115</span><br><span class="line">111.206.4.92 → 192.168.100.115</span><br><span class="line">119.167.215.208 → 192.168.100.115</span><br><span class="line">122.14.230.129 → 192.168.100.115</span><br><span class="line">123.125.102.19 → 192.168.100.115</span><br><span class="line">192.168.100.115 → 111.161.111.119</span><br><span class="line">192.168.100.115 → 111.206.101.25</span><br><span class="line">192.168.100.115 → 111.206.4.92</span><br><span class="line">192.168.100.115 → 119.167.215.208</span><br></pre></td></tr></table></figure>
<h2 id="查看丢包、带宽、吞吐、延迟"><a href="#查看丢包、带宽、吞吐、延迟" class="headerlink" title="查看丢包、带宽、吞吐、延迟"></a>查看丢包、带宽、吞吐、延迟</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 统计 ip 情况</span><br><span class="line">$ tshark -r wechat.pcap -q -z conv,ip</span><br><span class="line"></span><br><span class="line">// 跟踪一条流打印 16进制数据</span><br><span class="line">$ tshark -r wechat.pcap -q -z <span class="string">&quot;follow,tcp,hex,0&quot;</span> </span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_conv.png" alt="conv"></p>
<p><strong>计算丢包情况</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tshark -r wechat.pcap -q \</span><br><span class="line">-z io,<span class="built_in">stat</span>,1,<span class="string">&quot;COUNT(tcp.analysis.retransmission) tcp.analysis.retransmission&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.fast_retransmission) tcp.analysis.fast_retransmission&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.duplicate_ack) tcp.analysis.duplicate_ack&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.lost_segment) tcp.analysis.lost_segment&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>计算上行带宽</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tshark -o tcp.desegment_tcp_streams:TRUE -n \</span><br><span class="line">-q -r  ./wechat.pcap \</span><br><span class="line">-z io,<span class="built_in">stat</span>,99999999,<span class="string">&quot;BYTES()(ip.src!=10.0.0.0/8 and ip.src!=172.16.0.0/12 and ip.src!=192.168.0.0/16)&quot;</span></span><br></pre></td></tr></table></figure><br><strong>计算 TCP RTT</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tshark -o tcp.desegment_tcp_streams:TRUE -n \</span><br><span class="line">-q -r  ./wechat.pcap  -z \</span><br><span class="line">io,<span class="built_in">stat</span>,99999999,<span class="string">&quot;AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析 <code>tcp.stream</code> id 为 0 的传输带宽 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tshark -o tcp.desegment_tcp_streams:FALSE -n \</span><br><span class="line">-q -r wechat.pcapng -z io,stat,1,&quot;BYTES()tcp.stream&#x3D;&#x3D;0&quot;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">| IO Statistics               |</span><br><span class="line">|                             |</span><br><span class="line">| Duration: 50.712225 secs    |</span><br><span class="line">| Interval:  1 secs           |</span><br><span class="line">|                             |</span><br><span class="line">| Col 1: BYTES()tcp.stream&#x3D;&#x3D;0 |</span><br><span class="line">|-----------------------------|</span><br><span class="line">|          |1       |         |</span><br><span class="line">| Interval |  BYTES |         |</span><br><span class="line">|-------------------|         |</span><br><span class="line">|  0 &lt;&gt;  1 |      0 |         |</span><br><span class="line">|  1 &lt;&gt;  2 |      0 |         |</span><br><span class="line">...</span><br><span class="line">|  8 &lt;&gt;  9 | 128301 |         |</span><br><span class="line">|  9 &lt;&gt; 10 | 127132 |         |</span><br><span class="line">| 10 &lt;&gt; 11 | 128667 |         |</span><br><span class="line">| 11 &lt;&gt; 12 | 127749 |         |</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>wireshark 的TCP流图中的吞吐量</p>
<p><img src="https://img1.kiosk007.top/static/images/tshark/wireshark_throughput.png" style="height:300px"></p>
<p>对比通过 tshark的 io graph 绘出的图。</p>
<p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_throughput.png" style="weight:300px"></p>
<p>同理可以绘 丢包重传、飞行中的报文等。</p>
<p>对于排查网络延时/应用问题有一些过滤条件是非常有用的：</p>
<ul>
<li><code>tcp.analysis.lost_segment</code>：表明已经在抓包中看到不连续的序列号。报文丢失会造成重复的ACK，这会导致重传。</li>
<li><code>tcp.analysis.duplicate_ack</code>：显示被确认过不止一次的报文。大量的重复ACK是TCP端点之间高延时的迹象。</li>
<li><code>tcp.analysis.retransmission</code>：显示抓包中的所有重传。如果重传次数不多的话还是正常的，过多重传可能有问题。这通常意味着应用性能缓慢和/或用户报文丢失。</li>
<li><code>tcp.analysis.window_update</code>：将传输过程中的TCP window大小图形化。如果看到窗口大小下降为零，这意味着发送方已经退出了，并等待接收方确认所有已传送数据。这可能表明接收端已经不堪重负了。</li>
<li><code>tcp.analysis.bytes_in_flight</code>：某一时间点网络上未确认字节数。未确认字节数不能超过你的TCP窗口大小（定义于最初3此TCP握手），为了最大化吞吐量你想要获得尽可能接近TCP窗口大小。如果看到连续低于TCP窗口大小，可能意味着报文丢失或路径上其他影响吞吐量的问题。</li>
<li><code>tcp.analysis.ack_rtt</code>：衡量抓取的TCP报文与相应的ACK。如果这一时间间隔比较长那可能表示某种类型的网络延时（报文丢失，拥塞，等等）。</li>
</ul>
<h2 id="专家信息"><a href="#专家信息" class="headerlink" title="专家信息"></a>专家信息</h2><p>可统计重传、TLS 会话复用、HTTP 会话、TCP RST 等等。功能强大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tshark -r refresh_video.pcap -q -z expert</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_expert.png"></p>
<h2 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h2><ul>
<li>分析SQL查询的时间分布</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r gege_drds.pcap \</span><br><span class="line">-Y <span class="string">&quot;mysql.query or (tcp.srcport==3306  and tcp.len&gt;60)&quot;</span> \</span><br><span class="line">-o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields \</span><br><span class="line">-e frame.number -e frame.time_epoch  \</span><br><span class="line">-e frame.time_delta_displayed  \</span><br><span class="line">-e ip.src -e tcp.srcport -e tcp.dstport -e ip.dst \</span><br><span class="line">-e tcp.time_delta -e tcp.stream -e tcp.len \</span><br><span class="line">| awk <span class="string">&#x27;BEGIN &#123; \</span></span><br><span class="line"><span class="string">sum0=0;sum3=0;sum10=0;sum30=0;sum50=0; \</span></span><br><span class="line"><span class="string">sum100=0;sum300=0;sum500=0;sum1000=0;\</span></span><br><span class="line"><span class="string">sumo=0;count=0;sum=0</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">&#123; \</span></span><br><span class="line"><span class="string">rt=$8; \</span></span><br><span class="line"><span class="string">if(rt&gt;=0.000) sum=sum+rt; count=count+1; \</span></span><br><span class="line"><span class="string">if(rt&lt;=0.000) sum0=sum0+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.003) sum3=sum3+1 ;\</span></span><br><span class="line"><span class="string">else if(rt&lt;0.01) sum10=sum10+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.03) sum30=sum30+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.05) sum50=sum50+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.1) sum100=sum100+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.3) sum300=sum300+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.5) sum500=sum500+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 1) sum1000=sum1000+1; \</span></span><br><span class="line"><span class="string">else sum=sum+1 ; \</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">END &#123; printf &quot;-------------\n3ms:\t%s \n10ms:\t%s \n30ms:\t%s \n50ms:\t%s \n100ms:\t%s \n300ms:\t%s \n500ms:\t%s \n1000ms:\t%s \n&gt;1s:\t %s\n-------------\navg: %.6f \n&quot; , sum3,sum10,sum30,sum50,sum100,sum300,sum500,sum1000,sumo,sum/count;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"> -------------</span><br><span class="line">3ms:    145037 </span><br><span class="line">10ms:    78811 </span><br><span class="line">30ms:    7032 </span><br><span class="line">50ms:    2172 </span><br><span class="line">100ms:    1219 </span><br><span class="line">300ms:    856 </span><br><span class="line">500ms:    449 </span><br><span class="line">1000ms:118</span><br><span class="line">&gt;1s:    0</span><br><span class="line">-------------</span><br><span class="line">avg: 0.005937 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>分析每个包的response time</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tshark -r rsb2.cap -o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields -e frame.number -e frame.time_epoch \</span><br><span class="line">-e ip.src -e ip.dst -e tcp.stream -e tcp.len \</span><br><span class="line">-e tcp.analysis.initial_rtt -e tcp.time_delta</span><br><span class="line"></span><br><span class="line">1481	1465269331.308138000	100.98.199.36	10.25.92.13	302	0		0.002276000</span><br><span class="line">1482	1465269331.308186000	10.25.92.13	    100.98.199.36	361	11	0.000063000</span><br><span class="line">1483	1465269331.308209000	100.98.199.36	10.25.92.13	496	0		0.004950000</span><br><span class="line">1484	1465269331.308223000	100.98.199.36	10.25.92.13	513	0		0.000000000</span><br><span class="line">1485	1465269331.308238000	100.98.199.36	10.25.92.13	326	0		0.055424000</span><br><span class="line">1486	1465269331.308246000	100.98.199.36	10.25.92.13	514	0		0.000000000</span><br><span class="line">1487	1465269331.308261000	10.25.92.71	    10.25.92.13	48	0		0.000229000</span><br><span class="line">1488	1465269331.308277000	100.98.199.36	10.25.92.13	254	0		0.055514000</span><br></pre></td></tr></table></figure>
<ul>
<li>分析rtt时间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tshark -r wechat.pcapng -q -z \</span><br><span class="line">io,<span class="built_in">stat</span>,5,<span class="string">&quot;MIN(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span>,\</span><br><span class="line"><span class="string">&quot;MAX(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span>,\</span><br><span class="line"><span class="string">&quot;AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br><span class="line"></span><br><span class="line">========================================================</span><br><span class="line">| IO Statistics                                        |</span><br><span class="line">|                                                      |</span><br><span class="line">| Duration: 50.712225 secs                             |</span><br><span class="line">| Interval:  5 secs                                    |</span><br><span class="line">|                                                      |</span><br><span class="line">| Col 1: MIN(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|     2: MAX(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|     3: AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|------------------------------------------------------|</span><br><span class="line">|          |1         |2         |3         |          |</span><br><span class="line">| Interval |    MIN   |    MAX   |    AVG   |          |</span><br><span class="line">|-------------------------------------------|          |</span><br><span class="line">|  0 &lt;&gt;  5 | 0.000000 | 0.000000 | 0.000000 |          |</span><br><span class="line">|  5 &lt;&gt; 10 | 0.000987 | 0.358817 | 0.293383 |          |</span><br><span class="line">| 10 &lt;&gt; 15 | 0.001537 | 1.125008 | 0.336217 |          |</span><br><span class="line">| 15 &lt;&gt; 20 | 0.001598 | 0.745323 | 0.632126 |          |</span><br><span class="line">| 20 &lt;&gt; 25 | 0.002196 | 1.454920 | 0.584168 |          |</span><br><span class="line">| 25 &lt;&gt; 30 | 0.002674 | 0.892343 | 0.771408 |          |</span><br><span class="line">| 30 &lt;&gt; 35 | 0.001505 | 1.406873 | 1.066937 |          |</span><br><span class="line">| 35 &lt;&gt; 40 | 0.001333 | 1.372204 | 1.267557 |          |</span><br><span class="line">| 40 &lt;&gt; 45 | 0.001366 | 1.410311 | 1.204430 |          |</span><br><span class="line">| 45 &lt;&gt; 50 | 0.001513 | 1.360609 | 1.008420 |          |</span><br><span class="line">| 50 &lt;&gt; Dur| 0.001609 | 1.378431 | 0.956597 |          |</span><br><span class="line">========================================================</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="tshark-抓包"><a href="#tshark-抓包" class="headerlink" title="tshark 抓包"></a>tshark 抓包</h1><p>最后让我们来用伟大的tshark抓包吧，快放弃古老的 tcpdump。</p>
<p>执行 <code>sudo tshark -Y &#39;ip.addr == 8.8.8.8&#39; --color</code><br>会在终端以wireshark的风格开始抓包。<br><img src="https://img1.kiosk007.top/static/images/tshark/tshark_capture.png" alt></p>
<p>参考：</p>
<ul>
<li><a href="https://plantegg.github.io/2019/06/21/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82%E6%8A%93%E5%8C%85--WireShark%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88tshark/">就是让你懂抓包—WireShark之命令行版tshark</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - (二叉树)</title>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。以下会以几道 LeetCode 巩固自己的基础</p>
<a id="more"></a>
<p><a href="https://leetcode-cn.com/leetbook/detail/data-structure-binary-tree/?utm_campaign=leetbook&amp;utm_medium=%E9%A2%98%E5%BA%93&amp;utm_source=leetcode-cn&amp;utm_term=%E9%A2%98%E5%BA%93%E9%A1%B5%E6%A0%87%E7%AD%BE&amp;gio_link_id=q9A0Bxko">leetcode 树</a></p>
<h1 id="生成一个二叉树"><a href="#生成一个二叉树" class="headerlink" title="生成一个二叉树"></a>生成一个二叉树</h1><h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">	Val 	int</span><br><span class="line">	Left 	*TreeNode</span><br><span class="line">	Right 	*TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的工厂模式"><a href="#二叉树的工厂模式" class="headerlink" title="二叉树的工厂模式"></a>二叉树的工厂模式</h2><ul>
<li>创建节点、打印节点、设置节点</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;TreeNode&#123;val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">Print</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Print(node.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">SetVal</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	node.Val = val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加节点</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">Add</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> val &lt; node.Val &#123;</span><br><span class="line">		<span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">			node.Left = CreateNode(val)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			node.Left.Add(val)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">			node.Right = CreateNode(val)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			node.Right.Add(val)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/">动画演示</a><br><img src="https://img1.kiosk007.top/static/images/leetcode/tree_1.jpg"></p>
<ul>
<li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
</li>
<li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
</li>
<li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = <span class="built_in">print</span> r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：(中序排列结果为有序数组)</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;<span class="built_in">print</span> r-&gt;inOrder(r-&gt;right) </span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;<span class="built_in">print</span> r</span><br></pre></td></tr></table></figure>
<h2 id="LC二叉树-前序遍历"><a href="#LC二叉树-前序遍历" class="headerlink" title="LC二叉树 前序遍历"></a>LC二叉树 前序遍历</h2><p>例题链接：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span> <span class="title">preorderTraversal</span><span class="params">(f <span class="keyword">func</span>(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	f(root)</span><br><span class="line">	root.Left.preorderTraversal(f)</span><br><span class="line">	root.Right.preorderTraversal(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line">	list = <span class="built_in">append</span>(list, root.Val)</span><br><span class="line">	resLeft := preorderTraversal(root.Left)</span><br><span class="line">	resRight := preorderTraversal(root.Right)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(list, resLeft...), resRight...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 channel 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TraversalTreeWithChannel</span><span class="params">(rootNode *TreeNode)</span> <span class="params">(out <span class="keyword">chan</span> *TreeNode)</span></span> &#123;</span><br><span class="line">	out = <span class="built_in">make</span>(<span class="keyword">chan</span> *TreeNode)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		rootNode.preorderTraversal(<span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			out &lt;- node</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	treeRoot := CreateNode(<span class="number">0</span>)</span><br><span class="line">	treeRoot.Add(<span class="number">1</span>)</span><br><span class="line">	treeRoot.Add(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(preorderTraversal(treeRoot))</span><br><span class="line">	cnt := <span class="number">0</span></span><br><span class="line">	treeRoot.preorderTraversal(<span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">		cnt++</span><br><span class="line">		node.Print()</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;All Count: &quot;</span>, cnt)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过通道的方式遍历二叉树</span></span><br><span class="line">	out := TraversalTreeWithChannel(treeRoot)</span><br><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> out &#123;</span><br><span class="line">		c.Print()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉树的层次遍历（BFS广度优先遍历）"><a href="#二叉树的层次遍历（BFS广度优先遍历）" class="headerlink" title="二叉树的层次遍历（BFS广度优先遍历）"></a>二叉树的层次遍历（BFS广度优先遍历）</h2><p>例题链接：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/</a></p>
<p>题解：<br>创建一个先进先出的队列，从最顶层的节点依次加入节点，并遍历该层，每遍历该层的一个节点，把该层的子节点加入的队列的后面，这样就可以实现层次遍历，如果要蛇形遍历也是一个道理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> level [][]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> level</span><br><span class="line">	&#125;</span><br><span class="line">	queue := list.New()  <span class="comment">// 一个先进先出的队列,所有的元素需要依次进队</span></span><br><span class="line">	queue.PushFront(root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> curLevel []<span class="keyword">int</span></span><br><span class="line">		curLevelLength := queue.Len()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; curLevelLength; i++ &#123;</span><br><span class="line">			node := queue.Remove(queue.Back()).(*TreeNode)</span><br><span class="line">			curLevel = <span class="built_in">append</span>(curLevel, node.Val)</span><br><span class="line">			<span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;  <span class="comment">// 下一层遍历做准备, 把当前节点的子节点都加进去</span></span><br><span class="line">				queue.PushFront(node.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue.PushFront(node.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		level = <span class="built_in">append</span>(level, curLevel)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="剑指Offer-判断平衡二叉树"><a href="#剑指Offer-判断平衡二叉树" class="headerlink" title="剑指Offer - 判断平衡二叉树"></a>剑指Offer - 判断平衡二叉树</h2><ul>
<li>链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a></li>
<li>思路：平衡二叉树的判断方式即某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br>而一个数的高度为左子树和右子树中最高的。即只要比对左右子树的高度即可判断是否为平衡二叉树。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTreeDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(getTreeDepth(root.Left)), <span class="keyword">float64</span>(getTreeDepth(root.Right)))) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">	left := getTreeDepth(root.Left)</span><br><span class="line">	right := getTreeDepth(root.Right)</span><br><span class="line">    <span class="comment">// 判断左子树和右子树的绝对差值小于1 且 左子树 和 右子树 也满足平衡</span></span><br><span class="line">	<span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(left) - <span class="keyword">float64</span>(right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="No-235-二叉搜索树的公共祖先"><a href="#No-235-二叉搜索树的公共祖先" class="headerlink" title="No.235 二叉搜索树的公共祖先"></a>No.235 二叉搜索树的公共祖先</h2><ul>
<li><p>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
</li>
<li><p>思路：</p>
<ul>
<li>通过搜索的方式查找节点，并记录所有节点，查到2个点之后，比对两个查找链路上的最后一个公共节点即可</li>
<li>判断P,Q 两个节点如果在都小于root，则公共节点一定是在左子树，反之同理。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> || root == q || root == p &#123;</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p.Val &lt;= root.Val &amp;&amp; q.Val &lt;= root.Val &#123;   <span class="comment">//p和q都小于root,公共祖先节点一定在root的左边</span></span><br><span class="line">		<span class="keyword">return</span> lowestCommonAncestor(root.Left,p,q)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.Val &gt;= root.Val &amp;&amp; q.Val &gt;= root.Val &#123;   <span class="comment">//p和q都大于root,公共祖先节点一定在root的右边</span></span><br><span class="line">		<span class="keyword">return</span> lowestCommonAncestor(root.Right,p,q)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="No-112-路径总和"><a href="#No-112-路径总和" class="headerlink" title="No.112 路径总和"></a>No.112 路径总和</h2><ul>
<li>链接：<a href="https://leetcode-cn.com/submissions/detail/23501756/">https://leetcode-cn.com/submissions/detail/23501756/</a></li>
<li>思路：这种类似与 二叉树的深度遍历DFS肯定是要用到递归了。。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sum == root.Val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hasPathSum(root.Left, sum-root.Val) || hasPathSum(root.Right, sum-root.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法 - (数组、链表)</title>
    <url>/2020/09/26/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组、链表是编程语言中最常见的数据结构，也是最基础的数据结构。以下会以几道 LeetCode 巩固自己的基础</p>
<a id="more"></a>
<h1 id="结构对比"><a href="#结构对比" class="headerlink" title="结构对比"></a>结构对比</h1><p>数组和链表各有各的优势，比如数组的随机插入和删除都是O(n)的，可谓是很低效了。但是数组的查找是是O(1)，直接指定下标即可找到对应的元素。而链表必须遍历，也就是想要查找你一个元素的时间复杂度是 O(n)。所以数组和链表各有各的优势，互相补充。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据结构</th>
<th style="text-align:right">操作</th>
<th style="text-align:center">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td style="text-align:right">prepend</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">append</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">lookup</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">insert</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">delete</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">—</td>
<td style="text-align:center">—</td>
</tr>
<tr>
<td>链表</td>
<td style="text-align:right">prepend</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">append</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">lookup</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">insert</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">delete</td>
<td style="text-align:center">O(1)</td>
</tr>
</tbody>
</table>
</div>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">int</span></span><br><span class="line">b = <span class="built_in">append</span>(c, <span class="number">11</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, a...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// make( []Type, size, cap )</span></span><br><span class="line"><span class="comment">// 其中 Type 是指切片的元素类型，</span></span><br><span class="line"><span class="comment">// size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，</span></span><br><span class="line"><span class="comment">// 这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)  </span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义单链表</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;     </span><br><span class="line">	Val 	<span class="keyword">int</span></span><br><span class="line">	Next 	*ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *ListNode)</span> <span class="title">add</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ln == <span class="literal">nil</span> &#123;</span><br><span class="line">		ln = &amp;ListNode&#123;Val: v,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ln.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">		ln = ln.Next</span><br><span class="line">	&#125;</span><br><span class="line">	ln.Next = &amp;ListNode&#123;Val: v,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *ListNode)</span> <span class="title">traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ln != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>,ln.Val)</span><br><span class="line">		ln = ln.Next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="No-1-两数之和"><a href="#No-1-两数之和" class="headerlink" title="No.1 两数之和"></a>No.1 两数之和</h3><ul>
<li>链接：<a href="https://leetcode-cn.com/problems/two-sum/submissions/">https://leetcode-cn.com/problems/two-sum/submissions/</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	tmp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)/<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> index, ok := tmp[target-nums[i]]; ok &#123;</span><br><span class="line">			<span class="keyword">return</span> []<span class="keyword">int</span>&#123;index,i&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp[nums[i]] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="No-26-删除排序数组中的重复项"><a href="#No-26-删除排序数组中的重复项" class="headerlink" title="No.26 删除排序数组中的重复项"></a>No.26 删除排序数组中的重复项</h3><ul>
<li>链接: <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></li>
<li>思路1：<strong>双指针法</strong> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/26-shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xia-89/">题解动画</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i ++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">			j++</span><br><span class="line">			nums[j] = nums[i+<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路2： <strong>*旋转数组法</strong> 旋转数组应该是我比较喜欢的一种方式，比较简单，那就是数组翻转2次，可以将首位数转到末尾曲，重复项判断刚好使用这种方式，<font style="color:red">对于移动数组类的题是比较通吃的一个方法</font>问题就是时间复杂度比较大<br><a href="https://img1.kiosk007.top/static">https://img1.kiosk007.top/static</a><img src="/images/leetcode/list_1.jpeg" style="height:300px"></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversal</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; length &gt; <span class="number">1</span> &amp;&amp; i &lt; length/<span class="number">2</span>; i ++ &#123;</span><br><span class="line">		nums[i],nums[length<span class="number">-1</span>-i] = nums[length<span class="number">-1</span>-i],nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i ++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i + <span class="number">1</span> &lt; length &amp;&amp; nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">			reversal(nums[i+<span class="number">1</span>:length])</span><br><span class="line">			reversal(nums[i+<span class="number">1</span>:length<span class="number">-1</span>])</span><br><span class="line">			length = length - <span class="number">1</span></span><br><span class="line">			i = i - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h3 id="No-21-合并两个链表"><a href="#No-21-合并两个链表" class="headerlink" title="No.21 合并两个链表"></a>No.21 合并两个链表</h3><ul>
<li>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/">https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/</a></li>
<li>思路1: <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">迭代法</a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	tmp := &amp;ListNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">	prev := tmp</span><br><span class="line">	<span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> l1.Val &lt; l2.Val&#123;</span><br><span class="line">			prev.Next = l1</span><br><span class="line">			prev = prev.Next</span><br><span class="line"></span><br><span class="line">			l1 = l1.Next</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			prev.Next = l2</span><br><span class="line">			prev = prev.Next</span><br><span class="line"></span><br><span class="line">			l2 = l2.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		prev.Next = l2</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		prev.Next = l1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tmp.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="No-83-删除排序链表重复项"><a href="#No-83-删除排序链表重复项" class="headerlink" title="No.83 删除排序链表重复项"></a>No.83 删除排序链表重复项</h2></li>
<li>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></li>
<li>思路1：题解感觉和我差不太多，我的思路是先把重复项移到尾端，然后cur 指针指向重复项的尾端就好了。但不知道为啥 8ms 打败 7.3% 。理论就是 O(N) 啊。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur := &amp;ListNode&#123;&#125; </span><br><span class="line">	tmp := cur   <span class="comment">// 记录链表头</span></span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> head.Next != <span class="literal">nil</span> &amp;&amp; head.Val == head.Next.Val &#123;</span><br><span class="line">			 head = head.Next</span><br><span class="line">		&#125;</span><br><span class="line">		cur.Next = head</span><br><span class="line">		cur = cur.Next</span><br><span class="line">		head = head.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="No-141-环形链表"><a href="#No-141-环形链表" class="headerlink" title="No.141 环形链表"></a>No.141 环形链表</h2></li>
<li>链接: <a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></li>
<li>思路1：这道题思路非常简单，就是快慢指针，慢指针每次前进一步，快指针每次前进两步。如果存在环快指针一定会追上慢指针，<strong>问题就是边界条件太多，需要仔细判断。</strong></li>
<li>思路2：hash表存已有的数据做对比，这个最简单，不演示啦~</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	slow := head</span><br><span class="line">	fast := head.Next</span><br><span class="line">	<span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">		slow = slow.Next</span><br><span class="line">		fast = fast.Next.Next</span><br><span class="line">		<span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="No-206-反转链表"><a href="#No-206-反转链表" class="headerlink" title="No.206 反转链表"></a>No.206 反转链表</h2><ul>
<li>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></li>
<li>思路1：<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/206-fan-zhuan-lian-biao-shuang-zhi-zhen-fa-di-gui-/">双指针</a>  本质还是遍历 head， 上面的<code>next := head.Next</code>和下面的<code>head = next</code> 就是为了遍历， 中间的三行是 当前head的节点的下一个指向之前，cur即为当前head节点，cur 成为历史 prev</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> prev *ListNode = <span class="literal">nil</span></span><br><span class="line">	cur := prev</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := head.Next  <span class="comment">// 存下一个</span></span><br><span class="line"></span><br><span class="line">		head.Next = prev <span class="comment">// haed 的Next指向 prev</span></span><br><span class="line">		cur = head       <span class="comment">// cur 就是 head</span></span><br><span class="line">		prev = cur		 <span class="comment">// cur 成为 prev</span></span><br><span class="line"></span><br><span class="line">		head = next   <span class="comment">// head 前进</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现一个-LRU-缓存"><a href="#实现一个-LRU-缓存" class="headerlink" title="实现一个 LRU 缓存"></a>实现一个 LRU 缓存</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lru</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	MemoryOverFlow				<span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">	MemorySizeError				<span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">	NotFoundObject				<span class="keyword">int</span> = <span class="number">11</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lruErrorName = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	MemoryOverFlow:      <span class="string">&quot;MemoryOverFlow&quot;</span>,</span><br><span class="line">	MemorySizeError: 	 <span class="string">&quot;MemorySizeError&quot;</span>,</span><br><span class="line">	NotFoundObject: 	 <span class="string">&quot;NotFoundObject&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录存储数据的大小</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储的对象</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	key 	<span class="keyword">string</span></span><br><span class="line">	value 	Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">	maxBytes <span class="keyword">int64</span>        <span class="comment">// 最大使用内存</span></span><br><span class="line">	nBytes 	 <span class="keyword">int64</span>        <span class="comment">// 当前已使用内存</span></span><br><span class="line">	ll *list.List         <span class="comment">// 链表存储淘汰关系</span></span><br><span class="line">	cache  <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element   <span class="comment">//节点放到字典中，加速查找</span></span><br><span class="line">	OnEvicted  <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value Value)</span>   //某条记录被删除时候的回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateLRUCache</span><span class="params">(maxByte <span class="keyword">int64</span>,evicted <span class="keyword">func</span>(<span class="keyword">string</span>,Value)</span>) *<span class="title">Cache</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">		maxBytes:  maxByte,</span><br><span class="line">		nBytes:    <span class="number">0</span>,</span><br><span class="line">		ll:        <span class="built_in">new</span>(list.List),</span><br><span class="line">		cache:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element),</span><br><span class="line">		OnEvicted: evicted,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value Value,err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class="line">		c.ll.MoveToFront(ele)</span><br><span class="line">		<span class="keyword">return</span> ele.Value.(*entry).value, <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(lruErrorName[NotFoundObject])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">string</span>, value Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断是否可以加入(太大会把所有缓存冲掉)</span></span><br><span class="line">	<span class="keyword">if</span> c.isOutOfMaxMemory(value.Len()) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(lruErrorName[MemoryOverFlow])   <span class="comment">// 内存不足以添加该缓存</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断缓存中已有该键, 更新</span></span><br><span class="line">	<span class="keyword">if</span> v, ok := c.cache[key]; ok &#123;</span><br><span class="line">		oldValue := v.Value.(*entry)</span><br><span class="line">		<span class="comment">// 可以加入,将该键移动到队头</span></span><br><span class="line">		c.ll.MoveToFront(v)</span><br><span class="line">		c.cache[oldValue.key] = &amp;list.Element&#123;Value: &amp;entry&#123;key,value&#125;&#125;</span><br><span class="line">		c.nBytes = c.nBytes - oldValue.value.Len() + value.Len()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没有该键,第一次添加</span></span><br><span class="line">	ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">	c.cache[key] = ele</span><br><span class="line">	c.nBytes = c.nBytes + value.Len()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若内存不够，需要循环删除掉最老的</span></span><br><span class="line">	<span class="keyword">for</span> c.maxBytes != <span class="number">0</span> &amp;&amp; c.maxBytes &lt; c.nBytes &#123;</span><br><span class="line">		<span class="keyword">if</span> err := c.RemoveOldest(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	oldest := c.ll.Back()</span><br><span class="line">	<span class="keyword">if</span> oldest != <span class="literal">nil</span> &#123;</span><br><span class="line">		oldestEntry := oldest.Value.(*entry)</span><br><span class="line">		c.ll.Remove(oldest) <span class="comment">// 删除链表节点</span></span><br><span class="line">		c.nBytes = c.nBytes - oldestEntry.value.Len() <span class="comment">// 删除字节长度</span></span><br><span class="line">		<span class="built_in">delete</span>(c.cache, oldestEntry.key)  <span class="comment">// 删除字典</span></span><br><span class="line">		<span class="keyword">if</span> c.nBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(lruErrorName[MemorySizeError])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.OnEvicted(oldestEntry.key, oldestEntry.value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int64</span>(c.ll.Len())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">isOutOfMaxMemory</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> size &gt; c.maxBytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GeeByte <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GeeByte)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(g.Value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLruCache</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	lruObject := lru.CreateLRUCache(<span class="number">20</span>, <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value lru.Value)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s 被删除了, 释放了 %d 字节的空间\n&quot;</span>, key, value.Len())</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	_ = lruObject.Add(<span class="string">&quot;key1&quot;</span>, GeeByte&#123;[]<span class="keyword">byte</span>(<span class="string">&quot;Hello, Golang&quot;</span>)&#125;)</span><br><span class="line">	_ = lruObject.Add(<span class="string">&quot;key2&quot;</span>, GeeByte&#123;[]<span class="keyword">byte</span>(<span class="string">&quot;Hello, ByteDance&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> value, err := lruObject.Get(<span class="string">&quot;key2&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s&quot;</span>,value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>systemd 基本概念</title>
    <url>/2020/09/20/systemd-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>systemd 是 PID 为1的一个程序，负责初始化系统。所有的程序不是systemd直接启动就是由systemd的子系统启动。systemd是内核直接启动，所以信号9(KILL)对systemd也无效。</p>
<p>systemd 使用Linux控制组跟踪进程，维护安装和自动挂载点，并实现基于事务性依赖关系的详尽服务控制逻辑。其他部分包括日志记录守护程序，用于控制基本系统配置的实用程序，例如主机名，日期，区域设置，维护已登录用户和正在运行的容器和虚拟机的列表，系统帐户，运行时目录和设置，以及用于管理简单网络的守护程序配置，网络时间同步，日志转发和名称解析。</p>
<a id="more"></a>
<p><img src="https://img1.kiosk007.top/static/images/systemd/systemd.png" style="height:400px"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="对比-systemV"><a href="#对比-systemV" class="headerlink" title="对比 systemV"></a>对比 systemV</h2><p>从CentOS 7.x 以后，Red Hat 系列的 distribution 放弃沿用多年的System V 开机启动服务的流程. systemd 也是当年我从6.x 到 7.x 过度时感觉到最大的变化了，直到今天，MySQL的启动脚本还是可以通过 <code>service mysqld start</code> 启动的，但是升级到 CentOS 7.x 之后，就变成了 <code>systemd start mysqld</code> 了。当然还有经典的<code>init 0</code>的关机指令。</p>
<p>相比于 initd，systemd有以下几个大的进步。</p>
<ul>
<li><font color="blue">并行启动</font>：旧的 init 启动脚本是一项一项任务依序启动的模式，因此不相依的服务也是得要一个一个的等待。systemd可以让所有的服务同时启动，因此你会发现到，系统启动的速度变快了！</li>
<li><font color="blue">一经要求就回应的on-demand启动方式</font>：systemd全部就是仅有一只systemd服务搭配systemctl指令来处理，无须其他额外的指令来支援。不像systemV还要init, chkconfig, service…等等指令。此外， systemd由于常驻记忆体，因此任何要求(on-demand)都可以立即处理后续的daemon启动的任务。</li>
<li><font color="blue">服务相依性的自我检查</font>：由于systemd可以自订服务相依性的检查，因此如果B服务是架构在A服务上面启动的，那当你在没有启动A服务的情况下仅手动启动B服务时， systemd会自动帮你启动A服务。</li>
<li><font color="blue">依daemon功能分类</font>：systemd下管理的服务非常多，为了厘清所有服务的功能，因此，首先systemd先定义所有的服务为一个服务单位(unit)，并将该unit归类到不同的服务类型(type)去。旧的init仅分为stand alone与super daemon，systemd将服务单位(unit)区分为service, socket, target, path, snapshot, timer等多种不同的类型(type)，方便管理员的分类与记忆。</li>
<li><font color="blue">将多个daemons集合成为一个群组</font>：如同systemV的init里头有个runlevel的特色，systemd亦将许多的功能集合成为一个所谓的target项目，这个项目主要在设计操作环境的建置，所以是集合了许多的daemons，亦即是执行某个target就是执行好多个daemon的意思！</li>
<li><font color="blue">向下相容旧有的init服务脚本</font>：基本上， systemd是可以相容于init的启动脚本的，因此，旧的init启动脚本也能够透过systemd来管理，这也是为什么到现在还可以使用<code>serivce mysqld start</code> 这样命令的原因。</li>
</ul>
<blockquote>
<p><strong>综上可知，systemd 已经足够强大，可以管理一个进程的生命周期，如果是自己写的一套代码完全可以交给systemd 来维护呀，以前公司使用 <a href="https://ruby-china.org/topics/21354">god</a>(进程监控守护工具) 来管理服务，god 提供了服务启动、服务宕机自动拉起、环境变量和chroot、服务资源限制、定时任务等，但是systemd 的出现已经足够替代 god 这样的第三方服务，systemd 已经足够实现服务托管。</strong></p>
</blockquote>
<p><img src="https://img1.kiosk007.top/static/images/systemd/systemd_components2.png" style="height:400px"></p>
<h2 id="systemd-的配置文件"><a href="#systemd-的配置文件" class="headerlink" title="systemd 的配置文件"></a>systemd 的配置文件</h2><p>基本上， systemd 将过去所谓的daemon 执行脚本通通称为一个服务单位(unit)，而每种服务单位依据功能来区分时，就分类为不同的类型(type)。在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p>
<ul>
<li><font color="blue">automount</font>：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li>
<li><font color="blue">device</font>：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li>
<li><font color="blue">mount</font>：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li>
<li><font color="blue">path</font>：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li>
<li><font color="blue">scope</font>：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li>
<li><font color="blue">service</font>：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li>
<li><font color="blue">slice</font>：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li>
<li><font color="blue">snapshot</font>：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li>
<li><font color="blue">socket</font>：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li>
<li><font color="blue">swap</font>：定义一个用户做虚拟内存的交换分区</li>
<li><font color="blue">target</font>：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式。其实是一群unit 的集合，例如上面表格中谈到的multi-user.target 其实就是一堆服务的集合～也就是说， 选择执行multi-user.target 就是执行一堆其他.service 或/及.socket 之类的服务就是了！</li>
<li><font color="blue">timer</font>：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li>
</ul>
<p><strong>文件目录</strong><br>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p>
<ul>
<li><font color="blue">/etc/systemd/system/</font>：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能。</li>
<li><font color="blue">/run/systemd/system/</font>：系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li>
<li><font color="blue">/usr/lib/systemd/system/</font>：每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li>
</ul>
<p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>
<h1 id="Systemd-Service-Unit"><a href="#Systemd-Service-Unit" class="headerlink" title="Systemd Service Unit"></a>Systemd Service Unit</h1><h2 id="Unit-文件结构"><a href="#Unit-文件结构" class="headerlink" title="Unit 文件结构"></a>Unit 文件结构</h2><p>一般可以使用 <font style="color=blue">systemctl cat networking</font> 查看 Unit 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Hello World</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker <span class="built_in">kill</span> busybox1</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm busybox1</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c <span class="string">&quot;while true; do echo Hello World; sleep 1; done&quot;</span></span><br><span class="line">ExecStop=<span class="string">&quot;/usr/bin/docker stop busybox1&quot;</span></span><br><span class="line">ExecStopPost=<span class="string">&quot;/usr/bin/docker rm busybox1&quot;</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p><strong><font style="color:red"><code>[Unit]</code></font></strong> 区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Description</code>：简短描述</li>
<li><code>Documentation</code>：文档地址</li>
<li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li>
<li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li>
<li><code>BindsTo</code>：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li>
<li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li>
<li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li>
<li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li>
<li><code>Condition</code>：当前 Unit 运行必须满足的条件，否则不会运行</li>
<li><code>Assert</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li>
</ul>
</blockquote>
<p><strong><font style="color:red"><code>[Service]</code></font></strong> 区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Type</code>：定义启动时的进程行为。它有以下几种值。</li>
<li><code>Type=simple</code>：默认值，执行ExecStart指定的命令，启动主进程</li>
<li><code>Type=forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>
<li><code>Type=oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>
<li><code>Type=dbus</code>：当前服务通过D-Bus启动</li>
<li><code>Type=notify</code>：当前服务启动完毕，会通知Systemd，再继续往下执行</li>
<li><code>Type=idle</code>：若有其他任务执行完毕，当前服务才会运行</li>
<li><code>ExecStart</code>：启动当前服务的命令</li>
<li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li>
<li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li>
<li><code>ExecReload</code>：重启当前服务时执行的命令</li>
<li><code>ExecStop</code>：停止当前服务时执行的命令</li>
<li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li>
<li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li>
<li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li>
<li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li>
<li><code>Environment</code>：指定环境变量</li>
<li><code>EnvironmentFile</code>：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li>
<li><code>Nice</code>：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li>
<li><code>WorkingDirectory</code>：指定服务的工作目录</li>
<li><code>RootDirectory</code>：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li>
<li><code>User</code>：指定运行服务的用户</li>
<li><code>Group</code>：指定运行服务的用户组</li>
<li><code>MountFlags</code>：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private<ul>
<li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li>
<li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li>
<li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上</li>
</ul>
</li>
<li><code>LimitCPU</code> / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li>
</ul>
</blockquote>
<p><strong><font style="color:red"><code>[Install]</code></font></strong> 通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</li>
<li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</li>
<li><code>Alias</code>：当前 Unit 可用于启动的别名</li>
<li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li>
</ul>
</blockquote>
<p><strong>Unit 配置文件的完整字段清单，请参考 <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">官方文档</a>。</strong></p>
<h2 id="Unit-管理"><a href="#Unit-管理" class="headerlink" title="Unit 管理"></a>Unit 管理</h2><p><font style="color:blue">systemctl list-units </font>命令可以查看当前系统的所有 Unit 。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出正在运行的 Unit</span></span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有没有运行的 Unit</span></span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有加载失败的 Unit</span></span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看开机自启动的 service</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span> service |grep enabled</span><br></pre></td></tr></table></figure></p>
<h1 id="Systemd-Target"><a href="#Systemd-Target" class="headerlink" title="Systemd Target"></a>Systemd Target</h1><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p>
<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p>
<p>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的所有 Target</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动时的默认 Target</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动时的默认 Target</span></span><br><span class="line">$ sudo systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span></span><br><span class="line"><span class="comment"># systemctl isolate 命令改变这种行为，</span></span><br><span class="line"><span class="comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure>
<p>Target 与 传统 RunLevel 的对应关系如下。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Traditional runlevel      New target name     Symbolically linked to...</span><br><span class="line"></span><br><span class="line">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</span><br><span class="line">Runlevel 1           |    runlevel1.target -&gt; rescue.target</span><br><span class="line">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</span><br><span class="line">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</span><br><span class="line">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</span><br><span class="line">Runlevel 5           |    runlevel5.target -&gt; graphical.target</span><br><span class="line">Runlevel 6           |    runlevel6.target -&gt; reboot.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>它与<font style="color:blue">init</font>进程的主要差别如下。</p>
<p>（1）默认的 RunLevel（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p>
<p>（2）启动脚本的位置，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p>
<p>（3）配置文件的位置，以前init进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p>
<h1 id="Systemd-管理"><a href="#Systemd-管理" class="headerlink" title="Systemd 管理"></a>Systemd 管理</h1><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p><font style="color:blue"> systemctl </font> 是 Systemd 的主命令，用于管理系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU停止工作</span></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停系统</span></span><br><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入冬眠状态</span></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入交互式休眠状态</span></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure>
<h2 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h2><p><font style="color:blue"> systemd-analyze </font> 命令用于查看启动耗时。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure></p>
<h2 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h2><p><font style="color:blue"> hostnamectl </font> 命令用于查看当前主机的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure>
<h2 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h2><p><font style="color:blue"> localectl </font> 命令用于查看本地化设置。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ sudo localectl set-locale LANG=en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure></p>
<h2 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h2><p><font style="color:blue"> timedatectl </font>命令用于查看当前时区设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ sudo timedatectl set-timezone America/New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure>
<h2 id="loginctl"><a href="#loginctl" class="headerlink" title="loginctl"></a>loginctl</h2><p><font style="color:blue"> loginctl </font> 命令用于查看当前登录的用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure>
<h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<font style="color:blue"><code>journalctl</code></font>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since=<span class="string">&quot;2012-10-30 18:17:16&quot;</span></span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;20 min ago&quot;</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;2015-01-10&quot;</span> --until <span class="string">&quot;2015-01-11 03:00&quot;</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">&quot;1 hour ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部的最新10行日志</span></span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"> -o json-pretty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">systemd 入门教程</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 调度对象</title>
    <url>/2020/08/22/Kubernetes-Pod/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在容器的世界中，Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统，而如果仅仅是这样的化，容器是没有价值的，因为这样很难实现线上生产环境迁移到容器集群中，线上环境复杂多变，多个服务需要通过本地socket通信或者通过文件交互内容，所以在 k8s 中，pod才是最小的调度单元。</p>
<a id="more"></a>
<p>Pod是Kubernetes创建或部署的最小/最简单的基本单位，一个Pod代表集群上正在运行的一组进程。Pod 在 k8s 中扮演着重要的角色：<strong>容器的设计模式</strong>。</p>
<blockquote>
<p>Docker是Kubernetes Pod中最常见的runtime ，Pods也支持其他容器runtimes。</p>
</blockquote>
<h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><strong>首先要了解的一个事实是 Pod 只是一个逻辑概念，简单的理解是一组超亲密关系的容器</strong></p>
<p>这些容器共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。<br>在Docker中就有诸如 <code>$ docker run --net=B --volumes-from=B -name =A ...</code> 这样的命令可以让多个容器共享一个Namespace。</p>
<p>没错既然需要共享，那么就需要有容器的启动顺序，先启动一个基础容器，再将后启动的容器共享该基础容器的Namespace。<br><img src="https://img1.kiosk007.top/static/images/k8s/k8s_infra1.png" style="height:400px"></p>
<p>正如上图所示，在其他容器启动之前会先启动一个infra容器，infra容器一定只占用很少的资源，这个容器叫做‘k8s.gcr.io/pause’。这个镜像使用汇编编写，永远处于“暂停”状态，而infra容器提供基础的Namespace环境供该Pod里的其他容器共享。</p>
<p>所以，对于同一个Pod的里的所有容器来讲，他们的进出流量可以认为是通过 infra 容器完成的。<strong>之后如果要给k8s开发一个网络插件，应该考虑配置该Pod的Network Namesapce，Infra容器的rootfs里几乎什么东西都没有</strong></p>
<p>Pod 只是 k8s 里面的一个概念，提供的是一个编排思想，而不是具体的技术方案，比如 Mirantis 公司的 <a href="https://github.com/Mirantis/virtlet">virtlet</a> , 可以实现一个带有 systemd 进程的容器，来模拟传统的操作系统。</p>
<h2 id="Pod-配置文件"><a href="#Pod-配置文件" class="headerlink" title="Pod 配置文件"></a>Pod 配置文件</h2><p>Pod的创建时基于k8s 的配置文件 — yaml 文件创建的，这样的好处是可以记录每一个Pod的基础信息,<strong>凡是调度、网络、存储、安全相关的属性，基本上都是Pod级别的</strong></p>
<p>下面是Pod中的几个重要字段的含义和用法。具体更多的用法可以参考 <code>$GOPATH/src/k8s.io/kubernetes/vendor/k8s.io/api/core/v1/types.go</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1    # 版本号</span><br><span class="line">kind: Pod         # Pod</span><br><span class="line">metadata:         # 元数据</span><br><span class="line">  name: nginx     # Pod名称</span><br><span class="line">  namespace: string    # Pod所属的命名空间</span><br><span class="line">  labels:         # 自定义标签</span><br><span class="line">    - name: string   # 自定义标签名字</span><br><span class="line">  annotations:       # 自定义注释列表</span><br><span class="line">    - name: string </span><br><span class="line">spec:          # Pod中容器的详细定义</span><br><span class="line">  hostNetwork: true   # 共享宿主机网络</span><br><span class="line">  hostIPC: true       # 共享宿主机IPC</span><br><span class="line">  hostPID: true       # 共享宿主机PID</span><br><span class="line">  shareProcessNamespace: true   # Pod间共享PID</span><br><span class="line">  nodeSelector:       # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">  imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br><span class="line">    - name: string</span><br><span class="line">   disktype: ssd        </span><br><span class="line">  hostAliases:        # 设置 &#x2F;etc&#x2F;hosts</span><br><span class="line">   - ip: &quot;10.1.2.3&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.remote&quot;</span><br><span class="line">    - &quot;bar.remote&quot;</span><br><span class="line">  restartPolicy: [Always | Never | OnFailure]  # Pod的重启策略</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: shell</span><br><span class="line">    image: busybox</span><br><span class="line">    stdin: true</span><br><span class="line">    tty: true</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>spec</strong></li>
</ul>
<p><strong>nodeSeletor</strong> 是一个供用户将 Pod 与 Node 进行绑定的字段<br>这样的配置意味着该Pod只能运行在携带了“disktype：ssd”标签（Label）的节点上；否则会调度失败。</p>
<p><strong>hostAliases</strong> 定义了Pod中的 hosts 文件（比如 /etc/hosts）里的内容<br>在k8s中如果想要设置hosts文件的内容一定要通过这种方式，否则，Pod被删除重建后，kubelet会自动覆盖掉修改过的内容。</p>
<p><strong>restartPolicy</strong> ，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod。</p>
<blockquote>
<p>Pod在恢复过程中，永远是发生在当前的Node节点上，而不会去别的节点。如果想要Pod出现在其他可用节点，就需要使用 Deployment 这样的调度器来管理Pod，</p>
</blockquote>
<ul>
<li><strong>Namespace共享</strong></li>
</ul>
<p>凡是和Namespace相关的内容那么也一定是Pod级别的，Pod的设计就是要让Pod里的容器共享Namesapce，<code>shareProcessNamespace: true</code> 这条指令就可以实现Pod内的容器共享PID Namespace。</p>
<blockquote>
<p>创建Pod之后可以通过 <code>kubectl attach -it nginx -c shell</code> 后就可以通过ps 命令查看该Pod中的所有进程。</p>
</blockquote>
<p>同样添加 <code>hostNetwork</code>、<code>hostIPC</code>、<code>hostPID</code> 即可共享宿主机资源。</p>
<ul>
<li><strong>容器 &amp;&amp; 镜像</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:     # Pod中容器列表</span><br><span class="line">  - name: demo    # 容器名</span><br><span class="line">    image: nginx:1.19.2</span><br><span class="line">    command: [string]    # 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">    args: [string]       # 容器的启动命令参数列表</span><br><span class="line">    workingDir: string   # 容器的工作目录</span><br><span class="line">    imagePullPolicy: [Always | Never | IfNotPresent] # 容器拉取策略</span><br><span class="line">    nodeSelector: obeject  # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">    lifecycle:      # 容器生命周期</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; &#x2F;usr&#x2F;share&#x2F;message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]</span><br><span class="line">    volumes:       #在该pod上定义共享存储卷列表</span><br><span class="line">    - name: string     #共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">      emptyDir: &#123;&#125;     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br><span class="line">      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br><span class="line">        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录</span><br><span class="line">      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span><br><span class="line">        scretname: string  </span><br><span class="line">        items:     </span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br><span class="line">        name: string</span><br><span class="line">        items:</span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">    volumeMounts:    #挂载到容器内部的存储卷配置</span><br><span class="line">    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br><span class="line">      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符</span><br><span class="line">      readOnly: boolean    #是否为只读模式</span><br><span class="line">    ports:       #需要暴露的端口库号列表</span><br><span class="line">    - name: string     #端口号名称</span><br><span class="line">      containerPort: int   #容器需要监听的端口号</span><br><span class="line">      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同</span><br><span class="line">      protocol: string     #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    env:       #容器运行前需设置的环境变量列表</span><br><span class="line">    - name: string     #环境变量名称</span><br><span class="line">      value: string    #环境变量的值</span><br><span class="line">    resources:       #资源限制和请求的设置</span><br><span class="line">      limits:      #资源限制的设置</span><br><span class="line">        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br><span class="line">        memory: string     #内存限制，单位可以为Mib&#x2F;Gib，将用于docker run --memory参数</span><br><span class="line">      requests:      #资源请求的设置</span><br><span class="line">        cpu: string    #Cpu请求，容器启动的初始可用数量</span><br><span class="line">        memory: string     #内存请求，容器启动的初始可用数量</span><br><span class="line">    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span><br><span class="line">      exec:      #对Pod容器内检查方式设置为exec方式</span><br><span class="line">        command: [string]  #exec方式需要制定的命令或脚本</span><br><span class="line">      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式</span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged:false</span><br></pre></td></tr></table></figure>
<p><strong>ImagePullPolicy</strong> 定义了镜像拉取的策略，是一个Container级别的属性，默认值是Always，即每次创建Pod都重新拉取一次镜像，如果被定义为Never或者 ifNotPresent 时，则意味着Pod永远不会主动拉取这个镜像，或者只有宿主机不存在这个镜像时才会拉取。</p>
<p><strong>Lifecycle</strong> 定义了容器生命周期的一些钩子，可以执行容器启动前启动后的一些命令，</p>
<ul>
<li><strong>Projected Volume</strong></li>
</ul>
<p>在 k8s 中有一种特殊的Volume，叫做Projected Volume，存在的意义不是为了存放容器内的数据，也不是用来做数据交换，<strong>而是提供预先准备好的数据，所以从容器的角度来看就仿佛是被 k8s “投射”（Project）进入容器的，这正是Projected Volume 的含义。</strong></p>
<p>到目前为止，k8s共支持4种 Projected Volume.</p>
<ol>
<li>Secret   (例如加载数据库密码等)</li>
<li>ConfigMap   (例如加载配置文件等)</li>
<li>Downward API  (暴露Pod的meta信息给容器)</li>
<li>ServiceAccountToken  (保存授权信息)</li>
</ol>
<p>以Secret为例，其存在的意义其实就是将一些重要的数据投射进容器，比如数据库密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-projected-volume </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - &quot;86400&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: &quot;&#x2F;projected-volume&quot;</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: user</span><br><span class="line">      - secret:</span><br><span class="line">          name: pass</span><br></pre></td></tr></table></figure>
<p>数据库的用户名和密码，正是以Secret对象交付给 k8s 保存的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .&#x2F;username.txt</span><br><span class="line">admin</span><br><span class="line">$ cat .&#x2F;password.txt</span><br><span class="line">c1oudc0w!</span><br><span class="line"></span><br><span class="line">$ kubectl create secret generic user --from-file&#x3D;.&#x2F;username.txt</span><br><span class="line">$ kubectl create secret generic pass --from-file&#x3D;.&#x2F;password.txt</span><br><span class="line"></span><br><span class="line">$ kubectl get secrets</span><br><span class="line">NAME           TYPE                                DATA      AGE</span><br><span class="line">user          Opaque                                1         51s</span><br><span class="line">pass          Opaque                                1         51s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以通过yaml文件的格式创建Secret对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  user: YWRtaW4&#x3D;</span><br><span class="line">  pass: MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure>
<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>Pod 看似复杂的API对象，实际上是容器的进一步抽象和封装。而控制器（Deployment）则是控制Pod的抽象。有了控制器，我们可以定义需要2个pod，当pod个数不够时，自动创建pod直到pod个数满足配置文件 replicas 里 定义的个数。</p>
<p>在 k8s 架构中，有一个叫做 kube-controller-manager 的组件，这个组件负责了k8s集群中的集群属性。使用Deployment控制的pod在生产环境才有意义。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>定义Deployment来创建Pod和ReplicaSet</li>
<li>滚动升级和回滚应用</li>
<li>扩容和缩容</li>
<li>暂停和继续Deployment</li>
</ol>
<p>Deployment 本质也是从Etcd中获取到所有携带了“app：nginx” 标签的Pod，统计其数量，并根据 ReplicaSet 字段进行调整。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1   </span><br><span class="line">kind: Deployment                 </span><br><span class="line">metadata:</span><br><span class="line">  name: string         # Deployment名称</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3            # 目标副本数量</span><br><span class="line">  revisonHistoryLimit: 0 # 控制历史版本个数，0的话就没办法再进行回滚操作</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:       # 滚动更新</span><br><span class="line">      maxSurge: 1        # 滚动升级时最大同时升级1个pod</span><br><span class="line">      maxUnavailable: 1  # 滚动升级时最大允许不可用的pod个数</span><br><span class="line">  template:         </span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: string      # 模板名称</span><br><span class="line">    sepc:                # 定义容器模板，该模板可以包含多个容器</span><br><span class="line">      containers:                               </span><br><span class="line">        - name: string                                 </span><br><span class="line">          image: string </span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 8080  # 对service暴露端口</span><br></pre></td></tr></table></figure>
<p><strong>template</strong> Deployment里的template 字段和一个标准的Pod对象的API定义丝毫不差，而所有被这个Deployment管理的Pod实例就是根据这个template创建出来的。</p>
<ul>
<li><strong>ReplicaSet 对象</strong></li>
</ul>
<p>滚动更新不仅仅是 Deployment 中的一个字段，而是可以单独作为一个 k8s 中的重要的 API 对象。一个 ReplicaSet 对象，其实就是由副本数目的定义和一个Pod模板的组成。其实ReplicaSet是Deployment的一个子集。</p>
<p>滚动更新的过程可以通过 <code>kubectl rollout status xxx(deployment)</code>指令查看。或者 <code>kubectl describe deployment xxx(deployment)</code> 查看<br>，当修改了Pod 模板之后，Deployment Controller 会使用这个修改过的Pod模板，创建一个新的 ReplicaSet （hash=173242546624），这个新的 ReplicaSet 的初始化Pod的副本数是 0 。然后会扩展出一个新的Pod集群。</p>
<ol>
<li>想要查看replicaSet 对象 <code>kubectl get rs</code> </li>
<li>想要查看滚动升级历史 <code>kubectl rollout history xxx(deployment)</code></li>
<li>想要回滚升级至历史版本2 <code>kubectl rollout undo xxx(deployment) --revision=2</code></li>
<li>暂停更新和恢复 <code>kubectl rolllout pause xxxx</code> 和 <code>kubectl roolout resume xxxx</code></li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu20.04 部署 Kubernetes (k8s)</title>
    <url>/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Kubernetes（k8s）是一个免费的开源容器编排工具。它用于部署，扩展和管理基于容器的应用程序。在这篇文章中，这里将演示如何安装Kubernetes集群的Ubuntu 20.04 LTS服务器使用（Focal Fossa）kubeadm。在实验室设置中，我使用了三台Ubuntu 20.04 LTS服务器。<br><a id="more"></a></p>
<hr>
<p>以下为搭建环境。</p>
<ul>
<li>ubuntu 20.04 TLS Server</li>
<li>Minimum of 2 GB RAM</li>
<li>10 GB Free Space on /var</li>
<li>Privileged user with sudo rights</li>
</ul>
<p>结构：</p>
<ul>
<li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-master – 172.16.101.131</li>
<li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-node0 – 172.16.101.132</li>
<li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-node1 – 172.16.101.133</li>
</ul>
<p><img src="/images/k8s/k8s.png"></p>
<h1 id="安装-kubernetes"><a href="#安装-kubernetes" class="headerlink" title="安装 kubernetes"></a>安装 kubernetes</h1><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><h3 id="Step1-设置-hostname-amp-amp-增加解析-etc-hosts"><a href="#Step1-设置-hostname-amp-amp-增加解析-etc-hosts" class="headerlink" title="Step1) 设置 hostname &amp;&amp; 增加解析 /etc/hosts"></a>Step1) 设置 hostname &amp;&amp; 增加解析 /etc/hosts</h3><p>使用 <font color="Blue">hostnamectl </font> 为每一个节点命令设置 hostname , 示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-master&quot;     &#x2F;&#x2F; Run this command on master node</span><br><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-node0&quot;     &#x2F;&#x2F; Run this command on node-0</span><br><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-node1&quot;     &#x2F;&#x2F; Run this command on node-1</span><br></pre></td></tr></table></figure>
<p>在 <font color="Blue"> /etc/hosts </font> 下添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.16.101.131 k8s-master</span><br><span class="line">172.16.101.132 k8s-node0</span><br><span class="line">172.16.101.132 k8s-node1</span><br><span class="line"></span><br><span class="line">172.16.101.131 api-server.k8s.top  # kube API Server Lb</span><br></pre></td></tr></table></figure>
<h3 id="Step2-确保禁止掉swap分区-amp-amp-确保时间对齐-amp-amp-开启ip转发"><a href="#Step2-确保禁止掉swap分区-amp-amp-确保时间对齐-amp-amp-开启ip转发" class="headerlink" title="Step2) 确保禁止掉swap分区 &amp;&amp; 确保时间对齐 &amp;&amp; 开启ip转发"></a>Step2) 确保禁止掉swap分区 &amp;&amp; 确保时间对齐 &amp;&amp; 开启ip转发</h3><p>K8s的要求，在每个宿主机上关闭 swap，swap会将不活跃匿名页写入磁盘，降低应用程序的性能。使用 <font color="blue"> swapoff -a </font> 来关掉 swap<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"># &#x2F;swap.img      none    swap    sw      0       0</span><br></pre></td></tr></table></figure><br>每个宿主机上都要确保时区和时间是正确的。如果时区不正确，请使用下面的命令来修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><br>永久开启ip转发功能，编辑 “<font color="blue"> /etc/sysctl.d/k8s.conf </font>“ 添加 “<strong>net.ipv4.ip_forward=1</strong>” ，加载 “<strong>br_netfilter</strong>” 模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
<h3 id="Step3）安装-docker-Container-Runtime-到三个节点"><a href="#Step3）安装-docker-Container-Runtime-到三个节点" class="headerlink" title="Step3）安装 docker (Container Runtime) 到三个节点"></a>Step3）安装 docker (Container Runtime) 到三个节点</h3><p>在三台机器分别执行如下命令。Ubuntu 20.04 提供的这个包也很新（目前是docker 19.03）。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install docker.io -y</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 docker 运行状态，docker 版本</span></span><br><span class="line">systemctl status docker</span><br><span class="line">docker info</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>文件驱动默认由<code>systemd</code>改成<code>cgroupfs</code>.而我们安装的docker使用的文件驱动是systemd, 造成不一致, 导致镜像无法启动</p>
<p>修改或创建 <font color="blue"> /etc/docker/daemon.json </font>，加入下面的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>重启docker <code>systemctl restart docker</code>.</p>
<blockquote>
<p>不然会遇到 failed to create kubelet: misconfiguration: kubelet cgroup driver: “cgroupfs” is different from docker cgroup driver: “systemd” 错误</p>
</blockquote>
<p>参考：<a href="https://www.cnblogs.com/hongdada/p/9771857.html">https://www.cnblogs.com/hongdada/p/9771857.html</a></p>
<h2 id="安装k8s-master"><a href="#安装k8s-master" class="headerlink" title="安装k8s master"></a>安装k8s master</h2><p>以下的操作只在master宿主机上执行，适合中国大陆地区使用（因为弃用谷歌的源和repo，转而使用阿里云的镜像）：</p>
<h3 id="Step1）安装kubeadm-kubeadm-kubectl"><a href="#Step1）安装kubeadm-kubeadm-kubectl" class="headerlink" title="Step1）安装kubeadm kubeadm kubectl"></a>Step1）安装kubeadm kubeadm kubectl</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https curl</span><br><span class="line"></span><br><span class="line">curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;<span class="string">EOF </span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br><span class="line"><span class="comment"># 标记该软件包不被自动更新</span></span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<h3 id="Step2）通过-kubeadm-Kubernetes-初始化集群-from-master-node"><a href="#Step2）通过-kubeadm-Kubernetes-初始化集群-from-master-node" class="headerlink" title="Step2）通过 kubeadm Kubernetes 初始化集群 (from master node)"></a>Step2）通过 kubeadm Kubernetes 初始化集群 (from master node)</h3><p>查看完整配置选项 <a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a></p>
<p class="div-border green">kubernetes 的版本最好和 kubelet 的版本一致, kubelet --version 查看版本，本文写的时候，版本是 v1.18.6</p>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim .&#x2F;kubeadm-config.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.18.6</span><br><span class="line">imageRepository: registry.aliyuncs.com&#x2F;k8sxio</span><br><span class="line">controlPlaneEndpoint: &quot;api-server.k8s.top:6443&quot;</span><br><span class="line">apiServer:</span><br><span class="line">  certSANs:</span><br><span class="line">  - &quot;k8s-master&quot;</span><br><span class="line">  - &quot;api-server.k8s.top&quot;</span><br><span class="line">  - &quot;172.16.101.131&quot;</span><br><span class="line">networking:</span><br><span class="line">  serviceSubnet: &quot;10.96.0.0&#x2F;16&quot;</span><br><span class="line">  podSubnet: &quot;10.100.0.1&#x2F;16&quot;</span><br><span class="line">  dnsDomain: &quot;cluster.local&quot;</span><br><span class="line">controllerManagerExtraArgs:  </span><br><span class="line">  horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;  </span><br><span class="line">  horizontal-pod-autoscaler-sync-period: &quot;10s&quot;  </span><br><span class="line">  node-monitor-grace-period: &quot;10s&quot;</span><br><span class="line">apiServerExtraArgs:  </span><br><span class="line">  runtime-config: &quot;api&#x2F;all&#x3D;true&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># kubeadm init</span><br><span class="line"># 根据您服务器网速的情况，您需要等候 3 - 10 分钟</span><br><span class="line">kubeadm init --config&#x3D;kubeadm-config.yaml --upload-certs -v 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Kubernetes 集群默认需要加密方式访问。</span><br><span class="line"># 所以，这几条命令，就是将刚刚部署生成的 Kubernetes 集群的安全配置文件，保存到当前用户的.kube 目录下，</span><br><span class="line"># kubectl 默认会使用这个目录下的授权信息访问 Kubernetes 集群。如果不这么做的话，我们每次都需要通过 </span><br><span class="line"># export KUBECONFIG 环境变量告诉 kubectl 这个安全配置文件的位置。</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>podSubnet: Kubernetes</code> 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中</li>
<li><code>horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;:</code> kube-controller-manager 能够使用自定义资源（Custom Metrics）进行自动水平扩展。</li>
<li><code>controlPlaneEndpoint</code> 负载均衡器的地址始终与kubeadm相连接（方便kubeapi-server 横向扩展），既然是lb，那么最好不要填 k8s-master的hostname了，这里我写的是 <font color="red">api-server.k8s.top:6443 </font> </li>
<li><code>upload-certs</code> 将控制平面证书上传到 kubeadm-certs Secret。</li>
<li><code>-v 6</code> 更可能输出详细的日志，建议开启。</li>
</ul>
<p>初始化完成之后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You can now join any number of the control-plane node running the following command on each as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join api-server.k8s.top:6443 --token km8rml.3mnits2sbfh2srex \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3 \</span><br><span class="line">    --control-plane --certificate-key 619272158ec6c0a14c0539e032f5686df4d6c5576aa549412098ca50592315e6</span><br><span class="line"></span><br><span class="line">Please note that the certificate-key gives access to cluster sensitive data, keep it secret!</span><br><span class="line">As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use</span><br><span class="line">&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join api-server.k8s.top:6443 --token km8rml.3mnits2sbfh2srex \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3 </span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>查看Master节点的初始化状态 （only exec on master）</strong><br>执行<font color="blue"> kubectl get nodes -o wide </font> 可以看到我们的容器当前属于 NotReady 状态。NodeNotReady 的原因在于，我们尚未部署任何网络插件。通过 kubectl 检查这个节点上各个系统 Pod 的状态。可以看到，CoreDNS、kube-controller-manager 等依赖于网络的 Pod 都处于 Pending 状态，即调度失败。这当然是符合预期的：因为这个 Master 节点的网络尚未就绪。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># kubectl get nodes -o wide</span><br><span class="line">NAME         STATUS     ROLES    AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE           KERNEL-VERSION     CONTAINER-RUNTIME</span><br><span class="line">k8s-master   NotReady   master   22m   v1.18.6   172.16.101.131   &lt;none&gt;        Ubuntu 20.04 LTS   5.4.0-42-generic   docker:&#x2F;&#x2F;19.3.8</span><br><span class="line"></span><br><span class="line"># kubectl get pod -n kube-system -o wide</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-66db54ff7f-s4696             0&#x2F;1     Pending   0          26m   &lt;none&gt;           &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66db54ff7f-xxtvz             0&#x2F;1     Pending   0          26m   &lt;none&gt;           &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-k8s-master                      1&#x2F;1     Running   1          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-k8s-master            1&#x2F;1     Running   0          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-k8s-master   1&#x2F;1     Running   2          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-lvrkh                     1&#x2F;1     Running   0          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-k8s-master            1&#x2F;1     Running   2          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>安装网络插件</strong>&lt;/br&gt;<br>安装 calico 网络插件&lt;/br&gt;<br>参考文档 <a href="https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises">https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;kuboard.cn&#x2F;install-script&#x2F;calico&#x2F;calico-3.13.1.yaml</span><br><span class="line">kubectl apply -f calico-3.13.1.yaml</span><br></pre></td></tr></table></figure></p>
<h2 id="安装k8s-Worker"><a href="#安装k8s-Worker" class="headerlink" title="安装k8s Worker"></a>安装k8s Worker</h2><p>Kubernetes 的 Worker 节点跟 Master 节点几乎是相同的，它们运行着的都是一个 kubelet 组件。唯一的区别在于，在 kubeadm init 的过程中，kubelet 启动后，Master 节点上还会自动运行 kube-apiserver、kube-scheduler、kube-controller-manger 这三个系统 Pod。</p>
<p>所以，相比之下，部署 Worker 节点反而是最简单的，只需要两步即可完成。&lt;/br&gt;<br>第一步，在所有 Worker 节点(node0 node1)上执行“安装 kubeadm”。&lt;/br&gt;<br>第二步，执行部署 Master 节点时生成的 kubeadm join 指令：&lt;/br&gt;</p>
<p>操作在 worker 节点（k8s-node0 k8s-node1）之上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第一步骤：安装</span><br><span class="line">curl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list &lt;&lt;EOF </span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F; kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt-get install -y kubeadm</span><br><span class="line">apt-mark hold kubeadm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二步： 加入（初始化完成时的输出）</span><br><span class="line"></span><br><span class="line">kubeadm join api-server.k8s.top:6443 --token n9ksnt.zgxthovqoyl2weyq     --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第三步： 添加环境变量</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">cp -i &#x2F;etc&#x2F;kubernetes&#x2F;kubelet.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>不记得安装后的输出的话可以在 master节点执行 <font color="blue">kubeadm token create —print-join-command</font> 查看，该 token 的有效时间为 2 个小时，2小时内，您可以使用此 token 初始化任意数量的 worker 节点。</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.kuboard.cn/install/install-k8s.html">使用kubeadm安装kubernetes_v1.18.x</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/138554103">基于Ubuntu 20.04安装Kubernetes 1.18</a></li>
<li><a href="https://www.bookstack.cn/read/k8s-1.18-reference/e8ce7efca72fde85.md">Kubernetes v1.18 参考指南</a></li>
</ul>
<h2 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h2><h3 id="部署-Dashboard-可视化插件"><a href="#部署-Dashboard-可视化插件" class="headerlink" title="部署 Dashboard 可视化插件"></a>部署 Dashboard 可视化插件</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>由于 Dashboard 是一个 Web Server，很多人经常会在自己的公有云上无意地暴露 Dashboard 的端口，从而造成安全隐患。所以，1.7 版本之后的 Dashboard 项目部署完成后，默认只能通过 Proxy 的方式在本地访问。具体的操作，你可以查看 <a href="https://github.com/kubernetes/dashboard">Dashboard</a> 项目的官方文档。</p>
<p>Dashboard 向 Kubernetes 集群部署容器化应用诊断容器化应用的问题</p>
<ul>
<li>管理集群的资源</li>
<li>查看集群上所运行的应用程序</li>
<li>创建、修改Kubernetes 上的资源（例如 Deployment、Job、DaemonSet等）</li>
<li>展示集群上发生的错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.0.3&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后可以使用 <code>kubectl get pods</code> 命令来查看部署状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">...</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-6b4884c9d5-gs97j   1&#x2F;1     Running   0          100m</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-7f99b75bf4-h576c        1&#x2F;1     Running   0          100m</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>首先创建一个叫 <font color="blue"> admin-user </font> 的服务账号，并放在 <font color="blue">kubernetes-dashboard</font> 名称空间下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># admin-user.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<p>执行 <font color="blue"> kubectl create </font> 命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create -f admin-user.yaml</span><br></pre></td></tr></table></figure></p>
<h4 id="绑定角色"><a href="#绑定角色" class="headerlink" title="绑定角色"></a>绑定角色</h4><p>默认情况下，kubeadm 创建集群时已经创建了admin角色，我们直接绑定即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># admin-user-role-binding.yaml</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>执行 <font color="blue">kubectl create </font>命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create -f  admin-user-role-binding.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h4><p>们需要找到新创建的用户的Token，以便用来登录dashboard：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;&#123;print $1&#125;&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>Kubernetes API服务器是公开的，并可以从外部访问，那我们可以直接使用API Server的方式来访问，也是比较推荐的方式。</p>
<p>可以通过 proxy + Nginx 的方式访问<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl proxy --port&#x3D;8888 --accept-hosts&#x3D;&#39;^*$&#39; --address&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure><br>再将 Nginx 反向代理 8888 端口即可</p>
<p>Dashboard的访问地址为：<a href="https://172.16.101.131:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/node/k8s-node1?namespace=default">https://172.16.101.131:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/node/k8s-node1?namespace=default</a></p>
<p>但是直接访问会是403<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;services \&quot;https:kubernetes-dashboard:\&quot; is forbidden: User \&quot;system:anonymous\&quot; cannot get services&#x2F;proxy in the namespace \&quot;kube-system\&quot;&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;https:kubernetes-dashboard:&quot;,</span><br><span class="line">    &quot;kind&quot;: &quot;services&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是因为最新版的k8s默认启用了RBAC，并为未认证用户赋予了一个默认的身份：<font color="blue">anonymous</font><br>对于API Server来说，它是使用证书进行认证的，我们需要先创建一个客户端证书：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成client-certificate-data</span><br><span class="line">grep &#39;client-certificate-data&#39; ~&#x2F;.kube&#x2F;config | head -n 1 | awk &#39;&#123;print $2&#125;&#39; | base64 -d &gt;&gt; kubecfg.crt</span><br><span class="line"></span><br><span class="line"># 生成client-key-data</span><br><span class="line">grep &#39;client-key-data&#39; ~&#x2F;.kube&#x2F;config | head -n 1 | awk &#39;&#123;print $2&#125;&#39; | base64 -d &gt;&gt; kubecfg.key</span><br><span class="line"></span><br><span class="line"># 生成p12</span><br><span class="line">openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name &quot;kubernetes-client&quot;</span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/k8s/k8s_dashboard.png"></p>
<p>也可以通过 kube proxy 暴露8888端口，使用Nginx代理访问。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl proxy --port&#x3D;8888 --accept-hosts&#x3D;&#39;^*$&#39; --address&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/RainingNight/p/deploying-k8s-dashboard-ui.html">kubernetes-dashboard(1.8.3)部署与踩坑</a></li>
</ul>
<h3 id="部署持久化存储插件-rock"><a href="#部署持久化存储插件-rock" class="headerlink" title="部署持久化存储插件 rock"></a>部署持久化存储插件 rock</h3><p>Rook 项目是一个基于 Ceph 的 Kubernetes 存储插件（它后期也在加入对更多存储实现的支持）。不过，不同于对 Ceph 的简单封装，Rook 在自己的实现中加入了水平扩展、迁移、灾难备份、监控等大量的企业级功能，使得这个项目变成了一个完整的、生产级别可用的容器存储插件。</p>
<blockquote>
<p>友情提示，这玩意巨占空间，如果是本地虚拟机搭建的话需要磁盘稍微再大点。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/common.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/operator.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/cluster.yaml</span><br></pre></td></tr></table></figure>
<h2 id="通过-Taint-Toleration-调整-Master-执行-Pod-的策略-附加"><a href="#通过-Taint-Toleration-调整-Master-执行-Pod-的策略-附加" class="headerlink" title="通过 Taint/Toleration 调整 Master 执行 Pod 的策略 (附加)"></a>通过 Taint/Toleration 调整 Master 执行 Pod 的策略 (附加)</h2><p>默认情况下 Master 节点是不允许运行用户 Pod 的。而 Kubernetes 做到这一点，依靠的是 Kubernetes 的 Taint/Toleration 机制。</p>
<p>原理非常简单：一旦某个节点被加上了一个 Taint，即被“打上了污点”，那么所有 Pod 就都不能在这个节点上运行，因为 Kubernetes 的 Pod 都有“洁癖”。除非，有个别的 Pod 声明自己能“容忍”这个“污点”，即声明了 Toleration，它才可以在这个节点上运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建 taint</span><br><span class="line">kubectl taint nodes k8s-nodeXX foo&#x3D;bar:NoSchedule</span><br><span class="line"></span><br><span class="line"># 删除 taint</span><br><span class="line">kubectl taint nodes k8s-nodeXX foo&#x3D;bar:NoSchedule-</span><br></pre></td></tr></table></figure>
<p>master 默认已经有了一个 taint。即<font color="blue"> role.kubernetes.io/master:NoSchedule</font><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe node k8s-master</span><br><span class="line">Name:               k8s-master</span><br><span class="line">Roles:              master</span><br><span class="line">...</span><br><span class="line">CreationTimestamp:  Sat, 25 Jul 2020 09:44:07 +0800</span><br><span class="line">Taints:             node-role.kubernetes.io&#x2F;master:NoSchedule</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="创建-k8s容器化应用"><a href="#创建-k8s容器化应用" class="headerlink" title="创建 k8s容器化应用"></a>创建 k8s容器化应用</h1><p>这里创建一个Nginx, 准备一个 <font color="blue"> nginx-deployment.yaml </font> 文件，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.19.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &quot;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&quot;</span><br><span class="line">          name: nginx-vol</span><br><span class="line">      volumes:</span><br><span class="line">      - name: nginx-vol</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &quot;&#x2F;root&#x2F;data&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>spec.replicas</code>：Pod 副本个数 ：2</li>
<li><code>spec.containers.image</code>: 容器镜像 ：Nginx:latest</li>
<li><code>containerPort</code>: 容器端口：80</li>
<li><code>volumes.emptyDir</code>: 不显式声明宿主机目录的 Volume。所以，Kubernetes 也会在宿主机上创建一个临时目录，这个目录将来就会被绑定挂载到容器所声明的 Volume 目录上。当然，Kubernetes 也提供了显式的 Volume 定义，它叫作 hostPath。比如下面的这个 YAML 文件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...   </span><br><span class="line">   volumes:</span><br><span class="line">     - name: nginx-vol</span><br><span class="line">       hostPath: </span><br><span class="line">         path:  &quot; &#x2F;var&#x2F;data&quot;</span><br></pre></td></tr></table></figure>
使用 kubectl create 创建这个容器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure>
<p>查看运行状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -l app&#x3D;nginx</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-d4544f9cb-b24wq   1&#x2F;1     Running   0          5m13s</span><br><span class="line">nginx-deployment-d4544f9cb-f88bk   1&#x2F;1     Running   0          5m13s</span><br><span class="line"></span><br><span class="line"># 查看一个 API 对象的细节，通过 Events 字段</span><br><span class="line">kubectl describe pod nginx-deployment-d4544f9cb-b24wq</span><br></pre></td></tr></table></figure><br>查看API对象细节<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe pod nginx-deployment-57f45cfc58-9fpzt</span><br><span class="line">Name:         nginx-deployment-57f45cfc58-9fpzt</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         k8s-node1&#x2F;172.16.101.133</span><br><span class="line">Start Time:   Sat, 25 Jul 2020 18:00:01 +0800</span><br><span class="line">Labels:       app&#x3D;nginx</span><br><span class="line">              pod-template-hash&#x3D;57f45cfc58</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>在 kubectl describe 命令返回的结果中，可以看到这个 Pod 的详细信息，比如它的 IP 地址等等。其中，有一个部分值得你特别关注，就是 <strong>Events（事件）</strong>。</p>
<p>在 Kubernetes 执行的过程中，对 API 对象的所有重要操作，都会被记录在这个对象的 Events 里，并且显示在 kubectl describe 指令返回的结果中。</p>
<p>如果 pod 信息有改变，比如想要将Nginx的版本换成1.18。修改完 yaml 文件后，只需要执行<code>kubectl apply -f nginx-deployment.yaml</code> 即可。</p>
<p><strong>进入到pod中，即这个namesapce中</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl exec -it  nginx-deployment-57f45cfc58-9fpzt -- &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><br><strong>从 Kubernetes 集群中删除这个 Nginx Deployment </strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure></p>
<h1 id="k8s-的最小调度单元-pod"><a href="#k8s-的最小调度单元-pod" class="headerlink" title="k8s 的最小调度单元 pod"></a>k8s 的最小调度单元 pod</h1><p>前面已经完全搭建起来了一个 k8s 集群，并跑起来了第一个Nginx服务。但是这距离线上的生成环境还差的很远。</p>
<p>试想一下，Nginx 假设需要为静态资源前端文件提供服务部署能力，那么该如何实现呢？将前端文件内容和Nginx绑定部署？这显然是不合适的。</p>
<p>Linux 下的很多服务其实也是多个进程相互协作的，比如两个进程是通过本地socket通信的，那么就必须让两个进程处于同一个 namespace中，而在docker的世界，容器即进程，也就是一个容器跑着一个进程。</p>
<blockquote>
<p>再次强调一下：容器的“单进程模型”，并不是指容器里只能运行“一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程。可是，用户编写的应用，并不能够像正常操作系统里的 init 进程或者 systemd 那样拥有进程管理的功能。比如，你的应用是一个 Java Web 程序（PID=1），然后你执行 docker exec 在后台启动了一个 Nginx 进程（PID=3）。可是，当这个 Nginx 进程异常退出的时候，你该怎么知道呢？这个进程退出后的垃圾收集工作，又应该由谁去做呢？</p>
</blockquote>
<p>这就需要多个容器组成一个pod，pod里的容器可以共享namespace，比如共享<code>network namespace</code>或者共享volume的<code>mnt namesapce</code>。这就像 <code>docker run --net=B --volumes-from=B --name=A image-A ...</code>这样的联盟式容器一样的操作。</p>
<p>在k8s中，需要有一个初始的容器来提供初始化的环境，这个容器（k8s.grc.io/pause）会最先启动,并提供初始的各种namesapce环境，infra容器所占用的资源是最小的。<strong>k8s.gcr.io/pause</strong> 这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有 100~200 KB 左右。<br><img src="/images/k8s/k8s_infra.png" style="height:400px"></p>
<p>如果要开发容器的网络插件，也就是针对这个infra容器的，而不是应用本身的容器。</p>
<p>在web场景中经常即需要war包也需要运行war包的tomcat web服务器。web包需要放在tomcat的webapp下运行。<br>如果用容器去可能的2个实现方法是。</p>
<ol>
<li>把 WAR 包直接放在 Tomcat 镜像的 webapps 目录下，做成一个新的镜像运行起来。可是，这时候，如果你要更新 WAR 包的内容，或者要升级 Tomcat 镜像，就要重新制作一个新的发布镜像，非常麻烦。</li>
<li>压根儿不管 WAR 包，永远只发布一个 Tomcat 容器。不过，这个容器的 webapps 目录，就必须声明一个 hostPath 类型的 Volume，从而把宿主机上的 WAR 包挂载进 Tomcat 容器当中运行起来。不过，这样你就必须要解决一个问题，即：如何让每一台宿主机，都预先准备好这个存储有 WAR 包的目录呢？这样来看，你只能独立维护一套分布式存储系统了。</li>
</ol>
<p>有了 Pod 之后，这样的问题就很容易解决了。我们可以把 WAR 包和 Tomcat 分别做成镜像，然后把它们作为一个 Pod 里的两个容器“组合”在一起。<br>这里定义了2个容器 <code>war</code> 和 <code>tomcat</code>。war容器只专心提供war包，而tomcat基<br>本不变。不过，<code>war</code> 容器的类型不再是一个普通容器，而是一个 <strong>Init Container</strong> 类型的容器。Init Container 类型的 WAR 包容器启动后，执行了<code>cp /sample.war /app</code>，把应用的 WAR 包拷贝到 /app 目录下，然后退出。</p>
<ul>
<li>这种组合即“sidecar”，sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。</li>
</ul>
<blockquote>
<p>Init Container 定义的容器，都会比 spec.containers 定义的用户容器先启动。并且，Init Container 容器会按顺序逐一启动，而直到它们都启动并且退出了，用户容器才会启动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: javaweb-2</span><br><span class="line">spec:</span><br><span class="line">  initContainers:</span><br><span class="line">  - image: geektime&#x2F;sample:v2</span><br><span class="line">    name: war</span><br><span class="line">    command: [&quot;cp&quot;, &quot;&#x2F;sample.war&quot;, &quot;&#x2F;app&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &#x2F;app</span><br><span class="line">      name: app-volume</span><br><span class="line">  containers:</span><br><span class="line">  - image: geektime&#x2F;tomcat:7.0</span><br><span class="line">    name: tomcat</span><br><span class="line">    command: [&quot;sh&quot;,&quot;-c&quot;,&quot;&#x2F;root&#x2F;apache-tomcat-7.0.42-v2&#x2F;bin&#x2F;start.sh&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &#x2F;root&#x2F;apache-tomcat-7.0.42-v2&#x2F;webapps</span><br><span class="line">      name: app-volume</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      hostPort: 8001 </span><br><span class="line">  volumes:</span><br><span class="line">  - name: app-volume</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 信任自签名证书</title>
    <url>/2020/07/22/Android-%E4%BF%A1%E4%BB%BB%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前的文章 <a href="https://kiosk007.top/2020/05/30/VMTrafficShark-%E8%87%AA%E5%88%B6%E5%BC%B1%E7%BD%91%E6%A8%A1%E6%8B%9F%E5%99%A8/">VMTrafficShark 自制弱网模拟器</a> 中介绍了如何搭建一个弱网模拟器，并且进行弱网模拟，中间人，劫持重放测试等等。对了这里一般的测试设备是Android手机，那么这篇文章介绍一下Android 手机应该如何支持自签名证书。</p>
<a id="more"></a>
<hr>
<h1 id="Android-root"><a href="#Android-root" class="headerlink" title="Android root"></a>Android root</h1><p>Android 本身可以理解为一个Linux操作系统的终端，只是没有root权限，普通用户 <code>adb</code> 连上之后只有普通用户的权限。而root不是那么容易的，这里推荐 <code>Magisk Root</code> 这款软件，目前我的 Mi3， RedMi Note 8 Pro 都是已经root了的（曾经是米粉…）</p>
<p>甩几个链接参考</p>
<ul>
<li><a href="https://www.magiskroots.com/">Magic Mask To Enhance Your Default Android | The First Systemless Root Tool</a></li>
<li><a href="https://devsjournal.com/how-to-setup-magisk-manager-on-rooted-android-device-to-hide-root.html#:~:text=Installing%20Magisk%20Root%20via%20TWRP%3A%201%20Make%20sure,Zip%20and%20confirm%20flashing.%20...%20More%20items...%20">How To Setup Magisk Manager On Rooted Android Device To Hide “Root”</a></li>
<li><a href="https://c.mi.com/thread-1808315-1-0.html">How to Root Xiaomi Redmi Note 5</a></li>
</ul>
<h1 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h1><h2 id="X509-证书简介"><a href="#X509-证书简介" class="headerlink" title="X509 证书简介"></a>X509 证书简介</h2><p>首先介绍一下证书体系吧</p>
<p>公钥基础设施（PKI）是一种用于验证网络世界中的用户和设备的技术。基本思想是让一个或多个受信方对数据进行数字签名，以证明特定的加密密钥属于特定的用户或设备。然后该密钥可以用作证明该用户的身份。</p>
<p>而 x509 正是当下最常见的证书标准，<a href="https://tools.ietf.org/html/rfc5280">RFC5280</a> 阐述了IETF对X509证书的定义。x509证书的格式在google chrome 浏览器地址栏左边的小锁即可查看。</p>
<p>以cloudflare的官网域名 <a href="https://1.1.1.1">https://1.1.1.1</a> 举例（没错，还有ip证书）</p>
<p><strong>第一组详细信息包括有关主题的信息，包括公司名称和地址以及证书旨在保护的网站的通用名称（Fully Qualified Domain Name）</strong><br><img src="https://img1.kiosk007.top/static/images/network/AndroidRoot/cert_fqdn.png" style="height:450px"></p>
<p><strong>向下滑动，是发行者的信息（Issuer）, 这里可以看到签发者是 DigiCert。在颁发者下方，我们可以看到证书的序列号，X.509版本（3），签名算法以及指定证书有效期的日期。</strong><br><img src="https://img1.kiosk007.top/static/images/network/AndroidRoot/cert_sign.png" style="height:450px"></p>
<p><strong>X.509 v3证书还包括一组扩展，这些扩展在证书使用方面提供了更多的灵活性。例如，主题备用名称扩展名允许证书绑定到多个身份。（因此，有时将多域证书称为 <a href="https://www.ssl.com/faqs/what-is-a-san-certificate/">SAN</a> 证书）。这里提供了很多其他域名，这里还可以提供ip地址,可以看到 cloudflare 的1.1.1.1</strong></p>
<p><img src="https://img1.kiosk007.top/static/images/network/AndroidRoot/cert_san.png" style="height:450px"></p>
<h2 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h2><ul>
<li>.DER .CER，文件是二进制格式，只保存证书，不保存私钥。</li>
<li>.PEM，一般是文本格式，可保存证书，可保存私钥。</li>
<li>.CRT，可以是二进制格式，可以是文本格式，与 .DER 格式相同，不保存私钥。</li>
<li>.PFX .P12，二进制格式，同时包含证书和私钥，一般有密码保护。</li>
<li>.JKS，二进制格式，同时包含证书和私钥，一般有密码保护。</li>
</ul>
<h2 id="利用-Mitm-的-Root-CA-制作自签名证书"><a href="#利用-Mitm-的-Root-CA-制作自签名证书" class="headerlink" title="利用 Mitm 的 Root CA 制作自签名证书"></a>利用 Mitm 的 Root CA 制作自签名证书</h2><p><a href="https://docs.mitmproxy.org/stable/">mitmproxy</a> 是一款中间人工具，通过代理来实现https流量嗅探。</p>
<p>安装好 mitmproxy 后再家目录下就放着 mitm 的root ca。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ls ~/.mitmproxy</span><br><span class="line">mitmproxy-ca-cert.cer  mitmproxy-ca-cert.p12  mitmproxy-ca-cert.pem  mitmproxy-ca.p12  mitmproxy-ca.pem  mitmproxy-dhparam.pem</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这里我们取 <code>mitmproxy-ca.pem</code> 这个文件制作自签名证书。</p>
<h3 id="分离CA证书和私钥"><a href="#分离CA证书和私钥" class="headerlink" title="分离CA证书和私钥"></a>分离CA证书和私钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mkdir mitm &amp;&amp; <span class="built_in">cd</span> mitm</span><br><span class="line">➜  cp ~/.mitmproxy/mitmproxy-ca.pem .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离私钥</span></span><br><span class="line">➜  openssl pkey -<span class="keyword">in</span> mitmproxy-ca.pem -out mitmproxy-ca-private.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有证书，包括CA Chain</span></span><br><span class="line">➜  openssl crl2pkcs7 -nocrl -certfile mitmproxy-ca.pem | openssl pkcs7 -print_certs -out mitmproxy-ca-certificate.cert</span><br></pre></td></tr></table></figure>
<h3 id="创建自签名证书"><a href="#创建自签名证书" class="headerlink" title="创建自签名证书"></a>创建自签名证书</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成证书私钥（your-domain.com 换成你要签名的域名）</span></span><br><span class="line">➜  openssl genrsa -out your-domain.com.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书请求文件(并按要求填写 CN、SPN、LN等，不想填就全部回车)</span></span><br><span class="line">➜  openssl req -new -key your-domain.com.key -out your-domain.com.csr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Chrome 58 之后，改为使用 SAN(Subject Alternative Name) 检查域名的一致性。</p>
<p>而 SAN 属于 x509 扩展里面的内容，所以我们需要通过 -extfile 参数来指定存放扩展内容的文件。创建一个 your-domain.com.ext 文件用来保存 SAN 信息，通过指定多个 DNS 从而可以实现多域名证书。<br>参考：<a href="http://wiki.cacert.org/FAQ/subjectAltName">FAQ/subjectAltName (SAN)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vim your-domain.com.ext</span><br><span class="line">[req]</span><br><span class="line">req_extensions = v3_req</span><br><span class="line"></span><br><span class="line">[v3_req]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = your-domain.com.</span><br><span class="line">DNS.2 = *.your-domain.com.</span><br><span class="line">IP.1 = 127.0.0.1</span><br><span class="line">IP.2 = 192.168.0.107</span><br></pre></td></tr></table></figure>
<p>使用 mitm 的CA 公私钥对 签署自己域名的证书。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  openssl x509 -req -sha256 -<span class="keyword">in</span> your-domain.com.csr \</span><br><span class="line">-CA mitmproxy-ca-certificate.cert \</span><br><span class="line">-CAkey mitmproxy-ca-private.key \</span><br><span class="line">-CAcreateserial \</span><br><span class="line">-out your-domain.com.crt \</span><br><span class="line">-days 365 \</span><br><span class="line">-extfile kiosk007.top.ext \</span><br><span class="line">-extensions v3_req</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>至此，自签名证书已经生成完毕，自签名的证书为 <code>your-domain.crt</code> , 自签名的私钥为 <code>your-domain.key</code> 。只需要将 <code>mitmproxy-ca-certificate.cert</code> 导入到Android手机中，手机便会信任由这个root 证书签名的证书，如刚才的 <code>your-domian.crt</code></p>
<h2 id="导入根证书到Android手机"><a href="#导入根证书到Android手机" class="headerlink" title="导入根证书到Android手机"></a>导入根证书到Android手机</h2><h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到hash值</span></span><br><span class="line">➜  openssl x509 -subject_hash_old -<span class="keyword">in</span> mitmproxy-ca-certificate.cert |head -n 1</span><br><span class="line">➜  cp mitmproxy-ca-certificate.cert &lt;Certificate_Hash&gt;.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="安装到Android机"><a href="#安装到Android机" class="headerlink" title="安装到Android机"></a>安装到Android机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  adb push c8750f0d.0 /sdcard/</span><br><span class="line">➜  adb shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手机中操作</span></span><br><span class="line">begonia:/ $ su root</span><br><span class="line">:/ <span class="comment"># mount -o rw,remount /</span></span><br><span class="line">:/ <span class="comment"># mv /sdcard/c8750f0d.0 /system/etc/security/cacerts/</span></span><br><span class="line">:/ <span class="comment"># chmod 644 /system/etc/security/cacerts/c8750f0d.0</span></span><br><span class="line">:/ <span class="comment"># chown root:root /system/etc/security/cacerts/c8750f0d.0</span></span><br><span class="line">:/ <span class="comment"># mount -o ro,remount /</span></span><br><span class="line">:/ <span class="comment"># reboot</span></span><br><span class="line">➜  </span><br><span class="line">➜  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果遇到’/dev/block/dm-0’ is read-only报错，依次执行以下命令解决：</p>
<ol>
<li>adb root</li>
<li>adb disable-verity</li>
<li>adb reboot</li>
<li>adb remount</li>
<li>adb shell </li>
<li>mount -o rw,remount /system</li>
</ol>
<p>如若还不行(Andoird11)，可以进fastboot模式，执行 <code>fastboot oem unlock</code></p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.ssl.com/faqs/what-is-an-x-509-certificate/">What Is an X.509 Certificate?</a></li>
<li><a href="https://www.ssh.com/pki/">PKI - Public Key Infrastructure</a></li>
<li><a href="https://blog.freessl.cn/ssl-cert-format-introduce/">SSL 证书格式普及，PEM、CER、JKS、PKCS12</a></li>
</ul>
<h1 id="Android-ssh-终端-附加"><a href="#Android-ssh-终端-附加" class="headerlink" title="Android ssh 终端 (附加)"></a>Android ssh 终端 (附加)</h1><p>这一步主要是可以通过ssh操作终端（已经和信任自签名证书无关了哈，只是附加的。哈哈），因为<code>adb shell</code>实在是太难操作了。</p>
<p>这里先安装 Termux （可以在 google play 或者 豌豆荚下载）</p>
<p>安装 Termux 之后，安装sshd<br>手机上操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg install openssh -y</span><br><span class="line"># start ssh</span><br><span class="line">sshd</span><br></pre></td></tr></table></figure><br>配置远程登录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># PC copy ssh 公钥 (没有的化，执行 ssh-keygen 生成)</span><br><span class="line">➜  copy id_rsa.pub</span><br><span class="line"></span><br><span class="line"># Termux 粘贴公钥</span><br><span class="line">cd .ssh</span><br><span class="line">vim authorized_keys</span><br><span class="line">粘贴保存</span><br><span class="line"></span><br><span class="line">查看当前用户，后面登录用</span><br><span class="line">whoami</span><br><span class="line"></span><br><span class="line"># PC 上配置端口转发</span><br><span class="line">（如果是远程的话配置一下 adb connect xxxxxx:xxx）</span><br><span class="line">➜  adb forward --list</span><br><span class="line">➜  adb forward --remove-all</span><br><span class="line">➜  adb forward tcp:8022 tcp:8022</span><br><span class="line">➜  ssh u0_a221@127.0.0.1 -p 8022</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Tips: 界面左滑，长按 <code>KEYBOARD</code> 可以出现辅助按钮， ESC、CTR、ALT 等。再次单按 <code>KEYBOARD</code> 可出现键盘。</p>
</blockquote>
<p><img src="https://img1.kiosk007.top/static/images/network/AndroidRoot/android_root.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Certificate</tag>
      </tags>
  </entry>
  <entry>
    <title>理解协程</title>
    <url>/2020/07/18/%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>协程</strong> 在如今在高并发场景下最容易提到的一个技术，协程即能暂停执行以在之后恢复的函数。。下面是关于 <a href="https://en.cppreference.com/w/cpp/language/coroutines">GCC11 编辑器</a> 对协程的介绍 （ A coroutine is a function that can suspend execution to be resumed later. Coroutines are stackless: they suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. ）</p>
<a id="more"></a>
<hr>
<p>试想以下场景，百万级别的高并发场景下，如何实现用户访问静态资源的Web服务，需要的工作如下</p>
<ol>
<li>通过网络调用远程服务来进行身份验证</li>
<li>检查Memcache中是否存在相关的资源 </li>
<li>将请求的资源从磁盘中读取数据放入 HTTP Body的 Buffer中 </li>
<li>再将访问记录插入到MySQL数据库中。</li>
</ol>
<p>那么都有哪些技术呢？</p>
<ul>
<li>多进程？进程是操作系统资源分配（内存，显卡，磁盘）的最小单位。多进程面临着 CPU 寄存器和程序计数器等上下文的切换。</li>
<li>多线程？线程是执行调度（即cpu调度）的最小单位（cpu看到的都是线程而不是进程）。计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位)　一个进程可以有一个或多个线程，线程之间共享进程的资源。</li>
</ul>
<p>如果使用阻塞API写同步代码将最简单，但是一个线程同一时间只能处理一个请求，也就是每新建一个链接就需要新创建一个线程去处理，而CPU在处理越来越多的请求时，会切换线程来服务其他的线程,这样的做法能满足我们高并发的需求吗？</p>
<p><img src="https://img1.kiosk007.top/static/images/coroutines/mutli_pthread.jpeg"></p>
<p>无论是多进程还是多线程都有以下问题。</p>
<ul>
<li><font color="red">资源消耗的问题</font>: 比如 64 位Linux为每个线程的栈分配了8MB 的内存，C库还预分配了64MB的内存池，在同时存在数十万的连接情况下没有足够的内存开启如此之多的线程。</li>
<li><font color="red">上下文切换</font>：CPU资源消耗，<strong>当调度到阻塞的方法时，内核为了让CPU充分工作，也会切换到其他的线程执行</strong>　进程的切换会有很多寄存器，堆栈的切换，也会造成缓存命中率差，线程虽然切换会轻量一些，但还是会存在部分私有数据和寄存器数据的切换。一次的切换成本也会在几十纳秒到几微秒间。</li>
</ul>
<p>那么该怎样实现高并发？如果将本来应该由内核实现的请求切换工作，交给用户态的代码完成就能实现切换成本的降低，异步化改造依赖ＩＯ多路复用机制和非阻塞，然而写异步化代码很容易出错。异步化改造需要将阻塞的函数通过非阻塞的系统调用拆分成２个函数，第一个函数显式调用，第二个函数多路复用的调用。所以异步化改造程序是很复杂的。<br><img src="https://img1.kiosk007.top/static/images/coroutines/coroutine.jpeg"></p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程出现了，在异步化之上包了一层外衣，这就是异步框架。协程与异步编程的<strong>相似的地方</strong>在于他们都使用了非阻塞的系统调用与内核交互。把切换请求的实现放到了用户态。<strong>不同的地方</strong>在于协程把异步化中的两段函数封装成了一个“阻塞的协程函数”。这也是对用户友好的编程格式。函数在执行时，调用的协程无感知的放弃执行权，由协程框架切换到准备就绪的其他协程上。当这个函数满足执行条件时，协程框架再选择合适的时机，切换回它所在的协程执行。</p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>协程不需要什么“回调函数”，它允许用户调用“阻塞的函数”，即用同步编程的方式去写业务逻辑。解决了异步化通过大量的回调函数来完成请求函数的切换的复杂编程方式。</p>
<p><img src="https://img1.kiosk007.top/static/images/coroutines/coroutine_stack.png"><br>实际上，<strong>用户态的代码协程切换和内核协程切换的原理是一样的</strong>，内核通过管理CPU的寄存器来切换线程，而协程的切换是将内核的工作移到了协程框架实现而已，创建协程时，会从进程的堆中分配一段内存作为协程的栈。线程的栈有8MB，而协程的栈只有几十ＫＢ，并且Ｃ库的内存池也不会为协程预分配内存，因为它感知不到协程的存在。这样以来协程需要的内存空间就十分少了，几十万的并发也不需要很多的内存消耗</p>
<blockquote>
<p><strong>当然：栈缩小了，就尽量不要在协程中使用递归函数了</strong></p>
</blockquote>
<p>由此可见，协程就是用户态的线程。协程框架在用户空间做了线程切换等内核要做的事情。另外协程封装了所有阻塞的系统调用，例如<code>sleep()</code>函数会让当前的线程休眠，而线程一旦休眠，协程也就无法执行了。（协程是工作于线程之上的）。这就需要内核来唤醒sleep函数，协程化改造之后，<code>sleep()</code>函数只会让当前的协程休眠，由协程框架在指定时间后唤醒协程。</p>
<p><strong>所以协程的高性能就是建立在所有的切换由用户态代码实现，这就要求协程的生态是完整的，要覆盖所有组件。</strong>如果一个协程框架没有考虑到如<code>sleep()</code>函数的协程化改造，就会造成线程休眠，线程休眠就会造成在线程之上的协程也伴随着休眠。</p>
<h2 id="协程-线程"><a href="#协程-线程" class="headerlink" title="协程+线程"></a>协程+线程</h2><p>实际上面对当下服务器动辄几百核的多核CPU架构，线程也就需要和协程结合起来使用，因为协程的载体是线程。而CPU的执行对象是线程，线程在同一时刻只能拥有一颗CPU，那么好的设计是开启更多的线程，然后将协程分布在这些线程之上，这样就能充分的利用CPU资源。</p>
<p>除此之外，为了让协程获得更多的CPU时间，只要所在线程的优先级调高即可，甚至可以将CPU绑定到某个CPU上，增加协程执行时命中CPU的缓存几率。（要知道CPU的三级缓存SRAM是要比内存DRAM快很多的，如果多个线程频繁在不同的CPU切换来切换去就会造成缓存命中率低下，TLB根本起不到作用）</p>
<p>很多的协程库只提供了创建、挂起、恢复执行的基本方法，并没有协程框架的概念出现，这就需要业务在代码中自行实现调度协程。在协程的运行条件不满足需求时，多路复用框架会将它挂起，并根据优先级策略选择另一个协程执行。也就是不只是选择协程库，还需要结合IO多路复用的协程框架，这样就可以加快开发的速度。</p>
<p>比如OpenResty中的<code>cosocket</code>，<code>cosocket = coroutine + socket</code> ，<code>cosocket</code>利用lua的协程特性支持，又结合了Nginx事件机制。遇到网络I/O就会交出控制权（yield），把网络事件注册到Nginx的事件监听表中，并把权限重新交给Nginx，当有Nginx事件达到触发条件，会唤醒对应的协程继续处理（resume）</p>
<h2 id="golang协程"><a href="#golang协程" class="headerlink" title="golang协程"></a>golang协程</h2><p>Go在语言级别支持了协程（Goroutine）来实现高并发。作为程序员不必再考虑 像<code>Python</code> 那样引入一个异步协程库，利用其代码来实现异步协程化。</p>
<p>Goroutine天生对协程的完美支持，也让Goroutine传承了协程本身的优良特性。<br>Goroutine堆栈只有几十kb。如果某一线程之上的协程不幸发生阻塞，那么系统可以将其与协程移动到新的线程上执行，这一切不用程序员关心。多个协程之间通信的管道。信道可以防止多个协程访问共享内存时发生资源争抢的问题。(但是注意：多个goroutine 访问一个map时一定需要加锁！！)</p>
<p>在GO1.14之前golang的协程还是<code>非抢占式调度</code>.而在1.14之后，协程添加了一个重要的特性便是<code>抢占式调度</code>。</p>
<ul>
<li>非抢占式调度</li>
</ul>
<p>非抢占式的含义就是其他任务不会抢我的cpu，而是等待我主动让出去。别的goroutine才可以执行。而io等操作会主动让出去goroutine的执行权。如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">20</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i&lt; <span class="number">20</span>;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                a[i]++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在1.13 版本下的Go SDK 执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  go version</span><br><span class="line">go version go1.13.14 linux&#x2F;amd64</span><br><span class="line">➜  go run main.go</span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/coroutines/goroutine_NonPreemptive.png"></p>
<p>这个程序会卡住。因为main函数也是一个goroutine。而程序中对一个变量++ 是不会交出控制权的（io操作可以交出控制权，如fmt.println，一次IO系统调用等，或者手动交出控制权<code>runtime.Gosched()</code>），所以main也得不到运行了，可以看到这段程序死机了。可以看到，我是8核CPU，这个程序在执行时发生了死循环，占用CPU 738%(约等于800%)对应8个核。</p>
<ul>
<li>抢占式调度</li>
</ul>
<p><strong>Go1.14 引入了基于系统信号的抢占式调度</strong>, 在抢占式情况下，如果一个goroutine运行时间过长，它就会被剥夺运行权。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ go version</span><br><span class="line">go version go1.14.5 linux/amd64</span><br><span class="line">➜ go run main.go </span><br><span class="line">[223473156 204013472 207617086 235368900 147990153 216776090 245417848 278086836 299956269 268087158]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这次用1.14 的go sdk可以看到程序快速的输出了最终的答案，抢占式下，一个goroutine不能一直占CPU不放。</p>
<blockquote>
<p>垃圾回收器是需要stop the world的。如果垃圾回收器想要运行了，那么它必须先通知其它的goroutine合作停下来，这会造成较长时间的等待时间。考虑一种很极端的情况，所有的goroutine都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。(非抢占式存在这种情况，而抢占式不存在)</p>
</blockquote>
<h2 id="Golang-GMP模型"><a href="#Golang-GMP模型" class="headerlink" title="Golang GMP模型"></a>Golang GMP模型</h2><p>Go 的调度器内部有三个十分重要的结构，M，P，G</p>
<ul>
<li>M 表示真正的内核OS线程，和POSIX里的thread差不多，真正干活的人。</li>
<li>P 局部的调度器，使 go 代码在一个线程上跑，它是实现从N:1 （多个用户线程在一个内核线程上跑）到 N:M 映射的关键。由启动时环境变量 <span style="color:red"><b>$GOMAXPROCS</b></span> 或者是由<span style="color:red"><b>runtime.GOMAXPROCS()</b></span> 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。</li>
<li>G 代表一个 goroutine，它有自己的栈，用于调度。理论上没有数量上限限制的。查看当前G的数量可以使用 <span style="color:red"><b>runtime.NumGoroutine()</b></span></li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/coroutines/MPG.wepb"></p>
<p>上图表示有两个物理线程M，每个M都拥有一个context（P），每一个P上又拥有一个正在运行的G和很多等待运行的G。<br>P 的总数量可以通过 GOMAXPROCS() 设置。它表示真正的并发量，即有多少个goroutine可以同时运行。<br>上面等待的（灰色）goroutine处于ready的就绪态。而每个P都维护着一个队列（runqueue）</p>
<p><img src="https://img1.kiosk007.top/static/images/coroutines/MPG_block.webp"></p>
<p>当一个OS线程M0陷入阻塞时（如上图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。</p>
<p>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，<br>如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。</p>
<p><img src="https://img1.kiosk007.top/static/images/coroutines/MPG_banlance.webp"></p>
<p>某一个P所分配的任务G很快被执行完了（分配不均），这就导致一个context P 闲着，如果 global runqueue 上没有 G 了，那么它会偷其他P 的G。一般偷的话会偷一半。确保每个OS线程都能得到充分的使用。</p>
<blockquote>
<p>这段参考知乎 <a href="https://www.zhihu.com/question/20862617">Golang 的 goroutine 是如何实现的？</a> Yi Wang 的回答</p>
</blockquote>
<h2 id="GOMAXPROCS—性能调优"><a href="#GOMAXPROCS—性能调优" class="headerlink" title="GOMAXPROCS—性能调优"></a>GOMAXPROCS—性能调优</h2><p><strong>GOMAXPROCS</strong> 就是 go 中 runtime 包的一个函数。它设置了 P 的最多的个数。这也就直接导致了 M 最多的个数是多少，而 M 的个数就决定了各个 G 队列能同时被多少个 M 线程来进行调取执行！<br>故，我们一般将 GOMAXPROCS 的个数设置为 CPU 的核数，且需要注意的是：</p>
<p>go 1.5 版本之前的 GOMAXPROCS 默认是 1<br>go 1.5 版本之后的 GOMAXPROCS 默认是 Num of cpu</p>
<p>以刚才上面的代码为例。我是8核CPU，这里的线程却创建了10个线程，TID 为74261和74262 是空闲的。而实际跑的是8个线程，这对应了 20 个 G （goroutine）、10个M、8个P。<br>（如下图）<br><img src="https://img1.kiosk007.top/static/images/coroutines/goroutine_dispatch.png"></p>
<p>还有其他语言的异步协程库，比如python通过 syncio 包实现协程，而c++也有阿里大神多隆写的 libeasy 。但是都不如 go 的原生支持来的方便。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 容器技术基础</title>
    <url>/2020/07/11/docker-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://hijiangtao.github.io/2018/04/17/Docker-in-Action/">docker</a> 容器是随着PaaS技术的普及随之诞生的，Docker公司推出了docker并通过“容器镜像”解决了容器打包的根本性难题。而容器本身没有价值，有价值的是“容器编排技术”。Docker项目则通过容器技术解决了应用打包的根本性难题。</p>
<a id="more"></a>
<hr>
<p>为什么在开头就放出了 “容器本身没有价值” 的大话呢？</p>
<p>因为容器本身只是一个沙盒技术，其使用<strong>Cgroups</strong>和<strong>Namespace</strong>技术创建出来一个隔离环境，而docker项目之所以能得到如此之高的关注也是因为他解决了应用打包和发布这个困扰运维人员的多年的技术难题。能够把应用装到集装箱内方便搬来搬去才是PaaS的最理想状态。</p>
<p>Docker本身所用到的隔离技术也并不是什么黑科技，都是把已有的功能翻出来拼装了一下而已。<strong>容器的本质是一个“单进程”模型，本质是一个特殊的进程而已</strong></p>
<blockquote>
<p>Docker 容器技术由 Namespace、Cgroups、rootfs 三种技术构建出,其中Namespace、Cgroups 构建了容器的动态视图（称为 运行时），rootfs构建了容器的静态视图。</p>
</blockquote>
<h1 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h1><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p><strong>Namespace</strong>是Linux很早版本就实现的一个系统调用，他可以实现新创建一个进程的时候，为这个进程创建一个沙盒，比如让新的进程以为自己是1号PID进程，或者是让自己以为自己有一个新的网卡等等。</p>
<p>Linux创建新进程的时候有一个可选参数，加上 <strong>CLONE_NEWPID</strong> 就可以让创建的进程拥有一个全新的进程空间，在宿主机的真实进程空间，其PID还是那个PID，但是新进程自己认为自己是当前空间里的1号进程。他们无法看到真实的进程空间。也无法看到其他Namespace里的进程空间。</p>
<p><code>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</code></p>
<p>类似的参数还有</p>
<ul>
<li><code>CLONE_NEWNS</code>: 用于指定Mount Namespace (挂载点)</li>
<li><code>CLONE_NEWUTS</code>: 用于指定UTS Namespace (HOSTNAME和DOMAIN)</li>
<li><code>CLONE_NEWIPC</code>: 用于指定IPC Namespace (共享内存、信号量和消息队列)</li>
<li><code>CLONE_NEWPID</code>: 用于指定PID Namespace (进程号)</li>
<li><code>CLONE_NEWNET</code>: 用于指定Network Namespace （网络）</li>
<li><code>CLONE_NEWUSER</code>: 用于指定User Namespace  （用户）</li>
</ul>
<p>用户可以在<strong>/proc/$pid/ns</strong>文件下看到本进程所属的Namespace的文件信息。</p>
<p>比如使用 <code>docker run -it busybox /bin/sh</code> 启动一个容器，然后在另外一个终端看到</p>
<p><img src="https://img1.kiosk007.top/static/images/docker/docker_namespace.png"></p>
<p>同样，Linux也提供了其他系统调用，可以让其他进程加入到一个Namespace中，<code>int setns(int fd, int nstype);</code>，这也为之后的联盟式容器创造了可能。即多个进程使用相同的Namespace。系统调用<code>int unshare(int flags);</code>也为相同Namespace分家提供了技术支持。</p>
<p>所以，Docker容器这个听起来高端大气的概念，只不过是在创建容器进程时，指定了这个进程一组Namespace参数而已。</p>
<p>比如我们启动了一个容器。可以使用 <code>docker exec -it xxxxx /bin/bash</code> 进入到这个容器中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 25 </span><br><span class="line">83488</span><br><span class="line"></span><br><span class="line">➜  sudo ls -l /proc/`docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 25`/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 ipc -&gt; <span class="string">&#x27;ipc:[4026532521]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 mnt -&gt; <span class="string">&#x27;mnt:[4026532519]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:14 net -&gt; <span class="string">&#x27;net:[4026532586]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 pid -&gt; <span class="string">&#x27;pid:[4026532522]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 pid_for_children -&gt; <span class="string">&#x27;pid:[4026532522]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 uts -&gt; <span class="string">&#x27;uts:[4026532520]&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每一个进程的所有Linux Namespace，都在/proc/[pid 进程号]/ns 下有一个虚拟文件，并且链接到真实的Namespace上。这样其他进程就可以加入一个已经存在的Namespace中。这也为了之后的pod（联盟式容器）打下基础。如 <code>docker run -it  -net container:25836f0da751  busybox ifconfig</code>。这就是起一个容器，但是network namespace 用和 258xx 这个容器用一个。</p>
<p><strong>Namespace的问题</strong></p>
<p>既然容器技术只是一个特殊的进程被隔离而已，那么其缺点就很明显了，那就是容器的<strong>“隔离不彻底”</strong>。</p>
<font color="red">第一，容器既然是运行在宿主机上的一种特殊进程，那么多个进程还是共享同一个操作系统的内核（注意这里是Linux 内核 ，Mac和Windows上的容器首先是运行在Docker Machine上的，说白了运行在Linux虚拟机上）</font>

<font color="red">第二，容器并不是所有资源都可以Namespace化的，典型的不能被Namespace的例子就是：时间</font>

<font color="red">第三，由于避免不了多个容器共享宿主机内核的事实，那么就意味着容器的越狱比虚拟机简单的多了，一些危险的系统调用需要被监管加固</font>

<p>正是上述的问题，Docker的安全性会很差，一般不会直接把Docker暴露在公网上。</p>
<p>Refer:</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/73248894">浅谈Linux Namesapce机制 (知乎)</a></p>
</blockquote>
<h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>上面提到容器只是一个特殊的进程而已，那么这个容器进程和宿主机上其他的普通进程是平等的。如果容器进程可以占用宿主机全部资源的话，这显然不符合沙盒技术的特征。<strong>而Cgroups则正是 Linux 内核中用来限制资源的功能。</strong> </p>
<p>Cgroups 的本质是给进程挂上钩子 (hooks) ,当Task的运行涉及到某个资源的时就触发钩子上所携带的subsystem检测。最终进行资源限制和优先级分配。</p>
<p><img src="https://img1.kiosk007.top/static/images/docker/docker-cgroups.jpg"></p>
<p><strong>Cgroups全称是 Linux Control Group, 他最主要的作用就是限制一个进程组能够使用的资源上限，包括CPU，内存，磁盘，网络带宽等</strong></p>
<p>Cgroups 给用户直接暴露出来的操作接口是文件系统，即以文件和目录的方式组织在操作系统的 <code>/sys/fs/cgroups</code> 路径下，在这个路径下有很多诸如 <code>cpuset</code>、<code>cpu</code>、<code>memory</code> 这样的子目录。这些就是当前操作系统下可以被限制的资源类型。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>怎么样去限制一个进程的资源呢？需要在这些目录之下再创建一个目录，如进入 <code>/sys/fs/cgroup/cpu</code> 目录下。创建目录 container 。这样一个目录，操作系统会自动在这个目录下生成子系统对应的资源限制文件。<br><img src="https://img1.kiosk007.top/static/images/docker/cgroups.png"></p>
<p>这下，我们创建一个死循环，将CPU吃满，记录该进程的PID。向 container 组里的 cfs_quota 文件写入 2ms，这意味着每 100ms 内的单位时间内，被该控制组限制的进程只能使用2ms的CPU时间，即只能用到2%的计算力。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># echo 2000 &gt; cpu.cfs_quota_us </span></span><br><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># echo 4918 &gt; tasks </span></span><br><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>打开htop指令可以看到刚才的死循环只有2%的CPU占用。</p>
<blockquote>
<p>实验完成后可以使用  <code>cgdelete -r cpu:container</code> 删除</p>
</blockquote>
<p>这样就可以理解 Linux Cgroups 的设计，其限制进程的方式也是简单粗暴，为一个子目录系统上添加一组资源限制文件的组合即可。在docker容器中，也可以直接通过命令来查看。</p>
<p><code>docker run -it --cpu-period=100000 --cpu-quota=20000 busybox /bin/sh</code></p>
<p><img src="https://img1.kiosk007.top/static/images/docker/cgroups_docker.png"></p>
<p><strong>Cgroups 的问题</strong><br>容器的Cgroups只是限制了某个进程的使用资源而已，而进程本身看到的资源还是宿主机的资源。</p>
<font color="red"> /proc 文件系统并不知道 Cgroups 给某个进程做了什么限制。这就会造成在容器中使用 top,free,df 等命令看到的全部是宿主机上的资源。这会给应用的运行带来非常大的困惑。
</font>


<p>不过在生产环境，已经有 <strong><code>lxcfs</code></strong> 这样的技术可以修正这种偏差。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install -y lxcfs</span><br><span class="line">$ systemctl start lxcfs</span><br><span class="line">$ docker run -it -m 500m  \</span><br><span class="line">      -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/<span class="built_in">stat</span>:/proc/<span class="built_in">stat</span>:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/swaps:/proc/swaps:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw \</span><br><span class="line">      ubuntu:19.04 /bin/bash</span><br></pre></td></tr></table></figure><br>其原理是把宿主机上的 <code>/var/lib/lxcfs/proc/meminfo</code> 文件挂载到容器的 <code>/proc/meminfo</code> 位置。</p>
<p>refer:<br><a href="https://cuisongliu.github.io/2019/03/docker/lxcfs/">https://cuisongliu.github.io/2019/03/docker/lxcfs/</a></p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Namespace 和 Cgroups 使这个特殊的进程看到的是隔离环境，而且使用的资源也被限制。那么这样还有一个点，就是进程看到的文件系统是什么呢？这里没有新的技术，还是最开始提到的Mount Namespace技术，拥有这项技术，可以给容器挂载一个全新、独立的文件系统。</p>
<p>挂载完成之后使用 <code>chroot</code> 指令, 使得新的挂载点成为进程的 <code>/</code> 路径。一般为了让这个容器的根目录更为真实，一般会给进程容器的根目录下挂载一个完整操作系统的文件系统。比如 Ubuntu19.04 的ISO。<strong>而这个挂载在容器根目录上的、用来给容器进程提供隔离后执行环境的文件系统就是 rootfs（根文件系统）</strong></p>
<font color="red">这里我再来强调一遍，容器是一个特殊的进程而已！！！rootfs只是操作系统所包含的文件、配置和目录，并不包含内核，内核是宿主机的内核。所以说 rootfs只是操作系统的驱壳，并没有操作系统的灵魂 
</font>

<p>不过正是rootfs的存在，才有了容器作为PaaS的基础，一致性！开发的程序连同操作系统的整个目录环境被打包封装在一个集装箱里。真正的依赖库都放在了这个rootfs的<code>/var/lib/xxx</code> 里。</p>
<p>还没完，虽然这个时候已经解决了大部分问题，但是每个容器创建的时候都需要一个rootfs未免也太浪费空间了，Docker的解决方法是提出 <code>layer</code> 的概念。用户每制造出来一个镜像就生成一个层。</p>
<p>Linux操作系统又提供了一种联合文件系统（Union File System）的能力。<br>UFS 提供的能力是将多个目录挂载到同一个目录下，使得多个目录合并。</p>
<p>假设有两个目录<code>A</code>和<code>B</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│   ├── a</span><br><span class="line">│   └── x</span><br><span class="line">└── B</span><br><span class="line">    ├── b</span><br><span class="line">    └── x</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建目录<code>C</code>,并且将两个目录挂载到一个公共的目录<code>C</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir C</span><br><span class="line">$ mount -t aufs -o dirs&#x3D;.&#x2F;A:.&#x2F;B none .&#x2F;C</span><br><span class="line">$ tree C</span><br><span class="line">C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>以Docker容器为例,这个挂载点就是在 <code>/var/lib/docker/overlay2</code> 下。不出意外，这个下面拥有一个完整的ubuntu操作系统<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2# ll 6f56172222645f34f4454ecdbfd592785245dc7b68511dc49723e0591aba54a8&#x2F;diff&#x2F;</span><br><span class="line">总用量 48</span><br><span class="line">drwxr-xr-x 10 root   root     4096 7月  11 01:04 .&#x2F;</span><br><span class="line">drwx------  3 root   root     4096 7月  11 01:04 ..&#x2F;</span><br><span class="line">drwxr-xr-x  2 root   root    12288 6月  27 08:21 bin&#x2F;</span><br><span class="line">drwxr-xr-x  2 root   root     4096 6月  27 08:21 dev&#x2F;</span><br><span class="line">drwxr-xr-x  3 root   root     4096 6月  27 08:21 etc&#x2F;</span><br><span class="line">drwxr-xr-x  2 nobody nogroup  4096 6月  27 08:21 home&#x2F;</span><br><span class="line">drwx------  2 root   root     4096 6月  27 08:21 root&#x2F;</span><br><span class="line">drwxrwxrwt  2 root   root     4096 6月  27 08:21 tmp&#x2F;</span><br><span class="line">drwxr-xr-x  3 root   root     4096 6月  27 08:21 usr&#x2F;</span><br><span class="line">drwxr-xr-x  4 root   root     4096 6月  27 08:21 var&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>同时也可以看到，对应的操作系统挂载信息里面的overlay信息。可以看到最终多个目录被联合挂载到<code>/var/lib/docker/overlay2/3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1/merged</code> 上，而这个merged会最终呈现一个文件系统。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;mounts |grep overlay2</span><br><span class="line">overlay &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;merged overlay rw,relatime,lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;N2BLQFHN3PRM3P4BR6LYEALQN5:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FYVKPJJ3TF7THIM4Z4J2OAQTZN:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;GPBK6EICFMAEBZR5IBE6XTWPSO:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FLBZS3ORDOYOD2ECQTRUMHAUBV:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;JAFCRW5O4V3HB7PWVABFY3SLRK,upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;diff,workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;work,xino&#x3D;off 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/docker/aufs_image.png"></p>
<p>最下面的几层只读。上层的可写。而最上层是可读写。</p>
<blockquote>
<p>所以在运行容器的时候，只需要拉取不存在的 image layer。镜像一般完全拉下来的化需要3，4百M，一般的大厂都是采用 p2p 下载镜像，如 <a href="https://developer.aliyun.com/article/244897">阿里的蜻蜓 p2p 下载</a>。</p>
</blockquote>
<h1 id="制作Docker镜像"><a href="#制作Docker镜像" class="headerlink" title="制作Docker镜像"></a>制作Docker镜像</h1><p>使用 golang 编写一个web应用。准备一个main.go<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">        log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q \n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>制作Dockerfile 文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM golang:1.12-alpine</span><br><span class="line"></span><br><span class="line"># Set ENV</span><br><span class="line">ENV GO111MODULE&#x3D;on \</span><br><span class="line">    CGO_ENABLED&#x3D;0 \</span><br><span class="line">    GOOS&#x3D;linux \</span><br><span class="line">    GOARCH&#x3D;amd64</span><br><span class="line"></span><br><span class="line"># Set the Current Working Directory inside the container</span><br><span class="line">WORKDIR $GOPATH&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Copy all file to &#x2F;app</span><br><span class="line">ADD . $GOPATH&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Build the Go app</span><br><span class="line">RUN go build main.go</span><br><span class="line"></span><br><span class="line"># This container exposes port 8000 to the outside world</span><br><span class="line">EXPOSE 8000</span><br><span class="line"></span><br><span class="line"># Run the binary program produced by &#96;.&#x2F;main&#96;</span><br><span class="line">ENTRYPOINT [&quot;.&#x2F;main&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>制作镜像在当前目录执行<code>docker build -t hello .</code><br>run 起来该容器<code>docker run -p 8000:8000 hello</code></p>
<h2 id="上传到-docker-hub"><a href="#上传到-docker-hub" class="headerlink" title="上传到 docker hub"></a>上传到 docker hub</h2><p>在docker hub 上创建一个 docker 账号&lt;/br&gt;<br>使用 <code>docker login</code> 登录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为容器起一个完整的名字。</span></span><br><span class="line">docker tag helloworld your-docker-id/helloworld:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传到docker hub 上</span></span><br><span class="line">docker push your-docker-id/helloworld:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器中新建文件</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 29038er849jsa /bin/sh</span><br><span class="line">touch tmp.file</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新建的内容提交</span></span><br><span class="line">docker commit 29038er849jsa your-docker-id/helloworld:v2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 搜索</title>
    <url>/2020/06/13/Git-%E6%90%9C%E7%B4%A2%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本着绝不重复造论子的理念（其实就是想抄袭），需要在github上这个平台搜索自己感兴趣的项目。但是在平常使用中，其实经常没有搜索到自己真正想要的git项目。<br><a id="more"></a></p>
<hr>
<h1 id="github的核心功能"><a href="#github的核心功能" class="headerlink" title="github的核心功能"></a>github的核心功能</h1><ul>
<li><strong>features</strong><br><img src="https://img1.kiosk007.top/static/images/git/github_feature.png"></li>
</ul>
<p>github 的核心功能可以查看 <a href="https://github.com/features">features
</a> ，github的核心功能主要分为7大类 <code>持续继承/持续交付(CI/CD)</code>、<code>安全部署（Secure development）</code>、<code>代码检查（Code review）</code>、<code>Git应用（Apps）</code>、<code>代码托管 (Hosting)</code>、<code>项目管理 （Project managment）</code>、<code>团队管理（Team managment）</code></p>
<ul>
<li><strong>developer</strong><br><img src="https://img1.kiosk007.top/static/images/git/github_develop.png"></li>
</ul>
<p>github 的API可以查看 <a href="https://developer.github.com/">api</a> , 比如可以获取github上的自己的repo列表、OAuth2 token 认证、自动推送修改repo中文件等。</p>
<p>refer: <a href="https://segmentfault.com/a/1190000015144126">https://segmentfault.com/a/1190000015144126</a></p>
<h1 id="搜索git项目"><a href="#搜索git项目" class="headerlink" title="搜索git项目"></a>搜索git项目</h1><p>搜索项目可以在 Market Place 中找到一些火热的项目、工具等</p>
<ul>
<li><strong>Market Place</strong></li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/git/github_marketplace.png"></p>
<p>地址：<a href="https://github.com/marketplace/">https://github.com/marketplace/</a></p>
<p>里面有诸如监控、持续继承、devops的项目，大部分是免费的，可以免费安装使用。<br>如：</p>
<ul>
<li><a href="https://github.com/marketplace/sentry">Sentry</a> ：提供客户端APP实时的崩溃报告的平台。</li>
<li><a href="https://github.com/marketplace/jira-software-github">Jira Software + GitHub</a> ：将代码项目和项目管理平台Jira连接起来的平台。</li>
<li><a href="https://github.com/marketplace/gitpod-io">gitpod.io</a> : Github在线IDE gitpod.io</li>
</ul>
<p><strong>搜索技巧</strong></p>
<p>点击github左上角的搜索框，输入<code>Enter键</code>，弹出github搜索页，点击<code>advance search</code> 高级搜索。</p>
<p><img src="https://img1.kiosk007.top/static/images/git/advance_search.png"></p>
<p>高级搜索中可以按编程语言搜索，按repo时间搜索等等。</p>
<p><img src="https://img1.kiosk007.top/static/images/git/search_date.png"></p>
<p>默认直接在左上角的输入，只是搜索整个github所有repo的标题和描述。而我们其实要找的内容一般在readme中。</p>
<ul>
<li>搜索readme</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arp 欺骗 in:readme</span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/git/search_readme.png"></p>
<ul>
<li>搜索star大于100</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arp 欺骗 in:readme stars:&gt;100</span><br></pre></td></tr></table></figure>
<ul>
<li>搜索go语言</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arp 欺骗 in:readme stars:&gt;10 language:Go</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>性能大杀器epoll</title>
    <url>/2020/06/01/%E6%80%A7%E8%83%BD%E5%A4%A7%E6%9D%80%E5%99%A8epoll/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.kegel.com/c10k.html">C10K</a> 单机同时处理 1万个请求（并发连接 1 万）的问题，最早由 Dan Kegel 在 1999 年提出。那时的服务器还只是 32 位系统，运行着 Linux 2.2 版本（后来又升级到了 2.4 和 2.6，而 2.6 才支持 x86_64），只配置了很少的内存（2GB）和千兆网卡。在这样的系统能实现C10K问题吗？</p>
<p>这在当年看似十分难以实现的问题，在当下epoll这个性能大杀器实现了我们单机并发10K的梦想。</p>
<a id="more"></a>
<hr>
<p><img src="https://img1.kiosk007.top/static/images/network/epoll/c10k.jpg" style="height:300px;border-radius: 20px;"></p>
<h1 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h1><p>怎么实现单机并发 1W 条连接呢？我们先来算一笔账，对于一台 <code>通用型g6</code> (2核 8G 25 Gbit/s) 的 <a href="https://www.aliyun.com/product/ecs/">ECS</a> 来说。假设每条连接分配100KB内存，100Kbit带宽。1w 条连接也完全满足需求 1G内存，1000Mbit。硬件满足需求，那么看软件。</p>
<ul>
<li>每一条连接创建一个线程吗？</li>
</ul>
<p>64 位的 Linux 为每个线程的栈分配了 8MB 的内存，还预分配了 64MB 的内存作为堆内存池。单个线程的创建消耗过高，所以我们没有足够的内存创建上万级别的线程。</p>
<p>其次请求的切换，是Linux在内核中切换线程实现的。时间片用尽、调用阻塞方法都会导致线程切换，一次上下文的耗时在几十纳秒，但是短时间上万次的切换，会导致CPU大量的时间都浪费在切换线程上。</p>
<p>总上所述，每条连接创建一个线程是不合理的。（同理创建进程就更不合理了）</p>
<h1 id="I-O-模型优化"><a href="#I-O-模型优化" class="headerlink" title="I/O 模型优化"></a>I/O 模型优化</h1><p>这里就需要用到 多路复用/非阻塞 的IO框架模型了，那么什么是多路/非阻塞。<br>通俗来讲就是就是将很多的IO事件都收集起来统一管理，这样一个线程就可以做到分别运行不同的IO事件，哪个准备好了运行哪个。没有准备好的就先放在一边。</p>
<blockquote>
<p>IO 事件的类型非常多，比如：<br>1、标准输入文件描述符可读。2、标准输出文件描述符可写。3、新的连接建立成功。4、一个IO事件等待超过了10秒</p>
</blockquote>
<h2 id="IO-事件是如何产生的"><a href="#IO-事件是如何产生的" class="headerlink" title="IO 事件是如何产生的"></a>IO 事件是如何产生的</h2><p>简单的说，事件只有两种即读事件和写事件。<code>读事件</code>表示IO有消息到达需要处理，<code>写事件</code> 表示IO可以发送数据了（TCP的写缓冲区可写数据）。</p>
<p>在网络的视角，从三次握手开始。客户端发出SYN，服务端回复SYN+ACK。完成握手后，客户端即产生了<strong>写事件</strong>。如果缓冲区太小假设只有1M，而我们要发送的数据时2M，那么会先写入1M后，等待缓冲区空闲后，再次产生写事件。</p>
<p>同样四次挥手，当主动关闭方发送一个FIN，被动关闭方就会产生一个读事件。</p>
<blockquote>
<p>目前磁盘的异步IO技术还不成熟，它绕过了 PageCache 性能损失很大。所以当下的事件驱动，主要就是指网络事件。</p>
</blockquote>
<h2 id="IO-类型"><a href="#IO-类型" class="headerlink" title="IO 类型"></a>IO 类型</h2><h3 id="事件如何通知"><a href="#事件如何通知" class="headerlink" title="事件如何通知"></a>事件如何通知</h3><p>目前有两种 IO事件的通知方式<strong>水平触发</strong>和<strong>边缘触发</strong></p>
<ul>
<li><code>水平触发</code>：只要文件描述符可以非阻塞的执行IO，就会触发通知，也就是应用程序可以随时随地的检查文件描述符的状态，并根据其状态产生相应的动作。</li>
<li><code>边缘触发</code>：只有文件描述符的状态发生改变时，才发出一个通知，这时候应用程序需要尽可能多的执行IO操作，直到无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了。</li>
</ul>
<h3 id="IO-调用方式分哪几类"><a href="#IO-调用方式分哪几类" class="headerlink" title="IO 调用方式分哪几类"></a>IO 调用方式分哪几类</h3><ul>
<li><p><code>非阻塞</code>: 当应用程序调用阻塞 I/O 完成某个操作时，应用程序会被挂起，等待内核完成操作</p>
</li>
<li><p><code>阻塞</code>: 当应用程序调用非阻塞 I/O 完成某个操作时，内核立即返回，不会把 CPU 时间切换给其他进程，应用程序在返回后，可以得到足够的 CPU 时间继续完成其他事情。</p>
</li>
</ul>
<hr>
<h2 id="非阻塞IO-水平触发"><a href="#非阻塞IO-水平触发" class="headerlink" title="非阻塞IO+水平触发"></a>非阻塞IO+水平触发</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="select-用法"><a href="#select-用法" class="headerlink" title="select 用法"></a>select 用法</h4><ul>
<li>声明select函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">返回：若有就绪描述符则为其数目，若超时则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>maxfd 表示的是待测试的描述符基数，它的值是待测试的最大描述符加 1。</p>
<ul>
<li>设置描述字符集合</li>
</ul>
<p>分别是<code>读描述符集合</code> readset、<code>写描述符集合</code>writeset 和 <code>异常描述符集合</code>exceptset，这三个分别通知内核，在哪些描述符上检测数据可以读，可以写和有异常发生。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;　　#FD_ZERO 用来将这个向量的所有元素都设置成 <span class="number">0</span>；　　　　</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;　#FD_SET 用来把对应套接字 fd 的元素，a[fd]设置成 <span class="number">1</span>；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;　#FD_CLR 用来把对应套接字 fd 的元素，a[fd]设置成 <span class="number">0</span>；　　</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; #FD_ISSET 对这个向量进行检测，判断出对应套接字的元素 a[fd]是 <span class="number">0</span> 还是 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 0 代表不需要处理，1 代表需要处理。</p>
</blockquote>
<p>最后一个参数是 timeval 结构体时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span>   tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">long</span>   tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超时事件，如果全是0，则立马返回不等待（基本没有这么用的）、非0值等待一段时间后返回，可以用作超时、NULL一直监听等待有返回。</p>
<ul>
<li>select 程序例子</li>
</ul>
<p>refer：<a href="https://github.com/froghui/yolanda/blob/master/chap-22/nonblockingserver.c">https://github.com/froghui/yolanda/blob/master/chap-22/nonblockingserver.c</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (select(maxfd + <span class="number">1</span>, &amp;readset, &amp;writeset, &amp;exset, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">&quot;select error&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 处理监听套接字事件</span></span><br><span class="line">   <span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;readset)) &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 处理已建立好连接上的套接字事件</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxfd + <span class="number">1</span>; ++i) &#123;      </span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">0</span>;            </span><br><span class="line">       <span class="keyword">if</span> (i == listen_fd)                </span><br><span class="line">           <span class="keyword">continue</span>;            </span><br><span class="line">       <span class="keyword">if</span> (FD_ISSET(i, &amp;readset)) &#123;</span><br><span class="line">           r = onSocketRead(i, buffer[i]);</span><br><span class="line">       &#125;       </span><br><span class="line">       <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; FD_ISSET(i, &amp;writeset)) &#123;                </span><br><span class="line">           r = onSocketWrite(i, buffer[i]);</span><br><span class="line">       &#125;            </span><br><span class="line">       <span class="keyword">if</span> (r) &#123;                </span><br><span class="line">           buffer[i]-&gt;connect_fd = <span class="number">0</span>; </span><br><span class="line">           close(i);            </span><br><span class="line">           &#125;        </span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select-缺点"><a href="#select-缺点" class="headerlink" title="select 缺点"></a>select 缺点</h4><p>1、在 Linux 系统中，select 所支持的文件描述符的个数是有限的，默认最大值为 1024。（当然就不能做到 c10K 了）<br>2、应用程序每次调用 select 时，还需要把文件描述符的集合，从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<font color="#A52A2A"> c10K 还好一点，当c10M时，并发1 千万连接。若每个 socket 是 4 字节，那么 1 千万连接就是 40M 字节。这样，每收集一次事件，就需要从用户态复制 40M 字节到内核态。而且，高性能 Server 必须及时地处理网络事件，所以每隔几十毫秒就要收集一次事件，性能消耗巨大。</font>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><h4 id="poll用法"><a href="#poll用法" class="headerlink" title="poll用法"></a>poll用法</h4><ul>
<li>声明poll函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>; </span><br><span class="line">　　　</span><br><span class="line">返回值：若有就绪描述符则为其数目，若超时则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>和select不同，poll每次检查完，不会修改之前的传入值，这样就不需要每次检查完毕还需要重置带检测的套结字。poll 还有一个相比select的好处，对请求出错有更友好的检测。</p>
<ul>
<li>poll 服务端程序例子</li>
</ul>
<p>refer： <a href="https://github.com/froghui/yolanda/blob/master/chap-21/pollserver.c">https://github.com/froghui/yolanda/blob/master/chap-21/pollserver.c</a></p>
<h4 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h4><p>还是同select一样，需要将用户空间的套结字复制到内核态。消耗内存资源。</p>
<hr>
<h2 id="非阻塞IO-边缘触发"><a href="#非阻塞IO-边缘触发" class="headerlink" title="非阻塞IO + 边缘触发"></a>非阻塞IO + 边缘触发</h2><p><img src="https://img1.kiosk007.top/static/images/network/epoll/libevent-benchmark2.jpg" style="height:600px;"></p>
<p>首先看看上面的图，随着文件描述符的增多，poll和select的性能越来越差，而epoll和kqueue却几乎没有什么变化。为什么呢？</p>
<p>解答上面的疑问之前需要知道 五中最常见的 IO 模型。<code>阻塞IO （blocking I/O）</code>、<code>非阻塞IO （nonblocking I/O）</code>、<code>IO多路复用 （I/O multiplexing ）</code>、<code>事件驱动IO （signal driven I/O (SIGIO)）</code> 、<code>异步IO (asynchronous I/O (the POSIX aio_functions))</code> 。具体的网上的例子太多了，图也太多了，这里就不再赘述了。可以参考下这篇文章。<a href="https://cloud.tencent.com/developer/article/1373483">各种IO复用模式之select，poll，epoll，kqueue，iocp分析</a></p>
<p>这5种IO模型如下图，越靠右，性能越强。当然还有更厉害的性能大杀器 AIO (比epoll 更强)，这个之后再介绍。很可惜，真正强大的AIO 是 windows 的IOCP（windows服务器有人用吗？你懂得）。而Linux aio 系列函数是由 POSIX 定义的异步操作接口，可惜的是，Linux 下的 aio 操作，不是真正的操作系统级别支持的，它只是由 GNU libc 库函数在用户空间借由 pthread 方式实现的，而且仅仅针对磁盘类 I/O，套接字 I/O 不支持。自出现就备受社区诟病。但是Linux作为最常用的应用服务器，epoll也就是Linux下最常见的性能杀器。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/epoll/io.png" style="height:400px;"></p>
<blockquote>
<p><code>noblocking</code> + <code>I/O mutiplexing</code>（IO多路复用+非阻塞IO） 就是kqueue、epoll、select、poll的实现。 不过epoll 和 kqueue 比 select 和poll 强大的多。</p>
</blockquote>
<p><strong>Q：为什么 epoll、kqueue 比 select、poll</strong></p>
<p><strong>A:</strong>  因为epoll他们无轮询。他们用callback取代了。想想看，当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数或者直接告诉应用层具体哪些套接字处于活跃状态了，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>使用 epoll 进行网络程序的编写，需要三个步骤，分别是 epoll_create，epoll_ctl 和 epoll_wait。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/epoll/epoll_API.png" style="height:400px;"></p>
<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">        返回值: 若成功返回一个大于<span class="number">0</span>的值，表示epoll实例；若返回<span class="number">-1</span>表示出错</span><br></pre></td></tr></table></figure>
<p>关于这个参数 size，在一开始的 epoll_create 实现中，是用来告知内核期望监控的文件描述字大小，然后内核使用这部分的信息来初始化内核数据结构，在新的实现中，这个参数不再被需要，因为内核可以动态分配需要的内核数据结构。每次将 size 设置成一个大于 0 的整数就可以了。</p>
<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">       返回值: 若成功返回<span class="number">0</span>；若返回<span class="number">-1</span>表示出错</span><br></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>epfd：epoll_create 返回的句柄</li>
<li>op: 添加、删除、修改文件描述符。</li>
<li>fd: 注册事件的文件描述符</li>
<li>epoll_event: 注册的事件类型</li>
</ul>
<p>epoll_event:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">     <span class="keyword">void</span>        *ptr;</span><br><span class="line">     <span class="keyword">int</span>          fd;</span><br><span class="line">     <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">     <span class="keyword">uint64_t</span>     u64;</span><br><span class="line"> &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>EPOLLIN：表示对应的文件描述字可以读；</li>
<li>EPOLLOUT：表示对应的文件描述字可以写；</li>
<li>EPOLLRDHUP：表示套接字的一端已经关闭，或者半关闭；</li>
<li>EPOLLHUP：表示对应的文件描述字被挂起；</li>
<li>EPOLLET：设置为 edge-triggered，默认为 level-triggered。</li>
</ul>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">  返回值: 成功返回的是一个大于<span class="number">0</span>的数，表示事件的个数；返回<span class="number">0</span>表示的是超时时间到；若出错返回<span class="number">-1.</span></span><br></pre></td></tr></table></figure>
<p>调用者进程被挂起，等待内核的IO事件分发</p>
<p>参数：</p>
<ul>
<li>epfd：epoll句柄</li>
<li>epoll_event: 返回用户空间需要处理的epoll事件列表，是个数组。</li>
<li>maxevents: 返回的最大事件值</li>
<li>timeout：超时时间</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listen_fd, socket_fd;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> efd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line"></span><br><span class="line">    listen_fd = tcp_nonblocking_server_listen(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll create failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 注册event事件，事件可读，边缘触发 */</span></span><br><span class="line">    event.data.fd = listen_fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="comment">/* 添加事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(efd, EPOLL_CTL_ADD, listen_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll_ctl add listen fd failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer where events are returned */</span></span><br><span class="line">    events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait wakeup\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) ||</span><br><span class="line">                (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">                (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                close(events[i].data.fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理监听套接字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (listen_fd == events[i].data.fd) &#123;</span><br><span class="line">                struct sockaddr_storage ss;</span><br><span class="line">                <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">                <span class="keyword">int</span> fd = accept(listen_fd, (struct sockaddr *) &amp;ss, &amp;slen);</span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    make_nonblocking(fd);</span><br><span class="line">                    event.data.fd = fd;</span><br><span class="line">                    event.events = EPOLLIN | EPOLLET; <span class="comment">//edge-triggered</span></span><br><span class="line">                    <span class="keyword">if</span> (epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll_ctl add connection fd failed&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                socket_fd = events[i].data.fd;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get event on socket fd == %d \n&quot;</span>, socket_fd);</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">                    <span class="comment">// 处理读事件</span></span><br><span class="line">                    <span class="keyword">if</span> ((n = read(socket_fd, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>) &#123;                      </span><br><span class="line">                        <span class="comment">// 读出错，关闭套接字</span></span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                            error(<span class="number">1</span>, errno, <span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                            close(socket_fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                        close(socket_fd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                            buf[i] = rot13_char(buf[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                     </span><br><span class="line">                        <span class="keyword">if</span> (write(socket_fd, buf, n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            error(<span class="number">1</span>, errno, <span class="string">&quot;write error&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    close(listen_fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里会把每个套结字处理为非阻塞模式。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>epoll ，非阻塞IO + IO多路复用 + 边缘触发，造就了C10K，C100K 的问题解决。</p>
<h1 id="工作模型调整"><a href="#工作模型调整" class="headerlink" title="工作模型调整"></a>工作模型调整</h1><p>以Nginx为例，Nginx是典型的1个主Master进程 + 多个Worker进程。</p>
<ul>
<li>主进程执行 bind() 和 listen() 后，创建多个子进程。</li>
<li>每个子进程中通过都通过 accept() 或 epoll_wait() ，来处理相同的套接字。</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/epoll/Nginx.png" style="height:600px;"></p>
<p>而这里面就需要用到epoll来作 IO 分法器。从而设计出基于套接字的事件驱动程序。</p>
<p>这样的模型被称为主从模型（master-worker） 或 反应堆模型（reactor），这样的技术核心思想有2点。<br>1、存在一个无限循环的事件分发线程或进程（Nginx是进程）。而事件分发的背后正是epoll这样的IO分发技术。</p>
<p>2、所有的IO操作可以抽象为事件，每个事件都有一个回调函数来处理。worker 进程上有已建立好的套接字、可读、可写的套接字。这一个个都是事件，通过事件分发并调用相应的回调函数被触发。</p>
<p>代码参考：<a href="https://github.com/froghui/yolanda/blob/master/chap-29/epoll-server-multithreads.c">https://github.com/froghui/yolanda/blob/master/chap-29/epoll-server-multithreads.c</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接建立之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onConnectionCompleted</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection completed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据读到buffer之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onMessage</span><span class="params">(struct buffer *input, struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get message from tcp connection %s\n&quot;</span>, tcpConnection-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, input-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">output</span> =</span> buffer_new();</span><br><span class="line">    <span class="keyword">int</span> size = buffer_readable_size(input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        buffer_append_char(output, rot13_char(buffer_read_char(input)));</span><br><span class="line">    &#125;</span><br><span class="line">    tcp_connection_send_buffer(tcpConnection, output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据通过buffer写完之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onWriteCompleted</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write completed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接关闭之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onConnectionClosed</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection closed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">char</span> **v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主线程event_loop</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_loop</span> *<span class="title">eventLoop</span> =</span> event_loop_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化acceptor</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acceptor</span> *<span class="title">acceptor</span> =</span> acceptor_init(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始tcp_server，可以指定线程数目，这里线程是4，说明是一个acceptor线程，4个I/O线程，每一个I/O线程</span></span><br><span class="line">    <span class="comment">//tcp_server自己带一个event_loop</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TCPserver</span> *<span class="title">tcpServer</span> =</span> tcp_server_init(eventLoop, acceptor, onConnectionCompleted, onMessage, onWriteCompleted, onConnectionClosed, <span class="number">4</span>);</span><br><span class="line">    tcp_server_start(tcpServer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main thread for acceptor</span></span><br><span class="line">    event_loop_run(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置了很多Callback回调函数，会在客户端建立连接之后依次执行这些回调函数。</p>
<ul>
<li><code>event_loop_init()</code>：创建一个事件循环器</li>
<li><code>acceptor_init(SERV_PORT)</code>: 初始化acceptor线程，bind、listen</li>
<li><code>tcp_server_init()</code>: 创建线程池，传入回调函数，分别对应了连接建立完成、数据读取完成、数据发送完成、连接关闭完成几种操作，通过回调函数，让业务程序可以聚焦在业务层开发</li>
<li><code>tcp_server_start(tcpServer)</code>: 开始监听，acceptor主线程，开启多个线程，同时把tcpServer作为参数传给channel对象</li>
<li><code>event_loop_run(eventLoop)</code>: 调用dispatcher来进行事件分发,分发完回调事件处理函数</li>
</ul>
<h1 id="Linux-内核参数的调优"><a href="#Linux-内核参数的调优" class="headerlink" title="Linux 内核参数的调优"></a>Linux 内核参数的调优</h1><h2 id="打开的最大文件描述符"><a href="#打开的最大文件描述符" class="headerlink" title="打开的最大文件描述符"></a>打开的最大文件描述符</h2><p>Linux 下默认的最大文件描述符是1024个，也就是一个应用程序最多打开1024个文件描述符。如果连接数过多，会导致<code>Socket/File:Can&#39;t open so many files</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  <span class="built_in">ulimit</span> -n</span><br><span class="line">1024</span><br><span class="line">➜  sudo <span class="built_in">echo</span> <span class="string">&quot;fs.file-max = 1000000&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">➜  sudo sysctl -p</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="发送缓冲区的自动调节"><a href="#发送缓冲区的自动调节" class="headerlink" title="发送缓冲区的自动调节"></a>发送缓冲区的自动调节</h2><p>Socket编程时是可以可以在send函数中设置发送缓冲区大小的，而这个应该设为多少才合适呢？答案是不要设置！不要设置！不要设置！</p>
<p>正确的操作是让操作系统自己动态的改变 发送缓冲区大小（默认就是操作系统自己控制的，但是应用程序一旦自己设置了缓冲区大小，自动调节功能就失效了）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  sysctl -a | grep tcp_moderate_rcvbuf</span><br><span class="line">net.ipv4.tcp_moderate_rcvbuf = 1</span><br></pre></td></tr></table></figure><br>refer : <a href="https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/">就是要你懂TCP—性能和发送接收Buffer的关系</a></p>
<h1 id="C10M-的仰望"><a href="#C10M-的仰望" class="headerlink" title="C10M 的仰望"></a>C10M 的仰望</h1><p>C10K、C100K、C1000K 都可以凭借强大的epoll解决问题。但是对性能的追求是永无止境的，同时并发1百万可能操作系统已经达到极限了，前面说到C10K的问题在于IO阻塞、频繁的CPU上下文切换、套接字从应用层到内核的反复拷贝。那 <a href="http://c10m.robertgraham.com/p/blog-page.html">C10M</a> 的瓶颈是什么呢？</p>
<p>究其根本，还是 Linux 内核协议栈做了太多太繁重的工作。从网卡中断带来的硬中断处理程序开始，到软中断中的各层网络协议处理，最后再到应用程序，这个路径实在是太长了，就会导致网络包的处理优化，到了一定程度后，就无法更进一步了。</p>
<p>要解决这个问题，最重要就是跳过内核协议栈的冗长路径，把网络包直接送到要处理的应用程序那里去。这里有两种常见的机制，DPDK 和 XDP。</p>
<ul>
<li><p>DPDK:是用户态网络的标准。它跳过内核协议栈，直接由用户态进程通过轮询的方式，来处理网络接收。</p>
</li>
<li><p>XDP（eXpress Data Path），则是 Linux 内核提供的一种高性能网络数据路径。它允许网络包，在进入内核协议栈之前，就进行处理，也可以带来更高的性能。</p>
</li>
</ul>
<p>比较牛的开源项目就是 iqiyi 的DPVS了，DPVS 是基于 DPDK 的高性能 Layer-4负载均衡器。它源自Linux虚拟服务器 LVS 及其修改阿里巴巴/LVS 。</p>
<p><a href="https://www.worldlink.com.cn/osdir/dpvs.html">DPVS</a></p>
<p><a href="https://github.com/iqiyi/dpvs">https://github.com/iqiyi/dpvs</a></p>
<p>refer:</p>
<ul>
<li>[-]  <a href="https://cloud.tencent.com/developer/article/1373483">https://cloud.tencent.com/developer/article/1373483</a></li>
<li>[-]<a href="https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/">https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/</a></li>
<li>[-]  <a href="https://time.geekbang.org/column/intro/214">https://time.geekbang.org/column/intro/214</a></li>
<li>[-]  <a href="https://time.geekbang.org/column/article/81268">https://time.geekbang.org/column/article/81268</a></li>
<li>[-] <a href="https://zhuanlan.zhihu.com/p/43720867">https://zhuanlan.zhihu.com/p/43720867</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>socket编程</tag>
        <tag>network</tag>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd 的基本入门</title>
    <url>/2020/05/30/go-etcd-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>etcd</strong> 是一个强一致性的分布式键值存储系统，可以提供可靠的分布式集群的数据访问方式。</p>
<p>etcd is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be accessed by a distributed system or cluster of machines.</p>
<p>refer: <a href="https://etcd.io/">https://etcd.io/</a></p>
<a id="more"></a>
<hr>
<p><img src="https://img1.kiosk007.top/static/images/etcd/etcd.png"></p>
<h1 id="etcd简介"><a href="#etcd简介" class="headerlink" title="etcd简介"></a>etcd简介</h1><p>etcd 诞生于 CoreOS 公司，它最初是用于解决集群管理系统中 OS 升级的<strong>分布式并发控制</strong>、<strong>服务发现</strong>、<strong>集群状态存储</strong> 以及 <strong>配置文件的存储与分发</strong>等问题。基于此，etcd 被设计为提供高可用、强一致的小型 keyvalue 数据存储服务。</p>
<p>项目当前隶属于 CNCF 基金会，被 AWS、Google、Microsoft、Alibaba 等大型互联网公司广泛使用。</p>
<h1 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h1><ul>
<li>数据存储在集群中的高可用K-V存储</li>
<li>允许应用实时监听存储中的K-V的变化</li>
<li>能够容忍单点故障，能够应对网络分区</li>
</ul>
<blockquote>
<p>分布式的容灾策略是基于 <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/7215942.html">鸽巢理论</a> ，假设一个班级有60人，我将一个秘密告诉31人，那么随便在这个班级挑出30人来，肯定至少有一个人指导这个秘密。</p>
</blockquote>
<p><strong>etcd与Raft的关系</strong></p>
<p>Raft是强一致性的集群日志同步算法，etcd是一个分布式KV存储，etcd利用raft算法在集群中同步key-value 。etcd集群需要2N+1个节点。</p>
<p><img src="https://img1.kiosk007.top/static/images/etcd/raft_a_consensus_algorithm_for_replicated_logs_1440-21.jpg"><br>日志一旦由 leader节点 复制到了大多数 follower节点 即可完成提交。<br>上图可以看到7个节点的集群，log index 为9 的数据已经同步给 a,c,d 所以index 9 属于整个集群，index为11 的几个数据leader 不认，所以这个数据不属于集群。</p>
<blockquote>
<p><code>Raft 可以保证，给客户端承诺过的请求一定是不会丢失的</code><br><code>各个节点的数据一定是最终一致的</code> </p>
</blockquote>
<p><a href="http://thesecretlivesofdata.com/raft/">raft 算法英文动画演示</a></p>
<h1 id="交互协议"><a href="#交互协议" class="headerlink" title="交互协议"></a>交互协议</h1><ul>
<li>HTTP 基于JSON请求，例如 curl，简单通用。</li>
<li>SDK 内置GRPC协议，性能高效</li>
</ul>
<h1 id="etcd-功能"><a href="#etcd-功能" class="headerlink" title="etcd 功能"></a>etcd 功能</h1><p>refer： <a href="https://etcd.io/docs/v3.4.0/demo/">etcd 文档演示</a></p>
<ul>
<li><p>put、get、del 操作<br>  数据库普通的增加，查找，删除操作，如果想要更新，依旧使用put。</p>
</li>
<li><p>watch 监听</p>
<p> 支持监听某一key的变化，有变化即产生回调，另外还支持查找key 的历史版本。</p>
</li>
<li><p>lease 租约</p>
<p> 申请定时器，举例：申请一个TTL为10s的租约 lease，当 put 一个 key 时，携带该租约，当TTL到期时，key也会被删除，一个 lease id 可以关联多个key，也就是租约到期，多个key 可以被删除，想要防止被删除，可以用keepalive定期续租。</p>
</li>
<li><p>txn 事物、loack 分布式锁<br> etcd 支持将多个请求包装到一个事务中，或者添加一个分布式锁。</p>
</li>
</ul>
<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><ul>
<li>安装etcd</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  wget https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line">➜  tar -xf etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line">➜  <span class="built_in">cd</span> etcd-v3.4.9-linux-amd64/</span><br><span class="line">➜  sudo cp etcd /usr/<span class="built_in">local</span>/sbin/</span><br><span class="line">➜  sudo cp etcdctl /usr/<span class="built_in">local</span>/sbin/</span><br></pre></td></tr></table></figure>
<ul>
<li>设置集群信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TOKEN=token-01</span><br><span class="line">CLUSTER_STATE=new</span><br><span class="line">NAME_1=machine-1</span><br><span class="line">NAME_2=machine-2</span><br><span class="line">NAME_3=machine-3</span><br><span class="line">HOST_1=127.0.0.1</span><br><span class="line">HOST_2=127.0.0.1</span><br><span class="line">HOST_3=127.0.0.1</span><br><span class="line">CLUSTER=<span class="variable">$&#123;NAME_1&#125;</span>=http://<span class="variable">$&#123;HOST_1&#125;</span>:2381,<span class="variable">$&#123;NAME_2&#125;</span>=http://<span class="variable">$&#123;HOST_2&#125;</span>:2382,<span class="variable">$&#123;NAME_3&#125;</span>=http://<span class="variable">$&#123;HOST_3&#125;</span>:2383</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>启动集群</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For machine 1</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_1&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_1&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd1 --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">	--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2381 --listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2381 \</span><br><span class="line">	--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2371 --listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2371 \</span><br><span class="line">	--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">	--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> --initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For machine 2</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_2&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_2&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd2 --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">	--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2382 --listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2382 \</span><br><span class="line">	--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2372 --listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2372 \</span><br><span class="line">	--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">	--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> --initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For machine 3</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_3&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_3&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd3 --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">	--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2383 --listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2383 \</span><br><span class="line">	--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2373 --listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2373 \</span><br><span class="line">	--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">	--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> --initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用etcdctl 连接到etcd</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">HOST_1=127.0.0.1</span><br><span class="line">HOST_2=127.0.0.1</span><br><span class="line">HOST_3=127.0.0.1</span><br><span class="line">ENDPOINTS=<span class="variable">$HOST_1</span>:2371,<span class="variable">$HOST_2</span>:2372,<span class="variable">$HOST_3</span>:2373</span><br><span class="line"></span><br><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> member list</span><br></pre></td></tr></table></figure>
<ul>
<li>尝试添加一个key</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> put <span class="string">&quot;key&quot;</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h1 id="golang-操作-etcd"><a href="#golang-操作-etcd" class="headerlink" title="golang 操作 etcd"></a>golang 操作 etcd</h1><p>github 官方示例代码：<a href="https://github.com/etcd-io/etcd/tree/master/clientv3">https://github.com/etcd-io/etcd/tree/master/clientv3</a></p>
<p>使用前先安装 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get go.etcd.io/etcd/clientv3</span><br></pre></td></tr></table></figure>
<p>解决Golang1.14 etcd/clientv3报错：etcd undefined: resolver.BuildOption</p>
<p>refer: <a href="https://blog.csdn.net/qq_43442524/article/details/104997539">https://blog.csdn.net/qq_43442524/article/details/104997539</a></p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client *clientv3.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Conn</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cli, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">		Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">&quot;localhost:2371&quot;</span>, <span class="string">&quot;localhost:2372&quot;</span>, <span class="string">&quot;localhost:2373&quot;</span>&#125;,</span><br><span class="line">		DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// handle error!</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> cli.Close()</span><br><span class="line">	client = cli</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单操作-GET，PUT，DEL"><a href="#简单操作-GET，PUT，DEL" class="headerlink" title="简单操作 GET，PUT，DEL"></a>简单操作 GET，PUT，DEL</h2><p>refer：<a href="https://godoc.org/go.etcd.io/etcd/clientv3">https://godoc.org/go.etcd.io/etcd/clientv3</a></p>
<p>etcd的操作强大在可以添加 <code>WithOption</code> 比如 <code>WithPrevKV()</code> 获取前一个Key 和 <code>WithPrefix()</code> 遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EtcdApi <span class="keyword">struct</span> &#123;</span><br><span class="line">	KV clientv3.KV</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">PutKey</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(),<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// clientv3.WithPrevKV() 获取到删KV之前的值</span></span><br><span class="line">	<span class="keyword">if</span> putResp, err := e.KV.Put(ctx,key,value,clientv3.WithPrevKV()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> putResp.PrevKv != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;PrevValue: &quot;</span>, <span class="keyword">string</span>(putResp.PrevKv.Value))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">GetKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(),<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以遍历目录</span></span><br><span class="line">	<span class="keyword">if</span> getResp, err := e.KV.Get(ctx,key,clientv3.WithPrefix());err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, getResp.Kvs),err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">DelKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(),<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> delResp, err := e.KV.Delete(ctx,key,clientv3.WithPrevKV());err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value,<span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s&quot;</span>,delResp.PrevKvs),<span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Lease-租期"><a href="#Lease-租期" class="headerlink" title="Lease 租期"></a>Lease 租期</h2><ul>
<li>创建租约</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">GrantLease</span><span class="params">()</span> <span class="params">(lease clientv3.Lease, leaseId clientv3.LeaseID,err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> leaseGrantResp *clientv3.LeaseGrantResponse</span><br><span class="line">	</span><br><span class="line">	lease = clientv3.NewLease(e.Client)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 申请一个10s的租约</span></span><br><span class="line">	<span class="keyword">if</span> leaseGrantResp, err = lease.Grant(e.Ctx,<span class="number">10</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	leaseId = leaseGrantResp.ID</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put 一个KV, 关联租约，从而实现10s自动过期</span></span><br><span class="line">	<span class="keyword">if</span> putResp,err := e.KV.Put(e.Ctx,<span class="string">&quot;/key1/lease&quot;</span>,<span class="string">&quot;v1&quot;</span>,clientv3.WithLease(leaseId)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(putResp.Header.Revision)</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>续租</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EtcdApi)</span> <span class="title">KeepAlive</span><span class="params">(leaseId clientv3.LeaseID)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 自动续期</span></span><br><span class="line">	<span class="keyword">var</span> keepResp *clientv3.LeaseKeepAliveResponse</span><br><span class="line">	keepRespChan,err := e.Lease.KeepAlive(context.TODO(), leaseId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ERROR :&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span>&#123;</span><br><span class="line">			<span class="keyword">case</span> keepResp = &lt;- keepRespChan:</span><br><span class="line">				<span class="keyword">if</span> keepRespChan == <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(<span class="string">&quot;租约实效&quot;</span>)</span><br><span class="line">					<span class="keyword">goto</span> END</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123; <span class="comment">// 每秒续租一次</span></span><br><span class="line">					fmt.Println(<span class="string">&quot;续租&quot;</span>, keepResp.ID)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	END:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Return&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Watch-监听"><a href="#Watch-监听" class="headerlink" title="Watch 监听"></a>Watch 监听</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EtcdApi)</span> <span class="title">Watch</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个watcher</span></span><br><span class="line">	e.Watcher = clientv3.Watcher(e.Client)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 30 s 后取消监听</span></span><br><span class="line">	ctx, cancelFunc := context.WithCancel(context.TODO())</span><br><span class="line">	time.AfterFunc(<span class="number">30</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		cancelFunc()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动监听</span></span><br><span class="line">	watchRespChan := e.Watcher.Watch(ctx,<span class="string">&quot;/key1/watcher&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理kv变化事件</span></span><br><span class="line">	<span class="keyword">for</span> watchResp := <span class="keyword">range</span> watchRespChan &#123;</span><br><span class="line">		<span class="keyword">for</span> _,event := <span class="keyword">range</span> watchResp.Events &#123;</span><br><span class="line">			<span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">			<span class="keyword">case</span> mvccpb.PUT: &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot; 修改为： &quot;</span>, <span class="keyword">string</span>(event.Kv.Value), <span class="string">&quot;Revision: &quot;</span>, event.Kv.CreateRevision , event.Kv.ModRevision)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> mvccpb.DELETE: &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot; 删除： Revision: &quot;</span>, event.Kv.ModRevision)</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h2><p>可以将上面提到的 <code>Get</code>、<code>Put</code>、<code>Delete</code>等操作抽象成一个Operation。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">Op</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个OP：operation</span></span><br><span class="line">	putOp := clientv3.OpPut(<span class="string">&quot;/key1/op&quot;</span>,<span class="string">&quot;value_op&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行OP</span></span><br><span class="line">	opResp, err := e.KV.Do(e.Ctx,putOp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;写入Revision： &quot;</span>, &amp;opResp.Put().Header.Revision)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Txn"><a href="#Txn" class="headerlink" title="Txn"></a>Txn</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EtcdApi)</span> <span class="title">DoTxn</span><span class="params">(leaseId clientv3.LeaseID)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建事物</span></span><br><span class="line">	txn := e.KV.Txn(e.Ctx)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义事物</span></span><br><span class="line">	txn.If(clientv3.Compare(clientv3.CreateRevision(<span class="string">&quot;/key1/lease&quot;</span>),<span class="string">&quot;=&quot;</span>,<span class="string">&quot;0&quot;</span>)).</span><br><span class="line">		Then(clientv3.OpPut(<span class="string">&quot;/key1/lease&quot;</span>,<span class="string">&quot;value1&quot;</span>,clientv3.WithLease(leaseId))).</span><br><span class="line">		Else(clientv3.OpGet(<span class="string">&quot;/key1/lease&quot;</span>))  <span class="comment">//抢锁失败</span></span><br><span class="line">	</span><br><span class="line">	txnResp,err := txn.Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 是否抢到锁</span></span><br><span class="line">	<span class="keyword">if</span> !txnResp.Succeeded &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;抢锁失败,锁被占用：&quot;</span> , <span class="keyword">string</span>(txnResp.Responses[<span class="number">0</span>].GetResponseRange().Kvs[<span class="number">0</span>].Value))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>VMTrafficShark 自制弱网模拟器</title>
    <url>/2020/05/30/VMTrafficShark-%E8%87%AA%E5%88%B6%E5%BC%B1%E7%BD%91%E6%A8%A1%E6%8B%9F%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>VMTrafficShark是参考 <a href="http://geekluo.com/contents/2017/05/02/38-trafficshark-tool-for-network.html">TrafficShark</a> 改造后的弱网模拟和抓包工具。其本质是参考Facebook开源的弱网模拟器 <a href="https://github.com/facebookarchive/augmented-traffic-control">ATC</a> 。方便应用开发测试人员模拟弱网环境下的用户体验。VMTrafficShark是基于Vmware/VirtualBox 虚拟机，方便移动部署，一键开机，配置灵活，功能强大。</p>
<a id="more"></a>
<hr>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p><img src="https://img1.kiosk007.top/static/images/network/VMTrafficShark/vmtrafficshark.png"></p>
<p>VMTrafficShark 可以模拟各种复杂网络场景.</p>
<ul>
<li>[x] 低带宽、高丢包、高时延.</li>
<li>[x] DNS空解析、DNS劫持.</li>
<li>[x] 7层HTTP内容劫持、模拟服务端故障</li>
<li>[x] 中间人抓包、方便导出 pcap、sslkey.log （设备只要应用层没有做 SSL Pinning 等反中间人措施的APP均可嗅探TLS加密后的应用层内容）</li>
<li>[ ] 可视化前端操作、多场景模拟一键操作</li>
<li>[ ] 接入设备管理</li>
</ul>
<h1 id="环境搭建与安装"><a href="#环境搭建与安装" class="headerlink" title="环境搭建与安装"></a>环境搭建与安装</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>硬件</strong></p>
<ul>
<li>笔记本电脑</li>
<li>USB无线网卡</li>
</ul>
<blockquote>
<p>本文使用的是 <a href="https://item.jd.com/100006507594.html">COMFAST CF-812AC双频千兆无线网卡 (不是打广告)</a></p>
</blockquote>
<p><strong>软件</strong></p>
<ul>
<li>vmware workstation</li>
<li>ubuntu 19.10</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装必须软件包"><a href="#安装必须软件包" class="headerlink" title="安装必须软件包"></a>安装必须软件包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sudo apt-get update</span><br><span class="line">➜ sudo apt install git gcc make vim libssl-dev net-tools -y</span><br></pre></td></tr></table></figure>
<h3 id="连接USB网卡，安装驱动"><a href="#连接USB网卡，安装驱动" class="headerlink" title="连接USB网卡，安装驱动"></a>连接USB网卡，安装驱动</h3><ul>
<li>连接USB网卡</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/VMTrafficShark/netinterface_driver_install.png
"></p>
<blockquote>
<p>最好将USB改称USB 3.0 ，2.0好像兼容性不是特别好<br><img src="/images/network/VMTrafficShark/net_interface_usb.png
" style="height:250px"></p>
</blockquote>
<ul>
<li>安装驱动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ git <span class="built_in">clone</span> https://github.com/cilynx/rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959.git </span><br><span class="line">➜ <span class="built_in">cd</span> rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959/</span><br><span class="line">➜ make</span><br><span class="line">➜ sudo make install</span><br><span class="line">➜ sudo modprobe 88x2bu</span><br><span class="line">➜ sudo lsmod | grep 88x2bu</span><br><span class="line">➜ sudo reboot</span><br></pre></td></tr></table></figure>
<h3 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h3><ul>
<li><p>添加一块 host-only 的网卡 <code>eth1</code> ，用于我们ssh登陆 虚拟机使用<br><img src="https://img1.kiosk007.top/static/images/network/VMTrafficShark/eth1.png
" style="height:350px"><br>右键虚拟机tab，<code>settings</code> -&gt; <code>Add</code> -&gt; <code>Network Adapter</code> -&gt; <code>Host-only</code></p>
</li>
<li><p>修改网络内核参数</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认开启端口转发</span></span><br><span class="line">➜ sudo <span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 修改网络接口命名方式（默认为ens33规则，修改为eth0、wlan0规则，与上面对应）</span></span><br><span class="line">➜ sudo vim /etc/default/grub</span><br><span class="line"><span class="comment"># Modify GRUB_CMDLINE_LINUX</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;net.ifnames=0 biosdevname=0&quot;</span></span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line">➜ sudo reboot</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重启后就ssh不上了…  另外注意 eth0 必须是桥接模式，nat的话会导致tcp option丢失。</p>
</blockquote>
<ul>
<li>配置网卡</li>
</ul>
<p>ubuntu从17.10开始，已放弃在/etc/network/interfaces里固定IP的配置，即使配置也不会生效，而是改成netplan方式</p>
<p>refer: <a href="https://netplan.io/examples">https://netplan.io/examples</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sudo vim /etc/netplan/50-cloud-init.yaml </span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            dhcp4: <span class="literal">true</span></span><br><span class="line">        eth1:</span><br><span class="line">            dhcp4: <span class="literal">true</span></span><br><span class="line">        wlan0:</span><br><span class="line">            dhcp4: no</span><br><span class="line">            dhcp6: no</span><br><span class="line">            addresses: [192.168.100.1/24]</span><br><span class="line">    version: 2</span><br><span class="line">    </span><br><span class="line">➜ sodu netplan apply</span><br></pre></td></tr></table></figure>
<ul>
<li>配置完成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1&#x2F;128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 00:0c:29:1d:c7:31 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.104&#x2F;24 brd 192.168.0.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 6009sec preferred_lft 6009sec</span><br><span class="line">    inet6 fe80::20c:29ff:fe1d:c731&#x2F;64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 00:0c:29:1d:c7:3b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.246.128&#x2F;24 brd 172.16.246.255 scope global dynamic eth1</span><br><span class="line">       valid_lft 1510sec preferred_lft 1510sec</span><br><span class="line">    inet6 fe80::20c:29ff:fe1d:c73b&#x2F;64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 20:0d:b0:38:d2:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.100.1&#x2F;24 brd 192.168.100.255 scope global wlan0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::220d:b0ff:fe38:d2ea&#x2F;64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="安装dhcp服务"><a href="#安装dhcp服务" class="headerlink" title="安装dhcp服务"></a>安装dhcp服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sudo apt install isc-dhcp-server -y</span><br><span class="line"><span class="comment"># 备份</span></span><br><span class="line">➜ sudo cp /etc/default/isc-dhcp-server&#123;,.bak&#125; </span><br><span class="line"><span class="comment"># 更改DHCP生效网卡</span></span><br><span class="line">➜ sudo vim /etc/default/isc-dhcp-server</span><br><span class="line">DHCPDv4_CONF=/etc/dhcp/dhcpd.conf</span><br><span class="line">INTERFACESv4=<span class="string">&quot;wlan0&quot;</span></span><br><span class="line"><span class="comment"># 更改dhcp配置文件</span></span><br><span class="line">➜ sudo vim /etc/dhcp/dhcpd.cnf</span><br><span class="line">subnet 192.168.100.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    range 192.168.100.100 192.168.100.200;</span><br><span class="line">    option domain-name-servers 192.168.100.1;</span><br><span class="line">    option routers 192.168.100.1;</span><br><span class="line">&#125;</span><br><span class="line">➜ sudo systemctl restart isc-dhcp-server</span><br><span class="line">➜</span><br></pre></td></tr></table></figure>
<h3 id="安装hostapd服务"><a href="#安装hostapd服务" class="headerlink" title="安装hostapd服务"></a>安装hostapd服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sudo apt install hostapd -y</span><br><span class="line">➜ sudo sed -i <span class="string">&#x27;s|#DAEMON_CONF=&quot;&quot;|DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;|&#x27;</span> /etc/default/hostapd</span><br><span class="line">➜ sudo vim /etc/hostapd/hostapd.conf</span><br><span class="line">interface=wlan0</span><br><span class="line">driver=nl80211</span><br><span class="line">ssid=Traffic Shark</span><br><span class="line">hw_mode=g</span><br><span class="line">ieee80211n=1</span><br><span class="line">wmm_enabled=1</span><br><span class="line">channel=7</span><br><span class="line">macaddr_acl=0</span><br><span class="line">auth_algs=1</span><br><span class="line">ignore_broadcast_ssid=0</span><br><span class="line">wpa=2</span><br><span class="line">wpa_passphrase=12345678</span><br><span class="line">wpa_key_mgmt=WPA-PSK</span><br><span class="line">wpa_pairwise=TKIP</span><br><span class="line">rsn_pairwise=CCMP </span><br><span class="line">➜ sudo systemctl unmask hostapd</span><br><span class="line">➜ sudo systemctl <span class="built_in">enable</span> hostapd</span><br><span class="line">➜ sudo systemctl start hostapd</span><br></pre></td></tr></table></figure>
<h3 id="安装dnsmasq"><a href="#安装dnsmasq" class="headerlink" title="安装dnsmasq"></a>安装dnsmasq</h3><p>由于ubuntu 18.04 开始，多了一个系统的systemd-resolvd服务，与我们要安装的dnsmasq都监听在 53 端口，妨碍了我们启用dnsmasq，所以需要停掉。</p>
<ul>
<li>停止 systemd-resolved</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sudo systemctl <span class="built_in">disable</span> systemd-resolved</span><br><span class="line">➜ sudo systemctl stop systemd-resolved</span><br><span class="line">➜ ll /etc/resolv.conf </span><br><span class="line">lrwxrwxrwx 1 root root 39 Oct 17  2019 /etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br><span class="line">➜ rm -f /etc/resolv.conf </span><br><span class="line">➜ sudo tee /etc/resolv.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">nameserver 127.0.0.1</span></span><br><span class="line"><span class="string">nameserver 114.114.114.114</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>安装dnsmasq</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sudo apt-get install dnsmasq</span><br><span class="line">➜ touch /etc/hosts.chat.freenode.net</span><br><span class="line">➜ vim /etc/dnsmasq.conf</span><br><span class="line">interface=wlan0</span><br><span class="line">listen-address=192.168.100.1</span><br><span class="line">dhcp-range=192.168.100.100,192.168.100.199,255.255.255.0,24h</span><br><span class="line"></span><br><span class="line">address=/www.kiosk007.top/127.0.0.1</span><br><span class="line">addn-hosts=/etc/hosts.chat.freenode.net</span><br><span class="line">➜ systemctl <span class="built_in">enable</span> dnsmasq</span><br><span class="line">➜ systemctl start dnsmasq</span><br></pre></td></tr></table></figure>
<h3 id="安装中间人"><a href="#安装中间人" class="headerlink" title="安装中间人"></a>安装中间人</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ wget https://snapshots.mitmproxy.org/5.1.1/mitmproxy-5.1.1-linux.tar.gz</span><br><span class="line">➜ tar -xf mitmproxy-5.1.1-linux.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>安装Nginx是为了模拟服务端故障和7层劫持，如果配置了证书同样可以对https进行劫持</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sudo apt install nginx -y</span><br><span class="line">➜ sudo tee /etc/nginx/nginx.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">user www-data;</span></span><br><span class="line"><span class="string">worker_processes auto;</span></span><br><span class="line"><span class="string">pid /run/nginx.pid;</span></span><br><span class="line"><span class="string">include /etc/nginx/modules-enabled/*.conf;</span></span><br><span class="line"><span class="string">events &#123;</span></span><br><span class="line"><span class="string">        worker_connections 768;</span></span><br><span class="line"><span class="string">        multi_accept on;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">http &#123;</span></span><br><span class="line"><span class="string">        sendfile on;</span></span><br><span class="line"><span class="string">        tcp_nopush on;</span></span><br><span class="line"><span class="string">        tcp_nodelay on;</span></span><br><span class="line"><span class="string">        keepalive_timeout 65;</span></span><br><span class="line"><span class="string">        types_hash_max_size 2048;</span></span><br><span class="line"><span class="string">        include /etc/nginx/mime.types;</span></span><br><span class="line"><span class="string">        default_type application/octet-stream;</span></span><br><span class="line"><span class="string">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; </span></span><br><span class="line"><span class="string">        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="string">        access_log /var/log/nginx/access.log;</span></span><br><span class="line"><span class="string">        error_log /var/log/nginx/error.log;</span></span><br><span class="line"><span class="string">        gzip on;</span></span><br><span class="line"><span class="string">        include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用 iptables 命令转发流量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables -F</span><br><span class="line">iptables -t nat -F</span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<ul>
<li>手机搜索 AP “Traffic Shark”</li>
<li>密码 12345678</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/VMTrafficShark/wifi.png" style="height:550px"></p>
<p>下行带宽可以达到93.35Mbps<br>上行带宽可以达到30.50Mbps （主要还得看物理网卡和运营商猛不猛）<br><img src="https://img1.kiosk007.top/static/images/network/VMTrafficShark/traffic_test.png" style="height:550px"></p>
<h2 id="弱网模拟使用"><a href="#弱网模拟使用" class="headerlink" title="弱网模拟使用"></a>弱网模拟使用</h2><ul>
<li>弱网模拟使用的是tc</li>
<li>DNS劫持使用的dnsmasq</li>
<li>应用层劫持使用的Nginx和iptables</li>
<li>中间人使用的 mitmproxy</li>
</ul>
<h3 id="上行限速"><a href="#上行限速" class="headerlink" title="上行限速"></a>上行限速</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Uplink</span></span><br><span class="line">sudo tc qdisc del dev eth0 root</span><br><span class="line">sudo tc qdisc add dev eth0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev eth0 parent 1:1 classid 1:2 htb rate 100mbit</span><br><span class="line">sudo tc class add dev eth0 parent 1:1 classid 1:3 htb rate 100mbit</span><br><span class="line">sudo tc qdisc add dev eth0 parent 1:2 handle 2: sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev eth0 parent 1:3 handle 3: netem rate 2mbit</span><br><span class="line">sudo tc filter add dev eth0 protocol ip parent 1:0 u32 match ip src 192.168.100.0/24 flowid 1:3</span><br></pre></td></tr></table></figure>
<h3 id="下行限速"><a href="#下行限速" class="headerlink" title="下行限速"></a>下行限速</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Downlink</span></span><br><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:2 htb rate 100mbit</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:3 htb rate 100mbit</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2: sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem rate 20mbit</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1:0 u32 match ip dst 192.168.100.0/24 flowid 1:3</span><br></pre></td></tr></table></figure>
<h3 id="模拟丢包、高时延等弱网环境"><a href="#模拟丢包、高时延等弱网环境" class="headerlink" title="模拟丢包、高时延等弱网环境"></a>模拟丢包、高时延等弱网环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:2 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:3 htb rate 100mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2: netem rate 3000kbit</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem loss random 50%</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1:0 u32 match ip dst 192.168.0.0/24 flowid 1:2  <span class="comment"># ip 是 eth0 的出网ip</span></span><br></pre></td></tr></table></figure>
<h3 id="封禁DNS请求"><a href="#封禁DNS请求" class="headerlink" title="封禁DNS请求"></a>封禁DNS请求</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1: classid 1:2 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1: classid 1:3 htb rate 100mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2: sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem loss 100%</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1: prio 1 u32 match ip protocol 17 ff match ip sport 53 0xffff flowid 1:3</span><br></pre></td></tr></table></figure>
<h3 id="封禁IP段"><a href="#封禁IP段" class="headerlink" title="封禁IP段"></a>封禁IP段</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1: classid 1:2 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1: classid 1:3 htb rate 100mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2: sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem loss 100%</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1: u32 match ip src 8.8.0.0/16 flowid 1:3</span><br></pre></td></tr></table></figure>
<h3 id="组合弱网场景"><a href="#组合弱网场景" class="headerlink" title="组合弱网场景"></a>组合弱网场景</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:2 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:3 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:4 htb rate 100mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2:  sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem loss random 1% rate 20mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:4 handle 4: netem loss 100%</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1:0 u32 match ip dst 192.168.100.0/24 flowid 1:3  <span class="comment"># 限制下行带宽</span></span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1: prio 1 u32 match ip protocol 17 ff match ip sport 443 0xffff flowid 1:4  <span class="comment">#封禁 udp 443 端口 </span></span><br></pre></td></tr></table></figure>
<h3 id="dns-劫持"><a href="#dns-劫持" class="headerlink" title="dns 劫持"></a>dns 劫持</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ vim /etc/dnsmasq.conf</span><br><span class="line">address=/www.kiosk007.top/127.0.0.1</span><br><span class="line"></span><br><span class="line">如果想要解析多个ip</span><br><span class="line">➜ vim /etc/hosts.chat.freenode.net</span><br><span class="line">127.0.0.1 www.kiosk007.top</span><br><span class="line">127.0.0.2 www.kiosk007.top</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7层内容劫持"><a href="#7层内容劫持" class="headerlink" title="7层内容劫持"></a>7层内容劫持</h3><ul>
<li>1、利用 DNS 劫持先将流量劫持到 Nginx 上</li>
<li>2、自签名泛域名证书，参考 <a href="https://github.com/Fishdrowned/ssl">https://github.com/Fishdrowned/ssl</a></li>
<li>3、配置Nginx完成劫持</li>
</ul>
<h3 id="mitm中间人"><a href="#mitm中间人" class="headerlink" title="mitm中间人"></a>mitm中间人</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables  -t nat -F</span><br><span class="line">iptables  -t nat -A PREROUTING -i wlan0 -p tcp -j REDIRECT --to-port 8080</span><br><span class="line">ip6tables -t nat -A PREROUTING -i wlan0 -p tcp --dport 443 -j REDIRECT --to-port 8080</span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</span><br><span class="line">SSLKEYLOGFILE=<span class="string">&quot;/root/sslkey/sslkeylogfile.txt&quot;</span> mitmproxy --mode transparent --showhost</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/network/VMTrafficShark/mitmproxy.png"></p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>为了能将抓到的包在宿主机上实时显示，需要配置root用户ssh免密登陆,配合上面的mitm导出中间人密钥，再将sslkey_log所在目录挂载到宿主机导入wireshark中，可以做到实时查看tls内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ vim /etc/ssh/sshd_config</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line">➜ ssh root@172.16.246.128 <span class="string">&quot;tcpdump -i wlan0 -U -w - 2&gt;/dev/null&quot;</span>| wireshark -k -S -i -</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS 详解（二）</title>
    <url>/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>承接 TLS详解（一），本文主要以源码的视角介绍一下TLS的整体过程，这里以 <a href="http://golang.org/pkg/crypto/tls/">GoTLS</a> (golang 自己按照 RFC 实现的一套 tls)为切入点还原整个TLS过程。主要介绍 TLS 的 handshake protocol 和 record protocol。</p>
<a id="more"></a>
<hr>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/CPU.webp"></p>
<ul>
<li><a href="https://kiosk007.top/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/">TLS 详解（一）</a></li>
<li><a href="https://kiosk007.top/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/">TLS 详解（二）</a></li>
</ul>
<h1 id="TLS-过程分析"><a href="#TLS-过程分析" class="headerlink" title="TLS 过程分析"></a>TLS 过程分析</h1><p>我们按TLS的分record类来分析。共有以下4类。最主要的是 Handshake 和 Application。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	recordTypeChangeCipherSpec recordType = <span class="number">20</span></span><br><span class="line">	recordTypeAlert            recordType = <span class="number">21</span></span><br><span class="line">	recordTypeHandshake        recordType = <span class="number">22</span></span><br><span class="line">	recordTypeApplicationData  recordType = <span class="number">23</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="handshake-protocol"><a href="#handshake-protocol" class="headerlink" title="handshake protocol"></a>handshake protocol</h2><blockquote>
<p><strong>以下按照 TLS1.2 介绍</strong></p>
</blockquote>
<p>这里以LTS握手展开，同样以最常见的 <strong><code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code></strong> 为例。握手采用<code>ECDHE</code>，身份认证采用<code>RSA</code>。在handshake中，最主要的工作也是客户端和服务器端协商TLS协议版本号和一个CipherSuite，认证对端的身份（可选，一般如https是客户端认证服务器端的身份），并且使用密钥协商算法生成共享的master secret。</p>
<p>大致步骤如下：</p>
<ul>
<li>交换Hello消息，协商出算法，交换random值，检查session resumption.</li>
<li>交换必要的密码学参数，来支持client和server协商出premaster secret。</li>
<li>交换证书和密码学参数，让client和server做认证，证明自己的身份。</li>
<li>从premaster secret和交换的random值 ，生成出master secret。</li>
<li>允许client和server确认对端得出了相同的Security Parameters，并且握手过程的数据没有被攻击者篡改。。</li>
</ul>
<p>为了在握手协议解决降级攻击的问题，TLS协议规定：client发送ClientHello消息，server必须回复ServerHello消息，否则就是fatal error，当成连接失败处理。ClientHello和ServerHello消息用于建立client和server之间的安全增强能力，ClientHello和ServerHello消息建立如下属性：</p>
<ul>
<li>Protocol Version</li>
<li>Session ID</li>
<li>Cipher Suite</li>
<li>Compression Method.<br>另外，产生并交换两个random值 ClientHello.random 和 ServerHello.random<br>完整流程：<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ssl_handshake_diffie_hellman.jpg"></li>
</ul>
<h3 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h3><p>golang 在 <code>./tls/handshake_client.go</code> 中的 <code>makeClientHello()</code> 方法中初始化了一个 clienthello。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   hello := &amp;clientHelloMsg&#123;</span><br><span class="line">		vers:                         clientHelloVersion,</span><br><span class="line">		compressionMethods:           []<span class="keyword">uint8</span>&#123;compressionNone&#125;,</span><br><span class="line">		random:                       <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>),</span><br><span class="line">		sessionId:                    <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>),</span><br><span class="line">		ocspStapling:                 <span class="literal">true</span>,</span><br><span class="line">		scts:                         <span class="literal">true</span>,</span><br><span class="line">		serverName:                   hostnameInSNI(config.ServerName),</span><br><span class="line">		supportedCurves:              config.curvePreferences(),</span><br><span class="line">		supportedPoints:              []<span class="keyword">uint8</span>&#123;pointFormatUncompressed&#125;,</span><br><span class="line">		nextProtoNeg:                 <span class="built_in">len</span>(config.NextProtos) &gt; <span class="number">0</span>,</span><br><span class="line">		secureRenegotiationSupported: <span class="literal">true</span>,</span><br><span class="line">		alpnProtocols:                config.NextProtos,</span><br><span class="line">		supportedVersions:            supportedVersions,</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 插入支持的签名算法</span></span><br><span class="line">    <span class="keyword">if</span> hello.vers &gt;= VersionTLS12 &#123;</span><br><span class="line">		hello.supportedSignatureAlgorithms = supportedSignatureAlgorithms</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 客户端如果支持TLS1.3 ，需要带好相应的ECC椭圆参数</span></span><br><span class="line">    <span class="keyword">var</span> params ecdheParameters</span><br><span class="line">	<span class="keyword">if</span> hello.supportedVersions[<span class="number">0</span>] == VersionTLS13 &#123;</span><br><span class="line">		hello.cipherSuites = <span class="built_in">append</span>(hello.cipherSuites, defaultCipherSuitesTLS13()...)</span><br><span class="line">		curveID := config.curvePreferences()[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> _, ok := curveForCurveID(curveID); curveID != X25519 &amp;&amp; !ok &#123; ... &#125;</span><br><span class="line">		params, err = generateECDHEParameters(config.rand(), curveID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line">		hello.keyShares = []keyShare&#123;&#123;group: curveID, data: params.PublicKey()&#125;&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>vers</code>: 协议版本（protocol version）指示客户端支持的最佳协议版本。一般默认是TLS1.2，如果要使用TLS1.3的话需要协议升级。</li>
<li><code>compressionMethods</code>: 压缩算法（compression method），一般被禁用</li>
<li><code>random</code>: 客户端随机数</li>
<li><code>sessionId</code>: 用来session恢复使用的</li>
<li><code>ocspStapling</code>: 支持ocsp装订，允许服务端请求CA的ocsp程序来证明自己的真实性。</li>
<li><code>scts</code>： scts(signed certificate timestamp support)scts主要用于certificate transparency。主要是为了避免某些ca滥发证书， 通过建立第三方审计服务， 让ca/域名拥有者/用户能够检查到该域名是否有被恶意签发。 （<a href="http://www.certificate-transparency.org/what-is-ct">http://www.certificate-transparency.org/what-is-ct</a> 、<a href="https://imququ.com/post/certificate-transparency.html）">https://imququ.com/post/certificate-transparency.html）</a></li>
<li><code>supportedCurves</code> 和 <code>supportedPoints</code>: 支持的椭圆参数曲线。</li>
<li><code>nextProtoNeg</code> 和 <code>alpnProtocols</code>: 协议升级使用</li>
<li><code>supportedVersions</code>: 如果客户端支持TLS1.3则在此填写，服务端也支持TLS1.3的话后续会用TLS1.3 通信</li>
<li><code>supportedSignatrueAlgorithms</code>: 支持的签名算法，服务器提供的所有证书必须用 “signature_algoritms”中提供的 hash/signature 算法对之一签署，主要为RSA或ECDSA。常见的有 <ul>
<li>rsa_pss_rsae_sha256 (0x0804)</li>
<li>ecdsa_secp256r1_sha256 (0x0403)</li>
</ul>
</li>
</ul>
<p>除此之外，client hello 阶段，客户端还携带了自己所支持的 ciphersuite 列表。服务端会挑选一个。<br>下图是wireshark抓包得到的golang 发出的client hello。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/client_hello.png" style="height:300px;border-radius: 20px;"></p>
<hr>
<h3 id="服务端处理"><a href="#服务端处理" class="headerlink" title="服务端处理"></a>服务端处理</h3><p>Server 收到 Client Hello 后的处理流程。</p>
<p>Server 会检查是否Session 复用，再做完整的握手过程。<br>代码在 <code>./tls/handshake_server.go</code> 的 <code>serverHandshake()</code> 方法中<br>服务端收到Client Hello后检查是否TLS 复用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否 TLS 会话复用</span></span><br><span class="line">	<span class="keyword">if</span> hs.checkForResumption() &#123;</span><br><span class="line">		<span class="comment">// 如果客户端的握手信息包含Session Ticket，则进行简短的握手。</span></span><br><span class="line">		c.didResume = <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// The client didn&#x27;t include a session ticket, or it wasn&#x27;t</span></span><br><span class="line">		<span class="comment">// valid so we do a full handshake.</span></span><br><span class="line">		<span class="keyword">if</span> err := hs.pickCipherSuite(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.doFullHandshake(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.establishKeys(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.readFinished(c.clientFinished[:]); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err&#125;</span><br><span class="line">		c.clientFinishedIsFirst = <span class="literal">true</span></span><br><span class="line">		c.buffering = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">if</span> err := hs.sendSessionTicket(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.sendFinished(<span class="literal">nil</span>); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>服务端处理后会将Server Hello ,Certificate，Server Key Exchange，Server Hello Down 全部发出。以下代码在 <code>./tls/handshake_server.go</code> 的 <code>doFullHandshake()</code> 方法中</p>
<h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><p>上面的插播看到，Server会先从Client Hello 中的CipherSuite列表中挑选合适的。如果没问题的话会做剩下的握手动作。让我们看看Server端是如何处理的。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置ocsp标志位</span></span><br><span class="line">    <span class="keyword">if</span> hs.clientHello.ocspStapling &amp;&amp; <span class="built_in">len</span>(hs.cert.OCSPStaple) &gt; <span class="number">0</span> &#123; hs.hello.ocspStapling = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="comment">// 设置sessionticket 是否支持</span></span><br><span class="line">	hs.hello.ticketSupported = hs.clientHello.ticketSupported &amp;&amp; !c.config.SessionTicketsDisabled</span><br><span class="line">	hs.hello.cipherSuite = hs.suite.id</span><br><span class="line"><span class="comment">// 将TLS版本和加密套件做一个hash，最后的Finished报文用</span></span><br><span class="line">	hs.finishedHash = newFinishedHash(hs.c.vers, hs.suite)</span><br><span class="line">	...</span><br><span class="line"><span class="comment">// 简单的处理就，生成 Server Hello 报文了（TLS1.3的流程不再这里）</span></span><br><span class="line">    hs.finishedHash.Write(hs.hello.marshal())</span><br><span class="line">	<span class="keyword">if</span> _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">    ... </span><br></pre></td></tr></table></figure><br>很多具体的动作都在<code>hs.hello.marshal()</code> 中进行。全部是位操作。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *serverHelloMsg)</span> <span class="title">marshal</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m.raw != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> m.raw</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b cryptobyte.Builder</span><br><span class="line">	b.AddUint8(typeServerHello)</span><br><span class="line">	b.AddUint24LengthPrefixed(<span class="function"><span class="keyword">func</span><span class="params">(b *cryptobyte.Builder)</span></span> &#123;</span><br><span class="line">		b.AddUint16(m.vers)</span><br><span class="line">		addBytesWithLength(b, m.random, <span class="number">32</span>)  <span class="comment">// 设置服务端 Random ，这个也是最重要的一步</span></span><br><span class="line">		b.AddUint8LengthPrefixed(<span class="function"><span class="keyword">func</span><span class="params">(b *cryptobyte.Builder)</span></span> &#123;</span><br><span class="line">			b.AddBytes(m.sessionId)    <span class="comment">// 添加session id</span></span><br><span class="line">		&#125;)</span><br><span class="line">		b.AddUint16(m.cipherSuite)     <span class="comment">//  确定Server端选择的加密套件</span></span><br><span class="line">		b.AddUint8(m.compressionMethod)  <span class="comment">// 压缩方法（其实就是空）</span></span><br><span class="line">    ...</span><br><span class="line">    b.AddUint16(extensionNextProtoNeg)  </span><br><span class="line">    b.AddUint16(extensionStatusRequest) <span class="comment">// 如果选择要发起OCSP的话，扩展会带上</span></span><br><span class="line">    b.AddUint16(extensionRenegotiationInfo)  <span class="comment">// 重协商</span></span><br><span class="line">    b.AddUint16(extensionSupportedVersions)  <span class="comment">// 支持的版本</span></span><br><span class="line">    b.AddUint16(extensionKeyShare)</span><br><span class="line"> 	b.AddUint16(extensionPreSharedKey)</span><br><span class="line">	b.AddUint16(extensionCookie)</span><br><span class="line">    b.AddUint16(extensionKeyShare)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br>go 实现的server hello 十分简短。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/server_hello.png" style="height:250px;border-radius: 20px;"></p>
<h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><p>接下来就是生成Certificate报文。携带X.509证书链，证书链以ASN.1 DSR编码的一系列证书。主证书必须第一个发送，中间证书按照正确的顺序跟在后面，根证书需省略。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成证书</span></span><br><span class="line">	certMsg := <span class="built_in">new</span>(certificateMsg)</span><br><span class="line">	certMsg.certificates = hs.cert.Certificate</span><br><span class="line">	hs.finishedHash.Write(certMsg.marshal())</span><br><span class="line">	<span class="keyword">if</span> _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="comment">// 如果是支持ocspStapling的需要服务端发起 OCSP 请求,并生成</span></span><br><span class="line">	<span class="keyword">if</span> hs.hello.ocspStapling &#123;</span><br><span class="line">		certStatus := <span class="built_in">new</span>(certificateStatusMsg)</span><br><span class="line">		certStatus.response = hs.cert.OCSPStaple</span><br><span class="line">		hs.finishedHash.Write(certStatus.marshal())</span><br><span class="line">		<span class="keyword">if</span> _, err := c.writeRecord(recordTypeHandshake, certStatus.marshal()); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><br><strong>Certficate 报文</strong><br><img src="/images/network/TLSDetailAnalysis/Certificate.png" style="height:250px;border-radius: 20px;"><br><strong>OCSP 响应</strong>（这个不是每次都会出现）<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ocsp.png" style="height:200px;border-radius: 20px;"></p>
<h4 id="Server-Key-Excahnge"><a href="#Server-Key-Excahnge" class="headerlink" title="Server Key Excahnge"></a>Server Key Excahnge</h4><p>这里由于加密套件选择的是 <code>TLS_ECDHE_RSA_WIRH_AES_128_GCM_SHA256</code> ，也就是要通过ECDHE进行密钥交换，ECDHE是DH的变形，加入ECC椭圆曲线后安全性和计算性能上得到大幅提升。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   keyAgreement := hs.suite.ka(c.vers)</span><br><span class="line">skx, err := keyAgreement.generateServerKeyExchange(c.config, hs.cert, hs.clientHello, hs.hello)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">if</span> skx != <span class="literal">nil</span> &#123;</span><br><span class="line">	hs.finishedHash.Write(skx.marshal())</span><br><span class="line">	<span class="keyword">if</span> _, err := c.writeRecord(recordTypeHandshake, skx.marshal()); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里可以看到生成交换的Key，generateServerKeyExchange() 传入的参数有handshake信息、证书 client和server的hello和client的hello。</p>
<p>来大致分析以下生成 DH 公钥的过程。代码在 <code>/tls/key_agreement.go</code> 的 <code>generateServerKeyExchange</code> 方法中，大约147行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取最佳的曲线列表</span></span><br><span class="line">    preferredCurves := config.curvePreferences()</span><br><span class="line"><span class="comment">// 从最佳曲线和支持的曲线中匹配出一个曲线（其实做了一大堆都没啥用，go 只支持 x25519 曲线.....）</span></span><br><span class="line">	<span class="keyword">var</span> curveID CurveID</span><br><span class="line">NextCandidate:</span><br><span class="line">	<span class="keyword">for</span> _, candidate := <span class="keyword">range</span> preferredCurves &#123;</span><br><span class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> clientHello.supportedCurves &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 使用随机数和曲线计算出 DH交换所需要的公钥 </span></span><br><span class="line">    params, err := generateECDHEParameters(config.rand(), curveID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span>, err &#125;</span><br><span class="line">	ka.params = params</span><br><span class="line">	<span class="comment">// See RFC 4492, Section 5.4.</span></span><br><span class="line">	ecdhePublic := params.PublicKey()</span><br><span class="line">	... </span><br><span class="line">	<span class="built_in">copy</span>(serverECDHParams[<span class="number">4</span>:], ecdhePublic)    </span><br><span class="line"><span class="comment">// 获取到签名内容 </span></span><br><span class="line">signed := hashForServerKeyExchange(sigType, hashFunc, ka.version, clientHello.random, hello.random, serverECDHParams)</span><br><span class="line"></span><br><span class="line">	signOpts := crypto.SignerOpts(hashFunc)</span><br><span class="line">	<span class="keyword">if</span> sigType == signatureRSAPSS &#123;</span><br><span class="line">		signOpts = &amp;rsa.PSSOptions&#123;SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: hashFunc&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sig, err := priv.Sign(config.rand(), signed, signOpts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line">	skx := <span class="built_in">new</span>(serverKeyExchangeMsg)</span><br><span class="line">	sigAndHashLen := <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> ka.version &gt;= VersionTLS12 &#123; sigAndHashLen = <span class="number">2</span> &#125;</span><br><span class="line">	skx.key = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(serverECDHParams)+sigAndHashLen+<span class="number">2</span>+<span class="built_in">len</span>(sig))</span><br><span class="line">	<span class="built_in">copy</span>(skx.key, serverECDHParams)</span><br><span class="line">	k := skx.key[<span class="built_in">len</span>(serverECDHParams):]</span><br></pre></td></tr></table></figure>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/server_key_exchange.png" style="height:300px;border-radius: 20px;"></p>
<p>Server Key Exchange 主要是生成 DH 密钥交换的公钥，通过 <code>generateServerKeyExchange（）</code>方法拿到生成DH交换的公钥。通过 <code>随机数</code>和<code>curveID</code> 调用<code>generateECDHEParameters（）</code> 获取到ECDHE的公钥。</p>
<p>和RSA做密钥交换不同，证书里的公钥不做交换密钥使用，这也就是说服务端无法证明这个证书是属于自己的。因为RSA密钥交换，客户端拿证书中的公钥加密 pre master。服务端能用私钥解开就证明服务端拥有该证书。而DH 由于证书只用作身份验证，所以需要额外的签名认证。也就是 Server Key Exchange 报文下面的 Signature Algorithm，同样也为了证明签名的有效性，签名的函数<code>hashForServerKeyExchange()</code> 传入的参数为签名类型、hash函数、客户端和服务端的Random随机数和 DH 参数。来证明这个签名是本次加密通信使用的。</p>
<blockquote>
<p>ps: 证书是真的，但是属于不属于你就是另一回事了，因为任意一个站点的证书都是可以随便下载到的，所以服务端得证明证书属于自己。</p>
</blockquote>
<ul>
<li>EC Diffie-Hellman Server Params<ul>
<li><code>Curve Type</code>: named_curve </li>
<li><code>Named Curve</code>: x25519  (曲线名字， go 只支持这一种.也是当前性能最好的椭圆曲线)</li>
<li><code>Pubkey Length</code> 和 <code>Pubkey</code>: Diffie-Hellman 交换的公钥 (通过Server random 和 椭圆曲线 获得)</li>
<li><code>Signature Algorithm</code>: Hash SHA256 、Signature Hash Algorithm Signature RSA …</li>
</ul>
</li>
</ul>
<p>ECDHE_RSA 密钥交换算法的 SignatureAlgorithm 是 rsa 。 ECDHE_ECDSA 密钥交换算法的 SignatureAlgorithm 是 ecdsa。RSA 是 RSA证书，而ECDSA是ECC证书。</p>
<h4 id="Server-Hello-Down"><a href="#Server-Hello-Down" class="headerlink" title="Server Hello Down"></a>Server Hello Down</h4><p>没啥好说的，最简单的一个结束符。ServerHelloDone消息表示，服务器已经发送完了密钥协商需要的消息，并且客户端可以开始客户端的密钥协商处理了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装Server Hello Down</span></span><br><span class="line">	helloDone := <span class="built_in">new</span>(serverHelloDoneMsg)</span><br><span class="line">	hs.finishedHash.Write(helloDone.marshal())</span><br><span class="line">	<span class="keyword">if</span> _, err := c.writeRecord(recordTypeHandshake, helloDone.marshal()); err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// 发送上面封装的所有Server 相关的报文一起发送</span></span><br><span class="line">    <span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Server 相关的记录全部发出。舞台交给客户端。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/server_hello_down.png" style="height:250px;border-radius: 20px;"></p>
<h3 id="客户端处理"><a href="#客户端处理" class="headerlink" title="客户端处理"></a>客户端处理</h3><p>服务端将服务端信息全部发送过来之后，会处理服务端发送来的信息，如本次握手如果客户端发送了Session Id 等信息，服务端是否成功复用了上次的会话，如证书信任问题处理，Client端DH公私钥生成等，</p>
<p>代码在 <code>./tls/handshake_client.go</code> 的 <code>handshake()</code> 方法中。代码先是客户端判断是否session 复用，读取server hello 内容，判断选择的TLS版本等，这块的内容忽略。</p>
<p>判断如果复用的话.<br>处理流程为1. 生成相关的Key 2. 读Session Ticket 3. 读Finished 报文 4. 发送缓冲区内容</p>
<p>如果没有复用的话.<br>处理流程则需要现做完整的握手</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否复用</span></span><br><span class="line">	<span class="keyword">if</span> isResume &#123;</span><br><span class="line">		<span class="keyword">if</span> err := hs.establishKeys(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.readSessionTicket(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.readFinished(c.serverFinished[:]); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		c.clientFinishedIsFirst = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> err := hs.sendFinished(c.clientFinished[:]); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := hs.doFullHandshake(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.establishKeys(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.sendFinished(c.clientFinished[:]); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		c.clientFinishedIsFirst = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">if</span> err := hs.readSessionTicket(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">		<span class="keyword">if</span> err := hs.readFinished(c.serverFinished[:]); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>此后则需要经历 Client Key Exchange，Change Cipher Speace， Encrpyted Handshake Record 等过程。代码在 <code>./tls/handshake_client.go</code> 中的 <code>doFullHandshake()</code> 中。</p>
<hr>
<p>插播一段内容，在Client 做DH密钥交换之前，需先验证服务端证书。主要的函数为 <code>verifyServerCertificate()</code><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">verifyServerCertificate</span><span class="params">(certificates [][]<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	certs := <span class="built_in">make</span>([]*x509.Certificate, <span class="built_in">len</span>(certificates))</span><br><span class="line"><span class="comment">// 解析证书内容</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// InsecureSkipVerify 用来控制客户端是否证书和服务器主机名。如果设置为true,则不会校验证书以及证书中的主机名和服务器主机名是否一致。</span></span><br><span class="line">	<span class="keyword">if</span> !c.config.InsecureSkipVerify &#123;</span><br><span class="line">		opts := x509.VerifyOptions&#123;</span><br><span class="line">			Roots:         c.config.RootCAs,</span><br><span class="line">			CurrentTime:   c.config.time(),</span><br><span class="line">			DNSName:       c.config.ServerName,</span><br><span class="line">			Intermediates: x509.NewCertPool(),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, cert := <span class="keyword">range</span> certs[<span class="number">1</span>:] &#123;</span><br><span class="line">			opts.Intermediates.AddCert(cert)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		c.verifiedChains, err = certs[<span class="number">0</span>].Verify(opts)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 校验对方证书</span></span><br><span class="line">	<span class="keyword">if</span> c.config.VerifyPeerCertificate != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := c.config.VerifyPeerCertificate(certificates, c.verifiedChains); err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>除此之外在 <code>doFullHandshake()</code> 函数中处理 OCSP 内容，并且在<code>keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, c.peerCertificates[0], skx)</code> 读取Server Hello 的内容并处理。</p>
<h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><p>拿到Server 信息，加上Client的信息，可以生成Pre Master Key。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">preMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, c.peerCertificates[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line">	<span class="keyword">if</span> ckx != <span class="literal">nil</span> &#123;</span><br><span class="line">		hs.finishedHash.Write(ckx.marshal())</span><br><span class="line">		<span class="keyword">if</span> _, err := c.writeRecord(recordTypeHandshake, ckx.marshal()); err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>相比Server Key Exchange，Client 的很简单，就只有 DH 的公钥。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/client_key_exchange.png" style="height:200px;border-radius: 20px;"></p>
<h4 id="Change-Cipher-Speace"><a href="#Change-Cipher-Speace" class="headerlink" title="Change Cipher Speace"></a>Change Cipher Speace</h4><p>ChangeCipherSpec用来通知对端，开始启用协商好的Connection State做对称加密，内容只有1个字节。 这个协议是冗余的，在TLS 1.3里面直接被删除了。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/change_cipher_space.png" style="height:300px;border-radius: 20px;"></p>
<p>不过在此发送此报文之前，所有的Key 都是建立好的，下面分析Key是如何计算得出的。</p>
<p>此时客户端已经可以计算出通信使用的 预主对称密钥（通过ECDH交换得到）。还需要将预主密钥加工生成主密钥，就可以完成通信了。主密钥的计算在 <code>masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.hello.random, hs.serverHello.random)</code> 函数中，可以看到，主密钥依赖TLS版本、加密套件、预主密钥、客户端和服务端随机数。其中TLS版本和随机数生成一个种子。通过<code>prf伪随机函数</code>生成最终的Master Key。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// masterFromPreMasterSecret generates the master secret from the pre-master</span></span><br><span class="line"><span class="comment">// secret. See RFC 5246, Section 8.1.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">masterFromPreMasterSecret</span><span class="params">(version <span class="keyword">uint16</span>, suite *cipherSuite, preMasterSecret, clientRandom, serverRandom []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	seed := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(clientRandom)+<span class="built_in">len</span>(serverRandom))</span><br><span class="line">	seed = <span class="built_in">append</span>(seed, clientRandom...)</span><br><span class="line">	seed = <span class="built_in">append</span>(seed, serverRandom...)</span><br><span class="line"></span><br><span class="line">	masterSecret := <span class="built_in">make</span>([]<span class="keyword">byte</span>, masterSecretLength)</span><br><span class="line">	prfForVersion(version, suite)(masterSecret, preMasterSecret, masterSecretLabel, seed)</span><br><span class="line">	<span class="keyword">return</span> masterSecret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再通过master secret导出密钥<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *clientHandshakeState)</span> <span class="title">establishKeys</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c := hs.c</span><br><span class="line"></span><br><span class="line">	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=</span><br><span class="line">		keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)</span><br><span class="line">	<span class="keyword">var</span> clientCipher, serverCipher <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> clientHash, serverHash macFunction</span><br><span class="line">	<span class="keyword">if</span> hs.suite.cipher != <span class="literal">nil</span> &#123;</span><br><span class="line">		clientCipher = hs.suite.cipher(clientKey, clientIV, <span class="literal">false</span> <span class="comment">/* not for reading */</span>)</span><br><span class="line">		clientHash = hs.suite.mac(c.vers, clientMAC)</span><br><span class="line">		serverCipher = hs.suite.cipher(serverKey, serverIV, <span class="literal">true</span> <span class="comment">/* for reading */</span>)</span><br><span class="line">		serverHash = hs.suite.mac(c.vers, serverMAC)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		clientCipher = hs.suite.aead(clientKey, clientIV)</span><br><span class="line">		serverCipher = hs.suite.aead(serverKey, serverIV)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.in.prepareCipherSpec(c.vers, serverCipher, serverHash)</span><br><span class="line">	c.out.prepareCipherSpec(c.vers, clientCipher, clientHash)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为什么要通过Master Key 导出 clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV 。比如streamcipher, 如果攻击者知道TLS数据流一个方向的部分明文，那么对2个方向的密文做一下xor，就能得到另一个方向对应部分的明文了。<br>还有AEAD也规定了不能使用相同的key+nonce来加密不同的明文，故如果TLS双方使用相同的key，又从相同的数字开始给nonce递增，那就不符合规定，会直接导致aes-gcm 被攻破。</p>
<p>例如CBC算法使用先HMAC后加密的方式， HMAC中使用MAC KEY来做认证。<br>serverKey和clientKey是对称密钥做记录层的对称加密。<br>如果使用CBC算法， 在TLS1.1之前，使用clientIV, serverIV作为IV。<br>AEAD算法先做加密后摘要的方式，更加安全， 不使用mac key。</p>
<p>More Info: <a href="https://cryptologie.net/article/341/distinction-between-the-tls-prf-for-the-master-key-and-for-the-keys/">Distinction between the TLS PRF for the Master Key and for the Keys</a></p>
<blockquote>
<p>这里提一下，看到了吗？有clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV 六个值。虽然clientMAC和serverMAC 没啥用，因为有AEAD了。但是Key 和 IV 还是有用的，也就是如果内容是服务端发送的，则需要用 serverKey 和 serverIV 加密。客户端解密时也用的server Key 和 ServerIV。</p>
</blockquote>
<h4 id="Encrpyted-Handshake-Record"><a href="#Encrpyted-Handshake-Record" class="headerlink" title="Encrpyted Handshake Record"></a>Encrpyted Handshake Record</h4><p>加密第一段内容。如果开了 false start ，不必等服务端回 ChangeCipherSpace 则可以直接发送内容。</p>
<h3 id="完成握手"><a href="#完成握手" class="headerlink" title="完成握手"></a>完成握手</h3><p>接下来服务端也会发送 ChangeCipherSpace和EncrpytedHandRecord来结束。服务端如果支持Session Tikect的话也可以发送，以支持下一次的快速握手。</p>
<h2 id="record-protocol"><a href="#record-protocol" class="headerlink" title="record protocol"></a>record protocol</h2><p>一个TLS record Size 的最大为16k，也就是服务端（openssl）一般会开辟一个16K的 buffer存tls record size</p>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/tcp_tls.png" alt></p>
<ul>
<li>分片，逆向是重组</li>
<li>生成序列号，为每个数据块生成唯一编号，防止被重放或被重排序</li>
<li>压缩，可选步骤，使用握手协议协商出的压缩算法做压缩</li>
<li>加密，使用握手协议协商出来的key做加密/解密</li>
<li>算HMAC，对数据计算HMAC，并且验证收到的数据包的HMAC正确性（AES-GCM 有AEAD了就不需要HMAC了）</li>
<li>发给tcp/ip，把数据发送给 TCP/IP 做传输(或其它ipc机制)。</li>
</ul>
<p>这里就只介绍解密过程吧，加密是解密的逆过程。其中seq是递增的，从加密第一块内容起递增（第一次加密发生在 Finshed 报文）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TLSDecrypt</span><span class="params">(record []<span class="keyword">byte</span>,version,cipherSuite <span class="keyword">uint16</span>,clientRandom,serverRandom []<span class="keyword">byte</span>,seq [8]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	suite := cipherSuiteByID(cipherSuite)</span><br><span class="line">	_,master := GetMaster(hex.EncodeToString(clientRandom))</span><br><span class="line">	byteMaster,_ := hex.DecodeString(master)</span><br><span class="line">	cCipher,_,cHash,_,err := establishKeys(version,suite,byteMaster,clientRandom,serverRandom)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">var</span> clientConn = halfConn&#123;</span><br><span class="line">		err:<span class="literal">nil</span>,</span><br><span class="line">		version:VersionTLS12,</span><br><span class="line">		cipher:cCipher,</span><br><span class="line">		mac:cHash,</span><br><span class="line">		seq:seq,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	plaintext,_,err := clientConn.decrypt(record)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小赠，nginx的tls优化可以参考 <a href="https://blog.helong.info/blog/2015/05/08/https-config-optimize-in-nginx/">https://blog.helong.info/blog/2015/05/08/https-config-optimize-in-nginx/</a></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>[0]: <a href="https://golang.org/pkg/crypto/tls/">https://golang.org/pkg/crypto/tls/</a></li>
<li>[1]:<a href="https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/#5-handshake-%E5%8D%8F%E8%AE%AE">https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/#5-handshake-%E5%8D%8F%E8%AE%AE</a></li>
<li>[2]: <a href="https://blog.wangriyu.wang/2018/03-http-tls.html">https://blog.wangriyu.wang/2018/03-http-tls.html</a></li>
<li>[3]: <a href="http://www.cnhalo.net/2017/03/15/dive-into-tls-with-golang/">http://www.cnhalo.net/2017/03/15/dive-into-tls-with-golang/</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tls</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS 详解（一）</title>
    <url>/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TLS的设计目标是构建一个安全传输层（Transport Layer Security ），在基于连接的传输层（如tcp）之上提供安全加密的通信信道。它是旨在防止窃听，篡改和消息伪造的 <a href="https://mailarchive.ietf.org/arch/msg/ietf-announce/IhM9JJHVs_ZeK-_1eaVZrqxbnL8/">IETF</a> 标准。常见应用程序包括Web浏览器，即时消息传递，电子邮件和IP语音都在使用TLS。</p>
<blockquote>
<p>Title From <a href="https://www.networkworld.com/article/2303073/lan-wan-what-is-transport-layer-security-protocol.html">What is Transport Layer Security (TLS)?</a><br><a id="more"></a></p>
</blockquote>
<hr>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/encript-for-security.jpg" style="height:450px"></p>
<ul>
<li><a href="https://kiosk007.top/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/">TLS 详解（一）</a></li>
<li><a href="https://kiosk007.top/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/">TLS 详解（二）</a></li>
</ul>
<h1 id="TLS-简介"><a href="#TLS-简介" class="headerlink" title="TLS 简介"></a>TLS 简介</h1><p>下面主要介绍一下TLS的设计目标和发展历史。</p>
<h2 id="TLS的设计目标"><a href="#TLS的设计目标" class="headerlink" title="TLS的设计目标"></a>TLS的设计目标</h2><p>TLS用于两个应用程序之间提供保密性和数据完整性。一个TLS需要满足(1)、密码学安全 (2)、互操作，通用性 (3)、高效性 (4)、可扩展性 才能称为一个合格的TLS。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/TLS.png"></p>
<h2 id="TLS的发展历史"><a href="#TLS的发展历史" class="headerlink" title="TLS的发展历史"></a>TLS的发展历史</h2><ul>
<li>1994: <strong>SSL 1.0</strong>, 由Netscape提出，但未公开。</li>
<li>1995: <strong>SSL 2.0</strong>, 由Netscape提出，这个版本由于设计缺陷，并不安全，很快被发现有严重漏洞，已经废弃。</li>
<li>1996: <strong>SSL 3.0</strong>. 作为 RFC 6101 发布。2015年后已经不安全，必须禁用。</li>
<li>1999: <strong>TLS 1.0</strong>. 互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版.</li>
<li>2006: <strong>TLS 1.1</strong>. 作为 RFC 4346 发布。主要fix了CBC模式相关的如BEAST攻击等漏洞</li>
<li>2008: <strong>TLS 1.2</strong>. 作为RFC 5246 发布 ，增进安全性。此版本中的一个主要新功能是<strong>身份验证（AEAD）加密</strong>，它消除了对流和分组密码的需要（因而消除了固有的易受攻击的CBC模式）。</li>
<li>2011: 正式弃用SSL 2.0，IETF尝试通过发布RFC 6176正式弃用SSL v2 。根据SSL Labs的调查，2011年有54％的HTTPS服务器支持此过时的协议版本。</li>
<li>2013-2014: 多个针对TLS漏洞攻击手段相继爆出和同期发生的棱镜门事件也改变了人们对互联网安全的看法<ul>
<li>AlFardan和Paterson发布了<a href="http://www.isg.rhul.ac.uk/tls/Lucky13.html">pLucky 13</a>，他们对CBC套件的攻击。在TLS中，块加密旨在对纯文本（而不是密文）进行身份验证，这为攻击者提供了执行填充oracle攻击的机会。</li>
<li>发现了<a href="http://www.isg.rhul.ac.uk/tls/">针对RC4的新攻击</a>。以前，人们认为RC4弱点对TLS的影响不大，但这被证明是错误的。这项研究标志着RC4的死亡。</li>
<li>爱德华·斯诺登（Edward Snowden）向英国卫报记者发布了数千份美国国家安全局（NSA）分类文件，从而永远改变了公众对互联网的看法。</li>
<li><a href="http://dualec.org/">Dual EC DRBG</a> (由NIST标准化生成和推广的伪随机数）被认为是潜在的后门。</li>
<li>一项名为<a href="https://mitls.org/pages/attacks/3SHAKE">“三重握手攻击”</a>的新研究已经发布，TLS中的重新协商需要再次修复。</li>
<li><a href="http://heartbleed.com/">“心脏出血攻击（heartbleed）”</a>发现了OpenSSL（一个使用非常广泛的TLS库）中的一个严重漏洞。</li>
<li><a href="https://blog.qualys.com/ssllabs/2014/12/08/poodle-bites-tls">POODLE TLS</a>一些在SSL3.0 的填充攻击，即使TLS 1.0确实具有针对填充oracle攻击的内置防护，但某些实现仍无法正确避免。</li>
</ul>
</li>
<li>2015：TLS证书的不安全再次让互联网安全遭受打击，各机构再次出击。<ul>
<li>从2015-2016，Apple，Chrome和Mozilla 相继因为一些CA机构违反规则等问题选择不再信任 WoSign、StartCom，2016年Chrome又宣布取消对Symantec（赛门铁克）证书的信任。DigiCert收购Symantec后，各厂商恢复信任Symantec</li>
<li>由于多家CA机构存在乱签发CA的行为，经过多年的讨论，发布了<a href="https://tools.ietf.org/html/rfc7469">RFC 7469</a>，使任何人都可以使用公钥固定来保护自己免受欺诈性颁发的证书的侵害。</li>
<li><a href="https://tools.ietf.org/html/rfc7633">RFC 7633</a> 中发布了新的X.509扩展，以将具有某些TLS功能的证书耦合在一起。这是一项迫切需要的功能，它在信任证书之前需要有效的OCSP响应。</li>
</ul>
</li>
<li>2018: <strong>TLS 1.3</strong>，支持0-rtt，大幅增进安全性，砍掉了AEAD之外的加密方式</li>
</ul>
<p>From [@SSL/TLS and PKI History][3]</p>
<h1 id="TLS-CipherSuite"><a href="#TLS-CipherSuite" class="headerlink" title="TLS CipherSuite"></a>TLS CipherSuite</h1><p>加密套间一般在 TLS 握手时协商得出，之后的整个加密过程都遵循套件的约定进行加密通信，每个集合的名称代表组成它的特定算法。</p>
<p>以TLS1.2中最常见的 <strong><code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code></strong> 为例。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/tls_ciphersuite.png" style="height:200px"></p>
<ul>
<li><code>密钥交换算法</code> -规定交换对称密钥的方式；</li>
<li><code>身份验证算法</code> -指示如何执行服务器身份验证和（如果需要）客户端身份验证。 </li>
<li><code>对称加密算法</code> -指示将使用哪种对称密钥算法来加密实际数据；包含对称加密算法、强度、工作模式。</li>
<li><code>消息身份验证代码（MAC）算法</code> -指示连接将用于执行数据完整性检查的方法。</li>
</ul>
<p>在tls的世界有许多密码学名词，组合在一起就成了密码套件。</p>
<ol>
<li>块加密算法 block cipher : AES, Serpent, 等</li>
<li>流加密算法 stream cipher: RC4，ChaCha20 等</li>
<li>Hash函数 hash funtion:MD5，sha1，sha256，sha512 , ripemd 160，poly1305 等</li>
<li>消息验证码函数 message authentication code: HMAC-sha256，AEAD 等</li>
<li>密钥交换 key exchange: DH，ECDH，RSA，DHE，ECDHE 等</li>
<li>公钥加密 public-key encryption: RSA，rabin-williams 等</li>
<li>数字签名算法 signature algorithm: RSA，DSA，ECDSA 等</li>
<li>密码衍生函数 key derivation function: TLS-12-PRF(SHA-256) , bcrypto，scrypto，pbkdf2 等</li>
</ol>
<h2 id="非对称加密-密钥交换-身份验证"><a href="#非对称加密-密钥交换-身份验证" class="headerlink" title="非对称加密/密钥交换/身份验证"></a>非对称加密/密钥交换/身份验证</h2><p>非对称加密是一种使用公钥和私钥加解密的算法，一段明文如果用公钥加密，只能用私钥解密。如果用私钥加密，只能用公钥解密。公钥可以公开，但是私钥只能是一方保存。</p>
<h3 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h3><p><strong>一. 随机选择两个不相等的质数 p 和 q , p 与 q 越大，越安全</strong></p>
<p>比如 P = 67 ，Q = 71。计算他们的乘积 n = P * Q = 4757 ，转化为二进为 1001010010101，该加密算法即为 13 位，实际算法是 1024 位 或 2048 位，位数越长，算法越难被破解。</p>
<p><strong>二. 计算 p 和 q 的乘积 n, 并计算 n 的欧拉函数 φ(n)</strong></p>
<p>φ(n) 表示在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。例如：在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果 n = P <em> Q，P 与 Q 均为质数，则 φ(n) = φ(P </em> Q)= φ(P - 1)φ(Q - 1) = (P - 1)(Q - 1) 。 本例中 φ(n) = 66 * 70 = 4620，这里记为 m， m = φ(n) = 4620</p>
<p><strong>三. 随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质</strong></p>
<p>公约数只有 1 的两个整数，叫做互质整数，这里我们随机选择 e = 101 请注意不要选择 4619，如果选这个，则公钥和私钥将变得相同。</p>
<p><strong>四. 计算模反元素 d，可以使得 e*d 除以 m 的余数为 1。</strong> </p>
<p>即找一个整数 d，使得  (e <em> d ) % m = 1。 等价于 e </em> d - 1 = y <em> m ( y 为整数） 找到 d ，实质就是对下面二元一次方程求解。 e </em> x - m * y =1 ，其中 e = 101，m = 4620 101x - 4620y =1  这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。 总之算出一组整数解（x，y ）= （ 1601，35），即 d = 1601。 到此密钥对生成完毕。不同的 e 生成不同的 d，因此可以生成多个密钥对。本例中公钥为 （n，e) = (4757 , 101)，私钥为 （n，d) = (4757 ，1601) ，仅（n，e) = (4757 , 101) 是公开的，其余数字均不公开。可以想像如果只有 n 和 e，如何推导出 d，目前只能靠暴力破解，位数越长，暴力破解的时间越长。</p>
<p><strong>RSA 加密解密流程</strong></p>
<ul>
<li>加密：c=$m^k\pmod n$  </li>
<li><p>解密：m=$c^d\pmod n$   </p>
<p>m 是明文，c 是密文</p>
</li>
</ul>
<blockquote>
<p>缺点： RSA 不具备前向保密性，也就是加密的通信所依赖的 Pre Master Key 是基于公钥加密，私钥解密的。如果私钥丢失，前面加密过的会话如果被保存下来，都可以用泄漏的私钥还原的。</p>
</blockquote>
<h4 id="基于openssl实战验证RSA"><a href="#基于openssl实战验证RSA" class="headerlink" title="基于openssl实战验证RSA"></a>基于openssl实战验证RSA</h4><ul>
<li>待加密的明文</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>生成私钥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ openssl genrsa -out private.pem</span><br></pre></td></tr></table></figure>
<ul>
<li>从私钥中提取公钥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ openssl rsa -<span class="keyword">in</span> private.pem -pubout -out public.pem</span><br></pre></td></tr></table></figure>
<ul>
<li>加密</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ openssl rsautl -encrypt -<span class="keyword">in</span> hello.txt -inkey public.pem -pubin -out hello.en</span><br></pre></td></tr></table></figure>
<ul>
<li>解密</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ openssl rsautl -decrypt -<span class="keyword">in</span> hello.en  -inkey private.pem -out hello.de</span><br><span class="line">➜ cat hello.de</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h4 id="RSA-握手"><a href="#RSA-握手" class="headerlink" title="RSA 握手"></a>RSA 握手</h4><p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ssl_handshake_rsa.jpg
" style="height:600px"></p>
<h3 id="DH密钥交换"><a href="#DH密钥交换" class="headerlink" title="DH密钥交换"></a>DH密钥交换</h3><p>1976年有 Bailey Whitfield Diffe 和 Martin Edward Hellman 首次发表，所以也被称作 Diffie-Hellman key exchange，简称DH。可以让双方在完全没有对方任何预先信息的条件下建立一个密钥。所以其具备向前安全性。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/Diffie-Hellman.png
" style="height:200px"></p>
<ul>
<li>g、p、A、B 公开。A 为 Alice 的公钥，B 为 Bob 的公钥</li>
<li>a、b 保密。 a 为 Alice 的私钥匙，b 为 Alice 的私钥匙</li>
</ul>
<p><strong>DH 密钥交换协议举例</strong></p>
<ul>
<li>协定使用 p=23 以及 g=5</li>
<li>Alice选择密钥 a=6, 计算公钥 $A=g^a\pmod p$ ,并发送给Bob (A=$5^6\pmod{23} = 8$)</li>
<li>Bob 选择密钥 b=15，计算公钥 $B=g^b\pmod p$ ,并发送给Alice (A=$5^{15}\pmod{23} = 19$)</li>
<li>Alice 计算 $s=B^a\pmod p$ (s=$19^6\pmod{23}=2$)</li>
<li>Bob 计算 $s=A^b\pmod p$ (s=$8^{15}\pmod{23}=2$)</li>
</ul>
<blockquote>
<p>缺点：大数乘法运算，速度很慢。实际使用的大多都是 ECDH 交换算法，也就是ECC椭圆曲线+DH</p>
</blockquote>
<p><strong>ECDH</strong><br>ECDH 是椭圆曲线的（DH）笛福赫尔曼算法的变种，它其实不单单是一种加密算法，而是一种密钥协商协议，也就是说 ECDH 定义了（在某种程度上）密钥怎么样在通信双方之间生成和交换，至于使用这些密钥怎么样来进行加密完全取决通信双方。</p>
<p>ECDH比DH计算更快，同等安全程度下，密钥比DH更短。</p>
<h4 id="DH-握手"><a href="#DH-握手" class="headerlink" title="DH 握手"></a>DH 握手</h4><p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ssl_handshake_diffie_hellman.jpg
" style="height:600px"></p>
<h2 id="对称加密-消息身份验证"><a href="#对称加密-消息身份验证" class="headerlink" title="对称加密/消息身份验证"></a>对称加密/消息身份验证</h2><p>对称加密是一种使用单个密钥对数据进行加密（编码）和解密（解码）的加密方法。其明文的加密使用的是相同的一把密钥。</p>
<h3 id="XOR-与-填充"><a href="#XOR-与-填充" class="headerlink" title="XOR 与 填充"></a>XOR 与 填充</h3><p>对称加密的基本原理是XOR (异或运算)。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/XOR.png" style="height:200px"><br>但是密钥和明文存在长度不一致的情况。为了将密钥和明文对齐，这就引入了分组的概念，对称加密中分为块加密和流式加密。以块加密为例。</p>
<p>Block cipher 加密方式：将明文分为多个等长的Block块，再对每个模块分别加解密。若当最后一个明文block模块长度不够时，需要引入填充算法进行填充。<br>填充方案</p>
<ul>
<li>位填充：以bit为单位填充</li>
<li>字节填充：以字节为单位填充<ul>
<li>补零：缺少字节数全部补0</li>
<li>ANSI X9.23: 全部填0，但最后一个字节需要补充总共填写0个个数</li>
<li>ISO 10126：完全随即字符，但最后一个字节需要补充总共填写随即字符个数 </li>
<li>PKCS7（RFC5652）：全部填充缺省的字节个数，如缺4个字节，填4个04</li>
</ul>
</li>
</ul>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="ECB-Electronic-codebook-模式"><a href="#ECB-Electronic-codebook-模式" class="headerlink" title="ECB(Electronic codebook) 模式"></a>ECB(Electronic codebook) 模式</h4><p>ECB是DES的最简单和最弱的形式。它不使用初始化向量, 直接将明文分解为多个块，对每个块作独立的加密。其最致命的弱点就是无法隐藏数据特征。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ECB.jpg" style="height:400px"><br>图a 是加密前的明文， 图b 是ECB加密后的密文。可以看出，加密根本没有什么用处。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ECB_encryption.png" style="height:250px"></p>
<p>以下是zoom在其加密白皮书（2020）上所宣传的，其实很不安全。</p>
<blockquote>
<p>For use cases such as meeting real-time content (video, voice, and content share), where data is transmitted over User<br>Datagram Protocol (UDP), we use AES-256 in ECB mode to encrypt these compressed data streams. We expect to upgrade<br>this soon to AES-256 GCM. Additionally, for video, voice, and content share encrypted with AES, once it’s encrypted, it<br>remains encrypted as it passes through Zoom’s meeting servers until it reaches another Zoom Client or a Zoom Connector,<br>which helps translate the data to another protocol.</p>
</blockquote>
<p>Link: <a href="https://xie.infoq.cn/article/644f4ed6b8a84286cc9f74ebc">Zoom的加密算法，到底有什么问题？</a></p>
<h4 id="CBC-Cipher-block-chaining-模式"><a href="#CBC-Cipher-block-chaining-模式" class="headerlink" title="CBC(Cipher-block chaining) 模式"></a>CBC(Cipher-block chaining) 模式</h4><p>CBC 模式是最常见的传统加密模式。每个明文块先与前一个密文块异或后，再进行加密。由于此XOR处理，相同的明文块将不再导致加密产生相同的密文。</p>
<p><strong>缺点:</strong> 加密过程串行化，只有第一步完成才能接下来的第二步，多核CPU无法发挥作用。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/CBC_encryption.png
" style="height:250px"><br>第一组通过初始化向量 IV 将第一组明文和 密钥K 加密得到密文，第二组再用第一组得到的密文和第二组的明文和 密钥K 加密得到第二组的密文，如此往复。</p>
<blockquote>
<ol>
<li>IV不是密码短语的一部分，因为它不是秘密。它是作为随机数生成的，但是只有在了解此IV的情况下，您才能解密密钥本身。</li>
<li>因为漏洞（Lucky 13）问题，被高版本TLS所宣布禁止，另外H2的实现也不允许使用CBC模式的TLS。</li>
</ol>
</blockquote>
<h4 id="CTR（Counter）模式"><a href="#CTR（Counter）模式" class="headerlink" title="CTR（Counter）模式"></a>CTR（Counter）模式</h4><p>为了解决CBC不能串行加密的缺点。CTR模式支持每组加密采用一个计数向量，这样就可以多个块同时加密。它不具有消息依赖性，因此密文块不依赖于先前的明文块。</p>
<p><strong>缺点：</strong> 不能提供密文的消息完整性校验。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/CTR_encryption.svg
" style="height:250px"></p>
<h4 id="GCM（Galois-Counter-Mode）模式"><a href="#GCM（Galois-Counter-Mode）模式" class="headerlink" title="GCM（Galois Counter Mode）模式"></a>GCM（Galois Counter Mode）模式</h4><p>GCM 是 CTR + GMAC ，其兼顾CTR的并法加解密的特点，也可以使用MAC算法实现消息的完整性验证。</p>
<ul>
<li>验证完整性 MAC(Message Authentication Code)</li>
</ul>
<p>通过将加密后的密文消息和密钥经过专门的Hash函数加密，传输时需要将密文和MAC一块传给接收方。接收方通过相同的MAC算法，将密文和密钥再次算出MAC值，判断MAC值是否相等。</p>
<p>可以使用安全伪随机函数（<a href="http://www.crypto-it.net/eng/theory/prf-and-prp.html">PRF</a>）创建安全MAC算法。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/Message_Authentication_Code.png
" style="height:250px"></p>
<p>顾名思义，可以验证消息完整性，防止中间人恶意修改消息内容。</p>
<ul>
<li>GCM</li>
</ul>
<p>GMAC 是用到 Galois域的MAC算法，是众多消息验证算法的一种。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/two-parts-of-gcm-l.jpg
" style="height:350px"></p>
<ul>
<li>AEAD</li>
</ul>
<p>Authenticated Encryption with Associated Data (AEAD) 是一种同时具备保密性，完整性和可认证性的加密形式。</p>
<p>AEAD 产生的原因很简单，单纯的对称加密算法，其解密步骤是无法确认密钥是否正确的。也就是说，加密后的数据可以用任何密钥执行解密运算，得到一组疑似原始数据，而不知道密钥是否是正确的，也不知道解密出来的原始数据是否正确。因此，需要在单纯的加密算法之上，加上一层验证手段，来确认解密步骤是否正确。</p>
<p><code>AES-256-GCM</code> 就是常见的 AEAD 算法。其他的还有诸如 <code>ChaCha20-Poly1305</code>，<code>AES-128-GCM</code> 等</p>
<h3 id="AES-Advanced-Encryption-Standard-加密算法"><a href="#AES-Advanced-Encryption-Standard-加密算法" class="headerlink" title="AES(Advanced Encryption Standard) 加密算法"></a>AES(Advanced Encryption Standard) 加密算法</h3><p>AES是当今可能会遇到的流行和被广泛采用的对称加密算法。它由比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计，常用的填充算法为：PKCS7。常用的分组模式为：GCM。分组长度只能是16字节。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>AES</th>
<th style="text-align:center">密钥长度（32 bit）</th>
<th style="text-align:center">分组长度（32 bit）</th>
<th style="text-align:center">加密轮数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AES-128</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>AES-192</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>AES-256</td>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
</div>
<p><strong>AES加密步骤</strong></p>
<ol>
<li>将明文按照128 bit (16 字节)拆分为若干个明文块，每个明文块是 4*4 矩阵</li>
<li>按照选择的填充方式来填充最后一个明文块。（PKCS7）</li>
<li><strong>每一个明文块利用AES加密器和密钥，加密成密文块。</strong></li>
<li>拼接所有的密文块，加上上文提到的加密模式GCM。成为最终的密文。</li>
</ol>
<p>下面是详细的加密步骤。</p>
<p>第三步是最复杂，也是最重要的一步。也是上述加密轮数体现的地方。</p>
<h4 id="AES-加密流程"><a href="#AES-加密流程" class="headerlink" title="AES 加密流程"></a>AES 加密流程</h4><p>AES中的加密回合数是可变的，并且取决于密钥的长度。AES对128位密钥使用10轮，对192位密钥使用12轮，对于256位密钥使用14轮。这些回合中的每个回合都使用不同的128位回合密钥，该密钥是根据原始AES密钥计算得出的。<br>大体分为 <code>初始轮</code> 、 <code>普通轮</code> 、 <code>最终轮</code></p>
<p><strong>初始轮</strong></p>
<ul>
<li><code>AddRoundKey 轮密钥加</code>  将明文矩阵的16个字节视为128位，并与回合密钥的128位进行XOR运算。</li>
</ul>
<p><strong>普通轮</strong></p>
<ul>
<li><code>AddRoundKey 轮密钥加</code>  </li>
<li><code>Subytes 字节替代</code>   通过查找设计中给定的固定表（S-box）来替换16个输入字节。结果是四行四列的矩阵。</li>
<li><code>ShiftRows 行移位</code>    矩阵的四行中的每一行都向左移动。第一行不变，第二行左移1个字节，第三行左移2个字节，第四行左移3个字节。</li>
<li><code>MixColumns 列混合</code>  使用特殊的数学函数对每四个字节的列进行转换。此函数将一列的四个字节作为输入，并输出四个全新的字节，以替换原始列。结果是由16个新字节组成的另一个新矩阵。</li>
</ul>
<p><strong>最终轮</strong></p>
<ul>
<li><code>SubBytes 字节替代</code></li>
<li><code>ShiftRows 行移位</code></li>
<li><code>AddRoundKey 轮密钥加</code></li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/AES_Encrpyt.png
" style="height:350px"></p>
<ul>
<li>动画演示 <code>AES加密</code> : <a href="https://coolshell.cn/articles/3161.html">https://coolshell.cn/articles/3161.html</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数 p: 明文的字符串数组。</span></span><br><span class="line"><span class="comment"> * 参数 plen: 明文的长度。</span></span><br><span class="line"><span class="comment"> * 参数 key: 密钥的字符串数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> plen, <span class="keyword">char</span> *key)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> keylen = <span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(plen == <span class="number">0</span> || plen % <span class="number">16</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;明文字符长度必须为16的倍数！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!checkKeyLen(keylen)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;密钥字符长度错误！长度必须为16、24和32。当前长度为%d\n&quot;</span>,keylen);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    extendKey(key);<span class="comment">//扩展密钥</span></span><br><span class="line">    <span class="keyword">int</span> pArray[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; plen; k += <span class="number">16</span>) &#123;</span><br><span class="line">        convertToIntArray(p + k, pArray);</span><br><span class="line">        addRoundKey(pArray, <span class="number">0</span>);<span class="comment">//一开始的轮密钥加</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;<span class="comment">//前9轮</span></span><br><span class="line">            subBytes(pArray);<span class="comment">//字节代换</span></span><br><span class="line">            shiftRows(pArray);<span class="comment">//行移位</span></span><br><span class="line">            mixColumns(pArray);<span class="comment">//列混合</span></span><br><span class="line">            addRoundKey(pArray, i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//第10轮</span></span><br><span class="line">        subBytes(pArray);<span class="comment">//字节代换</span></span><br><span class="line">        shiftRows(pArray);<span class="comment">//行移位</span></span><br><span class="line">        addRoundKey(pArray, <span class="number">10</span>);</span><br><span class="line">        convertArrayToStr(pArray, p + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多有关对称加密的实现可以参考： <a href="https://tools.ietf.org/html/rfc5246#section-6.3">https://tools.ietf.org/html/rfc5246#section-6.3</a></p>
<h1 id="TLS的分层结构"><a href="#TLS的分层结构" class="headerlink" title="TLS的分层结构"></a>TLS的分层结构</h1><p>TLS 从实现上主要包含 <code>Record 记录协议</code> 和 <code>Handshake 握手协议</code>。</p>
<ul>
<li><strong>handshake protocol</strong>，验证通讯双方的身份，交换加解密的安全套间，协商加密参数</li>
<li><strong>record protocol</strong>，记录层作为对称加密传输的record协议</li>
</ul>
<p>另外还有三种辅助协议</p>
<ul>
<li><strong>changecipher spec</strong> ，用来通知对端从handshake切换到record协议(有点冗余，在TLS1.3里面已经被删掉了)</li>
<li><strong>alert协议，the alert</strong>, 用来通知各种返回码，</li>
<li><strong>application data协议</strong>，就是把http，smtp等的数据流传入record层做处理并传输。</li>
</ul>
<p>这种 <strong>认证密钥协商</strong> + <strong>对称加密传输</strong> 的结构，是绝大多数加密通信协议的通用结构。</p>
<h2 id="record-protocol"><a href="#record-protocol" class="headerlink" title="record protocol"></a>record protocol</h2><p>record协议做应用数据的对称加密传输，占据一个TLS连接的绝大多数流量。记录层将信息块分割成携带 2^14 字节 (16KB) 或更小块的数据的 TLSPlaintext 记录。有点像TCP中的segment，所有的其他子协议需要通过 record 协议封装，多个record 数据可以在一个TCP包里记录一次性发出。<br><img src="https://img1.kiosk007.top/static/images/network/tls_record.png" style="height:390px"><br>Record 协议 – 从应用层接受数据:</p>
<ul>
<li>分片，逆向是重组</li>
<li>生成序列号，为每个数据块生成唯一编号，防止被重放或被重排序</li>
<li>压缩，可选步骤，使用握手协议协商出的压缩算法做压缩 （大多不压缩）</li>
<li>加密，使用握手协议协商出来的key做加密/解密</li>
<li>算HMAC，对数据计算HMAC，并且验证收到的数据包的HMAC正确性</li>
<li>发给tcp/ip，把数据发送给 TCP/IP 做传输(或其它ipc机制)。</li>
</ul>
<h2 id="handshake-protocol"><a href="#handshake-protocol" class="headerlink" title="handshake protocol"></a>handshake protocol</h2><p>handshake 是 TLS里最复杂的子协议，浏览器和服务器在握手过程中协商TLS版本号、随机数、密码套件等信息，并且交换证书、身份验证、交换密钥参数等。最终用于后续的混合加密系统。<br>handshake在TLS的发展中又产生了多个变种，比如RSA密钥交换DH密钥交换。0RTT，false start 等等。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   Client                                               Server</span><br><span class="line">   ClientHello</span><br><span class="line">   (empty SessionTicket extension)-------&gt;</span><br><span class="line">                                                   ServerHello</span><br><span class="line">                               (empty SessionTicket extension)</span><br><span class="line">                                                  Certificate*</span><br><span class="line">                                            ServerKeyExchange*</span><br><span class="line">                                           CertificateRequest*</span><br><span class="line">                                &lt;--------      ServerHelloDone</span><br><span class="line">   Certificate*</span><br><span class="line">   ClientKeyExchange</span><br><span class="line">   CertificateVerify*</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                     --------&gt;</span><br><span class="line">                                              NewSessionTicket</span><br><span class="line">                                            [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------             Finished</span><br><span class="line">   Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">Figure 1: Message flow <span class="keyword">for</span> full handshake issuing new session ticket</span><br></pre></td></tr></table></figure></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li>[0]: <a href="https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/</a></li>
<li>[1]: <a href="https://blog.wangriyu.wang/2018/03-http-tls.html">https://blog.wangriyu.wang/2018/03-http-tls.html</a> </li>
<li>[3]: <a href="https://www.feistyduck.com/ssl-tls-and-pki-history/">https://www.feistyduck.com/ssl-tls-and-pki-history/</a> （TLS发展史）</li>
</ul>
<p><strong>加密套件相关</strong></p>
<ul>
<li>[ECB]: <a href="https://www.sciencedirect.com/topics/computer-science/electronic-code-book">https://www.sciencedirect.com/topics/computer-science/electronic-code-book</a></li>
<li>[CBC]: <a href="https://www.sciencedirect.com/topics/computer-science/cipher-block-chaining">https://www.sciencedirect.com/topics/computer-science/cipher-block-chaining</a></li>
<li>[CTR]: <a href="https://www.cryptopp.com/wiki/CTR_Mode">https://www.cryptopp.com/wiki/CTR_Mode</a></li>
<li>[MAC]: <a href="http://www.crypto-it.net/eng/theory/mac.html">http://www.crypto-it.net/eng/theory/mac.html</a></li>
<li>[AES]：<a href="https://www.tutorialspoint.com/cryptography/advanced_encryption_standard.htm">https://www.tutorialspoint.com/cryptography/advanced_encryption_standard.htm</a></li>
<li>[AEAD]: <a href="https://zhuanlan.zhihu.com/p/28566058">https://zhuanlan.zhihu.com/p/28566058</a></li>
<li>[Asymmetric encryption]: <a href="https://www.cloudflare.com/learning/ssl/what-is-asymmetric-encryption/">https://www.cloudflare.com/learning/ssl/what-is-asymmetric-encryption/</a></li>
<li>[RSA]: <a href="https://www.zhihu.com/search?type=content&amp;q=RSA">https://www.zhihu.com/search?type=content&amp;q=RSA</a>  (知乎 一文搞懂 rsa 算法)</li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tls</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程思维</title>
    <url>/2020/04/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>函数式编程是一种编程范式，常见的编程范式有 <strong>命令式编程（Imperative programming）</strong>，<strong>函数式</strong>，<strong>逻辑式</strong>。在函数式编程中，函数是一等公民。函数可以在任何地方定义，可以作为参数，返回值等。下面从Python 或 Golang 为例介绍一下函数式编程。<br><a id="more"></a></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>介绍一下闭包（closure）。闭包和嵌套函数类似，不同的是，这里外部函数返回的是一个函数，而不是一个具体的值。返回的函数通常也被赋予一个变量。这个变量在后面会一直被执行调用。</p>
<p>外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象，这就是闭包的重要概念。</p>
<p>闭包在很多中语言中都可以使用，下面以Python 和 Golang 举例</p>
<h2 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h2><p>举例，计算一个数的 n次冥 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_power</span>(<span class="params">exponent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exponent_of</span>(<span class="params">base</span>):</span>        </span><br><span class="line">        <span class="keyword">return</span> base ** exponent    </span><br><span class="line">    <span class="keyword">return</span> exponent_of</span><br><span class="line"></span><br><span class="line">square = nth_power(<span class="number">2</span>)</span><br><span class="line">cube = nth_power(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(square(<span class="number">3</span>)) <span class="comment"># 3 的平方</span></span><br><span class="line">print(cube(<span class="number">2</span>))   <span class="comment"># 2 的立方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 输出</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>如果我们不使用闭包，代码写出来长什么样子呢？<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_power_rewrite</span>(<span class="params">base, exponent</span>):</span></span><br><span class="line">    <span class="keyword">return</span> base ** exponent</span><br><span class="line"></span><br><span class="line">print(nth_power_rewrite(<span class="number">3</span>, <span class="number">2</span>)) <span class="comment"># 3 的平方</span></span><br><span class="line">print(nth_power_rewrite(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># 2 的立方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 输出</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><p>举例， 斐波那契数列<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	a,b := <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		b = a + b</span><br><span class="line">		a = b</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := fib()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, a())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 输出</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">256</span> <span class="number">512</span> </span><br></pre></td></tr></table></figure><br>因为闭包的存在，我们仍然可以访问外部函数的变量对象。</p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>所谓的装饰器，其实就是通过装饰器函数，来修改原函数的一些功能，使得原函数不需要修改。最常见的使用场景有，登录状态检查，日志记录，程序执行时间记录。</p>
<p>如果多个函数在运行时都需要相同的检查、记录功能的话，就使用装饰器。</p>
<p>Python 在装饰器上有现成的使用语法，而 Golang 也可以按照其语法实现装饰器。</p>
<h2 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h2><h3 id="最简单的装饰器实现"><a href="#最简单的装饰器实现" class="headerlink" title="最简单的装饰器实现"></a>最简单的装饰器实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;wrapper of decorator&#x27;</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    greet()</span><br></pre></td></tr></table></figure>
<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">message</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;wrapper of decorator&#x27;</span>)</span><br><span class="line">        func(message)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;hello &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    greet(<span class="string">&#x27;kiosk&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="带自定义参数的装饰器"><a href="#带自定义参数的装饰器" class="headerlink" title="带自定义参数的装饰器"></a>带自定义参数的装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">message</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">                print(<span class="string">&#x27;wrapper of decorator&#x27;</span>)</span><br><span class="line">                func(message)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> my_decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">2</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;hello &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    greet(<span class="string">&#x27;kiosk&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>类装饰器主要依赖于函数 <strong>_<em>call_</em>()</strong> ，每当你调用一个类的示例时，函数<strong>_<em>call_</em>()</strong> 就会被执行一次。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.call_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.call_count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&#x27;num of calls is: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.call_count))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Count</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;hello &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    greet(<span class="string">&#x27;kiosk&#x27;</span>)</span><br><span class="line">    greet(<span class="string">&#x27;007&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="检查是否登录"><a href="#检查是否登录" class="headerlink" title="检查是否登录"></a>检查是否登录</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        request = args[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> check_user_logged_in(request):  <span class="comment"># 如果用户处于登录状态</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 执行函数post_comment() </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Authentication failed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_user_logged_in</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@authenticate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_comment</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="参数计算结果缓存"><a href="#参数计算结果缓存" class="headerlink" title="参数计算结果缓存"></a>参数计算结果缓存</h4><p>根据参数缓存每次函数调用结果，对于相同参数的，无需重新函数计算，直接返回之前缓存的返回值；比如计算 递归、动态规划 类的函数时，很多次的函数计算都是重复的。对于函数输入参数结相同的我们直接把计算结果可以缓存下来。</p>
<p><strong>不带结果缓存</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多次调用递归会很慢</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_execution_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_fib</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        print(i, <span class="string">&quot;:&quot;</span>, fibonacci(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run_fib()</span><br><span class="line">    </span><br><span class="line"><span class="comment">###</span></span><br><span class="line">...</span><br><span class="line"><span class="number">19</span> : <span class="number">4181</span></span><br><span class="line"><span class="number">20</span> : <span class="number">6765</span></span><br><span class="line">run_fib took <span class="number">5.2937360014766455</span> ms</span><br></pre></td></tr></table></figure><br><strong>带结果缓存</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 lru_cache 缓存输入参数相同的结果，直接返回结果</span></span><br><span class="line"><span class="meta">@functools.lru_cache()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_execution_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_fib</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        print(i, <span class="string">&quot;:&quot;</span>, fibonacci(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run_fib()</span><br><span class="line">    </span><br><span class="line"><span class="comment">### </span></span><br><span class="line">...</span><br><span class="line"><span class="number">19</span> : <span class="number">4181</span></span><br><span class="line"><span class="number">20</span> : <span class="number">6765</span></span><br><span class="line">run_fib took <span class="number">0.19091700232820585</span> ms</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="Golang-实现-1"><a href="#Golang-实现-1" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><h3 id="最简单的装饰器实现-1"><a href="#最简单的装饰器实现-1" class="headerlink" title="最简单的装饰器实现"></a>最简单的装饰器实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decorator</span><span class="params">(callFunc <span class="keyword">func</span>()</span>) <span class="title">func</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;wrapper of decorator&quot;</span>)</span><br><span class="line">		callFunc()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;hello wrold &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testFunc := decorator(greet)</span><br><span class="line">	testFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="http-示例"><a href="#http-示例" class="headerlink" title="http 示例"></a>http 示例</h3><blockquote>
<p>以下完全参考 左耳朵耗子 叔的代码。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithServerHeader</span><span class="params">(h http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;---&gt;WithServerHeader()&quot;</span>)</span><br><span class="line">		w.Header().Set(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;HelloServer v0.0.1&quot;</span>)</span><br><span class="line">		h(w, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAuthCookie</span><span class="params">(h http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;---&gt;WithAuthCookie()&quot;</span>)</span><br><span class="line">		cookie := &amp;http.Cookie&#123;Name: <span class="string">&quot;Auth&quot;</span>, Value: <span class="string">&quot;Pass&quot;</span>, Path: <span class="string">&quot;/&quot;</span>&#125;</span><br><span class="line">		http.SetCookie(w, cookie)</span><br><span class="line">		h(w, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithBasicAuth</span><span class="params">(h http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;---&gt;WithBasicAuth()&quot;</span>)</span><br><span class="line">		cookie, err := r.Cookie(<span class="string">&quot;Auth&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value != <span class="string">&quot;Pass&quot;</span> &#123;</span><br><span class="line">			w.WriteHeader(http.StatusForbidden)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		h(w, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDebugLog</span><span class="params">(h http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;---&gt;WithDebugLog&quot;</span>)</span><br><span class="line">		_ = r.ParseForm()</span><br><span class="line">		log.Println(r.Form)</span><br><span class="line">		log.Println(<span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line">		log.Println(<span class="string">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class="line">		log.Println(r.Form[<span class="string">&quot;url_long&quot;</span>])</span><br><span class="line">		<span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;key:&quot;</span>, k)</span><br><span class="line">			log.Println(<span class="string">&quot;val:&quot;</span>, strings.Join(v, <span class="string">&quot;&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		h(w, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Recieved Request %s from %s\n&quot;</span>, r.URL.Path, r.RemoteAddr)</span><br><span class="line">	_, _ = fmt.Fprintf(w, <span class="string">&quot;Hello, World! &quot;</span>+r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/v1/hello&quot;</span>, WithServerHeader(WithAuthCookie(hello)))</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/v2/hello&quot;</span>, WithServerHeader(WithBasicAuth(hello)))</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/v3/hello&quot;</span>, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个装饰器的-Pipeline"><a href="#多个装饰器的-Pipeline" class="headerlink" title="多个装饰器的 Pipeline"></a>多个装饰器的 Pipeline</h3><p>上述的装饰器需要一个函数套一个函数，很不好看，可以写一个工具函数——用来遍历并调用各个 decorator<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HttpHandlerDecorator <span class="function"><span class="keyword">func</span><span class="params">(http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(h http.HandlerFunc, decors ...HttpHandlerDecorator)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> decors &#123;</span><br><span class="line">        d := decors[<span class="built_in">len</span>(decors)<span class="number">-1</span>-i] <span class="comment">// iterate in reverse</span></span><br><span class="line">        h = d(h)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 调用</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/v4/hello&quot;</span>, Handler(hello,</span><br><span class="line">                WithServerHeader, WithBasicAuth, WithDebugLog))</span><br></pre></td></tr></table></figure></p>
<h3 id="泛型装饰器"><a href="#泛型装饰器" class="headerlink" title="泛型装饰器"></a>泛型装饰器</h3><p>和 Python 相比, Go 的装饰器没有办法做到泛型，也就是其代码耦合了需要被修饰的函数的接口类型，无法做到非常通用。</p>
<p>Go 语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go 语言支持的最大的泛型是 interface{} 还有比较简单的 reflection 机制。可以实现泛型<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decorator</span><span class="params">(decoPtr, fn <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> decoratedFunc, targetFunc reflect.Value</span><br><span class="line"> </span><br><span class="line">    decoratedFunc = reflect.ValueOf(decoPtr).Elem()</span><br><span class="line">    targetFunc = reflect.ValueOf(fn)</span><br><span class="line"> </span><br><span class="line">    v := reflect.MakeFunc(targetFunc.Type(),</span><br><span class="line">            <span class="function"><span class="keyword">func</span><span class="params">(in []reflect.Value)</span> <span class="params">(out []reflect.Value)</span></span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;before&quot;</span>)</span><br><span class="line">                out = targetFunc.Call(in)</span><br><span class="line">                fmt.Println(<span class="string">&quot;after&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;)</span><br><span class="line"> </span><br><span class="line">    decoratedFunc.Set(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码动用了 reflect.MakeFunc() 函数制出了一个新的函数其中的 targetFunc.Call(in) 调用了被修饰的函数。<br>上面这个 Decorator() 需要两个参数。</p>
<ul>
<li>第一个是出参 decoPtr ，就是完成修饰后的函数</li>
<li>第二个是入参 fn ，就是需要修饰的函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(a, b <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %s \n&quot;</span>, a, b)</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mybar := bar</span><br><span class="line">	_ = Decorator(&amp;mybar, bar)</span><br><span class="line">	mybar(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### </span><br><span class="line">before</span><br><span class="line">hello, world! </span><br><span class="line">after</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>More Info：</p>
<ul>
<li>参考 <a href="https://coolshell.cn/articles/17929.html">GO语言的修饰器编程</a></li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>自建 Nginx 部署</title>
    <url>/2020/04/18/%E8%87%AA%E5%BB%BA-Nginx-%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这段时间搭建自己的 <a href="http://nginx.org/">Nginx</a> 服务器，顺便总结回顾了一些运维相关的知识点，详细介绍了如何搭建一个企业级的高性能 Nginx 服务器。<br><a id="more"></a></p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ul>
<li>本机：Ubuntu 19.10</li>
<li>Nginx：tengine-2.3.2</li>
<li>部署脚本：<a href="https://github.com/weijiaxiang007/nginx_install">https://github.com/weijiaxiang007/nginx_install</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/weijiaxiang007/nginx_install.git</span><br></pre></td></tr></table></figure>
<h2 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h2><blockquote>
<p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器，也是今天的主角。</p>
</blockquote>
<p>各组件版本</p>
<ul>
<li>luajit=”LuaJIT-2.0.5”</li>
<li>openssl=”openssl-1.1.1f”</li>
<li>pcre=”pcre-8.44”</li>
<li>tengine=”tengine-2.3.2”</li>
<li>jemalloc=”jemalloc-5.2.1”</li>
</ul>
<p>nginx 部署脚本 <a href="https://github.com/weijiaxiang007/nginx_install/blob/master/install.sh">install.sh</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">$ <span class="built_in">cd</span> nginx_install</span><br><span class="line">$ bash install.sh</span><br></pre></td></tr></table></figure>
<p>默认安装用户为 work ，安装目录在 <code>/home/work/nginx</code>, 自定义虚拟主机可以放在 <code>/home/work/nginx/conf.d</code>。默认配置文件在<code>/home/work/nginx/conf/nginx.conf</code>。之后Nginx将作为一个出色的反向代理服务器，成为后面工作的主角。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx -V</span></span><br><span class="line">JXWServer version: JXWServer/2.3.2</span><br><span class="line">nginx version: nginx/1.17.3</span><br><span class="line">built by gcc 9.2.1 20191008 (Ubuntu 9.2.1-9ubuntu2) </span><br><span class="line">built with OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/home/work/nginx --error-log-path=/home/work/<span class="built_in">log</span>/nginx/nginx.log --add-module=./modules/ngx_http_upstream_dyups_module --add-module=./modules/ngx_http_concat_module --add-module=./modules/ngx_http_upstream_session_sticky_module --add-module=./modules/ngx_http_upstream_check_module --add-module=./modules/ngx_http_upstream_dynamic_module --add-module=./modules/ngx_http_lua_module --add-module=./modules/ngx_backtrace_module --add-module=./modules/ngx_http_reqstat_module --add-module=./modules/ngx_http_user_agent_module --add-module=./modules/ngx_multi_upstream_module --add-module=./modules/headers-more-nginx-module --add-module=./modules/ngx_cache_purge --add-module=./modules/ngx_devel_kit --add-module=./modules/echo-nginx-module --add-module=./modules/ngx_slab_stat --add-module=./modules/ngx_http_sysguard_module --add-module=./modules/ngx_http_upstream_consistent_hash_module --add-module=./modules/ngx_http_proxy_connect_module --add-module=./modules/ngx_http_upstream_keepalive_module --without-http_upstream_keepalive_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --without-mail_pop3_module --without-mail_imap_module --without-mail_smtp_module --with-http_sub_module --with-pcre=/tmp/nginx_install/pcre-8.44 --with-pcre-jit --with-openssl=/tmp/nginx_install/openssl-1.1.1f --with-openssl-opt=enable-shared --with-jemalloc=/tmp/nginx_install/jemalloc-5.2.1 --with-luajit-inc=/usr/<span class="built_in">local</span>/include/luajit-2.0 --with-luajit-lib=/usr/<span class="built_in">local</span>/lib --with-http_auth_request_module --with-http_stub_status_module --with-google_perftools_module --with-ld-opt=-ltcmalloc --with-http_secure_link_module</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="Bind-部署"><a href="#Bind-部署" class="headerlink" title="Bind 部署"></a>Bind 部署</h2><blockquote>
<p>BIND是一种开源的DNS（Domain Name System）协议的实现，包含对域名的查询和响应所需的所有软件。它是互联网上最广泛使用的一种DNS服务器，对于类UNIX系统来说，已经成为事实上的标准。</p>
</blockquote>
<p>我们搭建内网的dns服务器，不仅可以解析我们自定义的域名，也可以作为转发型\缓存型的DNS服务器解析其他公网域名。</p>
<p>部署版本</p>
<ul>
<li>bind9</li>
</ul>
<p>安装bind9<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install bind9 bind9utils bind9-doc</span><br></pre></td></tr></table></figure><br>bind9的配置文件默认在 <code>/etc/bind</code>。主配置文件被保存在下列文件中。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/<span class="built_in">bind</span>/named.conf</span><br><span class="line">/etc/<span class="built_in">bind</span>/named.conf.options</span><br><span class="line">/etc/<span class="built_in">bind</span>/named.conf.local</span><br></pre></td></tr></table></figure><br>我的部署脚本中有最简版的bind9配置文件模板，可以将 <code>./bind9/named.conf.options</code> 拷贝到 <code>/etc/bind/named.conf.options</code>。然后照着例子生成一个 <code>db.demo.com</code>的待解析的文件即可<br>对配置文件做下简单的介绍<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat named.conf.options</span></span><br><span class="line">...</span><br><span class="line">		forwarders &#123;</span><br><span class="line">                127.0.0.53;  // 对于公网域名，直接转发。并缓存记录</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //========================================================================</span><br><span class="line">        // If BIND logs error messages about the root key being expired,</span><br><span class="line">        // you will need to update your keys.  See https://www.isc.org/bind-keys</span><br><span class="line">        //========================================================================</span><br><span class="line">        dnssec-validation auto;  // 递归查询服务器上开启DNSSEC验证</span><br><span class="line"></span><br><span class="line">        max-cache-ttl 120;  </span><br><span class="line">        max-ncache-ttl 120;</span><br><span class="line">        version <span class="string">&quot;[no version.]&quot;</span>;</span><br><span class="line">        minimal-responses yes;</span><br><span class="line">        recursion yes;    // 允许递归查询，直接返回结果</span><br><span class="line">        allow-query &#123;any;&#125;;  // 允许所有主机查询</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>上述的例子是最简单的例子，没有引入复杂的视图，logging等概念，详情可以参考如下链接。如果这是本机访问的话，大可不必搭建bind服务器，可以直接写 <code>/etc/hosts</code></p>
<p>More Info:</p>
<ul>
<li><a href="https://wiki.ubuntu.org.cn/Bind9%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97#Repositories_.E8.BD.AF.E4.BB.B6.E5.BA.93">Bind9安装设置指南</a></li>
<li><a href="https://www.cnblogs.com/ibyte/p/5805548.html">DNS(三)DNS SEC(域名系统安全扩展)</a></li>
<li><a href="https://blog.csdn.net/zhiyuan_2007/article/details/48930449">bind9支持edns-client-subnet</a></li>
<li><a href="https://www.cnblogs.com/anpengapple/p/5877661.html">BIND简易教程（1）：安装及基本配置</a></li>
</ul>
<h2 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h2><p>为了能实现https访问当前的自定义的域名。需要自签证书，然后将自签证书导入到系统证书中。</p>
<p>自签证书工具</p>
<ul>
<li>openssl1.1.1k</li>
</ul>
<p>自签证书已经写好了脚本只需要简单的运行即可生成自签证书<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ssl</span><br><span class="line">$ bash create_ca.sh</span><br><span class="line">$ bash create_client_cert.sh --ou SRE --cn kiosk.io --email admin@kiosk.io</span><br></pre></td></tr></table></figure><br>ca的证书在 <code>./demoCA/cacert.pem</code><br>kiosk.io 的证书在 <code>./kiosk.io/kiosk.io.crt</code> ， key在 <code>./kiosk.io/kiosk.io.key</code> 的。拷贝至Nginx所在目录即可。<br>将ca证书加入系统证书中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo cp .&#x2F;demoCA&#x2F;cacert.pem &#x2F;usr&#x2F;local&#x2F;share&#x2F;ca-certificates&#x2F;cacert.crt</span><br><span class="line">$ sudo update-ca-certificates</span><br></pre></td></tr></table></figure><br>其实update-ca-certificates是一个shell脚本,命令的本质其实是将PEM格式的根证书内容附加到<strong>/etc/ssl/certs/ca-certificates.crt</strong>, 而<strong>/etc/ssl/certs/ca-certificates.crt</strong> 中本身就包含了系统自带的各种可信根证书。</p>
<p>当然在企业内网还可以签署 客户端证书，没有装客户端证书的用户将不能访问该站点。在Nginx的配置文件中加上如下配置。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssl_client_certificate ssl_certs/demoCA/cacert.pem;</span><br><span class="line">ssl_crl ssl_certs/demoCA/private/ca.crl;</span><br><span class="line">ssl_verify_client on;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>ssl_client_certificate就是客户端证书的CA证书了，代表此CA签发的证书都是可信的。<br>ssl_verify_client on;代表强制启用客户端认证，非法客户端(无证书，证书不可信)都会返回400错。</p>
</blockquote>
<p>特别注意ssl_crl这个配置，代表Nginx会读取一个CRL(Certificate Revoke List)文件，之前说过，可能会有收回用户权限的需求，因此我们必须有吊销证书的功能，产生一个CRL文件让Nginx知道哪些证书被吊销了即可。</p>
<p>需要收回签发证书时，只需要<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash ./revoke_cert.sh aaa.demo.com</span><br></pre></td></tr></table></figure><br>这个脚本会自动吊销他的签证文件crt，并且自动更新CRL文件。特别注意需要reload或restart nginx才能让nginx重新加载CRL。这样被吊销的证书将无法访问网站了。</p>
<p><strong>可能出现的问题</strong></p>
<ul>
<li>NET::ERR_CERT_COMMON_NAME_INVALID</li>
</ul>
<p>自建CA和自签证书文档，但是发现自己生成之后，将ca证书导入客户端之后，Chrome访问网站总是会出现该错误。</p>
<p>如果要通过 修改 openssl.cnf 来签发证书，除将上述配置直接改到 openssl.cnf 相应位置外，必须将配置中的 basicConstraints = CA:FLASE 改为 basicConstraints = CA:TRUE，否则修改不生效，这是其他教程没有提到的。</p>
<p>如果是域名证书，也可以在此可以添加多域名，如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim http.ext</span></span><br><span class="line">keyUsage = nonRepudiation, digitalSignature, keyEncipherment</span><br><span class="line">extendedKeyUsage = serverAuth, clientAuth</span><br><span class="line">subjectAltName=@SubjectAlternativeName</span><br><span class="line"></span><br><span class="line">[ SubjectAlternativeName ]</span><br><span class="line">DNS.1=test.com</span><br><span class="line">DNS.2=www.test.com</span><br></pre></td></tr></table></figure><br>extendedKeyUsage 可以指定证书目的，即用途，一般有：</p>
<ul>
<li>serverAuth：保证远程计算机的身份</li>
<li>clientAuth：向远程计算机证明你的身份</li>
<li>codeSigning：确保软件来自软件发布者，保护软件在发行后不被更改</li>
<li>emailProtection：保护电子邮件消息</li>
<li>timeStamping：允许用当前时间签名数据</li>
</ul>
<p>如果不指定，则默认为 所有应用程序策略</p>
<p>More Info:</p>
<ul>
<li><a href="https://kiosk.io/admin/#/posts/ck95p6zs90000sfc6frdv25ia">Ubuntu添加可信任根证书</a></li>
<li><a href="https://www.cnblogs.com/will-space/p/11913744.html">OpenSSL自签发自建CA签发SSL证书</a></li>
<li><a href="https://blog.dteam.top/posts/2018-06/nginx-ssl%E5%BF%AB%E9%80%9F%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC.html">Nginx SSL快速双向认证配置(脚本)</a></li>
<li><a href="https://vimsky.com/article/3608.html">如何将.pem转换为.crt和.key？</a></li>
</ul>
<h1 id="Nginx-配置文件"><a href="#Nginx-配置文件" class="headerlink" title="Nginx 配置文件"></a>Nginx 配置文件</h1><p>在<code>/home/work/nginx/conf.d/</code> 下新建<code>kiosk.io.conf</code><br>配置文件内容如下：<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span>  hexo_backend &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:4000</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span> kiosk.io http2;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">if</span> ($scheme != <span class="string">&quot;https&quot;</span>) &#123;</span><br><span class="line">    		<span class="attribute">return</span> <span class="number">301</span> https://$http_host$request_uri;</span><br><span class="line">  	&#125;</span><br><span class="line">	</span><br><span class="line">        <span class="attribute">access_log</span>  /home/work/log/nginx/https_kiosk.io.log jxjson;</span><br><span class="line">        <span class="attribute">error_log</span>   /home/work/log/nginx/ssl-<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate</span>         ssl/kiosk.io/kiosk.io.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>     ssl/kiosk.io/kiosk.io.key;</span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span>   <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_session_cache</span>  shared:SSL:<span class="number">80m</span>;</span><br><span class="line">        <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line">        <span class="attribute">ssl_protocols</span>   TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:DHE-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4;</span><br><span class="line">        <span class="attribute">ssl_stapling</span> <span class="literal">on</span>; </span><br><span class="line">        <span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>; </span><br><span class="line">        <span class="attribute">ssl_trusted_certificate</span> ssl/kiosk.io/kiosk.io.crt;</span><br><span class="line">        <span class="attribute">ssl_dhparam</span> ssl/dhparam.pem;</span><br><span class="line">                </span><br><span class="line">        <span class="attribute">ssl_early_data</span>     <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">&quot;max-age=31536000; includeSubdomains&quot;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> X-Content-Type-Options nosniff;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Early-Data $ssl_early_data;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Host  $host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP         $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-Proto $scheme;</span><br><span class="line">	</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://hexo_backend/;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">               <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>日志格式参考: <a href="https://adamtheautomator.com/nginix-logs/">https://adamtheautomator.com/nginix-logs/</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ops</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 QUIC 协议</title>
    <url>/2020/04/06/QUIC-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HTTP 3 ，它来了，<a href="https://www.fastvue.co/fastvue/blog/googles-quic-protocols-security-and-reporting-implications/">QUIC（quick udp internet connection “快速 UDP 互联网连接”）</a>正如其名一样，它就是快。其正在标准化为新一代的互联网传输协议。是由google提出的使用udp进行多路并发的传输协议。</p>
<p>如果想要网站在弱网情况下提升网络访问速度，那么QUIC将是一个不错的选择。<br><a id="more"></a></p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/gquic-stack.png" style="width:600px;height:400px"></p>
<h2 id="QUIC-概述"><a href="#QUIC-概述" class="headerlink" title="QUIC 概述"></a>QUIC 概述</h2><p>QUIC解决了什么问题呢？从上世纪90年代至今，互联网一直按照一成不变的模式发展着。使用ipv4进行路由，使用tcp进行连接层面的拥塞控制，并保证其传输的可靠性，使用tls层进行安全加密和身份验证，使用http进行应用的数据传输。<br>这么多年的发展，这些协议只是小部分或者细节上有了改变，tcp提出了几个新的拥塞控制算法，tls改变了加密方式，http层进化出了h2。但是互联网发展至今，网络传输的内容越来越大，用户对传输的时延，带宽提出越来越大的要求。<br>tcp虽然也在拥塞控制上提出了一些优秀的拥塞控制算法，如BBR但是限制于其对操作系统内核版本的要求，windows操作系统又支持不好等。导致想要切换成更高效的协议成本巨大。</p>
<p>这里列出几个主要的矛盾。</p>
<ol>
<li>协议历史悠久导致中间设备僵化。</li>
<li>依赖于操作系统的实现导致协议本身僵化。</li>
<li>建立连接的握手延迟大。</li>
<li>队头阻塞。</li>
</ol>
<p>QUIC孕育而生，其抛开了TCP直接采用UDP，如一些拥塞算法，可靠性保证机制，不再依赖操作系统内核，而是可以自定义。<br>QUIC 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：</p>
<ol>
<li>快速（0-RTT）建连，类似于TLS的false start和TCP的TFO。</li>
<li>集成的拥塞控制算法，可插拔。</li>
<li>高安全性，类似于TLS，QUIC的报文始终被加密和认证。 </li>
<li>避免队头阻塞的多路复用。</li>
<li>基于Connection ID 的连接迁移，减少与移动端的重复建联。</li>
<li>前向冗余纠错（using FEC – Forward Error Correction）。</li>
</ol>
<h3 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h3><h4 id="中间设备僵化和操作系统老旧"><a href="#中间设备僵化和操作系统老旧" class="headerlink" title="中间设备僵化和操作系统老旧"></a>中间设备僵化和操作系统老旧</h4><p>有些防火墙只允许通过 80 和 443，不放通其他端口。因为通信协议栈都是固化到操作系统中的，只能通过内核参数进行调整，但是这样的调整极其有限，如果想要新加协议，只能重新编译内核。而现实是，可能还有一些Centos5 还作为某些古董公司的线上服务器。另外，windows xp 可能还是某些事业单位的办公电脑上装的操作系统，尽管xp的时代已经过去20年了。</p>
<h4 id="建立连接的握手延迟大"><a href="#建立连接的握手延迟大" class="headerlink" title="建立连接的握手延迟大"></a>建立连接的握手延迟大</h4><p>知道一个首次https网站的访问都要有哪些步骤吗？dns解析需要1个RTT，TCP三次握手，HTTP 302 跳转 HTTPS又需要RTT，TCP重新握手。TLS握手再消耗2个。解析CA的DNS（因为浏览器获取到证书后，有可能需要发起 OCSP 或者 CRL 请求，查询证书状态）再对CA进行TCP握手，OCSP响应。密钥协商又是RTT。当然这种情况是最极端的，大部分情况下不是所有流程都需要走一遍的。</p>
<p>More info: <a href="https://developer.baidu.com/resources/online/doc/security/https-pratice-2.html">大型网站的 HTTPS 实践（二）— HTTPS 对性能的影响</a></p>
<h4 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h4><ul>
<li><code>HTTP1.1的队头阻塞</code> HTTP1.1 是一发一收，也就是第一个数据没响应之前不能发第二个请求。</li>
<li><code>TCP的队头阻塞</code> 一个数据包丢了，后面的数据就算都收到了，内核也不会将缓冲区的数据交给应用层。所以基于TCP的HTTP2 在处理4层的队头阻塞问题上也是无能为力。</li>
<li><code>TLS的队头阻塞</code> TLS 协议都是按照 record 来处理数据的，如果一个 record 中丢失了数据，也会导致整个 record 无法正确处理。这个目前也没有很好的解决方法。</li>
</ul>
<p>基于以上的原因，QUIC选择了UDP。没有了三次握手，在应用层面完成了传输的可靠性，拥塞控制还有TLS的安全性。只要应用软件的客户端和服务端支持就行，绕开了操作系统内核版本这个硬骨头。</p>
<h2 id="协议解析"><a href="#协议解析" class="headerlink" title="协议解析"></a>协议解析</h2><p>最早这一实验性协议由 Google 推出，并命名为 gQUIC，因此，IETF 草案中仍然保留了 QUIC 概念</p>
<ul>
<li>QUIC 层由<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-29">https://tools.ietf.org/html/draft-ietf-quic-transport-29</a> 描述，它定义了连接、报文的可靠传输、有序字节流的实现；</li>
<li>TLS 协议会将 QUIC 层的部分报文头部暴露在明文中，方便代理服务器进行路由。<a href="https://tools.ietf.org/html/draft-ietf-quic-tls-29">https://tools.ietf.org/html/draft-ietf-quic-tls-29</a> 规范定义了 QUIC 与 TLS 的结合方式；</li>
<li>丢包检测、RTO 重传定时器预估等功能由<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery-29">https://tools.ietf.org/html/draft-ietf-quic-recovery-29</a> 定义，目前拥塞控制使用了类似TCP New RENO 的算法，未来有可能更换为基于带宽检测的算法（例如BBR）；</li>
<li>基于以上 3 个规范，<a href="https://tools.ietf.org/html/draft-ietf-quic-http-29">https://tools.ietf.org/html/draft-ietf-quic-http-29</a> 定义了 HTTP 语义的实现，包括服务器推送、请求响应的传输等；</li>
<li>在 HTTP/2 中，由 HPACK 规范定义 HTTP 头部的压缩算法。由于 HPACK 动态表的更新具有时序性，无法满足 HTTP/3 的要求。在 HTTP/3 中，QPACK 定义 HTTP 头部的编码：<a href="https://tools.ietf.org/html/draft-ietf-quic-qpack-16。">https://tools.ietf.org/html/draft-ietf-quic-qpack-16。</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UDP Header</span><br><span class="line">Packet Header     -----</span><br><span class="line">QUIC Frame Header    --  TLS1.3</span><br><span class="line">HTTP3 Frame Header   -- </span><br><span class="line">HTTP Message      -----</span><br></pre></td></tr></table></figure>
<p>为了实现 多路复用、链接迁移、非队头阻塞等特性，QUIC必须做到多层定义，另外层与层之间要做到非强依赖。<br>这 3 层 Header 实现的功能各不相同：</p>
<ul>
<li>Packet Header 实现了可靠的连接。当 UDP 报文丢失后，通过 Packet Header 中的 Packet Number 实现报文重传。连接也是通过其中的 Connection ID 字段定义的；</li>
<li>QUIC Frame Header 不可跨越Packet，在无序的 Packet 报文中，基于 QUIC Stream 概念实现了有序的字节流，这允许 HTTP 消息可以像在 TCP 连接上一样传输；</li>
<li>HTTP/3 Frame Header 可跨越多个Packet,定义了 HTTP Header、Body 的格式，以及服务器推送、QPACK 编解码流等功能。</li>
<li>HTTP Message</li>
</ul>
<h3 id="如何实现连接迁移"><a href="#如何实现连接迁移" class="headerlink" title="如何实现连接迁移"></a>如何实现连接迁移</h3><p>Packet Header 可以细分为两种：Long Packet Header 用于首次建立连接；Short Packet Header 用于日常传输数据。</p>
<p><strong>Long Packet Header</strong><br>其中，Long Packet Header 的格式如下图所示：<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_longpacket.png" alt="quic_longpacket"></p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_longpacket_pcap.png" alt="quic_longpacket_pcap"></p>
<p>建立连接时，连接是由服务器通过 Source Connection ID 字段分配的，这样，后续传输时，双方只需要固定住 Destination Connection ID，就可以在客户端 IP 地址、端口变化后，绕过 UDP 四元组（与 TCP 四元组相同），实现连接迁移功能。下面是 <strong>Short Packet Header</strong> 头部的格式，这里就不再需要传输 Source Connection ID 字段了：</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_shortpacket.png" alt="quic_shortpacket"></p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_shortpacket_pcap.png" alt="quic_longpacket_pcap"></p>
<p><strong>Packet Number</strong> 是每个报文独一无二的序号，基于它可以实现丢失报文的精准重发。<strong>为了防范各类网络攻击 Packet Number 会被 TLS 层加密保护。自Packet以下基本实现了全加密，Packet层自己也实现了半加密（握手除外）</strong></p>
<h3 id="如何实现多路复用"><a href="#如何实现多路复用" class="headerlink" title="如何实现多路复用"></a>如何实现多路复用</h3><p>一个 Packet 报文中可以存放多个 QUIC Frame，所有 Frame 的长度之和不能大于 PMTUD（Path Maximum Transmission Unit Discovery，这是大于 1200 字节的值），你可以把它与 IP 路由中的 MTU 概念对照理解：</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_frame.png" alt="quic_frame"></p>
<p>每一个 Frame 都有明确的类型：如PADDING、PING等<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_frame_type.png" alt="quic_frame"></p>
<p>其中， <strong>0x08-0x0f 这 8 种 STREAM 类型的 Frame 用于传递 HTTP 消息</strong>，它的格式如下所示：</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_frame_stream.png" alt="quic_frame"></p>
<p>可见，Stream Frame 头部的 3 个字段，完成了多路复用、有序字节流以及报文段层面的二进制分隔功能，包括：</p>
<ul>
<li><p>Stream ID 定义了一个有序字节流。当 HTTP Body 非常大，需要跨越多个 Packet 时，只要在每个 Stream Frame 中含有同样的 Stream ID，就可以传输任意长度的消息。多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别；</p>
</li>
<li><p>消息序列化后的“有序”特性，是通过 Offset 字段完成的，它类似于 TCP 协议中的 Sequence 序号，用于实现 Stream 内多个 Frame 间的累计确认功能；</p>
</li>
<li><p>Length 指明了 Frame 数据的长度。</p>
</li>
</ul>
<p>0x08-0x0f 这 8 种类型其实是由 3 个二进制位组成，它们实现了以下 3 标志位的组合：</p>
<ul>
<li>第 1 位表示是否含有 Offset，当它为 0 时，表示这是 Stream 中的起始 Frame，这也是上图中 Offset 是可选字段的原因；</li>
<li>第 2 位表示是否含有 Length 字段；</li>
<li>第 3 位 Fin，表示这是 Stream 中最后 1 个 Frame，与 HTTP/2 协议 Frame 帧中的 FIN 标志位相同。</li>
</ul>
<p>Stream 数据中并不会直接存放 HTTP 消息，因为 HTTP/3 还需要实现服务器推送、权重优先级设定、流量控制等功能，所以 Stream Data 中首先存放了 <strong>HTTP/3 Frame</strong> (这里就相当于是HTTP2的FRAME了，如 HEADER 帧、DATA 帧 、 SETTINGS 帧等)：</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_http3.png" alt="quic_http3"></p>
<p>其中，Length 指明了 HTTP 消息的长度，而 Type 字段（低 2 位在 QPACK 实现上有特殊用途）。QUIC Stream Frame 定义了有序字节流，且多个 Stream 间的传输没有时序性要求。这样，HTTP 消息基于 QUIC Stream 就实现了真正的多路复用，队头阻塞问题自然就被解决掉了。</p>
<h3 id="如何阻塞队头阻塞"><a href="#如何阻塞队头阻塞" class="headerlink" title="如何阻塞队头阻塞"></a>如何阻塞队头阻塞</h3><p>其实上面的多路复用已经解决了一大半的对头阻塞问题。但实际上在H2时代除了 TCP 、TLS 的队头阻塞还有一个 HPACK 的动态表阻塞。</p>
<p>所谓动态表，就是将未包含在静态表中的 Header 项，在其首次出现时加入动态表，这样后续传输时仅用 1 个数字表示，大大提升了编码效率。因此，动态表是天然具备时序性的，如果首次出现的请求出现了丢包，后续请求解码 HPACK 头部时，一定会被阻塞！</p>
<p>QPACK 将动态表的编码、解码独立在单向 Stream 中传输，仅当单向 Stream 中的动态表编码成功后，接收端才能解码双向 Stream 上 HTTP 消息里的动态表索引。</p>
<p>QUIC Stream Frame 中的 Stream ID 别有玄机，除了标识 Stream 外，它的低 2 位还可以表达以下组合：<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_stream_id.png" alt="quic_stream"></p>
<p>当 Stream ID 是 0、4、8、12 时，这就是客户端发起的双向 Stream（HTTP/3 不支持服务器发起双向 Stream），它用于传输 HTTP 请求与响应。单向 Stream 有很多用途，所以它在数据前又多出一个 Stream Type 字段，当 Stream Type 为 </p>
<ul>
<li>0x02：用于编码 QPACK 动态表，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送动态表编码；</li>
<li>0x03：用于通知编码端 QPACK 动态表的更新结果。</li>
</ul>
<p>由于 HTTP/3 的 Stream 之间是乱序传输的，因此，若先发送的编码 Stream 后到达，双向 Stream 中的 QPACK 头部就无法解码，此时传输 HTTP 消息的双向 Stream 就会进入 Block 阻塞状态。 而单向流中的QUIC FRAME 会立马更新动态表内容。</p>
<blockquote>
<p>另外可以看到，QUIC的每一层之间都实现了良好的隔离性，这就意味着其实QUIC可以作为一个传输协议，上面不仅可以跑 HTTP协议，还可以用来跑raw data。就是剥离 HTTP3 层以上的数据即可。</p>
</blockquote>
<h2 id="QUIC核心特性"><a href="#QUIC核心特性" class="headerlink" title="QUIC核心特性"></a>QUIC核心特性</h2><h3 id="0RTT握手"><a href="#0RTT握手" class="headerlink" title="0RTT握手"></a>0RTT握手</h3><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_0rtt.gif" alt="quic_0rtt"></p>
<p>在HTTPS over TCP+TLS的时代。HTTPS需要3个RTT，在session 复用的情况下是2个RTT。而QUIC做到了1RTT和会话复用的0RTT。<br>QUIC的TLS只能使用TLS1.3，这就可以做到PSK的0RTT。</p>
<h3 id="改进的拥塞控制"><a href="#改进的拥塞控制" class="headerlink" title="改进的拥塞控制"></a>改进的拥塞控制</h3><p>TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复。其中TCP中拥塞控制是被编译进内核中的，如果想要更改就需要改变内核参数，但是想要对已有的拥塞控制算法进行更改就需要重新编译内核。QUIC用很多应用层实现的拥塞控制算法，想要修改是十分方便的。</p>
<h3 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h3><p>TCP和TLS由于设计都会存在队头阻塞的情况。</p>
<ul>
<li><code>TCP队头阻塞</code> 是由于传输的请求由于中间的报文没有收全，会一直重传，直到报文被重传成功，之后的数据才能接着传。</li>
<li><code>TLS队头阻塞</code> Record 是 TLS 协议处理的最小单位，最大不能超过 16K，Record由Encrypt和SSL Record Header组成， 一个Record可能是由多个TCP Segment组成，只要是Record中16KB有一个字节没有收到，整个TLS过程都无法完成。</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/tls_record.png" alt="tls_record"></p>
<ul>
<li><code>HPACK队头阻塞</code> Hpack是H2中提出的一个压缩传输体积的算法，但是HPACK是一个有时间顺序的算法。（上面已解释）</li>
</ul>
<p>基于UDP实现的QUIC，当丢包发生之后，不必等丢失的报文完全响应，可以将已经收到的响应交给上层处理。QUIC的解决思路如下</p>
<ul>
<li>QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。</li>
<li>Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。这是基于QUIC 的Packet Header 中的Connection Id 实现的。</li>
</ul>
<h3 id="加密认证的报文"><a href="#加密认证的报文" class="headerlink" title="加密认证的报文"></a>加密认证的报文</h3><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p>
<p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p>
<h3 id="基于-stream-和-connecton-级别的流量控制"><a href="#基于-stream-和-connecton-级别的流量控制" class="headerlink" title="基于 stream 和 connecton 级别的流量控制"></a>基于 stream 和 connecton 级别的流量控制</h3><p>QUIC 的流量控制类似 HTTP2，即在 Connection 和 Stream 级别提供了两种流量控制。</p>
<ul>
<li>Stream 可以认为就是一条 HTTP 请求。</li>
<li>Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</li>
</ul>
<p>QUIC 实现流量控制的原理比较简单：<br>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</p>
<p>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。</p>
<p>但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。</p>
<p>针对 QUIC Stream：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可用窗口数 &#x3D; 最大窗口数 - 接收到的最大偏移数</span><br></pre></td></tr></table></figure><br>针对 Connection：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可用窗口数 &#x3D; Stream1窗口 + Stream2窗口 + Stream3窗口 + SteamN窗口</span><br></pre></td></tr></table></figure></p>
<h3 id="更灵活的拥塞控制算法"><a href="#更灵活的拥塞控制算法" class="headerlink" title="更灵活的拥塞控制算法"></a>更灵活的拥塞控制算法</h3><p>QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，但是可以灵活的支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法</p>
<h4 id="单调递增的Package-Number"><a href="#单调递增的Package-Number" class="headerlink" title="单调递增的Package Number"></a>单调递增的Package Number</h4><p>TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。</p>
<p>QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/tcp_rt.jpg" style="width:600px;height:200px"></p>
<p>如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断。</p>
<p>如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小。</p>
<p>由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_rt.jpg" style="width:600px;height:200px"><br>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。</p>
<p>但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 Stream Offset 的概念。</p>
<p>即一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖。但是 Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。如错误! 未找到引用源。所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。</p>
<p>假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。</p>
<h4 id="更多的-Ack-块"><a href="#更多的-Ack-块" class="headerlink" title="更多的 Ack 块"></a>更多的 Ack 块</h4><p>TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。</p>
<p>由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节，所以留给 Sack 选项的只有 30 个字节。</p>
<p>每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block。</p>
<p>但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量。</p>
<h4 id="Ack-Delay-时间"><a href="#Ack-Delay-时间" class="headerlink" title="Ack Delay 时间"></a>Ack Delay 时间</h4><p>Tcp 的 Timestamp 选项存在一个问题，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。这样就会导致RTT计算误差</p>
<p><img src="https://img1.kiosk007.top/static/images/network/QUIC/ack_delay.jpg" style="width:600px;height:300px"></p>
<p>可以认为 TCP 的 RTT 计算：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTT &#x3D; timestamp1 - timestamp2 </span><br></pre></td></tr></table></figure><br>QUIC 的 RTT 计算：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTT &#x3D; timestamp1 - timestamp2 - Ack Delay</span><br></pre></td></tr></table></figure><br>当然具体还得基于采样和历史数据综合计算。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651000241&amp;idx=2&amp;sn=2b6e9426d15099c799c1d0a34d3877d4&amp;chksm=bdbef5e28ac97cf4207ebcb8d119eafc96d590e167921bbc29b180210321a9d21d5c38c44f77&amp;scene=27#wechat_redirect">科普：QUIC协议原理分析
</a></p>
<p>[2] <a href="https://www.sohu.com/a/126685728_355140">腾讯HTTPS优化性能实践</a></p>
<p>[3] <a href="https://www.infoq.cn/article/Iiv7uzf6ayb9jsxWqkbe">QUIC 协议在腾讯的实践和优化
</a></p>
<p>[4] <a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=1309">技术扫盲-新一代的基于UDP的低延时网络传输协议</a></p>
<p>[5] <a href="http://www.alloyteam.com/2020/05/14385/">HTTP3原理与实践</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>QUIC</tag>
      </tags>
  </entry>
  <entry>
    <title>TIME_WAIT 问题解决</title>
    <url>/2020/04/06/TIME_WAIT%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用服务器通过发起 TCP 连接其他服务器时，如代理服务器需要请求上游服务器，每个连接会占用一个连接发起方端口，在高并发场景下，可能会导致端口耗尽。同时连接主动关闭方为了TCP正常断开连接，TCP 主动关闭方为了确保最后一个ACK能够达到被动关闭方，所以会等待2MSL。在等待期间该端口就会处于 <a href="https://benohead.com/blog/2013/07/21/tcp-about-fin_wait_2-time_wait-and-close_wait/">TIME_WAIT</a> 状态。<br><a id="more"></a></p>
<p><strong>MSL (maximum segment lifetime)</strong>：LINUX 的硬编码字段，名称为 TCP_TIMEWAIT_LEN，值为60s，而一个time_wait 默认等待的时间为 2MSL</p>
<h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ol>
<li>内存资源占用，内存资源的占用不是很严重，可暂且忽略</li>
<li>端口资源占用，一个TCP连接需要消耗一个本地端口，一般可开启的端口为32768 ～ 61000。</li>
</ol>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="net-ipv4-ip-local-port-range"><a href="#net-ipv4-ip-local-port-range" class="headerlink" title="net.ipv4.ip_local_port_range"></a>net.ipv4.ip_local_port_range</h4><p>调大主动建联时的端口范围</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo sysctl -w net.ipv4.ip_local_port_range=<span class="string">&quot;1024 65000&quot;</span></span><br></pre></td></tr></table></figure>
<p>or<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># increase system IP port limits</span></span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br></pre></td></tr></table></figure><br>More info: <a href="https://mozillazg.com/2019/05/linux-what-net.ipv4.ip_local_port_range-effect-or-mean.html">ip_local_port_range</a></p>
<p> 但是这种方案治标不治本</p>
<h4 id="net-ipv4-tcp-max-tw-buckets"><a href="#net-ipv4-tcp-max-tw-buckets" class="headerlink" title="net.ipv4.tcp_max_tw_buckets"></a>net.ipv4.tcp_max_tw_buckets</h4><p>此值默认是 18000，当系统中处于 TIME_WAIT 的连接大于该值后，系统会将所有的 TIME_WAIT 连接重置，并打印出警告信息。这个方法过于暴力，解决的问题比带来的问题多，不建议使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo sysctl -w net.ipv4.tcp_max_tw_buckets = 55000</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://sysctl-explorer.net/net/ipv4/tcp_max_tw_buckets/">tcp_max_tw_buckets</a></p>
<h4 id="调低-TCP-TIMEWAIT-LEN，重新编译系统"><a href="#调低-TCP-TIMEWAIT-LEN，重新编译系统" class="headerlink" title="调低 TCP_TIMEWAIT_LEN，重新编译系统"></a>调低 TCP_TIMEWAIT_LEN，重新编译系统</h4><p>得编译内核，而且TCP发明至今这些固化到内核的参数都是有一定道理的，不要乱改。</p>
<h4 id="SO-LINGER-设置"><a href="#SO-LINGER-设置" class="headerlink" title="SO_LINGER 设置"></a>SO_LINGER 设置</h4><p>在应用程序中设置套接字选项，调用close 或者 shutdown 关闭连接时候的行为。是用来设置 <strong>延迟关闭</strong> 的选项。</p>
<p>等待套接字发送缓冲区中的数据发送完成。没有设置该选项时，在调用close()后，在发送完FIN后会立即进行一些清理工作并返回。如果设置了SO_LINGER选项，并且等待时间为正值，则在清理之前会等待一段时间。</p>
<p>SO_LINGER 的一个作用就是用来减少TIME_WAIT套接字的数量。在设置SO_LINGER选项时，指定等待时间为0，此时调用主动关闭时不会发送FIN来结束连接，而是直接将连接设置为CLOSE状态，清除套接字中的发送和接收缓冲区，直接对对端发送RST包。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">　<span class="keyword">int</span>　 l_onoff;　　　　<span class="comment">/* 0=off, nonzero=on */</span></span><br><span class="line">　<span class="keyword">int</span>　 l_linger;　　　　<span class="comment">/* linger time, POSIX specifies units as seconds */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>onoff: linger 的开关<ul>
<li>l_onoff 为 0：关闭linger 选项，默认行为，close 或 shutdown 立即返回，如果在套接字发送缓冲区有数据残留，系统会将试着把这些数据都发送出去</li>
<li>l_onoff 为 1：打开linger 选项，具体行为看 l_linger<ul>
<li>l_linger 为0：调用close后，立即发送一个RST标志给对端，该TCP跳过四次挥手，直接关闭，这种方式被称为“强行关闭”，这种情况下，排队的数据不会被发送，被动关闭方也不知道对端已经彻底断开，只有当被动关闭方正阻塞在recv() 调用上，接受到 RST 时，会立刻得到一个 “connect reset by peer”的异常。</li>
<li>l_linger 为1：调用close后，调用close的线程将阻塞，直到数据都被发送出去，或者设置 l_linger 的计时时间到。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SO_LINGER选项的作用是等待发送缓冲区中的数据发送完成，但是并不保证发送缓冲区中的数据一定被对端接收（对端宕机或线路问题），只是说会等待一段时间让这个过程完成。如果在等待的这段时间里接收到了带数据的包，还是会给对端发送RST包，并且会reset掉套接字，因为此时已经关闭了接收通道。</p>
<p>More info <a href="https://www.cnblogs.com/javawebsoa/p/3201324.html">SO_LINGER</a></p>
<h4 id="net-ipv4-tcp-tw-reuse-更安全的设置"><a href="#net-ipv4-tcp-tw-reuse-更安全的设置" class="headerlink" title="net.ipv4.tcp_tw_reuse : 更安全的设置"></a>net.ipv4.tcp_tw_reuse : 更安全的设置</h4><p>从协议角度理解如果是安全的话，可以复用处于 TIME_WAIT 的套接字为新的连接所用。</p>
<p>这里的协议角度 的安全是指：<br>只适用与连接的发起方，即客户端<br>对应的TIME_WAIT 状态的连接创建时间超过1s才可以被复用。</p>
<p>使用的这个选项的前提，需要打开对TCP时间戳的支持。<br>即 net.ipv4.tcp_timestamps = 1 （默认即为1），重复的数据包会因为时间戳过期被自然丢弃。</p>
<p>More info <a href="https://sysctl-explorer.net/net/ipv4/tcp_tw_reuse/">tcp_tw_reuse</a></p>
<p> <strong>同时这个也是最推荐的设置</strong></p>
<h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h4><p>这个比较特殊，网上有很多教程都说拿这个解决 TIME_WAIT，其实是对的，但是不是一回事。为什么？</p>
<p>前面解决的问题都是客户端角度没有新端口去建联了，而这个是服务端挂了重启服务后，监听的端口处于TIME_WAIT 的解决方案</p>
<p>这个是解决端口复用问题的，并不是解决 TIME_WAIT ，这个是告诉内核，即使TIME_WAIT 的套接字，也可以作为新的套接字使用，这是为了避免服务端监听端口时，因为被监听的端口处于 TIME_WAIT 导致服务端无法启动。<br>其本质是解决 服务端 监听端口时的 TIME_WAIT ，而我们上面一直说的是作为客户端建联时没有足够的随机端口导致的无法建联。</p>
<p>More info <a href="https://www.jianshu.com/p/141aa1c41f15">SO_REUSEADDR</a></p>
<h4 id="终极解决方案：-长连接"><a href="#终极解决方案：-长连接" class="headerlink" title="终极解决方案： 长连接"></a>终极解决方案： 长连接</h4><p>既然代理服务器需要与后端上游服务器通信，最好保持好长连接，连接复用。不然反复的新建连接，握手也是一种消耗。</p>
<p>但是仅限内网这么搞，公网的话，一条连接总是不断，运营商可能会搞些小动作，给你限个速。</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>socket编程</tag>
        <tag>TCP协议</tag>
      </tags>
  </entry>
</search>
