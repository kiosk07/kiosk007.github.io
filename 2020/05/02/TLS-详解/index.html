<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="TLS 详解（一）"><meta name="keywords" content="tls"><meta name="author" content="kiosk"><meta name="copyright" content="kiosk"><title>TLS 详解（一） | kiosk007's Blog</title><link rel="shortcut icon" href="/img/favicon-16x16-dragon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f3d277b6c83066a05a8b7db067b2308";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="kiosk007's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TLS-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">TLS 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">TLS的设计目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">1.2.</span> <span class="toc-text">TLS的发展历史</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TLS-CipherSuite"><span class="toc-number">2.</span> <span class="toc-text">TLS CipherSuite</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-number">2.1.</span> <span class="toc-text">非对称加密&#x2F;密钥交换&#x2F;身份验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA-%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">RSA 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eopenssl%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81RSA"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">基于openssl实战验证RSA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RSA-%E6%8F%A1%E6%89%8B"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">RSA 握手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DH%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.1.2.</span> <span class="toc-text">DH密钥交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DH-%E6%8F%A1%E6%89%8B"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">DH 握手</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E6%B6%88%E6%81%AF%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-number">2.2.</span> <span class="toc-text">对称加密&#x2F;消息身份验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XOR-%E4%B8%8E-%E5%A1%AB%E5%85%85"><span class="toc-number">2.2.1.</span> <span class="toc-text">XOR 与 填充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ECB-Electronic-codebook-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">ECB(Electronic codebook) 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CBC-Cipher-block-chaining-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">CBC(Cipher-block chaining) 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CTR%EF%BC%88Counter%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">CTR（Counter）模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">GCM（Galois Counter Mode）模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES-Advanced-Encryption-Standard-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">AES(Advanced Encryption Standard) 加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AES-%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">AES 加密流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TLS%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">TLS的分层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#record-protocol"><span class="toc-number">3.1.</span> <span class="toc-text">record protocol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handshake-protocol"><span class="toc-number">3.2.</span> <span class="toc-text">handshake protocol</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">参考：</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img1.kiosk007.top/static/images/avatar.jpg"></div><div class="author-info__name text-center">kiosk</div><div class="author-info__description text-center">NoOps</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/weijiaxiang007">Ordinary But Great</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img1.kiosk007.top/static/images/background_1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">kiosk007's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">TLS 详解（一）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/network/">network</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5.2k</span><span class="post-meta__separator">|</span><span>Reading time: 18 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>TLS的设计目标是构建一个安全传输层（Transport Layer Security ），在基于连接的传输层（如tcp）之上提供安全加密的通信信道。它是旨在防止窃听，篡改和消息伪造的 <a target="_blank" rel="noopener" href="https://mailarchive.ietf.org/arch/msg/ietf-announce/IhM9JJHVs_ZeK-_1eaVZrqxbnL8/">IETF</a> 标准。常见应用程序包括Web浏览器，即时消息传递，电子邮件和IP语音都在使用TLS。</p>
<blockquote>
<p>Title From <a target="_blank" rel="noopener" href="https://www.networkworld.com/article/2303073/lan-wan-what-is-transport-layer-security-protocol.html">What is Transport Layer Security (TLS)?</a><br><a id="more"></a></p>
</blockquote>
<hr>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/encript-for-security.jpg" style="height:450px"></p>
<ul>
<li><a href="https://kiosk007.top/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/">TLS 详解（一）</a></li>
<li><a href="https://kiosk007.top/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/">TLS 详解（二）</a></li>
</ul>
<h1 id="TLS-简介"><a href="#TLS-简介" class="headerlink" title="TLS 简介"></a>TLS 简介</h1><p>下面主要介绍一下TLS的设计目标和发展历史。</p>
<h2 id="TLS的设计目标"><a href="#TLS的设计目标" class="headerlink" title="TLS的设计目标"></a>TLS的设计目标</h2><p>TLS用于两个应用程序之间提供保密性和数据完整性。一个TLS需要满足(1)、密码学安全 (2)、互操作，通用性 (3)、高效性 (4)、可扩展性 才能称为一个合格的TLS。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/TLS.png"></p>
<h2 id="TLS的发展历史"><a href="#TLS的发展历史" class="headerlink" title="TLS的发展历史"></a>TLS的发展历史</h2><ul>
<li>1994: <strong>SSL 1.0</strong>, 由Netscape提出，但未公开。</li>
<li>1995: <strong>SSL 2.0</strong>, 由Netscape提出，这个版本由于设计缺陷，并不安全，很快被发现有严重漏洞，已经废弃。</li>
<li>1996: <strong>SSL 3.0</strong>. 作为 RFC 6101 发布。2015年后已经不安全，必须禁用。</li>
<li>1999: <strong>TLS 1.0</strong>. 互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版.</li>
<li>2006: <strong>TLS 1.1</strong>. 作为 RFC 4346 发布。主要fix了CBC模式相关的如BEAST攻击等漏洞</li>
<li>2008: <strong>TLS 1.2</strong>. 作为RFC 5246 发布 ，增进安全性。此版本中的一个主要新功能是<strong>身份验证（AEAD）加密</strong>，它消除了对流和分组密码的需要（因而消除了固有的易受攻击的CBC模式）。</li>
<li>2011: 正式弃用SSL 2.0，IETF尝试通过发布RFC 6176正式弃用SSL v2 。根据SSL Labs的调查，2011年有54％的HTTPS服务器支持此过时的协议版本。</li>
<li>2013-2014: 多个针对TLS漏洞攻击手段相继爆出和同期发生的棱镜门事件也改变了人们对互联网安全的看法<ul>
<li>AlFardan和Paterson发布了<a target="_blank" rel="noopener" href="http://www.isg.rhul.ac.uk/tls/Lucky13.html">pLucky 13</a>，他们对CBC套件的攻击。在TLS中，块加密旨在对纯文本（而不是密文）进行身份验证，这为攻击者提供了执行填充oracle攻击的机会。</li>
<li>发现了<a target="_blank" rel="noopener" href="http://www.isg.rhul.ac.uk/tls/">针对RC4的新攻击</a>。以前，人们认为RC4弱点对TLS的影响不大，但这被证明是错误的。这项研究标志着RC4的死亡。</li>
<li>爱德华·斯诺登（Edward Snowden）向英国卫报记者发布了数千份美国国家安全局（NSA）分类文件，从而永远改变了公众对互联网的看法。</li>
<li><a target="_blank" rel="noopener" href="http://dualec.org/">Dual EC DRBG</a> (由NIST标准化生成和推广的伪随机数）被认为是潜在的后门。</li>
<li>一项名为<a target="_blank" rel="noopener" href="https://mitls.org/pages/attacks/3SHAKE">“三重握手攻击”</a>的新研究已经发布，TLS中的重新协商需要再次修复。</li>
<li><a target="_blank" rel="noopener" href="http://heartbleed.com/">“心脏出血攻击（heartbleed）”</a>发现了OpenSSL（一个使用非常广泛的TLS库）中的一个严重漏洞。</li>
<li><a target="_blank" rel="noopener" href="https://blog.qualys.com/ssllabs/2014/12/08/poodle-bites-tls">POODLE TLS</a>一些在SSL3.0 的填充攻击，即使TLS 1.0确实具有针对填充oracle攻击的内置防护，但某些实现仍无法正确避免。</li>
</ul>
</li>
<li>2015：TLS证书的不安全再次让互联网安全遭受打击，各机构再次出击。<ul>
<li>从2015-2016，Apple，Chrome和Mozilla 相继因为一些CA机构违反规则等问题选择不再信任 WoSign、StartCom，2016年Chrome又宣布取消对Symantec（赛门铁克）证书的信任。DigiCert收购Symantec后，各厂商恢复信任Symantec</li>
<li>由于多家CA机构存在乱签发CA的行为，经过多年的讨论，发布了<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7469">RFC 7469</a>，使任何人都可以使用公钥固定来保护自己免受欺诈性颁发的证书的侵害。</li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7633">RFC 7633</a> 中发布了新的X.509扩展，以将具有某些TLS功能的证书耦合在一起。这是一项迫切需要的功能，它在信任证书之前需要有效的OCSP响应。</li>
</ul>
</li>
<li>2018: <strong>TLS 1.3</strong>，支持0-rtt，大幅增进安全性，砍掉了AEAD之外的加密方式</li>
</ul>
<p>From [@SSL/TLS and PKI History][3]</p>
<h1 id="TLS-CipherSuite"><a href="#TLS-CipherSuite" class="headerlink" title="TLS CipherSuite"></a>TLS CipherSuite</h1><p>加密套间一般在 TLS 握手时协商得出，之后的整个加密过程都遵循套件的约定进行加密通信，每个集合的名称代表组成它的特定算法。</p>
<p>以TLS1.2中最常见的 <strong><code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code></strong> 为例。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/tls_ciphersuite.png" style="height:200px"></p>
<ul>
<li><code>密钥交换算法</code> -规定交换对称密钥的方式；</li>
<li><code>身份验证算法</code> -指示如何执行服务器身份验证和（如果需要）客户端身份验证。 </li>
<li><code>对称加密算法</code> -指示将使用哪种对称密钥算法来加密实际数据；包含对称加密算法、强度、工作模式。</li>
<li><code>消息身份验证代码（MAC）算法</code> -指示连接将用于执行数据完整性检查的方法。</li>
</ul>
<p>在tls的世界有许多密码学名词，组合在一起就成了密码套件。</p>
<ol>
<li>块加密算法 block cipher : AES, Serpent, 等</li>
<li>流加密算法 stream cipher: RC4，ChaCha20 等</li>
<li>Hash函数 hash funtion:MD5，sha1，sha256，sha512 , ripemd 160，poly1305 等</li>
<li>消息验证码函数 message authentication code: HMAC-sha256，AEAD 等</li>
<li>密钥交换 key exchange: DH，ECDH，RSA，DHE，ECDHE 等</li>
<li>公钥加密 public-key encryption: RSA，rabin-williams 等</li>
<li>数字签名算法 signature algorithm: RSA，DSA，ECDSA 等</li>
<li>密码衍生函数 key derivation function: TLS-12-PRF(SHA-256) , bcrypto，scrypto，pbkdf2 等</li>
</ol>
<h2 id="非对称加密-密钥交换-身份验证"><a href="#非对称加密-密钥交换-身份验证" class="headerlink" title="非对称加密/密钥交换/身份验证"></a>非对称加密/密钥交换/身份验证</h2><p>非对称加密是一种使用公钥和私钥加解密的算法，一段明文如果用公钥加密，只能用私钥解密。如果用私钥加密，只能用公钥解密。公钥可以公开，但是私钥只能是一方保存。</p>
<h3 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h3><p><strong>一. 随机选择两个不相等的质数 p 和 q , p 与 q 越大，越安全</strong></p>
<p>比如 P = 67 ，Q = 71。计算他们的乘积 n = P * Q = 4757 ，转化为二进为 1001010010101，该加密算法即为 13 位，实际算法是 1024 位 或 2048 位，位数越长，算法越难被破解。</p>
<p><strong>二. 计算 p 和 q 的乘积 n, 并计算 n 的欧拉函数 φ(n)</strong></p>
<p>φ(n) 表示在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。例如：在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果 n = P <em> Q，P 与 Q 均为质数，则 φ(n) = φ(P </em> Q)= φ(P - 1)φ(Q - 1) = (P - 1)(Q - 1) 。 本例中 φ(n) = 66 * 70 = 4620，这里记为 m， m = φ(n) = 4620</p>
<p><strong>三. 随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质</strong></p>
<p>公约数只有 1 的两个整数，叫做互质整数，这里我们随机选择 e = 101 请注意不要选择 4619，如果选这个，则公钥和私钥将变得相同。</p>
<p><strong>四. 计算模反元素 d，可以使得 e*d 除以 m 的余数为 1。</strong> </p>
<p>即找一个整数 d，使得  (e <em> d ) % m = 1。 等价于 e </em> d - 1 = y <em> m ( y 为整数） 找到 d ，实质就是对下面二元一次方程求解。 e </em> x - m * y =1 ，其中 e = 101，m = 4620 101x - 4620y =1  这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。 总之算出一组整数解（x，y ）= （ 1601，35），即 d = 1601。 到此密钥对生成完毕。不同的 e 生成不同的 d，因此可以生成多个密钥对。本例中公钥为 （n，e) = (4757 , 101)，私钥为 （n，d) = (4757 ，1601) ，仅（n，e) = (4757 , 101) 是公开的，其余数字均不公开。可以想像如果只有 n 和 e，如何推导出 d，目前只能靠暴力破解，位数越长，暴力破解的时间越长。</p>
<p><strong>RSA 加密解密流程</strong></p>
<ul>
<li>加密：c=$m^k\pmod n$  </li>
<li><p>解密：m=$c^d\pmod n$   </p>
<p>m 是明文，c 是密文</p>
</li>
</ul>
<blockquote>
<p>缺点： RSA 不具备前向保密性，也就是加密的通信所依赖的 Pre Master Key 是基于公钥加密，私钥解密的。如果私钥丢失，前面加密过的会话如果被保存下来，都可以用泄漏的私钥还原的。</p>
</blockquote>
<h4 id="基于openssl实战验证RSA"><a href="#基于openssl实战验证RSA" class="headerlink" title="基于openssl实战验证RSA"></a>基于openssl实战验证RSA</h4><ul>
<li>待加密的明文</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>生成私钥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl genrsa -out private.pem</span><br></pre></td></tr></table></figure>
<ul>
<li>从私钥中提取公钥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl rsa -<span class="keyword">in</span> private.pem -pubout -out public.pem</span><br></pre></td></tr></table></figure>
<ul>
<li>加密</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl rsautl -encrypt -<span class="keyword">in</span> hello.txt -inkey public.pem -pubin -out hello.en</span><br></pre></td></tr></table></figure>
<ul>
<li>解密</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl rsautl -decrypt -<span class="keyword">in</span> hello.en  -inkey private.pem -out hello.de</span><br><span class="line">➜ cat hello.de</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h4 id="RSA-握手"><a href="#RSA-握手" class="headerlink" title="RSA 握手"></a>RSA 握手</h4><p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ssl_handshake_rsa.jpg
" style="height:600px"></p>
<h3 id="DH密钥交换"><a href="#DH密钥交换" class="headerlink" title="DH密钥交换"></a>DH密钥交换</h3><p>1976年有 Bailey Whitfield Diffe 和 Martin Edward Hellman 首次发表，所以也被称作 Diffie-Hellman key exchange，简称DH。可以让双方在完全没有对方任何预先信息的条件下建立一个密钥。所以其具备向前安全性。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/Diffie-Hellman.png
" style="height:200px"></p>
<ul>
<li>g、p、A、B 公开。A 为 Alice 的公钥，B 为 Bob 的公钥</li>
<li>a、b 保密。 a 为 Alice 的私钥匙，b 为 Alice 的私钥匙</li>
</ul>
<p><strong>DH 密钥交换协议举例</strong></p>
<ul>
<li>协定使用 p=23 以及 g=5</li>
<li>Alice选择密钥 a=6, 计算公钥 $A=g^a\pmod p$ ,并发送给Bob (A=$5^6\pmod{23} = 8$)</li>
<li>Bob 选择密钥 b=15，计算公钥 $B=g^b\pmod p$ ,并发送给Alice (A=$5^{15}\pmod{23} = 19$)</li>
<li>Alice 计算 $s=B^a\pmod p$ (s=$19^6\pmod{23}=2$)</li>
<li>Bob 计算 $s=A^b\pmod p$ (s=$8^{15}\pmod{23}=2$)</li>
</ul>
<blockquote>
<p>缺点：大数乘法运算，速度很慢。实际使用的大多都是 ECDH 交换算法，也就是ECC椭圆曲线+DH</p>
</blockquote>
<p><strong>ECDH</strong><br>ECDH 是椭圆曲线的（DH）笛福赫尔曼算法的变种，它其实不单单是一种加密算法，而是一种密钥协商协议，也就是说 ECDH 定义了（在某种程度上）密钥怎么样在通信双方之间生成和交换，至于使用这些密钥怎么样来进行加密完全取决通信双方。</p>
<p>ECDH比DH计算更快，同等安全程度下，密钥比DH更短。</p>
<h4 id="DH-握手"><a href="#DH-握手" class="headerlink" title="DH 握手"></a>DH 握手</h4><p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ssl_handshake_diffie_hellman.jpg
" style="height:600px"></p>
<h2 id="对称加密-消息身份验证"><a href="#对称加密-消息身份验证" class="headerlink" title="对称加密/消息身份验证"></a>对称加密/消息身份验证</h2><p>对称加密是一种使用单个密钥对数据进行加密（编码）和解密（解码）的加密方法。其明文的加密使用的是相同的一把密钥。</p>
<h3 id="XOR-与-填充"><a href="#XOR-与-填充" class="headerlink" title="XOR 与 填充"></a>XOR 与 填充</h3><p>对称加密的基本原理是XOR (异或运算)。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/XOR.png" style="height:200px"><br>但是密钥和明文存在长度不一致的情况。为了将密钥和明文对齐，这就引入了分组的概念，对称加密中分为块加密和流式加密。以块加密为例。</p>
<p>Block cipher 加密方式：将明文分为多个等长的Block块，再对每个模块分别加解密。若当最后一个明文block模块长度不够时，需要引入填充算法进行填充。<br>填充方案</p>
<ul>
<li>位填充：以bit为单位填充</li>
<li>字节填充：以字节为单位填充<ul>
<li>补零：缺少字节数全部补0</li>
<li>ANSI X9.23: 全部填0，但最后一个字节需要补充总共填写0个个数</li>
<li>ISO 10126：完全随即字符，但最后一个字节需要补充总共填写随即字符个数 </li>
<li>PKCS7（RFC5652）：全部填充缺省的字节个数，如缺4个字节，填4个04</li>
</ul>
</li>
</ul>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="ECB-Electronic-codebook-模式"><a href="#ECB-Electronic-codebook-模式" class="headerlink" title="ECB(Electronic codebook) 模式"></a>ECB(Electronic codebook) 模式</h4><p>ECB是DES的最简单和最弱的形式。它不使用初始化向量, 直接将明文分解为多个块，对每个块作独立的加密。其最致命的弱点就是无法隐藏数据特征。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ECB.jpg" style="height:400px"><br>图a 是加密前的明文， 图b 是ECB加密后的密文。可以看出，加密根本没有什么用处。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/ECB_encryption.png" style="height:250px"></p>
<p>以下是zoom在其加密白皮书（2020）上所宣传的，其实很不安全。</p>
<blockquote>
<p>For use cases such as meeting real-time content (video, voice, and content share), where data is transmitted over User<br>Datagram Protocol (UDP), we use AES-256 in ECB mode to encrypt these compressed data streams. We expect to upgrade<br>this soon to AES-256 GCM. Additionally, for video, voice, and content share encrypted with AES, once it’s encrypted, it<br>remains encrypted as it passes through Zoom’s meeting servers until it reaches another Zoom Client or a Zoom Connector,<br>which helps translate the data to another protocol.</p>
</blockquote>
<p>Link: <a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/644f4ed6b8a84286cc9f74ebc">Zoom的加密算法，到底有什么问题？</a></p>
<h4 id="CBC-Cipher-block-chaining-模式"><a href="#CBC-Cipher-block-chaining-模式" class="headerlink" title="CBC(Cipher-block chaining) 模式"></a>CBC(Cipher-block chaining) 模式</h4><p>CBC 模式是最常见的传统加密模式。每个明文块先与前一个密文块异或后，再进行加密。由于此XOR处理，相同的明文块将不再导致加密产生相同的密文。</p>
<p><strong>缺点:</strong> 加密过程串行化，只有第一步完成才能接下来的第二步，多核CPU无法发挥作用。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/CBC_encryption.png
" style="height:250px"><br>第一组通过初始化向量 IV 将第一组明文和 密钥K 加密得到密文，第二组再用第一组得到的密文和第二组的明文和 密钥K 加密得到第二组的密文，如此往复。</p>
<blockquote>
<ol>
<li>IV不是密码短语的一部分，因为它不是秘密。它是作为随机数生成的，但是只有在了解此IV的情况下，您才能解密密钥本身。</li>
<li>因为漏洞（Lucky 13）问题，被高版本TLS所宣布禁止，另外H2的实现也不允许使用CBC模式的TLS。</li>
</ol>
</blockquote>
<h4 id="CTR（Counter）模式"><a href="#CTR（Counter）模式" class="headerlink" title="CTR（Counter）模式"></a>CTR（Counter）模式</h4><p>为了解决CBC不能串行加密的缺点。CTR模式支持每组加密采用一个计数向量，这样就可以多个块同时加密。它不具有消息依赖性，因此密文块不依赖于先前的明文块。</p>
<p><strong>缺点：</strong> 不能提供密文的消息完整性校验。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/CTR_encryption.svg
" style="height:250px"></p>
<h4 id="GCM（Galois-Counter-Mode）模式"><a href="#GCM（Galois-Counter-Mode）模式" class="headerlink" title="GCM（Galois Counter Mode）模式"></a>GCM（Galois Counter Mode）模式</h4><p>GCM 是 CTR + GMAC ，其兼顾CTR的并法加解密的特点，也可以使用MAC算法实现消息的完整性验证。</p>
<ul>
<li>验证完整性 MAC(Message Authentication Code)</li>
</ul>
<p>通过将加密后的密文消息和密钥经过专门的Hash函数加密，传输时需要将密文和MAC一块传给接收方。接收方通过相同的MAC算法，将密文和密钥再次算出MAC值，判断MAC值是否相等。</p>
<p>可以使用安全伪随机函数（<a target="_blank" rel="noopener" href="http://www.crypto-it.net/eng/theory/prf-and-prp.html">PRF</a>）创建安全MAC算法。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/Message_Authentication_Code.png
" style="height:250px"></p>
<p>顾名思义，可以验证消息完整性，防止中间人恶意修改消息内容。</p>
<ul>
<li>GCM</li>
</ul>
<p>GMAC 是用到 Galois域的MAC算法，是众多消息验证算法的一种。<br><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/two-parts-of-gcm-l.jpg
" style="height:350px"></p>
<ul>
<li>AEAD</li>
</ul>
<p>Authenticated Encryption with Associated Data (AEAD) 是一种同时具备保密性，完整性和可认证性的加密形式。</p>
<p>AEAD 产生的原因很简单，单纯的对称加密算法，其解密步骤是无法确认密钥是否正确的。也就是说，加密后的数据可以用任何密钥执行解密运算，得到一组疑似原始数据，而不知道密钥是否是正确的，也不知道解密出来的原始数据是否正确。因此，需要在单纯的加密算法之上，加上一层验证手段，来确认解密步骤是否正确。</p>
<p><code>AES-256-GCM</code> 就是常见的 AEAD 算法。其他的还有诸如 <code>ChaCha20-Poly1305</code>，<code>AES-128-GCM</code> 等</p>
<h3 id="AES-Advanced-Encryption-Standard-加密算法"><a href="#AES-Advanced-Encryption-Standard-加密算法" class="headerlink" title="AES(Advanced Encryption Standard) 加密算法"></a>AES(Advanced Encryption Standard) 加密算法</h3><p>AES是当今可能会遇到的流行和被广泛采用的对称加密算法。它由比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计，常用的填充算法为：PKCS7。常用的分组模式为：GCM。分组长度只能是16字节。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>AES</th>
<th style="text-align:center">密钥长度（32 bit）</th>
<th style="text-align:center">分组长度（32 bit）</th>
<th style="text-align:center">加密轮数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AES-128</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>AES-192</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>AES-256</td>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
</div>
<p><strong>AES加密步骤</strong></p>
<ol>
<li>将明文按照128 bit (16 字节)拆分为若干个明文块，每个明文块是 4*4 矩阵</li>
<li>按照选择的填充方式来填充最后一个明文块。（PKCS7）</li>
<li><strong>每一个明文块利用AES加密器和密钥，加密成密文块。</strong></li>
<li>拼接所有的密文块，加上上文提到的加密模式GCM。成为最终的密文。</li>
</ol>
<p>下面是详细的加密步骤。</p>
<p>第三步是最复杂，也是最重要的一步。也是上述加密轮数体现的地方。</p>
<h4 id="AES-加密流程"><a href="#AES-加密流程" class="headerlink" title="AES 加密流程"></a>AES 加密流程</h4><p>AES中的加密回合数是可变的，并且取决于密钥的长度。AES对128位密钥使用10轮，对192位密钥使用12轮，对于256位密钥使用14轮。这些回合中的每个回合都使用不同的128位回合密钥，该密钥是根据原始AES密钥计算得出的。<br>大体分为 <code>初始轮</code> 、 <code>普通轮</code> 、 <code>最终轮</code></p>
<p><strong>初始轮</strong></p>
<ul>
<li><code>AddRoundKey 轮密钥加</code>  将明文矩阵的16个字节视为128位，并与回合密钥的128位进行XOR运算。</li>
</ul>
<p><strong>普通轮</strong></p>
<ul>
<li><code>AddRoundKey 轮密钥加</code>  </li>
<li><code>Subytes 字节替代</code>   通过查找设计中给定的固定表（S-box）来替换16个输入字节。结果是四行四列的矩阵。</li>
<li><code>ShiftRows 行移位</code>    矩阵的四行中的每一行都向左移动。第一行不变，第二行左移1个字节，第三行左移2个字节，第四行左移3个字节。</li>
<li><code>MixColumns 列混合</code>  使用特殊的数学函数对每四个字节的列进行转换。此函数将一列的四个字节作为输入，并输出四个全新的字节，以替换原始列。结果是由16个新字节组成的另一个新矩阵。</li>
</ul>
<p><strong>最终轮</strong></p>
<ul>
<li><code>SubBytes 字节替代</code></li>
<li><code>ShiftRows 行移位</code></li>
<li><code>AddRoundKey 轮密钥加</code></li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/TLSDetailAnalysis/AES_Encrpyt.png
" style="height:350px"></p>
<ul>
<li>动画演示 <code>AES加密</code> : <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/3161.html">https://coolshell.cn/articles/3161.html</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数 p: 明文的字符串数组。</span></span><br><span class="line"><span class="comment"> * 参数 plen: 明文的长度。</span></span><br><span class="line"><span class="comment"> * 参数 key: 密钥的字符串数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> plen, <span class="keyword">char</span> *key)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> keylen = <span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(plen == <span class="number">0</span> || plen % <span class="number">16</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;明文字符长度必须为16的倍数！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!checkKeyLen(keylen)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;密钥字符长度错误！长度必须为16、24和32。当前长度为%d\n&quot;</span>,keylen);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    extendKey(key);<span class="comment">//扩展密钥</span></span><br><span class="line">    <span class="keyword">int</span> pArray[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; plen; k += <span class="number">16</span>) &#123;</span><br><span class="line">        convertToIntArray(p + k, pArray);</span><br><span class="line">        addRoundKey(pArray, <span class="number">0</span>);<span class="comment">//一开始的轮密钥加</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;<span class="comment">//前9轮</span></span><br><span class="line">            subBytes(pArray);<span class="comment">//字节代换</span></span><br><span class="line">            shiftRows(pArray);<span class="comment">//行移位</span></span><br><span class="line">            mixColumns(pArray);<span class="comment">//列混合</span></span><br><span class="line">            addRoundKey(pArray, i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//第10轮</span></span><br><span class="line">        subBytes(pArray);<span class="comment">//字节代换</span></span><br><span class="line">        shiftRows(pArray);<span class="comment">//行移位</span></span><br><span class="line">        addRoundKey(pArray, <span class="number">10</span>);</span><br><span class="line">        convertArrayToStr(pArray, p + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多有关对称加密的实现可以参考： <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5246#section-6.3">https://tools.ietf.org/html/rfc5246#section-6.3</a></p>
<h1 id="TLS的分层结构"><a href="#TLS的分层结构" class="headerlink" title="TLS的分层结构"></a>TLS的分层结构</h1><p>TLS 从实现上主要包含 <code>Record 记录协议</code> 和 <code>Handshake 握手协议</code>。</p>
<ul>
<li><strong>handshake protocol</strong>，验证通讯双方的身份，交换加解密的安全套间，协商加密参数</li>
<li><strong>record protocol</strong>，记录层作为对称加密传输的record协议</li>
</ul>
<p>另外还有三种辅助协议</p>
<ul>
<li><strong>changecipher spec</strong> ，用来通知对端从handshake切换到record协议(有点冗余，在TLS1.3里面已经被删掉了)</li>
<li><strong>alert协议，the alert</strong>, 用来通知各种返回码，</li>
<li><strong>application data协议</strong>，就是把http，smtp等的数据流传入record层做处理并传输。</li>
</ul>
<p>这种 <strong>认证密钥协商</strong> + <strong>对称加密传输</strong> 的结构，是绝大多数加密通信协议的通用结构。</p>
<h2 id="record-protocol"><a href="#record-protocol" class="headerlink" title="record protocol"></a>record protocol</h2><p>record协议做应用数据的对称加密传输，占据一个TLS连接的绝大多数流量。记录层将信息块分割成携带 2^14 字节 (16KB) 或更小块的数据的 TLSPlaintext 记录。有点像TCP中的segment，所有的其他子协议需要通过 record 协议封装，多个record 数据可以在一个TCP包里记录一次性发出。<br><img src="https://img1.kiosk007.top/static/images/network/tls_record.png" style="height:390px"><br>Record 协议 – 从应用层接受数据:</p>
<ul>
<li>分片，逆向是重组</li>
<li>生成序列号，为每个数据块生成唯一编号，防止被重放或被重排序</li>
<li>压缩，可选步骤，使用握手协议协商出的压缩算法做压缩 （大多不压缩）</li>
<li>加密，使用握手协议协商出来的key做加密/解密</li>
<li>算HMAC，对数据计算HMAC，并且验证收到的数据包的HMAC正确性</li>
<li>发给tcp/ip，把数据发送给 TCP/IP 做传输(或其它ipc机制)。</li>
</ul>
<h2 id="handshake-protocol"><a href="#handshake-protocol" class="headerlink" title="handshake protocol"></a>handshake protocol</h2><p>handshake 是 TLS里最复杂的子协议，浏览器和服务器在握手过程中协商TLS版本号、随机数、密码套件等信息，并且交换证书、身份验证、交换密钥参数等。最终用于后续的混合加密系统。<br>handshake在TLS的发展中又产生了多个变种，比如RSA密钥交换DH密钥交换。0RTT，false start 等等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   Client                                               Server</span><br><span class="line">   ClientHello</span><br><span class="line">   (empty SessionTicket extension)-------&gt;</span><br><span class="line">                                                   ServerHello</span><br><span class="line">                               (empty SessionTicket extension)</span><br><span class="line">                                                  Certificate*</span><br><span class="line">                                            ServerKeyExchange*</span><br><span class="line">                                           CertificateRequest*</span><br><span class="line">                                &lt;--------      ServerHelloDone</span><br><span class="line">   Certificate*</span><br><span class="line">   ClientKeyExchange</span><br><span class="line">   CertificateVerify*</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                     --------&gt;</span><br><span class="line">                                              NewSessionTicket</span><br><span class="line">                                            [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------             Finished</span><br><span class="line">   Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">Figure 1: Message flow <span class="keyword">for</span> full handshake issuing new session ticket</span><br></pre></td></tr></table></figure></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li>[0]: <a target="_blank" rel="noopener" href="https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/</a></li>
<li>[1]: <a target="_blank" rel="noopener" href="https://blog.wangriyu.wang/2018/03-http-tls.html">https://blog.wangriyu.wang/2018/03-http-tls.html</a> </li>
<li>[3]: <a target="_blank" rel="noopener" href="https://www.feistyduck.com/ssl-tls-and-pki-history/">https://www.feistyduck.com/ssl-tls-and-pki-history/</a> （TLS发展史）</li>
</ul>
<p><strong>加密套件相关</strong></p>
<ul>
<li>[ECB]: <a target="_blank" rel="noopener" href="https://www.sciencedirect.com/topics/computer-science/electronic-code-book">https://www.sciencedirect.com/topics/computer-science/electronic-code-book</a></li>
<li>[CBC]: <a target="_blank" rel="noopener" href="https://www.sciencedirect.com/topics/computer-science/cipher-block-chaining">https://www.sciencedirect.com/topics/computer-science/cipher-block-chaining</a></li>
<li>[CTR]: <a target="_blank" rel="noopener" href="https://www.cryptopp.com/wiki/CTR_Mode">https://www.cryptopp.com/wiki/CTR_Mode</a></li>
<li>[MAC]: <a target="_blank" rel="noopener" href="http://www.crypto-it.net/eng/theory/mac.html">http://www.crypto-it.net/eng/theory/mac.html</a></li>
<li>[AES]：<a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/cryptography/advanced_encryption_standard.htm">https://www.tutorialspoint.com/cryptography/advanced_encryption_standard.htm</a></li>
<li>[AEAD]: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28566058">https://zhuanlan.zhihu.com/p/28566058</a></li>
<li>[Asymmetric encryption]: <a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/what-is-asymmetric-encryption/">https://www.cloudflare.com/learning/ssl/what-is-asymmetric-encryption/</a></li>
<li>[RSA]: <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?type=content&amp;q=RSA">https://www.zhihu.com/search?type=content&amp;q=RSA</a>  (知乎 一文搞懂 rsa 算法)</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">kiosk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://kiosk007.top/2020/05/02/TLS-详解/">http://kiosk007.top/2020/05/02/TLS-详解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tls/">tls</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=kiosk" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/"><i class="fa fa-chevron-left">  </i><span>TLS 详解（二）</span></a></div><div class="next-post pull-right"><a href="/2020/04/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/"><span>函数式编程思维</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'XhYn8GEq1Sg7ufJQAVmR4dWN-gzGzoHsz',
  appKey:'r42k4lqU022wD7IvtwGaQfjN',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://img1.kiosk007.top/static/images/background_1.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By kiosk</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">京ICP备20015006号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://img1.kiosk007.top/static/js/utils.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fancybox.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/sidebar.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/copy.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fireworks.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/transition.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/scroll.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="https://img1.kiosk007.top/static/js/katex.js"></script><script src="https://img1.kiosk007.top/static/js/search/local-search.js"></script><script id="ribbon" src="https://img1.kiosk007.top/static/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zIndex="-1" data-click="true"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>