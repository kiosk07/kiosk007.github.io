<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="性能大杀器epoll"><meta name="keywords" content="socket编程,network,epoll"><meta name="author" content="kiosk"><meta name="copyright" content="kiosk"><title>性能大杀器epoll | kiosk007's Blog</title><link rel="shortcut icon" href="/img/favicon-16x16-dragon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f3d277b6c83066a05a8b7db067b2308";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="kiosk007's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C10K"><span class="toc-number">1.</span> <span class="toc-text">C10K</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O-%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">I&#x2F;O 模型优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-%E4%BA%8B%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84"><span class="toc-number">2.1.</span> <span class="toc-text">IO 事件是如何产生的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">IO 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E7%9F%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">事件如何通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E5%88%86%E5%93%AA%E5%87%A0%E7%B1%BB"><span class="toc-number">2.2.2.</span> <span class="toc-text">IO 调用方式分哪几类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO-%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91"><span class="toc-number">2.3.</span> <span class="toc-text">非阻塞IO+水平触发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">2.3.1.</span> <span class="toc-text">select</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select-%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">select 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">select 缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll"><span class="toc-number">2.3.2.</span> <span class="toc-text">poll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">poll用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">poll缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO-%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91"><span class="toc-number">2.4.</span> <span class="toc-text">非阻塞IO + 边缘触发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">2.4.1.</span> <span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-create"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-ctl"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">epoll_ctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-wait"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">epoll_wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E8%B0%83%E6%95%B4"><span class="toc-number">3.</span> <span class="toc-text">工作模型调整</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E4%BC%98"><span class="toc-number">4.</span> <span class="toc-text">Linux 内核参数的调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E7%9A%84%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">打开的最大文件描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E8%87%AA%E5%8A%A8%E8%B0%83%E8%8A%82"><span class="toc-number">4.2.</span> <span class="toc-text">发送缓冲区的自动调节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C10M-%E7%9A%84%E4%BB%B0%E6%9C%9B"><span class="toc-number">5.</span> <span class="toc-text">C10M 的仰望</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img1.kiosk007.top/static/images/avatar.jpg"></div><div class="author-info__name text-center">kiosk</div><div class="author-info__description text-center">NoOps</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/weijiaxiang007">Ordinary But Great</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img1.kiosk007.top/static/images/backgroud.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">kiosk007's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/about/">关于</a><a class="site-page" href="/archives/">文章</a><a class="site-page" href="/tags/">标签</a><a class="site-page" href="/categories/">分类</a><a class="site-page" href="/express/">Express</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">性能大杀器epoll</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/network/">network</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.7k</span><span class="post-meta__separator">|</span><span>Reading time: 17 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a target="_blank" rel="noopener" href="http://www.kegel.com/c10k.html">C10K</a> 单机同时处理 1万个请求（并发连接 1 万）的问题，最早由 Dan Kegel 在 1999 年提出。那时的服务器还只是 32 位系统，运行着 Linux 2.2 版本（后来又升级到了 2.4 和 2.6，而 2.6 才支持 x86_64），只配置了很少的内存（2GB）和千兆网卡。在这样的系统能实现C10K问题吗？</p>
<p>这在当年看似十分难以实现的问题，在当下epoll这个性能大杀器实现了我们单机并发10K的梦想。</p>
<a id="more"></a>
<hr>
<p><img src="https://img1.kiosk007.top/static/images/network/epoll/c10k.jpg" style="height:300px;border-radius: 20px;"></p>
<h1 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h1><p>怎么实现单机并发 1W 条连接呢？我们先来算一笔账，对于一台 <code>通用型g6</code> (2核 8G 25 Gbit/s) 的 <a target="_blank" rel="noopener" href="https://www.aliyun.com/product/ecs/">ECS</a> 来说。假设每条连接分配100KB内存，100Kbit带宽。1w 条连接也完全满足需求 1G内存，1000Mbit。硬件满足需求，那么看软件。</p>
<ul>
<li>每一条连接创建一个线程吗？</li>
</ul>
<p>64 位的 Linux 为每个线程的栈分配了 8MB 的内存，还预分配了 64MB 的内存作为堆内存池。单个线程的创建消耗过高，所以我们没有足够的内存创建上万级别的线程。</p>
<p>其次请求的切换，是Linux在内核中切换线程实现的。时间片用尽、调用阻塞方法都会导致线程切换，一次上下文的耗时在几十纳秒，但是短时间上万次的切换，会导致CPU大量的时间都浪费在切换线程上。</p>
<p>总上所述，每条连接创建一个线程是不合理的。（同理创建进程就更不合理了）</p>
<h1 id="I-O-模型优化"><a href="#I-O-模型优化" class="headerlink" title="I/O 模型优化"></a>I/O 模型优化</h1><p>这里就需要用到 多路复用/非阻塞 的IO框架模型了，那么什么是多路/非阻塞。<br>通俗来讲就是就是将很多的IO事件都收集起来统一管理，这样一个线程就可以做到分别运行不同的IO事件，哪个准备好了运行哪个。没有准备好的就先放在一边。</p>
<blockquote>
<p>IO 事件的类型非常多，比如：<br>1、标准输入文件描述符可读。2、标准输出文件描述符可写。3、新的连接建立成功。4、一个IO事件等待超过了10秒</p>
</blockquote>
<h2 id="IO-事件是如何产生的"><a href="#IO-事件是如何产生的" class="headerlink" title="IO 事件是如何产生的"></a>IO 事件是如何产生的</h2><p>简单的说，事件只有两种即读事件和写事件。<code>读事件</code>表示IO有消息到达需要处理，<code>写事件</code> 表示IO可以发送数据了（TCP的写缓冲区可写数据）。</p>
<p>在网络的视角，从三次握手开始。客户端发出SYN，服务端回复SYN+ACK。完成握手后，客户端即产生了<strong>写事件</strong>。如果缓冲区太小假设只有1M，而我们要发送的数据时2M，那么会先写入1M后，等待缓冲区空闲后，再次产生写事件。</p>
<p>同样四次挥手，当主动关闭方发送一个FIN，被动关闭方就会产生一个读事件。</p>
<blockquote>
<p>目前磁盘的异步IO技术还不成熟，它绕过了 PageCache 性能损失很大。所以当下的事件驱动，主要就是指网络事件。</p>
</blockquote>
<h2 id="IO-类型"><a href="#IO-类型" class="headerlink" title="IO 类型"></a>IO 类型</h2><h3 id="事件如何通知"><a href="#事件如何通知" class="headerlink" title="事件如何通知"></a>事件如何通知</h3><p>目前有两种 IO事件的通知方式<strong>水平触发</strong>和<strong>边缘触发</strong></p>
<ul>
<li><code>水平触发</code>：只要文件描述符可以非阻塞的执行IO，就会触发通知，也就是应用程序可以随时随地的检查文件描述符的状态，并根据其状态产生相应的动作。</li>
<li><code>边缘触发</code>：只有文件描述符的状态发生改变时，才发出一个通知，这时候应用程序需要尽可能多的执行IO操作，直到无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了。</li>
</ul>
<h3 id="IO-调用方式分哪几类"><a href="#IO-调用方式分哪几类" class="headerlink" title="IO 调用方式分哪几类"></a>IO 调用方式分哪几类</h3><ul>
<li><p><code>非阻塞</code>: 当应用程序调用阻塞 I/O 完成某个操作时，应用程序会被挂起，等待内核完成操作</p>
</li>
<li><p><code>阻塞</code>: 当应用程序调用非阻塞 I/O 完成某个操作时，内核立即返回，不会把 CPU 时间切换给其他进程，应用程序在返回后，可以得到足够的 CPU 时间继续完成其他事情。</p>
</li>
</ul>
<hr>
<h2 id="非阻塞IO-水平触发"><a href="#非阻塞IO-水平触发" class="headerlink" title="非阻塞IO+水平触发"></a>非阻塞IO+水平触发</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="select-用法"><a href="#select-用法" class="headerlink" title="select 用法"></a>select 用法</h4><ul>
<li>声明select函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">返回：若有就绪描述符则为其数目，若超时则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>maxfd 表示的是待测试的描述符基数，它的值是待测试的最大描述符加 1。</p>
<ul>
<li>设置描述字符集合</li>
</ul>
<p>分别是<code>读描述符集合</code> readset、<code>写描述符集合</code>writeset 和 <code>异常描述符集合</code>exceptset，这三个分别通知内核，在哪些描述符上检测数据可以读，可以写和有异常发生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;　　#FD_ZERO 用来将这个向量的所有元素都设置成 <span class="number">0</span>；　　　　</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;　#FD_SET 用来把对应套接字 fd 的元素，a[fd]设置成 <span class="number">1</span>；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;　#FD_CLR 用来把对应套接字 fd 的元素，a[fd]设置成 <span class="number">0</span>；　　</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; #FD_ISSET 对这个向量进行检测，判断出对应套接字的元素 a[fd]是 <span class="number">0</span> 还是 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 0 代表不需要处理，1 代表需要处理。</p>
</blockquote>
<p>最后一个参数是 timeval 结构体时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span>   tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">long</span>   tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超时事件，如果全是0，则立马返回不等待（基本没有这么用的）、非0值等待一段时间后返回，可以用作超时、NULL一直监听等待有返回。</p>
<ul>
<li>select 程序例子</li>
</ul>
<p>refer：<a target="_blank" rel="noopener" href="https://github.com/froghui/yolanda/blob/master/chap-22/nonblockingserver.c">https://github.com/froghui/yolanda/blob/master/chap-22/nonblockingserver.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (select(maxfd + <span class="number">1</span>, &amp;readset, &amp;writeset, &amp;exset, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">&quot;select error&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 处理监听套接字事件</span></span><br><span class="line">   <span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;readset)) &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 处理已建立好连接上的套接字事件</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxfd + <span class="number">1</span>; ++i) &#123;      </span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">0</span>;            </span><br><span class="line">       <span class="keyword">if</span> (i == listen_fd)                </span><br><span class="line">           <span class="keyword">continue</span>;            </span><br><span class="line">       <span class="keyword">if</span> (FD_ISSET(i, &amp;readset)) &#123;</span><br><span class="line">           r = onSocketRead(i, buffer[i]);</span><br><span class="line">       &#125;       </span><br><span class="line">       <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; FD_ISSET(i, &amp;writeset)) &#123;                </span><br><span class="line">           r = onSocketWrite(i, buffer[i]);</span><br><span class="line">       &#125;            </span><br><span class="line">       <span class="keyword">if</span> (r) &#123;                </span><br><span class="line">           buffer[i]-&gt;connect_fd = <span class="number">0</span>; </span><br><span class="line">           close(i);            </span><br><span class="line">           &#125;        </span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select-缺点"><a href="#select-缺点" class="headerlink" title="select 缺点"></a>select 缺点</h4><p>1、在 Linux 系统中，select 所支持的文件描述符的个数是有限的，默认最大值为 1024。（当然就不能做到 c10K 了）<br>2、应用程序每次调用 select 时，还需要把文件描述符的集合，从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<font color="#A52A2A"> c10K 还好一点，当c10M时，并发1 千万连接。若每个 socket 是 4 字节，那么 1 千万连接就是 40M 字节。这样，每收集一次事件，就需要从用户态复制 40M 字节到内核态。而且，高性能 Server 必须及时地处理网络事件，所以每隔几十毫秒就要收集一次事件，性能消耗巨大。</font>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><h4 id="poll用法"><a href="#poll用法" class="headerlink" title="poll用法"></a>poll用法</h4><ul>
<li>声明poll函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>; </span><br><span class="line">　　　</span><br><span class="line">返回值：若有就绪描述符则为其数目，若超时则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>和select不同，poll每次检查完，不会修改之前的传入值，这样就不需要每次检查完毕还需要重置带检测的套结字。poll 还有一个相比select的好处，对请求出错有更友好的检测。</p>
<ul>
<li>poll 服务端程序例子</li>
</ul>
<p>refer： <a target="_blank" rel="noopener" href="https://github.com/froghui/yolanda/blob/master/chap-21/pollserver.c">https://github.com/froghui/yolanda/blob/master/chap-21/pollserver.c</a></p>
<h4 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h4><p>还是同select一样，需要将用户空间的套结字复制到内核态。消耗内存资源。</p>
<hr>
<h2 id="非阻塞IO-边缘触发"><a href="#非阻塞IO-边缘触发" class="headerlink" title="非阻塞IO + 边缘触发"></a>非阻塞IO + 边缘触发</h2><p><img src="https://img1.kiosk007.top/static/images/network/epoll/libevent-benchmark2.jpg" style="height:600px;"></p>
<p>首先看看上面的图，随着文件描述符的增多，poll和select的性能越来越差，而epoll和kqueue却几乎没有什么变化。为什么呢？</p>
<p>解答上面的疑问之前需要知道 五中最常见的 IO 模型。<code>阻塞IO （blocking I/O）</code>、<code>非阻塞IO （nonblocking I/O）</code>、<code>IO多路复用 （I/O multiplexing ）</code>、<code>事件驱动IO （signal driven I/O (SIGIO)）</code> 、<code>异步IO (asynchronous I/O (the POSIX aio_functions))</code> 。具体的网上的例子太多了，图也太多了，这里就不再赘述了。可以参考下这篇文章。<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1373483">各种IO复用模式之select，poll，epoll，kqueue，iocp分析</a></p>
<p>这5种IO模型如下图，越靠右，性能越强。当然还有更厉害的性能大杀器 AIO (比epoll 更强)，这个之后再介绍。很可惜，真正强大的AIO 是 windows 的IOCP（windows服务器有人用吗？你懂得）。而Linux aio 系列函数是由 POSIX 定义的异步操作接口，可惜的是，Linux 下的 aio 操作，不是真正的操作系统级别支持的，它只是由 GNU libc 库函数在用户空间借由 pthread 方式实现的，而且仅仅针对磁盘类 I/O，套接字 I/O 不支持。自出现就备受社区诟病。但是Linux作为最常用的应用服务器，epoll也就是Linux下最常见的性能杀器。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/epoll/io.png" style="height:400px;"></p>
<blockquote>
<p><code>noblocking</code> + <code>I/O mutiplexing</code>（IO多路复用+非阻塞IO） 就是kqueue、epoll、select、poll的实现。 不过epoll 和 kqueue 比 select 和poll 强大的多。</p>
</blockquote>
<p><strong>Q：为什么 epoll、kqueue 比 select、poll</strong></p>
<p><strong>A:</strong>  因为epoll他们无轮询。他们用callback取代了。想想看，当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数或者直接告诉应用层具体哪些套接字处于活跃状态了，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>使用 epoll 进行网络程序的编写，需要三个步骤，分别是 epoll_create，epoll_ctl 和 epoll_wait。</p>
<p><img src="https://img1.kiosk007.top/static/images/network/epoll/epoll_API.png" style="height:400px;"></p>
<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">        返回值: 若成功返回一个大于<span class="number">0</span>的值，表示epoll实例；若返回<span class="number">-1</span>表示出错</span><br></pre></td></tr></table></figure>
<p>关于这个参数 size，在一开始的 epoll_create 实现中，是用来告知内核期望监控的文件描述字大小，然后内核使用这部分的信息来初始化内核数据结构，在新的实现中，这个参数不再被需要，因为内核可以动态分配需要的内核数据结构。每次将 size 设置成一个大于 0 的整数就可以了。</p>
<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">       返回值: 若成功返回<span class="number">0</span>；若返回<span class="number">-1</span>表示出错</span><br></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>epfd：epoll_create 返回的句柄</li>
<li>op: 添加、删除、修改文件描述符。</li>
<li>fd: 注册事件的文件描述符</li>
<li>epoll_event: 注册的事件类型</li>
</ul>
<p>epoll_event:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">     <span class="keyword">void</span>        *ptr;</span><br><span class="line">     <span class="keyword">int</span>          fd;</span><br><span class="line">     <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">     <span class="keyword">uint64_t</span>     u64;</span><br><span class="line"> &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>EPOLLIN：表示对应的文件描述字可以读；</li>
<li>EPOLLOUT：表示对应的文件描述字可以写；</li>
<li>EPOLLRDHUP：表示套接字的一端已经关闭，或者半关闭；</li>
<li>EPOLLHUP：表示对应的文件描述字被挂起；</li>
<li>EPOLLET：设置为 edge-triggered，默认为 level-triggered。</li>
</ul>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">  返回值: 成功返回的是一个大于<span class="number">0</span>的数，表示事件的个数；返回<span class="number">0</span>表示的是超时时间到；若出错返回<span class="number">-1.</span></span><br></pre></td></tr></table></figure>
<p>调用者进程被挂起，等待内核的IO事件分发</p>
<p>参数：</p>
<ul>
<li>epfd：epoll句柄</li>
<li>epoll_event: 返回用户空间需要处理的epoll事件列表，是个数组。</li>
<li>maxevents: 返回的最大事件值</li>
<li>timeout：超时时间</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listen_fd, socket_fd;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> efd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line"></span><br><span class="line">    listen_fd = tcp_nonblocking_server_listen(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll create failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 注册event事件，事件可读，边缘触发 */</span></span><br><span class="line">    event.data.fd = listen_fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="comment">/* 添加事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(efd, EPOLL_CTL_ADD, listen_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll_ctl add listen fd failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer where events are returned */</span></span><br><span class="line">    events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait wakeup\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) ||</span><br><span class="line">                (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">                (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                close(events[i].data.fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理监听套接字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (listen_fd == events[i].data.fd) &#123;</span><br><span class="line">                struct sockaddr_storage ss;</span><br><span class="line">                <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">                <span class="keyword">int</span> fd = accept(listen_fd, (struct sockaddr *) &amp;ss, &amp;slen);</span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    make_nonblocking(fd);</span><br><span class="line">                    event.data.fd = fd;</span><br><span class="line">                    event.events = EPOLLIN | EPOLLET; <span class="comment">//edge-triggered</span></span><br><span class="line">                    <span class="keyword">if</span> (epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll_ctl add connection fd failed&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                socket_fd = events[i].data.fd;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get event on socket fd == %d \n&quot;</span>, socket_fd);</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">                    <span class="comment">// 处理读事件</span></span><br><span class="line">                    <span class="keyword">if</span> ((n = read(socket_fd, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>) &#123;                      </span><br><span class="line">                        <span class="comment">// 读出错，关闭套接字</span></span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                            error(<span class="number">1</span>, errno, <span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                            close(socket_fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                        close(socket_fd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                            buf[i] = rot13_char(buf[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                     </span><br><span class="line">                        <span class="keyword">if</span> (write(socket_fd, buf, n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            error(<span class="number">1</span>, errno, <span class="string">&quot;write error&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    close(listen_fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里会把每个套结字处理为非阻塞模式。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>epoll ，非阻塞IO + IO多路复用 + 边缘触发，造就了C10K，C100K 的问题解决。</p>
<h1 id="工作模型调整"><a href="#工作模型调整" class="headerlink" title="工作模型调整"></a>工作模型调整</h1><p>以Nginx为例，Nginx是典型的1个主Master进程 + 多个Worker进程。</p>
<ul>
<li>主进程执行 bind() 和 listen() 后，创建多个子进程。</li>
<li>每个子进程中通过都通过 accept() 或 epoll_wait() ，来处理相同的套接字。</li>
</ul>
<p><img src="https://img1.kiosk007.top/static/images/network/epoll/Nginx.png" style="height:600px;"></p>
<p>而这里面就需要用到epoll来作 IO 分法器。从而设计出基于套接字的事件驱动程序。</p>
<p>这样的模型被称为主从模型（master-worker） 或 反应堆模型（reactor），这样的技术核心思想有2点。<br>1、存在一个无限循环的事件分发线程或进程（Nginx是进程）。而事件分发的背后正是epoll这样的IO分发技术。</p>
<p>2、所有的IO操作可以抽象为事件，每个事件都有一个回调函数来处理。worker 进程上有已建立好的套接字、可读、可写的套接字。这一个个都是事件，通过事件分发并调用相应的回调函数被触发。</p>
<p>代码参考：<a target="_blank" rel="noopener" href="https://github.com/froghui/yolanda/blob/master/chap-29/epoll-server-multithreads.c">https://github.com/froghui/yolanda/blob/master/chap-29/epoll-server-multithreads.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接建立之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onConnectionCompleted</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection completed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据读到buffer之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onMessage</span><span class="params">(struct buffer *input, struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get message from tcp connection %s\n&quot;</span>, tcpConnection-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, input-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">output</span> =</span> buffer_new();</span><br><span class="line">    <span class="keyword">int</span> size = buffer_readable_size(input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        buffer_append_char(output, rot13_char(buffer_read_char(input)));</span><br><span class="line">    &#125;</span><br><span class="line">    tcp_connection_send_buffer(tcpConnection, output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据通过buffer写完之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onWriteCompleted</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write completed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接关闭之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onConnectionClosed</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection closed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">char</span> **v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主线程event_loop</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_loop</span> *<span class="title">eventLoop</span> =</span> event_loop_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化acceptor</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acceptor</span> *<span class="title">acceptor</span> =</span> acceptor_init(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始tcp_server，可以指定线程数目，这里线程是4，说明是一个acceptor线程，4个I/O线程，每一个I/O线程</span></span><br><span class="line">    <span class="comment">//tcp_server自己带一个event_loop</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TCPserver</span> *<span class="title">tcpServer</span> =</span> tcp_server_init(eventLoop, acceptor, onConnectionCompleted, onMessage, onWriteCompleted, onConnectionClosed, <span class="number">4</span>);</span><br><span class="line">    tcp_server_start(tcpServer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main thread for acceptor</span></span><br><span class="line">    event_loop_run(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置了很多Callback回调函数，会在客户端建立连接之后依次执行这些回调函数。</p>
<ul>
<li><code>event_loop_init()</code>：创建一个事件循环器</li>
<li><code>acceptor_init(SERV_PORT)</code>: 初始化acceptor线程，bind、listen</li>
<li><code>tcp_server_init()</code>: 创建线程池，传入回调函数，分别对应了连接建立完成、数据读取完成、数据发送完成、连接关闭完成几种操作，通过回调函数，让业务程序可以聚焦在业务层开发</li>
<li><code>tcp_server_start(tcpServer)</code>: 开始监听，acceptor主线程，开启多个线程，同时把tcpServer作为参数传给channel对象</li>
<li><code>event_loop_run(eventLoop)</code>: 调用dispatcher来进行事件分发,分发完回调事件处理函数</li>
</ul>
<h1 id="Linux-内核参数的调优"><a href="#Linux-内核参数的调优" class="headerlink" title="Linux 内核参数的调优"></a>Linux 内核参数的调优</h1><h2 id="打开的最大文件描述符"><a href="#打开的最大文件描述符" class="headerlink" title="打开的最大文件描述符"></a>打开的最大文件描述符</h2><p>Linux 下默认的最大文件描述符是1024个，也就是一个应用程序最多打开1024个文件描述符。如果连接数过多，会导致<code>Socket/File:Can&#39;t open so many files</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">ulimit</span> -n</span><br><span class="line">1024</span><br><span class="line">➜  sudo <span class="built_in">echo</span> <span class="string">&quot;fs.file-max = 1000000&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">➜  sudo sysctl -p</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="发送缓冲区的自动调节"><a href="#发送缓冲区的自动调节" class="headerlink" title="发送缓冲区的自动调节"></a>发送缓冲区的自动调节</h2><p>Socket编程时是可以可以在send函数中设置发送缓冲区大小的，而这个应该设为多少才合适呢？答案是不要设置！不要设置！不要设置！</p>
<p>正确的操作是让操作系统自己动态的改变 发送缓冲区大小（默认就是操作系统自己控制的，但是应用程序一旦自己设置了缓冲区大小，自动调节功能就失效了）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  sysctl -a | grep tcp_moderate_rcvbuf</span><br><span class="line">net.ipv4.tcp_moderate_rcvbuf = 1</span><br></pre></td></tr></table></figure><br>refer : <a target="_blank" rel="noopener" href="https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/">就是要你懂TCP—性能和发送接收Buffer的关系</a></p>
<h1 id="C10M-的仰望"><a href="#C10M-的仰望" class="headerlink" title="C10M 的仰望"></a>C10M 的仰望</h1><p>C10K、C100K、C1000K 都可以凭借强大的epoll解决问题。但是对性能的追求是永无止境的，同时并发1百万可能操作系统已经达到极限了，前面说到C10K的问题在于IO阻塞、频繁的CPU上下文切换、套接字从应用层到内核的反复拷贝。那 <a target="_blank" rel="noopener" href="http://c10m.robertgraham.com/p/blog-page.html">C10M</a> 的瓶颈是什么呢？</p>
<p>究其根本，还是 Linux 内核协议栈做了太多太繁重的工作。从网卡中断带来的硬中断处理程序开始，到软中断中的各层网络协议处理，最后再到应用程序，这个路径实在是太长了，就会导致网络包的处理优化，到了一定程度后，就无法更进一步了。</p>
<p>要解决这个问题，最重要就是跳过内核协议栈的冗长路径，把网络包直接送到要处理的应用程序那里去。这里有两种常见的机制，DPDK 和 XDP。</p>
<ul>
<li><p>DPDK:是用户态网络的标准。它跳过内核协议栈，直接由用户态进程通过轮询的方式，来处理网络接收。</p>
</li>
<li><p>XDP（eXpress Data Path），则是 Linux 内核提供的一种高性能网络数据路径。它允许网络包，在进入内核协议栈之前，就进行处理，也可以带来更高的性能。</p>
</li>
</ul>
<p>比较牛的开源项目就是 iqiyi 的DPVS了，DPVS 是基于 DPDK 的高性能 Layer-4负载均衡器。它源自Linux虚拟服务器 LVS 及其修改阿里巴巴/LVS 。</p>
<p><a target="_blank" rel="noopener" href="https://www.worldlink.com.cn/osdir/dpvs.html">DPVS</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/iqiyi/dpvs">https://github.com/iqiyi/dpvs</a></p>
<p>refer:</p>
<ul>
<li>[-]  <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1373483">https://cloud.tencent.com/developer/article/1373483</a></li>
<li>[-]<a target="_blank" rel="noopener" href="https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/">https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/</a></li>
<li>[-]  <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/214">https://time.geekbang.org/column/intro/214</a></li>
<li>[-]  <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/81268">https://time.geekbang.org/column/article/81268</a></li>
<li>[-] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43720867">https://zhuanlan.zhihu.com/p/43720867</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">kiosk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://kiosk007.top/2020/06/01/性能大杀器epoll/">http://kiosk007.top/2020/06/01/性能大杀器epoll/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/socket%E7%BC%96%E7%A8%8B/">socket编程</a><a class="post-meta__tags" href="/tags/network/">network</a><a class="post-meta__tags" href="/tags/epoll/">epoll</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=kiosk" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/13/Git-%E6%90%9C%E7%B4%A2%E5%B0%8F%E6%8A%80%E5%B7%A7/"><i class="fa fa-chevron-left">  </i><span>Github 搜索</span></a></div><div class="next-post pull-right"><a href="/2020/05/30/go-etcd-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"><span>etcd 的基本入门</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'XhYn8GEq1Sg7ufJQAVmR4dWN-gzGzoHsz',
  appKey:'r42k4lqU022wD7IvtwGaQfjN',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://img1.kiosk007.top/static/images/backgroud.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By kiosk</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">京ICP备20015006号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://img1.kiosk007.top/static/js/utils.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fancybox.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/sidebar.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/copy.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/fireworks.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/transition.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/scroll.js?version=1.9.0"></script><script src="https://img1.kiosk007.top/static/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="https://img1.kiosk007.top/static/js/katex.js"></script><script src="https://img1.kiosk007.top/static/js/search/local-search.js"></script><script id="ribbon" src="https://img1.kiosk007.top/static/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zIndex="-1" data-click="true"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>