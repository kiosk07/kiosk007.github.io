<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="docker 容器技术基础"><meta name="keywords" content="devops,docker,k8s"><meta name="author" content="kiosk"><meta name="copyright" content="kiosk"><title>docker 容器技术基础 | kiosk007's Blog</title><link rel="shortcut icon" href="/images/favicon-16x16-dragon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6f3d277b6c83066a05a8b7db067b2308";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"We didn't find any results for the search: ${query}"}},copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"},hexoVersion:"5.3.0"}</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="kiosk007's Blog" type="application/atom+xml"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">1.</span> <span class="toc-text">容器技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Namespace"><span class="toc-number">1.1.</span> <span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cgroups"><span class="toc-number">1.2.</span> <span class="toc-text">Cgroups</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F"><span class="toc-number">1.3.</span> <span class="toc-text">镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%B6%E4%BD%9CDocker%E9%95%9C%E5%83%8F"><span class="toc-number">2.</span> <span class="toc-text">制作Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%88%B0-docker-hub"><span class="toc-number">2.1.</span> <span class="toc-text">上传到 docker hub</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">kiosk</div><div class="author-info__description text-center">NoOps</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/weijiaxiang007">Ordinary But Great</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(/images/background_1.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">kiosk007's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>Search</span></a></span></div><div id="post-info"><div id="post-title">docker 容器技术基础</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/docker/">docker</a><div class="post-meta-wordcount"><span>Word count:</span> <span class="word-count">3.5k</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a target="_blank" rel="noopener" href="https://hijiangtao.github.io/2018/04/17/Docker-in-Action/">docker</a> 容器是随着PaaS技术的普及随之诞生的，Docker公司推出了docker并通过“容器镜像”解决了容器打包的根本性难题。而容器本身没有价值，有价值的是“容器编排技术”。Docker项目则通过容器技术解决了应用打包的根本性难题。</p><a id="more"></a><hr><p>为什么在开头就放出了 “容器本身没有价值” 的大话呢？</p><p>因为容器本身只是一个沙盒技术，其使用<strong>Cgroups</strong>和<strong>Namespace</strong>技术创建出来一个隔离环境，而docker项目之所以能得到如此之高的关注也是因为他解决了应用打包和发布这个困扰运维人员的多年的技术难题。能够把应用装到集装箱内方便搬来搬去才是PaaS的最理想状态。</p><p>Docker本身所用到的隔离技术也并不是什么黑科技，都是把已有的功能翻出来拼装了一下而已。<strong>容器的本质是一个“单进程”模型，本质是一个特殊的进程而已</strong></p><blockquote><p>Docker 容器技术由 Namespace、Cgroups、rootfs 三种技术构建出,其中Namespace、Cgroups 构建了容器的动态视图（称为 运行时），rootfs构建了容器的静态视图。</p></blockquote><h1 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h1><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p><strong>Namespace</strong>是Linux很早版本就实现的一个系统调用，他可以实现新创建一个进程的时候，为这个进程创建一个沙盒，比如让新的进程以为自己是1号PID进程，或者是让自己以为自己有一个新的网卡等等。</p><p>Linux创建新进程的时候有一个可选参数，加上 <strong>CLONE_NEWPID</strong> 就可以让创建的进程拥有一个全新的进程空间，在宿主机的真实进程空间，其PID还是那个PID，但是新进程自己认为自己是当前空间里的1号进程。他们无法看到真实的进程空间。也无法看到其他Namespace里的进程空间。</p><p><code>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</code></p><p>类似的参数还有</p><ul><li><code>CLONE_NEWNS</code>: 用于指定Mount Namespace (挂载点)</li><li><code>CLONE_NEWUTS</code>: 用于指定UTS Namespace (HOSTNAME和DOMAIN)</li><li><code>CLONE_NEWIPC</code>: 用于指定IPC Namespace (共享内存、信号量和消息队列)</li><li><code>CLONE_NEWPID</code>: 用于指定PID Namespace (进程号)</li><li><code>CLONE_NEWNET</code>: 用于指定Network Namespace （网络）</li><li><code>CLONE_NEWUSER</code>: 用于指定User Namespace （用户）</li></ul><p>用户可以在<strong>/proc/$pid/ns</strong>文件下看到本进程所属的Namespace的文件信息。</p><p>比如使用 <code>docker run -it busybox /bin/sh</code> 启动一个容器，然后在另外一个终端看到</p><p><img src="/images/docker/docker_namespace.png"></p><p>同样，Linux也提供了其他系统调用，可以让其他进程加入到一个Namespace中，<code>int setns(int fd, int nstype);</code>，这也为之后的联盟式容器创造了可能。即多个进程使用相同的Namespace。系统调用<code>int unshare(int flags);</code>也为相同Namespace分家提供了技术支持。</p><p>所以，Docker容器这个听起来高端大气的概念，只不过是在创建容器进程时，指定了这个进程一组Namespace参数而已。</p><p>比如我们启动了一个容器。可以使用 <code>docker exec -it xxxxx /bin/bash</code> 进入到这个容器中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 25 </span><br><span class="line">83488</span><br><span class="line"></span><br><span class="line">➜  sudo ls -l /proc/`docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 25`/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 ipc -&gt; <span class="string">&#x27;ipc:[4026532521]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 mnt -&gt; <span class="string">&#x27;mnt:[4026532519]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:14 net -&gt; <span class="string">&#x27;net:[4026532586]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 pid -&gt; <span class="string">&#x27;pid:[4026532522]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 pid_for_children -&gt; <span class="string">&#x27;pid:[4026532522]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 uts -&gt; <span class="string">&#x27;uts:[4026532520]&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个进程的所有Linux Namespace，都在/proc/[pid 进程号]/ns 下有一个虚拟文件，并且链接到真实的Namespace上。这样其他进程就可以加入一个已经存在的Namespace中。这也为了之后的pod（联盟式容器）打下基础。如 <code>docker run -it -net container:25836f0da751 busybox ifconfig</code>。这就是起一个容器，但是network namespace 用和 258xx 这个容器用一个。</p><p><strong>Namespace的问题</strong></p><p>既然容器技术只是一个特殊的进程被隔离而已，那么其缺点就很明显了，那就是容器的<strong>“隔离不彻底”</strong>。</p><font color="red">第一，容器既然是运行在宿主机上的一种特殊进程，那么多个进程还是共享同一个操作系统的内核（注意这里是Linux 内核 ，Mac和Windows上的容器首先是运行在Docker Machine上的，说白了运行在Linux虚拟机上）</font> <font color="red">第二，容器并不是所有资源都可以Namespace化的，典型的不能被Namespace的例子就是：时间</font> <font color="red">第三，由于避免不了多个容器共享宿主机内核的事实，那么就意味着容器的越狱比虚拟机简单的多了，一些危险的系统调用需要被监管加固</font><p>正是上述的问题，Docker的安全性会很差，一般不会直接把Docker暴露在公网上。</p><p>Refer:</p><blockquote><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73248894">浅谈Linux Namesapce机制 (知乎)</a></p></blockquote><h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>上面提到容器只是一个特殊的进程而已，那么这个容器进程和宿主机上其他的普通进程是平等的。如果容器进程可以占用宿主机全部资源的话，这显然不符合沙盒技术的特征。<strong>而Cgroups则正是 Linux 内核中用来限制资源的功能。</strong></p><p>Cgroups 的本质是给进程挂上钩子 (hooks) ,当Task的运行涉及到某个资源的时就触发钩子上所携带的subsystem检测。最终进行资源限制和优先级分配。</p><p><img src="/images/docker/docker-cgroups.jpg"></p><p><strong>Cgroups全称是 Linux Control Group, 他最主要的作用就是限制一个进程组能够使用的资源上限，包括CPU，内存，磁盘，网络带宽等</strong></p><p>Cgroups 给用户直接暴露出来的操作接口是文件系统，即以文件和目录的方式组织在操作系统的 <code>/sys/fs/cgroups</code> 路径下，在这个路径下有很多诸如 <code>cpuset</code>、<code>cpu</code>、<code>memory</code> 这样的子目录。这些就是当前操作系统下可以被限制的资源类型。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>怎么样去限制一个进程的资源呢？需要在这些目录之下再创建一个目录，如进入 <code>/sys/fs/cgroup/cpu</code> 目录下。创建目录 container 。这样一个目录，操作系统会自动在这个目录下生成子系统对应的资源限制文件。<br><img src="/images/docker/cgroups.png"><p></p><p>这下，我们创建一个死循环，将CPU吃满，记录该进程的PID。向 container 组里的 cfs_quota 文件写入 2ms，这意味着每 100ms 内的单位时间内，被该控制组限制的进程只能使用2ms的CPU时间，即只能用到2%的计算力。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># echo 2000 &gt; cpu.cfs_quota_us </span></span><br><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># echo 4918 &gt; tasks </span></span><br><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>打开htop指令可以看到刚才的死循环只有2%的CPU占用。<p></p><blockquote><p>实验完成后可以使用 <code>cgdelete -r cpu:container</code> 删除</p></blockquote><p>这样就可以理解 Linux Cgroups 的设计，其限制进程的方式也是简单粗暴，为一个子目录系统上添加一组资源限制文件的组合即可。在docker容器中，也可以直接通过命令来查看。</p><p><code>docker run -it --cpu-period=100000 --cpu-quota=20000 busybox /bin/sh</code></p><p><img src="/images/docker/cgroups_docker.png"></p><p><strong>Cgroups 的问题</strong><br>容器的Cgroups只是限制了某个进程的使用资源而已，而进程本身看到的资源还是宿主机的资源。</p><font color="red">/proc 文件系统并不知道 Cgroups 给某个进程做了什么限制。这就会造成在容器中使用 top,free,df 等命令看到的全部是宿主机上的资源。这会给应用的运行带来非常大的困惑。</font><p>不过在生产环境，已经有 <strong><code>lxcfs</code></strong> 这样的技术可以修正这种偏差。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ apt install -y lxcfs</span><br><span class="line">$ systemctl start lxcfs</span><br><span class="line">$ docker run -it -m 500m  \</span><br><span class="line">      -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/<span class="built_in">stat</span>:/proc/<span class="built_in">stat</span>:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/swaps:/proc/swaps:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw \</span><br><span class="line">      ubuntu:19.04 /bin/bash</span><br></pre></td></tr></table></figure><br>其原理是把宿主机上的 <code>/var/lib/lxcfs/proc/meminfo</code> 文件挂载到容器的 <code>/proc/meminfo</code> 位置。<p></p><p>refer:<br><a target="_blank" rel="noopener" href="https://cuisongliu.github.io/2019/03/docker/lxcfs/">https://cuisongliu.github.io/2019/03/docker/lxcfs/</a></p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Namespace 和 Cgroups 使这个特殊的进程看到的是隔离环境，而且使用的资源也被限制。那么这样还有一个点，就是进程看到的文件系统是什么呢？这里没有新的技术，还是最开始提到的Mount Namespace技术，拥有这项技术，可以给容器挂载一个全新、独立的文件系统。</p><p>挂载完成之后使用 <code>chroot</code> 指令, 使得新的挂载点成为进程的 <code>/</code> 路径。一般为了让这个容器的根目录更为真实，一般会给进程容器的根目录下挂载一个完整操作系统的文件系统。比如 Ubuntu19.04 的ISO。<strong>而这个挂载在容器根目录上的、用来给容器进程提供隔离后执行环境的文件系统就是 rootfs（根文件系统）</strong></p><font color="red">这里我再来强调一遍，容器是一个特殊的进程而已！！！rootfs只是操作系统所包含的文件、配置和目录，并不包含内核，内核是宿主机的内核。所以说 rootfs只是操作系统的驱壳，并没有操作系统的灵魂</font><p>不过正是rootfs的存在，才有了容器作为PaaS的基础，一致性！开发的程序连同操作系统的整个目录环境被打包封装在一个集装箱里。真正的依赖库都放在了这个rootfs的<code>/var/lib/xxx</code> 里。</p><p>还没完，虽然这个时候已经解决了大部分问题，但是每个容器创建的时候都需要一个rootfs未免也太浪费空间了，Docker的解决方法是提出 <code>layer</code> 的概念。用户每制造出来一个镜像就生成一个层。</p><p>Linux操作系统又提供了一种联合文件系统（Union File System）的能力。<br>UFS 提供的能力是将多个目录挂载到同一个目录下，使得多个目录合并。</p><p>假设有两个目录<code>A</code>和<code>B</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│   ├── a</span><br><span class="line">│   └── x</span><br><span class="line">└── B</span><br><span class="line">    ├── b</span><br><span class="line">    └── x</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建目录<code>C</code>,并且将两个目录挂载到一个公共的目录<code>C</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir C</span><br><span class="line">$ mount -t aufs -o dirs&#x3D;.&#x2F;A:.&#x2F;B none .&#x2F;C</span><br><span class="line">$ tree C</span><br><span class="line">C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>以Docker容器为例,这个挂载点就是在 <code>/var/lib/docker/overlay2</code> 下。不出意外，这个下面拥有一个完整的ubuntu操作系统<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2# ll 6f56172222645f34f4454ecdbfd592785245dc7b68511dc49723e0591aba54a8&#x2F;diff&#x2F;</span><br><span class="line">总用量 48</span><br><span class="line">drwxr-xr-x 10 root   root     4096 7月  11 01:04 .&#x2F;</span><br><span class="line">drwx------  3 root   root     4096 7月  11 01:04 ..&#x2F;</span><br><span class="line">drwxr-xr-x  2 root   root    12288 6月  27 08:21 bin&#x2F;</span><br><span class="line">drwxr-xr-x  2 root   root     4096 6月  27 08:21 dev&#x2F;</span><br><span class="line">drwxr-xr-x  3 root   root     4096 6月  27 08:21 etc&#x2F;</span><br><span class="line">drwxr-xr-x  2 nobody nogroup  4096 6月  27 08:21 home&#x2F;</span><br><span class="line">drwx------  2 root   root     4096 6月  27 08:21 root&#x2F;</span><br><span class="line">drwxrwxrwt  2 root   root     4096 6月  27 08:21 tmp&#x2F;</span><br><span class="line">drwxr-xr-x  3 root   root     4096 6月  27 08:21 usr&#x2F;</span><br><span class="line">drwxr-xr-x  4 root   root     4096 6月  27 08:21 var&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>同时也可以看到，对应的操作系统挂载信息里面的overlay信息。可以看到最终多个目录被联合挂载到<code>/var/lib/docker/overlay2/3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1/merged</code> 上，而这个merged会最终呈现一个文件系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;mounts |grep overlay2</span><br><span class="line">overlay &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;merged overlay rw,relatime,lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;N2BLQFHN3PRM3P4BR6LYEALQN5:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FYVKPJJ3TF7THIM4Z4J2OAQTZN:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;GPBK6EICFMAEBZR5IBE6XTWPSO:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FLBZS3ORDOYOD2ECQTRUMHAUBV:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;JAFCRW5O4V3HB7PWVABFY3SLRK,upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;diff,workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;work,xino&#x3D;off 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="/images/docker/aufs_image.png"><p></p><p>最下面的几层只读。上层的可写。而最上层是可读写。</p><blockquote><p>所以在运行容器的时候，只需要拉取不存在的 image layer。镜像一般完全拉下来的化需要3，4百M，一般的大厂都是采用 p2p 下载镜像，如 <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/244897">阿里的蜻蜓 p2p 下载</a>。</p></blockquote><h1 id="制作Docker镜像"><a href="#制作Docker镜像" class="headerlink" title="制作Docker镜像"></a>制作Docker镜像</h1><p>使用 golang 编写一个web应用。准备一个main.go<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">        log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q \n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>制作Dockerfile 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.12-alpine</span><br><span class="line"></span><br><span class="line"># Set ENV</span><br><span class="line">ENV GO111MODULE&#x3D;on \</span><br><span class="line">    CGO_ENABLED&#x3D;0 \</span><br><span class="line">    GOOS&#x3D;linux \</span><br><span class="line">    GOARCH&#x3D;amd64</span><br><span class="line"></span><br><span class="line"># Set the Current Working Directory inside the container</span><br><span class="line">WORKDIR $GOPATH&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Copy all file to &#x2F;app</span><br><span class="line">ADD . $GOPATH&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Build the Go app</span><br><span class="line">RUN go build main.go</span><br><span class="line"></span><br><span class="line"># This container exposes port 8000 to the outside world</span><br><span class="line">EXPOSE 8000</span><br><span class="line"></span><br><span class="line"># Run the binary program produced by &#96;.&#x2F;main&#96;</span><br><span class="line">ENTRYPOINT [&quot;.&#x2F;main&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>制作镜像在当前目录执行<code>docker build -t hello .</code><br>run 起来该容器<code>docker run -p 8000:8000 hello</code><p></p><h2 id="上传到-docker-hub"><a href="#上传到-docker-hub" class="headerlink" title="上传到 docker hub"></a>上传到 docker hub</h2><p>在docker hub 上创建一个 docker 账号&lt;/br&gt;<br>使用 <code>docker login</code> 登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为容器起一个完整的名字。</span></span><br><span class="line">docker tag helloworld your-docker-id/helloworld:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传到docker hub 上</span></span><br><span class="line">docker push your-docker-id/helloworld:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器中新建文件</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 29038er849jsa /bin/sh</span><br><span class="line">touch tmp.file</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新建的内容提交</span></span><br><span class="line">docker commit 29038er849jsa your-docker-id/helloworld:v2</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author:</span> <span class="post-copyright-info"><a href="mailto:undefined">kiosk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link:</span> <span class="post-copyright-info"><a href="http://kiosk007.top/2020/07/11/docker-容器技术基础/">http://kiosk007.top/2020/07/11/docker-容器技术基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice:</span> <span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/devops/">devops</a><a class="post-meta__tags" href="/tags/docker/">docker</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=kiosk" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/18/%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"><i class="fa fa-chevron-left"></i> <span>理解协程</span></a></div><div class="next-post pull-right"><a href="/2020/06/13/Git-%E6%90%9C%E7%B4%A2%E5%B0%8F%E6%8A%80%E5%B7%A7/"><span>Github 搜索</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify=!1,verify=!1,record_ip=!1,GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter((function(i){return GUEST_INFO.indexOf(i)>-1}));guest_info=0==guest_info.length?GUEST_INFO:guest_info,window.valine=new Valine({el:"#vcomment",notify:notify,verify:verify,recordIP:record_ip,appId:"XhYn8GEq1Sg7ufJQAVmR4dWN-gzGzoHsz",appKey:"r42k4lqU022wD7IvtwGaQfjN",placeholder:"Just go go",avatar:"mm",guest_info:guest_info,pageSize:"10",lang:"zh-cn"})</script></div></div><footer class="footer-bg" style="background-image:url(/images/background_1.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By kiosk</div><div class="framework-info"><span>Driven -</span> <a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">京ICP备20015006号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zindex="-1" data-click="true"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>