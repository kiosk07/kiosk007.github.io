<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kiosk007&#39;s Blog</title>
  
  <subtitle>专注 量变产生质变!</subtitle>
  <link href="http://kiosk007.top/atom.xml" rel="self"/>
  
  <link href="http://kiosk007.top/"/>
  <updated>2021-03-27T05:52:18.000Z</updated>
  <id>http://kiosk007.top/</id>
  
  <author>
    <name>kiosk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建我的ELK 7.12</title>
    <link href="http://kiosk007.top/2021/03/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84ELK-7-2/"/>
    <id>http://kiosk007.top/2021/03/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84ELK-7-2/</id>
    <published>2021-03-27T05:52:18.000Z</published>
    <updated>2021-03-27T05:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。</p><p>“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。</p><p>引用官网的一句话：</p><blockquote><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="https://img1.kiosk007.top/static/images/elk/elk.png" style="height:500px"></p><p><strong>ElasticSearch 的目录结构</strong></p><div class="table-container"><table><thead><tr><th>目录</th><th style="text-align:right">配置文件</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>bin</td><td style="text-align:right"></td><td style="text-align:center">脚本文件，包括启动elasticsearch，安装插件，运行统计数据等 </td></tr><tr><td>config</td><td style="text-align:right">elasticsearch.yml</td><td style="text-align:center">集群配置文件，user，role based 相关配置</td></tr><tr><td>JDK</td><td style="text-align:right"></td><td style="text-align:center">java 运行环境</td></tr><tr><td>data</td><td style="text-align:right">path.data</td><td style="text-align:center">数据文件</td></tr><tr><td>lib</td><td style="text-align:right"></td><td style="text-align:center">java 类库</td></tr><tr><td>logs</td><td style="text-align:right">path.log</td><td style="text-align:center">日志文件</td></tr><tr><td>modules</td><td style="text-align:right"></td><td style="text-align:center">包含所有ES模块</td></tr><tr><td>plugins</td><td style="text-align:right"></td><td style="text-align:center">包含所有已经安装的插件</td></tr></tbody></table></div><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><p>官方文档 Set up Elasticsearch 有各个 OS 的安装指导，页面 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/install-elasticsearch.html">Installing Elasticsearch</a> 中提供了多种安装包对应的指导链接！</p><p>本文选择绿色安装包的的方式（tar.gz）安装。</p><ul><li>安装环境： ubuntu 20.04</li><li>下载链接： <a href="https://mirrors.huaweicloud.com/elasticsearch/">华为镜像站</a> 速度能快一点</li></ul><p>说明：ElasticSearch使用java语言开发，所以默认需要安装并配置JDK，设置 JAVA_HOME, 但是从 7.0 开始，ElasticSearch 内置了Java环境，无需再安装。另外ES启动不能使用root用户</p><p>内核参数修改（32C + 128G参考）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改文件描述符数量</span></span><br><span class="line">grep <span class="string">&quot;* - nofile 512000&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span>  <span class="string">&quot;* - nofile 512000&quot;</span>  &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改最大打开进程数数量</span></span><br><span class="line">grep <span class="string">&quot;work - nproc unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;elasticsearch - nproc unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"><span class="comment">#配合es mem lock，centos6无须添加</span></span><br><span class="line">grep <span class="string">&quot;* soft memlock unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;* soft memlock unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#配合es mem lock，centos6无须添加</span></span><br><span class="line">grep <span class="string">&quot;* hard memlock unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;* hard memlock unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改系统文件描述符</span></span><br><span class="line">grep <span class="string">&quot;fs.file-max = 1024000&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;fs.file-max = 1024000&quot;</span>  &gt;&gt; /etc/sysctl.conf </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改程序最大管理的vm</span></span><br><span class="line">grep <span class="string">&quot;vm.max_map_count = 262144&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.max_map_count = 262144&quot;</span>  &gt;&gt;  /etc/sysctl.conf  </span><br><span class="line"></span><br><span class="line">grep  <span class="string">&quot;vm.min_free_kbytes = 2097152&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.min_free_kbytes = 2097152&quot;</span>  &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">grep  <span class="string">&quot;vm.zone_reclaim_mode = 0&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.zone_reclaim_mode = 0&quot;</span>  &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">swapoff -a   <span class="comment">#关闭虚拟内存</span></span><br></pre></td></tr></table></figure><h2 id="1-安装-elasticsearch"><a href="#1-安装-elasticsearch" class="headerlink" title="1. 安装 elasticsearch"></a>1. 安装 elasticsearch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xf elasticsearch-7.12.0-linux-x86_64.tar.gz -C ~</span><br><span class="line"><span class="built_in">cd</span> ~/elasticsearch-7.12.0</span><br><span class="line">./bin/elasticsearch  <span class="comment"># 启动</span></span><br></pre></td></tr></table></figure><p>启动成功后访问本地的 9200 端口，可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:9200</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;k8s-master&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;sEn3TgEVSnW4kHpIAU1-5Q&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : <span class="string">&quot;7.12.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_type&quot;</span> : <span class="string">&quot;tar&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_hash&quot;</span> : <span class="string">&quot;78722783c38caa25a70982b5b042074cde5d3b3a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_date&quot;</span> : <span class="string">&quot;2021-03-18T06:17:15.410153305Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;lucene_version&quot;</span> : <span class="string">&quot;8.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;6.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p class="div-border red">如果有安装的错误，参考：</p><ul><li><strong>seccomp unavailable 错误</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：elasticsearch.yml 配置</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure></li><li><strong>max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：修改 &#x2F;etc&#x2F;security&#x2F;limits.conf，配置：</span><br><span class="line">hard nofile 80000</span><br><span class="line">soft nofile 80000</span><br></pre></td></tr></table></figure></li><li><strong>max virtual memory areas vm.max_map_count [65530] is too low</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：修改 &#x2F;etc&#x2F;sysctl.conf，添加 ：</span><br><span class="line">vm.max_map_count &#x3D; 262144</span><br><span class="line">然后 sysctl -p 生效</span><br></pre></td></tr></table></figure><blockquote><p>安装插件方式：./bin/elasticsearch-plugin install analysis-icu</p></blockquote></li></ul><p><strong>ES 相关配置</strong></p><ul><li>官网关于配置的内容主要有两处：<ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html">Configuring Elasticsearch</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">Important Elasticsearch configuration</a></li></ul></li><li>Elasticsearch 主要有三个配置文件：<ul><li><code>elasticsearch.yml</code>：ES的配置文件 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">more</a></li><li><code>jvm.options</code>: ES JVM 参数 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/jvm-options.html#jvm-options">more</a></li><li><code>log4j2.properties</code>: ES log 配置 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/logging.html#logging">more</a></li></ul></li></ul><p>默认情况，ES 告诉 JVM 使用一个最小和最大都为 4GB 的堆。但是到了生产环境，这个配置就比较重要了，确保 ES 有足够堆空间可用。</p><blockquote><p>但是我的XPS 16G内存。不改堆内存大小的只能起一个实例，再起其他实例，旧的实例总显示 Killed。<br>修复方式，更改 <code>./config/jvm.options</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g </span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>运行多个Elasticsearch 实例</strong></p><p>每个实例的配置文件需要不同，这里降低复杂度，不修改配置文件，而是直接用命令行的形式启动一个集群。</p><ul><li>启动实例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动实例1</span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -Enode.name=node0 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">false</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9200 -E transport.tcp.port=9300 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-E cluster.initial_master_nodes=<span class="string">&quot;node0&quot;</span> -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动实例2 </span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -E node.name=node1 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">true</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E path.data=./data/data_node1 -E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9201 -E transport.tcp.port=9301 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动实例3 </span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -E node.name=node2 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">true</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E path.data=./data/data_node2 -E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9202 -E transport.tcp.port=9302 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-d</span><br></pre></td></tr></table></figure><blockquote><ul><li>9300端口： ES节点之间通讯使用</li><li>9200端口： ES节点 和 外部 通讯使用</li><li><code>discovery.seed_hosts</code>: 发现设置。有两种重要的发现和集群形成配置，以便集群中的节点能够彼此发现并且选择一个主节点.其中 <code>discovery.seed_hosts</code> 是组件集群时比较重要的配置，用于启动当前节点时，发现其他节点的初始列表。<br>当一个已经加入过集群的节点重启时，如果他无法与之前集群中的节点通信，很可能就会报这个错误 master not discovered or elected yet, an election requires at least 2 nodes with ids from。必须至少配置 [discovery.seed_hosts，discovery.seed_providers，cluster.initial_master_nodes] 中的一个。</li><li><code>cluster.initial_master_nodes</code>: 初始的候选 master 节点列表。初始主节点应通过其 node.name 标识，默认为其主机名。确保 cluster.initial_master_nodes 中的值与 node.name 完全匹配。<p class="div-border red">`cluster.initial_master_nodes` 该配置项并不是需要每个节点设置保持一致，设置需谨慎，如果其中的主节点关闭了，可能会导致其他主节点也会关闭。因为一旦节点初始启动时设置了这个参数，它下次启动时还是会尝试和当初指定的主节点链接，当链接失败时，自己也会关闭！因此，为了保证可用性，预备做主节点的节点不用每个上面都配置该配置项！保证有的主节点上就不设置该配置项，这样当有主节点故障时，还有可用的主节点不会一定要去寻找初始节点中的主节点！</p></li><li>详细资料参考：<ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-discovery-bootstrap-cluster.html">Bootstrapping a cluster</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-settings.html">Discovery and cluster formation settings</a></li></ul></li></ul><p>在新版 7.x 的 ES 中，对 ES 的集群发现系统做了调整，不再有 discovery.zen.minimum_master_nodes 这个控制集群脑裂的配置，转而由集群自主控制，并且新版在启动一个新的集群的时候需要有cluster.initial_master_nodes 初始化集群主节点列表。如果一个集群一旦形成，你不该再设置该配置项，应该移除它。该配置项仅仅是集群第一次创建时设置的！集群形成之后，这个配置也会被忽略的！</p><ul><li><code>discovery.seed_hosts</code>: 提供群集中符合master节点资格的地址列表</li></ul></blockquote><p>node0 节点仅仅是一个 master 节点，它不是一个数据节点。</p><p>先启动 node0 节点，因为它设置了初始主节点的列表。这时候就可以使用 <code>http://&lt;host IP&gt;:9200/</code> 看到结果了。然后逐一启动 node1 和 node2。通过访问 <code>http://127.0.0.1:9200/_cat/nodes</code> 查看集群是否 OK。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:9200/_cat/nodes</span><br><span class="line">127.0.0.1 42 49 58 4.45 2.09 1.37 lmr        * node0</span><br><span class="line">127.0.0.1 42 49 54 4.45 2.09 1.37 cdfhlmrstw - node1</span><br><span class="line">127.0.0.1 42 49 45 4.45 2.09 1.37 cdfhlmrstw - node2</span><br></pre></td></tr></table></figure></p><h2 id="2-安装-Kibana"><a href="#2-安装-Kibana" class="headerlink" title="2. 安装 Kibana"></a>2. 安装 Kibana</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xf kibana-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kibana-7.12.0-linux-x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>启动kibana</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将kibana改成中文</span></span><br><span class="line">vim config/kibana.yml</span><br><span class="line">     i18n.locale: <span class="string">&quot;zh-CN&quot;</span>   <span class="comment">## 最后一行</span></span><br><span class="line">./bin/kibana</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问本地的5601端口<br>查看样例。点击右下角的 <code>try out sample data</code> ，可以导入kibana的测试数据。分别是电商网站报表、航空数据、日志<br><img src="https://img1.kiosk007.top/static/images/elk/kinana_home.png"><br>这里分 <a href="https://www.elastic.co/cn/enterprise-search?elektra=home&amp;storm=river1">Enterprise Search(企业搜索)</a>、<a href="https://www.elastic.co/guide/en/observability/7.9/observability-introduction.html">Observability(监控)</a>、<a href="https://www.elastic.co/guide/en/security/7.9/es-overview.html">Security(安全)</a></p><ul><li>Enterprise Search(企业搜索)：可建立强大的搜索体验，当然是付费滴。</li><li>Observability(监控)：日志、APM、站点SLA监控、指标打点。（支持Nginx、MySQL、Redis等日志）</li><li>Security(安全): 安全相关的解决方案</li></ul><p>另外还开以打开 <code>http://127.0.0.1:5601/app/dev_tools#/console</code> 控制台，这个是直接对接 ES 的。可在这里直接使用查询语句。</p><h2 id="3-安装-Logstash"><a href="#3-安装-Logstash" class="headerlink" title="3. 安装 Logstash"></a>3. 安装 Logstash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-安装-cerebro"><a href="#4-安装-cerebro" class="headerlink" title="4. 安装 cerebro"></a>4. 安装 cerebro</h2><p>cerebro是专业化项目管理系统，提供一个协作工作环境和项目管理软件，用于处理复杂的视觉材料。它<br>专为 CGI 和动画工作室、广告公司、电视公司和建筑设计公司而开发。也可以说它是一款Elasticsearch监控工具。</p><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/lmenezes/cerebro/releases/download/v0.9.3/cerebro-0.9.3.tgz</span><br><span class="line">tar -xf cerebro-0.9.3.tgz </span><br><span class="line"><span class="built_in">cd</span> cerebro-0.9.3 </span><br><span class="line">./bin/cerebro   <span class="comment"># 启动</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>cerebro 需要 java 才能运行，没有java环境的化，可以执行 <code>sudo apt install openjdk-11-jdk</code> 。 Java 11 是 Java 的一个长期支持版本（LTS）。它同时也是 Ubuntu 20.04的默认 Java 开发和运行环境。</p></blockquote><p>访问 <code>http://127.0.0.1:9000</code> 浏览器打开。</p><p><img src="https://img1.kiosk007.top/static/images/elk/cerebro.png "></p><p>点击左上方 node，可查看节点情况。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>下载测试样本 movielens<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://files.grouplens.org/datasets/movielens/ml-20m.zip</span><br><span class="line">unzip ml-20m.zip</span><br></pre></td></tr></table></figure><br>开始配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">&quot;/home/work/logs/ml-20m/movies.csv&quot;</span></span><br><span class="line">    start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">    sincedb_path =&gt; <span class="string">&quot;/dev/null&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  csv &#123;</span><br><span class="line">    separator =&gt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    columns =&gt; [<span class="string">&quot;id&quot;</span>,<span class="string">&quot;content&quot;</span>,<span class="string">&quot;genre&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123; <span class="string">&quot;genre&quot;</span> =&gt; <span class="string">&quot;|&quot;</span> &#125;</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;path&quot;</span>, <span class="string">&quot;host&quot;</span>,<span class="string">&quot;@timestamp&quot;</span>,<span class="string">&quot;message&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line"></span><br><span class="line">    split =&gt; [<span class="string">&quot;content&quot;</span>, <span class="string">&quot;(&quot;</span>]</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;title&quot;</span> =&gt; <span class="string">&quot;%&#123;[content][0]&#125;&quot;</span>&#125;</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;year&quot;</span> =&gt; <span class="string">&quot;%&#123;[content][1]&#125;&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    convert =&gt; &#123;</span><br><span class="line">      <span class="string">&quot;year&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    strip =&gt; [<span class="string">&quot;title&quot;</span>]</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;path&quot;</span>, <span class="string">&quot;host&quot;</span>,<span class="string">&quot;@timestamp&quot;</span>,<span class="string">&quot;message&quot;</span>,<span class="string">&quot;content&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch &#123;</span><br><span class="line">     hosts =&gt; <span class="string">&quot;http://localhost:9200&quot;</span></span><br><span class="line">     index =&gt; <span class="string">&quot;movies&quot;</span></span><br><span class="line">     document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>导入测试数据到ES中<br><code>logstash -f log.conf</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。&lt;/p&gt;
&lt;p&gt;“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。&lt;/p&gt;
&lt;p&gt;引用官网的一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Worker Pool in Golang</title>
    <link href="http://kiosk007.top/2021/03/21/Worker-Pool-in-Golang/"/>
    <id>http://kiosk007.top/2021/03/21/Worker-Pool-in-Golang/</id>
    <published>2021-03-21T07:41:37.000Z</published>
    <updated>2021-03-21T07:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。但是，如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响</p><a id="more"></a><h1 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h1><p>Pool 的出现，可以避免反复的创建一些对象，比如 TCP链接、数据库链接等等，这些对象创建都比较耗时，如果将创建好的对象放入到池子中，需要的时候取，不需要的时候归还池子，将是一个非常不错的实现方式。</p><p>通过创建一个 Worker Pool 来减少 goroutine 的使用。比如，我们实现一个 TCP 服务器，如果每一个连接都要由一个独立的 goroutine 去处理的话，在大量连接的情况下，就会创建大量的 goroutine，这个时候，我们就可以创建一个固定数量的 goroutine（Worker），由这一组 Worker 去处理连接，比如 fasthttp 中的<a href="https://github.com/valyala/fasthttp/blob/9f11af296864153ee45341d3f2fe0f5178fd6210/workerpool.go#L16">Worker Pool</a>。</p><ul><li><p>著名的TCP连接池实现：fatih 开发的 <a href="https://github.com/fatih/pool">fatih/pool</a>, 虽然已经归档，但是这是由于这个项目已经足够稳定。</p></li><li><p>数据库连接池实现：database/sql 可以参考这篇分析 <a href="https://blog.csdn.net/qq_39384184/article/details/103954821">Golang 侧数据库连接池原理和参数调优</a>，同样使用方式直接参考 <a href="https://www.jianshu.com/p/2d58243fae22">这篇文章</a></p></li></ul><p><strong>一句话总结：保存和复用临时对象，减少内存分配，降低 GC 压力。</strong></p><p>举例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int32</span></span><br><span class="line">Remark [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf, _ = json.Marshal(Student&#123;Name: <span class="string">&quot;Geektutu&quot;</span>, Age: <span class="number">25</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarsh</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := &amp;Student&#123;&#125;</span><br><span class="line">json.Unmarshal(buf, stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>json 的反序列化在文本解析和网络通信过程中非常常见，当程序并发度非常高的情况下，短时间内需要创建大量的临时对象。而这些对象是都是分配在堆上的，会给 GC 造成很大压力，严重影响程序的性能。</p><p><strong>声明对象池</strong></p><p>只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> studentPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(Student) </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Get &amp;&amp; Put </strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu := studentPool.Get().(*Student)</span><br><span class="line">json.Unmarshal(buf, stu)</span><br><span class="line">studentPool.Put(stu)</span><br></pre></td></tr></table></figure></p><ul><li>Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。</li><li>Put() 则是在对象使用完毕后，返回对象池。</li></ul><h1 id="gammazero-workerpool"><a href="#gammazero-workerpool" class="headerlink" title="gammazero/workerpool"></a>gammazero/workerpool</h1><p><a href="https://pkg.go.dev/github.com/gammazero/workerpool">gammazero/workerpool</a> gammazero/workerpool 可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</p><p>下面做一些介绍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gammazero/workerpool&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wp := workerpool.New(<span class="number">2</span>)</span><br><span class="line">requests := []<span class="keyword">string</span>&#123;<span class="string">&quot;alpha&quot;</span>, <span class="string">&quot;beta&quot;</span>, <span class="string">&quot;gamma&quot;</span>, <span class="string">&quot;delta&quot;</span>, <span class="string">&quot;epsilon&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> requests &#123;</span><br><span class="line">r := r</span><br><span class="line">wp.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Handling request:&quot;</span>, r)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wp.StopWait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用提示</strong></li></ul><p>排队的任务数没有上限，只有系统资源的限制。如果入站任务的数量太多，以至于无法排队等待处理那么解决方案就超出了workerpool的处理范围，应该通过在多个系统上分配负载来解决</p><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h2 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h2><p>用户通过 <code>Submit(task func())</code> 方法提交一个 task 到 task 队列中。<br>task 函数默认没有返回值，如果想要有返回值，可以用管道将task 的返回值传到管道中。</p><p>提交的 task 会立即开启一个可用的worker或者新创建一个worker。如果没有可用的worker或者worker数已经达到最大，task会被放入到 task 等待队列中。当worker空闲时会从task 等待队列中取出task。</p><p>一个Worker长时间闲置时可以删除并释放资源。</p><p>这个函数非常简单，就是将收到的待执行任务放入到 task等待队列中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">Submit</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> task != <span class="literal">nil</span> &#123;</span><br><span class="line">p.taskQueue &lt;- task</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有一个变种, 支持同步等待结果<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">SubmitWait</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> task == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">doneChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">p.taskQueue &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">task()</span><br><span class="line"><span class="built_in">close</span>(doneChan)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-doneChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="New"><a href="#New" class="headerlink" title="New"></a>New</h2><p><code>New()</code> 函数创建了一个 worker goroutines pool 。 Max 指定了最大的worker数量，也就是最大并发的执行数，当没有新到来的 task 时，worker会逐渐减少至0.这里注意 taskQueue 是一个只有1个buffer的缓冲，task等待队列是 <code>waitingQueue()</code> 。dispatch 里实现派发任务的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxWorkers <span class="keyword">int</span>)</span> *<span class="title">WorkerPool</span></span> &#123;</span><br><span class="line"><span class="comment">// There must be at least one worker.</span></span><br><span class="line"><span class="keyword">if</span> maxWorkers &lt; <span class="number">1</span> &#123;</span><br><span class="line">maxWorkers = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool := &amp;WorkerPool&#123;</span><br><span class="line">maxWorkers:  maxWorkers,</span><br><span class="line">taskQueue:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>, 1),</span></span><br><span class="line">workerQueue: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>),</span></span><br><span class="line">stopSignal:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">stoppedChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the task dispatcher.</span></span><br><span class="line"><span class="keyword">go</span> pool.dispatch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch 任务派发</strong> 通过设置 idleTimer ，超过这个时间还没有task，就会杀掉一个worker。这个函数刚开始判断等待队列是否为 0，如果不为0，说明任务已经积压，需要将新的task传到等待队列中 ，<code>processWaitingQueue</code>函数内将 task 传给 waitQueue，并在workerQueue有buffer时将任务传给 worker Queue。</p><p>如果 waitQueue 不存在（长度为0），说明还不存在任务排队情况，会将task传给 workerQueue（如果workerQueue能把task塞进去的话），如果塞不进去<br>就创建一个新worker，要么worker刚好又不够了（达到最大worker数量），任务扔进 waitQueue。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispatch sends the next queued task to an available worker.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(p.stoppedChan)</span><br><span class="line">timeout := time.NewTimer(idleTimeout)</span><br><span class="line"><span class="keyword">var</span> workerCount <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> idle <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.waitingQueue.Len() != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !p.processWaitingQueue() &#123;</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.taskQueue:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Got a task to do.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.workerQueue &lt;- task:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Create a new worker, if not at max.</span></span><br><span class="line"><span class="keyword">if</span> workerCount &lt; p.maxWorkers &#123;</span><br><span class="line"><span class="keyword">go</span> startWorker(task, p.workerQueue)</span><br><span class="line">workerCount++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Enqueue task to be executed by next available worker.</span></span><br><span class="line">p.waitingQueue.PushBack(task)</span><br><span class="line">atomic.StoreInt32(&amp;p.waiting, <span class="keyword">int32</span>(p.waitingQueue.Len()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">idle = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line"><span class="comment">// Timed out waiting for work to arrive.  Kill a ready worker if</span></span><br><span class="line"><span class="comment">// pool has been idle for a whole timeout.</span></span><br><span class="line"><span class="keyword">if</span> idle &amp;&amp; workerCount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.killIdleWorker() &#123;</span><br><span class="line">workerCount--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">idle = <span class="literal">true</span></span><br><span class="line">timeout.Reset(idleTimeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If instructed to wait, then run tasks that are already queued.</span></span><br><span class="line"><span class="keyword">if</span> p.wait &#123;</span><br><span class="line">p.runQueuedTasks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop all remaining workers as they become ready.</span></span><br><span class="line"><span class="keyword">for</span> workerCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">p.workerQueue &lt;- <span class="literal">nil</span></span><br><span class="line">workerCount--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>waitingQueue</code> 的目的是讲一个新的task放入到等待 task 队列。或者等待工人队列中有可用的工人时将 task 等待队列中取出 task 交给 worker 队列。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">processWaitingQueue</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.taskQueue:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">p.waitingQueue.PushBack(task)</span><br><span class="line"><span class="keyword">case</span> p.workerQueue &lt;- p.waitingQueue.Front().(<span class="function"><span class="keyword">func</span><span class="params">()</span>):</span></span><br><span class="line"><span class="comment">// A worker was ready, so gave task to worker.</span></span><br><span class="line">p.waitingQueue.PopFront()</span><br><span class="line">&#125;</span><br><span class="line">atomic.StoreInt32(&amp;p.waiting, <span class="keyword">int32</span>(p.waitingQueue.Len()))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。但是，如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP/3</title>
    <link href="http://kiosk007.top/2021/02/21/HTTP3/"/>
    <id>http://kiosk007.top/2021/02/21/HTTP3/</id>
    <published>2021-02-21T03:08:54.000Z</published>
    <updated>2021-02-21T03:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不得不说国外的很多文章写的都十分优秀，将技术的历史背景和细节都讲得十分出色。下面是转自 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> ，这里有很多对外国优秀文章的翻译。关于<strong>HTTP/3</strong>相关的知识。下面做一些简短的记录。</p><a id="more"></a><blockquote><ul><li>原文地址：HTTP/3: From root to tip</li><li>原文作者：Lucas Pardue</li><li>译文出自：掘金翻译计划</li><li>译者：Starrier</li></ul></blockquote><h1 id="HTTP-3-起源"><a href="#HTTP-3-起源" class="headerlink" title="HTTP/3 起源"></a>HTTP/3 起源</h1><p>HTTP/3 是 QUIC 传输层的 HTTP 应用程序映射。该名称在最近（2018 年 10 月底）草案的第 17 个版本中被正式提出（<a href="https://tools.ietf.org/html/draft-ietf-quic-http-17">draft-ietf-quic-http-17</a>），在 11 月举行的 IETF 103 会议中进行了讨论并形成了初步的共识。HTTP/3 以前被称为 QUIC（以前被称为 HTTP/2）。在此之前，我们已经有了 gQUIC，而在更早之前，我们还有 SPDY。事实是，HTTP/3 只是一种适用于 IETF QUIC 的新 HTTP 语法 —— 基于 UDP 的多路复用和安全传输。</p><p>这篇文章将讲述 HTTP/3 的发展历史。详细发展图见 <a href="https://blog.cloudflare.com/content/images/2019/01/web_timeline_large1.svg">Cloudflare Secure Web Timeline</a></p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/gquic-stack.png" style="height:400px"></p><p>HTTP/3 分层模型（蛋糕模型）</p><h2 id="HTTP-演进"><a href="#HTTP-演进" class="headerlink" title="HTTP 演进"></a>HTTP 演进</h2><p>在我们关注 HTTP 之前，值得回忆的是两个共享 QUIC 的名称。就像我们之前解释得那样，gQUIC 通常是指 Google QUIC（协议起源），QUIC 通常用于表示与 gQUIC 不同的 IETF 标准（正在开发的版本）。</p><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP/1"></a><strong>HTTP/1</strong></h3><p>HTTP/1.1 是非常成功的协议，时间线显示 1999 年以后 IETF 并不活跃。然而，事实是，多年的积极使用，为 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 研究潜在问题提供了实战经验，但这也导致了一些交互操作的问题。此外，RFC（像 2817 和 2818）还对该协议进行了扩展。2007 年决定启动一项改进 HTTP 协议规范的新活动 —— HTTPbis（”bis” 源自拉丁语，意为“二”、“两次”或“重复”），它还采用了新的工作组形式。最初的<a href="https://tools.ietf.org/wg/httpbis/charters?item=charter-httpbis-2007-10-23.txt">章程</a>详细描述了尝试解决的问题。</p><p>简而言之，HTTPbis 决定重构 RFC 2616。它将纳入勘误修订，合并在此期间发布的其他规范的一些内容。文件将被分为几个部分，这导致 2017 年 12 月发布了 6 个 I-D：</p><ol><li>draft-ietf-httpbis-p1-messaging</li><li>draft-ietf-httpbis-p2-semantics</li><li>draft-ietf-httpbis-p4-conditional</li><li>draft-ietf-httpbis-p5-range</li><li>draft-ietf-httpbis-p6-cache</li><li>draft-ietf-httpbis-p7-auth</li></ol><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/http1_refactor.png" style="height:400px"></p><p>图表显示了这项工作是如何在长达 7 年的草案过程中取得进展的，在最终被标准化之前，已经发布了 27 份草案。2014 年 6 月，发布了 RFC 723x 系列（x 范围在 0-5）。HTTPbis 工作组的主席以 “<a href="https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead">RFC2616 is Dead</a>“ 来庆祝这一成果。如果它不够清楚，这些新文档就会弃用旧的 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>。</p><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a><strong>SPDY</strong></h3><p>尽管 IETF 的 RFC 723x 系列的工作繁忙，但是技术的进步并未停止。人们继续加强、扩展和测试因特网上的 HTTP。而 Google 已率先开始尝试名为 SPDY（发音同 Speedy）的技术。该协议宣称可以提高 Web 浏览性能，一个使用 HTTP 原则的用例。2009 年底，SPDY v1 发布，2010 年 SPDY v2 紧随其后。</p><p>Google 对 SPDY 实验表明，改变 HTTP 语法是有希望的，维持现有 HTTP 语义是有意义的。比如，保留 URL 的使用格式 —— <code>https://</code>，可以避免许多可能影响采用的问题。看到一些积极的结果后，IETF 决定考虑 HTTP/2.0。2012 年 3 月 IETF 83 期间举行的 HTTPbis 会议的 slides显示了请求、目标和成功标准。它还明确指出 “HTTP/2.0 与 HTTP/1.x 连线格式不兼容”。</p><h3 id="gQUIC-横空出世"><a href="#gQUIC-横空出世" class="headerlink" title="gQUIC 横空出世"></a><strong>gQUIC 横空出世</strong></h3><p>2012 - 2015 之间，Google 继续进行试验，他们发布了 SPDY v3 和 v3.1。他们还开始研究 gQUIC(当时的发音类似于 quick），在 2012 年年初，发布了初始的公共规范。gQUIC 的早期版本使用 SPDY v3 形式的 HTTP 语法。这个选择是有意义的，因为 HTTP/2 尚未完成。SPDY 二进制语法被打包到可以用 UDP 数据报发送数据的 QUIC 包中。</p><p>gQUIC 使用巧妙的设计来实现性能优化。其中一个是破坏应用程序与传输层之间清晰的分层。这也意味着 gQUIC 只支持 HTTP。因此，gQUIC 最后被称为 “QUIC”。它是 HTTP 下一个候选版本的同义词。QUIC 从过去的几年到现在，一直在持续更新，QUIC 也被人们理解为是初始 HTTP 的变体。不幸的是，这正是我们在讨论协议时，经常出现混乱的原因。</p><p>gQUIC 继续在实验中摸索，最后选择了更接近 HTTP/2 的语法。也正因为如此，它才被称为 “HTTP/2 over QUIC”。但因为技术上的限制，所有存在一些非常微妙的差别。一个示例是，HTTP 头是如何序列化并交换的。这是一个细微的差别，但实际上，这意味着 HTTP/2 式 gQUIC 与 IETF’s HTTP/2 并不兼容。</p><p class="div-border yellow">17年-20年市面上大多商用的QUIC均是gQuic，客户端一般为cronet（chromium的网络库），服务端接入层的Nginx一般经过chromium 的封装 </p><p>最后，同样重要的是，我们总是需要考虑互联网协议的安全方面。gQUIC 选择不使用 TLS 来提供安全性。转而使用 Google 开发的另一种称为 QUIC Crypto 的方法。其中一个有趣的方面是有一种加速安全握手的新方法。以前与服务器建立了安全会话的客户端可以重用信息来进行“零延迟往返握手”或 0-RTT 握手。0-RTT 后来被纳入 TLS 1.3。</p><h3 id="什么是HTTP-3"><a href="#什么是HTTP-3" class="headerlink" title="什么是HTTP/3"></a>什么是HTTP/3</h3><p>当然，现在可以说什么是HTTP/3 了，gQUIC 并非与众不同。在2015 年 6 月的 draft-tsvwg-quic-protocol-00 中，写有 “QUIC：基于 UDP 的安全可靠的 HTTP/2 传输” 已经提交。请记住我之前提过的，几乎都是 HTTP/2 的语法。</p><p>Google <a href="https://groups.google.com/a/chromium.org/forum/#!topic/proto-quic/otGKB4ytAyc">宣布</a>将在布拉格举行一次 Bar BoF IETF 93 会议。如有疑问，请参阅 <a href="https://tools.ietf.org/html/rfc6771">RFC 6771</a>。提示：BoF 是物以类聚（Birds of a Feather）的缩写。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_adoption.png" style="height:400px"></p><p>总之，与 IETF 的合作结果是 QUIC 在传输层提供了许多优势，而且它应该与 HTTP 分离。应该重新引入层与层之间清楚的隔离。此外，还有返回基于 TLS 握手的优先级</p><p>大约是一年后，在 2016 年，一组新的 I-D 集合被提交：</p><ul><li><a href="https://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-00">draft-hamilton-quic-transport-protocol-00</a></li><li><a href="https://tools.ietf.org/html/draft-thomson-quic-tls-00">draft-thomson-quic-tls-00</a></li><li><a href="https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00">draft-iyengar-quic-loss-recovery-00</a></li><li><a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a></li></ul><p>这里是关于 HTTP 和 QUIC 的另一个困惑的来源。<a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a> 题为 “HTTP/2 使用 QUIC 传输协议的语义”，对于自己的描述是 “HTTP/2 式 QUIC 的另一种语义映射”。但这个解释并不正确。HTTP/2 在维护语义的同时，改变了语法。而且，我很早之前就说过了，”HTTP/2 式 gQUIC” 从未对语法进行确切的描述，记住这个概念。</p><p>2016 年在柏林举行 IETF 96 会议决定了有数百人参加了这次会议。会议结束时，达成了一致的共识：<strong>QUIC 将被 IETF 采用并标准化。</strong></p><p class="div-border green">之后的QUIC必将全面IETF化</p><p>将 HTTP 映射到 QUIC 的第一个 IETF QUIC I-D —— <a href="https://tools.ietf.org/html/draft-ietf-quic-http-00">draft-ietf-quic-http-00</a>，采用了 Ronseal 方法来简化命名 —— “HTTP over QUIC”。不幸的是，它并没有达到预期效果，整个内容中都残留有 HTTP/2 术语的实例。Mike Bishop —— I-D 的新编辑，发现并修复了 HTTP/2 的错误名称。在 01 草案中，将描述修改为 “a mapping of HTTP semantics over QUIC”。</p><p>随着时间和版本的推进，”HTTP/2” 的使用逐渐减少，实例部分仅仅是对 <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> 部分的引用。从 2018 年 10 月开始向前回退两年的时间开始计算，I-D 如今已经是第 16 版本。虽然 HTTP over QUIC 与 HTTP/2 有相似内容，但始终是独立的（非向后兼容的 HTTP 语法）。然而，对那些不密切关注 IETF 发展的人来说（人数众多），他们并不能从名称中发现一些细微的差异。标准化的重点之一是帮助通信和互操作性。但像命名这样的简单事件，才是导致社区相对混乱的主要原因。<br>回顾 2012 年的内容，”HTTP/2.0 意味着 wire 格式与 HTTP/1.x 格式不兼容”。IETF 遵循现有线索。IETF 103 是经过深思熟虑才最终达成一致的，即：”HTTP over QUIC” 命名为 HTTP/3。互联网正在促使世界变得更加美好，我们可以继续进行更加重要的的探讨。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>概况来说就是：HTTP/3 只是一种适用于 IETF QUIC 的新 HTTP 语法 —— 一种基于 UDP 多路复用的安全传输层。仍有许多有趣的领域需要深入探索。</p><blockquote><p>参考文章</p><ul><li>：<a href="https://juejin.cn/post/6914561963393548295#heading-11">揭秘QUIC的性能与安全</a></li><li>：<a href="https://juejin.cn/post/6908522467107536903#heading-3">Google、Facebook等均开始支持的HTTP3到底是个什么鬼？</a></li></ul></blockquote><h1 id="QUIC的实现"><a href="#QUIC的实现" class="headerlink" title="QUIC的实现"></a>QUIC的实现</h1><h2 id="QUIC-握手"><a href="#QUIC-握手" class="headerlink" title="QUIC 握手"></a>QUIC 握手</h2><p>在2016年11月国际互联网工程任务组(IETF)召开的第一次QUIC工作组会议，受到了业界的广泛关注。这也意味着QUIC开始了它的标准化过程，成为新一代传输层协议，形成了最新的iQUIC。<strong>IETF在QUIC的加密协议上就放弃了google的加密协议使用了标准的TLS1.3。</strong></p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_struct.png"></p><p><strong>QUIC 握手</strong></p><p>QUIC 连接的建立整体流程大致为：QUIC在握手过程中使用Diffie-Hellman算法协商初始密钥，初始密钥依赖于服务器存储的一组配置参数，该参数会周期性的更新。初始密钥协商成功后，服务器会提供一个临时随机数，双方根据这个数再生成会话密钥。客户端和服务器会使用新生的的密钥进行数据加解密。</p><p>以上过程主要分为两个步骤：<span class="inline-tag grey">初始握手（Initial handshake）</span>、<span class="inline-tag grey">最终 与重复 握手（Final (and repeat) handshake）</span> ，分别介绍下这两个过程。</p><h3 id="初始握手（Initial-handshake）"><a href="#初始握手（Initial-handshake）" class="headerlink" title="初始握手（Initial handshake）"></a>初始握手（Initial handshake）</h3><p>在连接开始建立时，客户端会向服务端发送一个打招呼信息，（inchoate client hello (CHLO)），因为是初次建立，所以，服务端会返回一个拒绝消息（REJ），表明握手未建立或者密钥已过期。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake1.jpeg"></p><p>但是，这个拒绝消息中还会包含更多的信息（配置参数），主要有：</p><ol><li>Server Config：一个服务器配置，包括服务器端的Diffie-Hellman算法的长期公钥（long term Diffie-Hellman public value）</li><li>Certificate Chain：用来对服务器进行认证的信任链</li><li>Signature of the Server Config：将Server Config使用信任链的叶子证书的public key加密后的签名</li><li>Source-Address Token：一个经过身份验证的加密块，包含客户端公开可见的IP地址和服务器的时间戳。</li></ol><p>在客户端接收到拒绝消息（REJ）之后，客户端会进行数据解析，签名验证等操作，之后会将必要的配置缓存下来。<br>同时，在接收到REJ之后，客户端会为这次连接随机产生一对自己的短期密钥（ephemeral Diffie-Hellman private value） 和 短期公钥（ephemeral Diffie-Hellman public value）。</p><p>之后，客户端会将自己刚刚产生的短期公钥打包一个Complete CHLO的消息包中，发送给服务端。这个请求的目的是将自己的短期密钥传输给服务端，方便做前向保密。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake2.jpeg"></p><p>在发送了Complete CHLO消息给到服务器之后，为了减少RTT，客户端并不会等到服务器的响应，而是立刻会进行数据传输。</p><p>为了保证数据的安全性，客户端会自己的短期密钥和服务器返回的长期公钥进行运算，得到一个初始密钥（initial keys）。接下来他接收到客户端使用初始密钥加密的数据之后，就可以使用这个初识密钥进行解密了，并且可以将自己的响应再通过这个初始密钥进行加密后返回给客户端。</p><h3 id="最终（与重复）握手"><a href="#最终（与重复）握手" class="headerlink" title="最终（与重复）握手"></a>最终（与重复）握手</h3><p>那么，之后的数据传输就可以使用初始密钥（initial keys）加密了吗？<br>其实并不完全是，因为初始密钥毕竟是基于服务器的长期公钥产生的，而在公钥失效前，几乎多有的连接使用的都是同一把公钥，所以，这其实存在着一定的危险性。<br>所以，为了达到前向保密 (Forward Secrecy) 的安全性，客户端和服务端需要使用彼此的短期公钥和自己的短期密钥来进行运算。</p><p>那么现在问题是，客户端的短期密钥已经发送给服务端，而服务端只把自己的长期密钥给了客户端，并没有给到自己的短期密钥。<br>所以，服务端在收到Complete CHLO之后，会给到服务器一个server hello(SHLO)消息，这个消息会使用初始密钥（initial keys）进行加密。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake4.jpeg"></p><p>这个CHLO消息包中，会包含一个服务端重新生成的短期公钥。<br>这样客户端和服务端就都有了对方的短期公钥（ephemeral Diffie-Hellman public value）。<br>这样，客户端和服务端都可以基于自己的短期密钥和对方的短期公钥做运算，产生一个仅限于本次连接使用的前向保密密钥 (Forward-Secure Key)，后续的请求发送，都基于这个密钥进行加解密就可以了。<br>这样，双方就完成了最终的密钥交换、连接的握手并且建立了QUIC连接。<br>当下一次要重新创建连接的时候，客户端会从缓存中取出自己之前缓存下来的服务器的长期公钥，并重新创建一个短期密钥，重新生成一个初识密钥，再使用这个初始密钥对想要传输的数据进行加密，向服务器发送一个Complete CHLO 请求即可。这样就达到了0 RTT的数据传输。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake5.jpeg"></p><p>所以，如果是有缓存的长期公钥，那么数据传输就会直接进行，准备时间是0 RTT</p><p><strong>以上，通过使用Diffie-Hellman算法协商密钥，并且对加密和握手过程进行合并，大大减小连接过程的RTT ，使得基于QUIC的连接建立可以少到1 RTT甚至0 RTT。</strong></p><p>下面是建立握手的完整过程</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake6.jpeg"></p><p><strong>小结</strong>：</p><p>QUIC的通讯过程在初次没有建立过连接时使用1-RTT的握手机制，同时保证连接的建立和达到安全的保障。以下是QUIC的1-RTT的握手过程：</p><ol><li>Server端会持有0-RTT公私钥对，并且生成SCFG（服务端的配置信息对象），把公钥放入SCFG中；</li><li>客户端初次请求时，需要向服务端获取0-RTT公钥，这个需要消耗一个RTT，这也QUIC的1-RTT的所在；</li><li>客户端在收到0-RTT公钥以后会缓存起来，同时生成自己的临时公私钥对，经过前面的一个RTT后客户端把自己的临时私钥与服务端发过来的0-RTT的公钥根据DH算法生成一个加密密钥K1，同时使用K1加密数据同时附送自己的临时公钥一起发送服务端，此时已有用户数据发送；</li><li>在服务端收到用户使用K1加密的用户数据和客户端发来的临时公钥以后，会做如下几件事：<ul><li>使用0-RTT私钥与客户端发来的临时公钥通过DH算法生成K1解密用户数据并递交到应用；</li><li>生成服务端临时公私钥对，使用临时公私钥对的私钥，与客户端发来的客户端临时公钥，生成K2加密服务端要传输的数据</li><li>把服务端的临时公钥和使用K2加密的应用数据发送到客户端</li></ul></li><li>客户端收到服务端发送的服务端临时公钥和使用K2加密的应用数据后会再次使用DH算法把服务端的临时公钥和客户端原来的临时私钥重新生成K2解密数据，并且从此以后使用K2进行数据层的加解密</li></ol><ul><li><strong>1RTT握手</strong></li></ul><p>0-RTT是QUIC一个很关键的属性，能够在连接的第一个数据报文就可以携带用户数据。但是我们也可以看到如果客户端和服务端从来没有通讯过，那么是不存在0-RTT的，需要一个完成的RTT之后才能承载用户数据。<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_1rtt.png" style="height:400px"></p><ul><li><strong>0RTT握手</strong></li></ul><p>这个流程是gQUIC的流程，iQUIC由于使用的是TLS1.3，握手阶段报文的细节会有些不一样，例如首个请求的是证书、PSK等信息。在0-RTT阶段使用的是session复用的ticket方式。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_0rtt.png" style="height:400px"></p><p class="div-border yellow">gQUIC使用的是gQUIC Crypto，并不是TLS1.3</p><ul><li><strong>安全考虑</strong></li></ul><p>UDP的安全性存在的几个关键的地方，源地址欺骗攻击，UDP放大攻击等。在QUIC中有设计了源地址TOKEN（STK）验证的安全机制来解决源地址的欺骗攻击，在通讯过程中服务器要求确认客户端的源地址TOKEN，这个源地址TOKEN根据数据包的源地址和服务器的时间戳等因子生成STK，随后和响应数据包一起发送到客户端，而在后续的数据传输过程中客户端需要透传这个STK到服务端，从而服务端可以进行校验。当服务端发现连接对应的源地址发送变化时会主动发送RETRY报文进行服务端主动源地址验证。客户端也可以主动发起源地址验证信息。源地址验证可以保护两类攻击问题，源地址欺骗攻击和UDP放大攻击。</p><ol><li><p>连接建立时，为了验证客户端的地址是否是攻击者伪造的，服务端会生成一个令牌（token）并通过重试包（Retry packet）响应给客户端。客户端需要在后续的初始包（Initial packet）带上这个令牌，以便服务端进行地址验证。</p></li><li><p>服务端可以在当前连接中通过 NEW_TOKEN 帧预先发布令牌，以便客户端在后续的新连接使用，这是 QUIC 实现 0-RTT 很重要的一个功能。</p></li><li><p>当我们的网络路径变化时（比如从蜂窝网络切换到 WIFI），QUIC 提供了连接迁移（connection migration）的功能来避免连接中断。QUIC 通过路径验证（Path Validation）验证网络新地址的可达性（reachability），防止在连接迁移中的地址是攻击者伪造的。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;不得不说国外的很多文章写的都十分优秀，将技术的历史背景和细节都讲得十分出色。下面是转自 &lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt; ，这里有很多对外国优秀文章的翻译。关于&lt;strong&gt;HTTP/3&lt;/strong&gt;相关的知识。下面做一些简短的记录。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GoLang 编程模式 -- 基本概念</title>
    <link href="http://kiosk007.top/2021/01/30/GoLang-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://kiosk007.top/2021/01/30/GoLang-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-30T03:12:07.000Z</published>
    <updated>2021-01-30T03:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为了巩固一下 Go 的基础，主要涉及 Slice、Interface、函数式编程等。</p><a id="more"></a><p>也是读了<a href="https://coolshell.cn/" style>左耳朵耗子</a> 叔的 <a href="https://coolshell.cn/articles/21128.html">Go编程模式</a> 的系列文章发现有的细节确实之前也有遗漏，刚好也趁机复习巩固一下。</p><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">//指向存放数据的数组指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span>            <span class="comment">//长度有多大</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span>            <span class="comment">//容量有多大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Slicce标头的<strong>array</strong>字段是底层真正指向数组的指针。</p><p><img src="https://i0.wp.com/golangbyexample.com/wp-content/uploads/2020/05/slice.jpg?w=391&amp;ssl=1" alt></p><p>Golang 的切片是子集。切片可以是数组、列表或字符串的子集。可以从一个字符串中提取多个片段，每个片段作为一个新变量。</p><h3 id="与数组的不同："><a href="#与数组的不同：" class="headerlink" title="与数组的不同："></a><strong>与数组的不同</strong>：</h3><p>数组在声明为一定大小后，不能调整大小，而切片可以调整大小。切片是引用类型，而数组是值类型。</p><h3 id="在Golang中创建切片"><a href="#在Golang中创建切片" class="headerlink" title="在Golang中创建切片"></a><strong>在Golang中创建切片</strong></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> stringSlice = []<span class="keyword">string</span>&#123;<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;slice&quot;</span>&#125;</span><br><span class="line">fmt.Println(stringSlice)  <span class="comment">// prints [This is a string slice]</span></span><br><span class="line"><span class="comment">// res:  [This is a string slice]</span></span><br><span class="line"></span><br><span class="line">myset := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* take slice */</span></span><br><span class="line">s1 := myset[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">// res:  [0 1 2 3]</span></span><br><span class="line"></span><br><span class="line">mystring := <span class="string">&quot;Go programming&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* take slice */</span></span><br><span class="line">s2 := mystring[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s2)</span><br><span class="line"><span class="comment">// res:  Go</span></span><br><span class="line"></span><br><span class="line">numbers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;numbers=%v\n&quot;</span>, numbers)</span><br><span class="line">fmt.Printf(<span class="string">&quot;length=%d\n&quot;</span>, <span class="built_in">len</span>(numbers))</span><br><span class="line">fmt.Printf(<span class="string">&quot;capacity=%d\n&quot;</span>, <span class="built_in">cap</span>(numbers))</span><br><span class="line"><span class="comment">// res:</span></span><br><span class="line"><span class="comment">//numbers=[0 0 0]</span></span><br><span class="line"><span class="comment">//length=3</span></span><br><span class="line"><span class="comment">//capacity=5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片引用"><a href="#切片引用" class="headerlink" title="切片引用"></a><strong>切片引用</strong></h3><p>切片是引用类型，那么就意味着数组指针的问题——数据会发生共享！下面我们来看看 Slice 的一些操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">foo[<span class="number">3</span>] = <span class="number">42</span></span><br><span class="line">foo[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">bar  := foo[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">bar[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 foo</span></span><br><span class="line"><span class="comment">// 打印 bar</span></span><br></pre></td></tr></table></figure><ol><li>首先，创建一个 foo 的 Slice，其中的长度和容量都是 5；</li><li>然后，开始对 foo 所指向的数组中的索引为 3 和 4 的元素进行赋值；</li><li>最后，对 foo 做切片后赋值给 bar，再修改 bar[1]。</li></ol><p>最终的foo和bar的结果是什么呢? 是不是和想象的不太一样，这是因为切片操作的底层数组是同一个数组。foo 和 bar 的内存是共享的，所以，foo 和 bar 对数组内容的修改都会影响到对方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(foo)  &#x2F;&#x2F; res: [0 0 99 42 100]</span><br><span class="line">fmt.Println(bar)  &#x2F;&#x2F; res: [0 99 42]</span><br></pre></td></tr></table></figure></p><p>再来看一个 <code>append</code> 的例子。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">16</span>]</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印a</span></span><br><span class="line"><span class="comment">// 打印b</span></span><br></pre></td></tr></table></figure><br>在这段代码中，把 <code>a[1:16]</code> 的切片赋给 b ，此时，a 和 b 的内存空间是共享的，然后，对 a 做了一个 append()的操作，这个操作会让 a 重新分配内存，这就会导致 a 和 b 不再共享，如下图所示：<br><img src="https://static001.geekbang.org/resource/image/9a/13/9a29d71d309616f6092f6bea23f30013.png" style="max-width: 70%;border-radius: 6px"></p><p>这时 a 和 b 的值是多少？append()操作让 a 的容量变成了 64，而长度是 33。这里你需要重点注意一下，<strong>append()这个函数在 cap 不够用的时候，就会重新分配内存以扩大容量，如果够用，就不会重新分配内存了！</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(a)  &#x2F;&#x2F; res: [0 0 42 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]</span><br><span class="line">fmt.Println(b)  &#x2F;&#x2F; res: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>那既然这样相同的例子我们再来一遍，如果让a不要重新分配内存(比如初始化a的时候使用<code>a := make([]int, 33))</code>，那么b的结果就会变成 <code>[0 42 0 0 0 0 0 0 0 0 0 0 0 0 0]</code> <strong>注意</strong>：这时的b会因为<code>a[2]</code> 的变化而变化。</p><p>同样的例子如下，只要没有发生<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path := []<span class="keyword">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">sepIndex := bytes.IndexByte(path,<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dir1 := path[:sepIndex]</span><br><span class="line">dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir1),<span class="built_in">cap</span>(dir1)) <span class="comment">// prints: len: 4 cap: 14</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir2),<span class="built_in">cap</span>(dir2)) <span class="comment">// prints: len: 9 cap: 14</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">dir1 = <span class="built_in">append</span>(dir1,<span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; uffixBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子中，dir1 和 dir2 共享内存，虽然 dir1 有一个 append() 操作，但是因为 cap 足够，于是数据扩展到了dir2 的空间。下面是相关的图示（注意上图中 dir1 和 dir2 结构体中的 cap 和 len 的变化）：</p><p><img src="https://static001.geekbang.org/resource/image/17/aa/1727ca49dfe2e6a73627a52a899535aa.png" style="max-width: 70%;border-radius: 6px"></p><p>这里的 <code>dir1:=path[:sepIndex]</code> 没有触发重新分配内存，如果想要强行重新分配内存的话可以使用<code>dir1 := path[:sepIndex:sepIndex]</code> 最后一个参数叫“Limited Capacity”，于是，后续的 append() 操作会导致重新分配内存。</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface 接口是一个抽象概念，它支持Go中的<strong>多态</strong>。该接口的变量可以保存实现该类型的值。类型断言用于获取底层的具体值。接口也是给Go语言带来了无限扩展空间。其中 <code>io.Reader</code> 接口就是一个典型的例子，<strong>io.Reader</strong> 表示读取设备数据流的能力，可以从<a href="https://golang.cafe/blog/golang-reader-example.html">网络、文件、字符串</a>等等。先简单介绍下 <code>io.Reader</code> 接口 ，后面会介绍如何使用接口式编程的方式封装 Reader 。</p><h3 id="接口式编程"><a href="#接口式编程" class="headerlink" title="接口式编程"></a>接口式编程</h3><p><a href="https://golang.org/pkg/io/#Reader">io.Reader</a> interface 可以表示从实体中读取字节流。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即只要实现了 <code>Read(buf []byte) (n int, err error)</code> 方法便就是 <code>io.Reader</code> 接口。Read最多将 <code>len(buf)</code> 字节读入buf并返回读取的字节, 直到读到 <code>io.EOF</code> 时返回。标准库中实现了很多Reader的实现。并且很多应用程序都接受 <code>Reader</code> 作为输入。</p><ul><li><strong>直接从字节流中读取</strong></li></ul><p>这里分为 <code>Read</code>、 <code>io.ReadFull</code>、 <code>ioutil.ReadAll</code> 三种方法。每种方法都有一些区别。</p><ol><li>直接使用 Read 方法</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r := strings.NewReader(<span class="string">&quot;abcde&quot;</span>)</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(buf)</span><br><span class="line">fmt.Println(n, err, buf[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个字节流 <code>r</code>, 在循环从r中读取出数据。循环会执行3次，第一次读取4个字节，第二次读取1个字节，第三次读到 <code>io.EOF</code> 返回跳出循环。注意，Read方法读取时会清空 <code>buf</code> 里的数据，所以这里需要每次读完打印一下。再次读时，<code>buf</code> 里的数据会被重新覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 &lt;nil&gt; [97 98 99 100]</span><br><span class="line">1 &lt;nil&gt; [101]</span><br><span class="line">0 EOF []</span><br></pre></td></tr></table></figure><p>另外还可以使用 <code>io.ReadFull</code> 或者 <code>ioutil.ReadAll</code> 取读取字节流,<code>io.ReadFull</code>用法和<code>Read</code>差不多，<code>ioutil.ReadAll</code>不需要设置buf可直接返回buf。更多可参考：<a href="https://yourbasic.org/golang/io-reader-interface-explained/">How to use the io.Reader interface</a></p><ul><li><strong>利用接口特性</strong></li></ul><p>下面的代码是一个实时统计标准输入字符个数的代码。用户每次按下回车都可以看到当前输入的字符以及历史上已经输入的字符的个数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountNumber</span><span class="params">(input <span class="keyword">chan</span> []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> input &#123;</span><br><span class="line">count += <span class="built_in">len</span>(data)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> bytes := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>)</span><br><span class="line"> fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line"> <span class="keyword">go</span> CountNumber(bytes)</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，但是似乎和我们要讲到的接口式编程没什么关系。下面我们用接口封装一下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCountReader</span><span class="params">()</span> *<span class="title">CountReader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CountReader&#123;</span><br><span class="line">bytes: <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>),</span><br><span class="line">data:  <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountReader <span class="keyword">struct</span> &#123;     <span class="comment">// 声明CountReader对象</span></span><br><span class="line">bytes    <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line">data     []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123; <span class="comment">// 实现Read方法</span></span><br><span class="line">ok := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> ok &amp;&amp; <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line">h.data, ok = &lt;-h.bytes   <span class="comment">// 将bytes里的数据全部传给 data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok || <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, io.EOF    <span class="comment">// 可能读到了结尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l := <span class="built_in">copy</span>(p, h.data)</span><br><span class="line">h.data = h.data[l:]</span><br><span class="line"><span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := bufio.NewReader(h)</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">n,err := b.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">count += <span class="built_in">len</span>(buf[:n])</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明了一个结构体 <code>CountReader</code>, 再实现了一个 <code>Read()</code> 方法调用，我们知道实现了<code>Read()</code>即可以成为 <code>io.Reader</code> 接口的实现。也就是说 <code>CountReader</code> 就是一个 <code>io.Reader</code> ，那么 <code>io.Reader</code> 可以使用的方法，也可以给 <code>CountReader</code> 使用。这时就可以使用 <code>bufio</code> 这个库了。使用 <code>bufio.NewReader</code> 的函数对输入数据进行读取和计算。</p><p class="div-border yellow"><code>bufio.NewReader()</code> 方法提供一个缓存buf, 默认缓存4k buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line">Counter := NewCountReader()</span><br><span class="line"><span class="keyword">go</span> Counter.run()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">Counter.bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来通过上述代码即可完成相同的操作，这只是一个简单的例子，如果换成文件io、网络io就会有非常可观的收益。带来业务性能的提升。</p><h1 id="Functional-Option"><a href="#Functional-Option" class="headerlink" title="Functional Option"></a>Functional Option</h1><p>Functional Options 这个编程模式是一个函数式编程的应用案例，编程技巧也很好，是目前 Go 语言中最流行的一种编程模式。</p><p>假设实际编程中需要针对业务对象设置很多属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr     <span class="keyword">string</span></span><br><span class="line">    Port     <span class="keyword">int</span></span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    MaxConns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 Server 对象中，我们可以看到：</p><ul><li>要设置侦听的 IP 地址 Addr 和端口号 Port。（必填）</li><li>协议、超时时间、最大链接数、TLS选项等属性需要配置。（非必填）</li></ul><p>那么如何让调用方实现这个必填参数和非必填参数呢？一个方法是将非必填参数设成 <code>...interface&#123;&#125;</code> 但这样肯定不好，因为不同的参数类型都不一样。另一种方式就是将 必填参数和非必填参数分开了。</p><p>如非必填参数搞成一个结构体</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    Maxconns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必填参数和这个 <code>Config</code> 直接传给初始化函数，如果没有要填的参数可以将 <code>Config</code> 设为 <code>nil</code> 。</p><p>这样一来 <code>Server</code> 结构体便成了这样, 初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Conf *Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, conf *Config)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using the default configuratrion</span></span><br><span class="line">srv1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="literal">nil</span>) </span><br><span class="line"></span><br><span class="line">conf := ServerConfig&#123;Protocol:<span class="string">&quot;tcp&quot;</span>, Timeout: <span class="number">60</span>*time.Duration&#125;</span><br><span class="line">srv2, _ := NewServer(<span class="string">&quot;locahost&quot;</span>, <span class="number">9000</span>, &amp;conf)</span><br></pre></td></tr></table></figure><p>这样便已经是大多数人的作法了。但是不是没有修改空间，下面介绍一下 Functional Option 方式。</p><h2 id="初始化-Server-示例"><a href="#初始化-Server-示例" class="headerlink" title="初始化 Server 示例"></a><strong>初始化 Server 示例</strong></h2><p>首先我们定义一个 <code>Option</code> 类型:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span></span></span><br></pre></td></tr></table></figure><p>用函数式方式定义一组函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Protocol = p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Timeout = timeout</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxConns</span><span class="params">(maxconns <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.MaxConns = maxconns</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TLS</span><span class="params">(tls *tls.Config)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.TLS = tls</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这组代码的含义是传入一个参数，返回一个函数，函数会将 <code>Server</code> 结构的对应参数值进行设置。例如，当我们调用其中的一个函数 MaxConns(30) 时，其返回值是一个 func(s* Server) { s.MaxConns = 30 } 的函数。</p><p>这下，我们可以定义一个 <code>NewServer</code> 函数，其中有一个可变参数 <code>option</code> ,用一个循环来设置 Server 的属性。不仅提供了默认值，还提供将默认值改成可修改选项进行修改。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...<span class="keyword">func</span>(*Server)</span>) <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  srv := Server&#123;</span><br><span class="line">    Addr:     addr,</span><br><span class="line">    Port:     port,</span><br><span class="line">    Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">    Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">    MaxConns: <span class="number">1000</span>,</span><br><span class="line">    TLS:      <span class="literal">nil</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">    option(&amp;srv)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，我们在创建 Server 对象的时候，就可以像下面这样：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">1024</span>)</span><br><span class="line">s2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">2048</span>, Protocol(<span class="string">&quot;udp&quot;</span>))</span><br><span class="line">s3, _ := NewServer(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8080</span>, Timeout(<span class="number">300</span>*time.Second), MaxConns(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p>这下对 Server 的封装就像搭积木一样简单容易并且可视化很好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为了巩固一下 Go 的基础，主要涉及 Slice、Interface、函数式编程等。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>探索 Webtransport</title>
    <link href="http://kiosk007.top/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/"/>
    <id>http://kiosk007.top/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/</id>
    <published>2021-01-23T02:33:00.000Z</published>
    <updated>2021-01-23T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://wicg.github.io/web-transport/">WebTransport</a> 是一个新一代的浏览器API，提供客户端-服务端之间的双向低延迟交互，并在顶部使用常见 API 来实现其下的可插拔协议（<font style="color:#FF7F50">尤其是基于<a style="color:#FF7F50" href=" https://www.chromium.org/quic">QUIC</a></font>）。该 API 与 WebSocket 相似，也是客户端和服务器的双向连接，但允许进一步减少客户端和服务器之间的网络通信延迟，并且还支持多个流、单向流、乱序和不可靠传输。基于QUIC的Webtransport (Quictransport)即支持通过 datagram API 发送不可靠的数据，也支持通过 stream API 实现可靠数据传输。</p><p>使用场景包括使用不可靠且乱序的消息向服务器重复发送低延迟的游戏状态、从服务器到客户端的媒体片段的低延迟传输以及大多数逻辑在服务器上运行的云场景。</p><p>WebTransport 提案详细介绍：<font style="color:#FF7F50"> <a href="https://wicg.github.io/web-transport/">https://wicg.github.io/web-transport/</a> </font></p><p><strong>重点</strong></p><ol><li>Webtransport 支持不可靠传输，通过轻量级、低延迟的UDP协议传输。</li><li>Webtransport 可基于 QUIC 实现 Client-Server 可靠的流式传输。</li><li>可支持多条流的相互独立 + QUIC 多路复用\非队头阻塞特性 完美代替当前的 Websocket。Webtransport 提供了一些当前websocket规范不可能提供的功能。可消除当前多个数据包之间的队头阻塞。</li></ol><p><strong>标准规范</strong></p><ol><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-overview-01"> WebTransport overview </a> : Webtransport 的概述及对传输层的要求。</li><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-quic"> WebTransport over QUIC</a> : 定义了基于QUIC的 Webtransport</li><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-http3-02"> WebTransport over HTTP/3 </a>: 定义了基于HTTP/3的 Webtransport （实际上 HTTP/3 也是基于QUIC的）</li></ol><p>当前 Chrome 团队只实现了基于 QUIC 的 Webtransport 。然而目前也仅仅是实验性的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transport = <span class="keyword">new</span> QuicTransport(<span class="string">&#x27;quic-transport://localhost:4433/path&#x27;</span>);</span><br></pre></td></tr></table></figure><br>Webtransport draft 标明是支持TCP的， 但显然目前大家都在UDP上了投入了大量精力，也主要是以UDP去实现的。</p><p><img src="https://img1.kiosk007.top/static/images/network/WebTransport/common_transport_requirements.png"></p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>当前的Webtransport 必须基于 QUIC draft-29 或更高版本。客户端主要以 chrome 浏览器为主，版本必须 &gt;= 85 。服务端我们将基于 <a href="github.com/lucas-clemente/quic-go" style="color:#FF7F50"> github.com/lucas-clemente/quic-go </a>  go library 。因为是本地测试，我们还需要签发一个自签名证书。</p><h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>因为当前Webtransport的底层实现是基于 QUIC or HTTP/3 ，所以我们必须要实现自签名证书，确保通信过程的安全性。这里我们使用的是 <code>openssl</code> </p><p>首先需要确保你的 <code>openssl</code> 安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ <span class="built_in">which</span> openssl</span><br><span class="line">/usr/bin/openssl</span><br><span class="line">➜ openssl version</span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>创建证书和私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl req -newkey rsa:2048 -nodes -keyout certificate.key \</span><br><span class="line">-x509 -out certificate.pem -subj <span class="string">&#x27;/CN=Test Certificate&#x27;</span> \</span><br><span class="line">-addext <span class="string">&quot;subjectAltName = DNS:localhost&quot;</span></span><br></pre></td></tr></table></figure><p>计算证书的指纹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl x509 -pubkey -noout -<span class="keyword">in</span> certificate.pem |</span><br><span class="line">openssl rsa -pubin -outform der |</span><br><span class="line">openssl dgst -sha256 -binary | base64</span><br><span class="line"><span class="comment">#      The result should be a base64-encoded blob that looks like this:</span></span><br><span class="line"><span class="comment">#          &quot;Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=&quot;</span></span><br></pre></td></tr></table></figure><p>向chrome传入参数指明允许使用自签证书的服务端地址+端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--origin-to-force-quic-on=localhost:4433</span><br></pre></td></tr></table></figure><p>使用如下参数以信任证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ignore-certificate-errors-spki-list=Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=</span><br></pre></td></tr></table></figure><br>更多可以参考： <a href="https://www.chromium.org/developers/how-tos/run-chromium-with-flags">docs on how to run Chrome/Chromium with custom flags.</a></p><p>最后打开 <a style="color:#FF7F50" href="https://googlechrome.github.io/samples/webtransport/client.html">https://googlechrome.github.io/samples/webtransport/client.html</a></p><p><img src="https://img1.kiosk007.top/static/images/network/WebTransport/webtransport_client.png" style="height:550px"></p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>我们使用 github.com/lucas-clemente/quic-go 来实现QUIC。</p><p>Run 方法来实现接受客户端的连接请求。quic.ListenAddr 创建一个监听器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   listener, err := quic.ListenAddr(s.config.ListenAddr, s.generateTLSConfig(), s.generateQUICConfig())</span><br><span class="line">   utils.Logging.Info().Err(err)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;WebTransport Engine v0.1 Start ...&quot;</span>)</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;Listening for %s connections on %s&quot;</span>,<span class="string">&quot;udp&quot;</span>, s.config.ListenAddr)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      session, err := listener.Accept(context.Background())</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      utils.Logging.Info().Msgf(<span class="string">&quot;session accepted: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _ = session.CloseWithError(<span class="number">0</span>, <span class="string">&quot;bye&quot;</span>)</span><br><span class="line">            utils.Logging.Info().Msgf(<span class="string">&quot;close session: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line">         &#125;()</span><br><span class="line">         s.handleSession(session)</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端需要在 ALPN 中携带 alpnQuicTransport = “wq-vvv-01” 服务端读取后就会针对开始Webtransport 传输。<br><img src="https://img1.kiosk007.top/static/images/network/WebTransport/wq-vvv-01_alpn.png" style="height:550px"></p><p>代码参见：<a href="https://github.com/weijiaxiang007/webtransport/" style="color:#FF7F50"> https://github.com/weijiaxiang007/webtransport/ </a></p><h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p><font style="color:#6495ED">QUIC使用流ID的最低两位指示流标识以下信息</font></p><ol><li>单向 or 双向流</li><li>由客户端 or 服务端发起。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+----------------------------------+</span><br><span class="line">| Bits | Stream Type                      |</span><br><span class="line">+======+==================================+</span><br><span class="line">| 0x0  | Client-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x1  | Server-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x2  | Client-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x3  | Server-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br></pre></td></tr></table></figure><ul><li>对于每一个双向流，流的发起方和流的接收方均可以在一条双向流上传输数据。</li><li>对于每一条单向流，只能是流的发起方向流的接收方发送数据。接收方可以在一条新的单向流上回复数据。</li><li>对于数据报格式的数据，由于 quic-go 底层不支持，这里不再赘述。不过已经有相关的提交去支持 <a href="https://github.com/lucas-clemente/quic-go/pull/2162" style="color:#FF7F50"> https://github.com/lucas-clemente/quic-go/pull/2162 </a></li></ul><p>更多信息参见：<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1" style="color:#FF7F50">https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1</a></p><p><font style="color:#6495ED">客户端请求</font><br>客户端请求一般 按照 Key — Value 的方式携带请求的资源标识。如下是请求的 Origin 和 Path。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientIndicationKey <span class="keyword">int16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   clientIndicationKeyOrigin clientIndicationKey = <span class="number">0</span></span><br><span class="line">   clientIndicationKeyPath                       = <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Key (16)            |          Length (16)          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Value (*)                         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>这里只实现了双向流，可以看到双向流建立之前会先建立一个单向流用于认证信息。之后的数据会在双向流上传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">handleSession</span><span class="params">(sess quic.Session)</span></span> &#123;</span><br><span class="line">stream, err := sess.AcceptUniStream(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utils.Logging.Info().Msgf(<span class="string">&quot;unidirectional stream accepted, id: %d&quot;</span>, stream.StreamID())</span><br><span class="line">indication, err := receiveClientIndication(stream)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utils.Logging.Info().Msgf(<span class="string">&quot;client indication: %+v&quot;</span>, indication)</span><br><span class="line"><span class="keyword">if</span> err := s.validateClientIndication(indication); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = s.communicate(sess)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="QUIC" scheme="http://kiosk007.top/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>Go Reflect </title>
    <link href="http://kiosk007.top/2021/01/18/Go-Reflect/"/>
    <id>http://kiosk007.top/2021/01/18/Go-Reflect/</id>
    <published>2021-01-18T15:57:00.000Z</published>
    <updated>2021-01-18T15:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言标准库 <a href="https://golang.org/pkg/reflect/">reflect</a> 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。</p><a id="more"></a><h1 id="类型和接口-Types-and-interfaces"><a href="#类型和接口-Types-and-interfaces" class="headerlink" title="类型和接口 (Types and interfaces)"></a>类型和接口 (Types and interfaces)</h1><p>因为反射是建立在类型之上的，所以想要了解反射必须先知道Go 语言中所有的变量都有一个静态类型。例如 <code>int</code>、<code>[]byte</code>、<code>float32</code>、<code>*MyType</code>等等。<br>如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure><br>接口是一种特殊的类型，它表示固定的方法集。接口变量可以存储任何具体（非接口）值,只要该值实现接口的方法。最经典的例子便是 io.Reader \ io.Writer 。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有人说Go的接口是动态类型的，但这是误导。它们是静态类型。一个特殊的例子是空接口，即 <code>interface&#123;&#125;</code>。</p><p>在这个例子中。<font style="color:#00008B">os.OpenFile</font> 的返回参数tty的类型是 <code>*os.File</code>，由于 <code>*os.File</code> 实现了 <font style="color:#00008B">Read()</font> 方法，所以该类型可以被赋于类型 io.Reader (io.Reader是一个interface)。尽管 <code> *os.File</code> 实现了很多方法，但是变量r仅有一个方法Read。但内部的值仍包含有关该值的所有类型信息。这就是为什么我们可以做 <code>w=r.(io.Writer)</code> 的原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>) <span class="comment">// tty *os.File</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> &#125;</span><br><span class="line">r = tty</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer    </span><br><span class="line">w = r.(io.Writer)  <span class="comment">// 由于r实际内部是有Write方法的，所以r可以被断言成 io.Writer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;12345&quot;</span>));err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">_ = tty.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以继续执行下面的操作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br><span class="line">fmt.Println(reflect.TypeOf(empty))</span><br></pre></td></tr></table></figure></p><h2 id="反射基本用法"><a href="#反射基本用法" class="headerlink" title="反射基本用法"></a>反射基本用法</h2><h3 id="从接口值到反射对象"><a href="#从接口值到反射对象" class="headerlink" title="从接口值到反射对象"></a><font style="color:#483D8B"><strong>从接口值到反射对象</strong></font></h3><p>ValueOf用来获取输入参数接口中的数据的值。如果是空接口则返回 invalid 。<br>TypeOf用来动态获取输入参数接口中的值的类型，如果空接口则返回nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>,reflect.TypeOf(num))     <span class="comment">// type:  float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>,reflect.ValueOf(num))   <span class="comment">// value:  1.2345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以判断类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(v)</span><br><span class="line"><span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line">fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;   <span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从反射对象到接口值"><a href="#从反射对象到接口值" class="headerlink" title="从反射对象到接口值"></a><font style="color:#483D8B"><strong>从反射对象到接口值</strong></font></h3><p>go 提供了反射和反射的逆，可以通过 <code>.(type)</code> 断言的方式将一个Interface()转成他真正的类型。如果断言的类型不匹配，会发生panic。</p><p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说 明</th></tr></thead><tbody><tr><td>Interface() interface{}</td><td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td>Int() int64</td><td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td>Uint() uint64</td><td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td>Float() float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td>Bool() bool</td><td>将值以 bool 类型返回</td></tr><tr><td>Bytes() []bytes</td><td>将值以字节数组 []bytes 类型返回</td></tr><tr><td>String() string</td><td>将值以字符串类型返回</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi <span class="keyword">float64</span></span><br><span class="line">pi = <span class="number">3.1415926</span></span><br><span class="line">v := reflect.ValueOf(pi)</span><br><span class="line">y := v.Interface().(<span class="keyword">float64</span>) <span class="comment">// y will have type float64.</span></span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></table></figure><h3 id="要修改反射对象，该值必须可设置"><a href="#要修改反射对象，该值必须可设置" class="headerlink" title="要修改反射对象，该值必须可设置"></a><font style="color:#483D8B"><strong>要修改反射对象，该值必须可设置</strong></font></h3><p>如果运行下面的代码将会 <font style="color:#8B0000"> panic </font> ，这时因为 v 是不可设置的。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>备  注</th></tr></thead><tbody><tr><td>Elem() Value</td><td>取值指向的元素值，类似于语言层*操作</td></tr><tr><td>Addr() Value</td><td>对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机</td></tr><tr><td>CanAddr() bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet() bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>通过 <code>CanSet()</code> 即可判断，<code>CanSet()</code> 报告 v 的值是否可以改变。值只能在可寻址的情况下更改，并且不能通过使用未导出的结构字段获取。如果 CanSet 返回 false ，则调用 Set 或任何类型特定的 setter （例如 SetBool ，SetInt ）将会发生panic。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><br>v 不可寻址，因为 v 只是 x 的拷贝，即便把 x 换成 &amp;x,还是不可寻址，因为 <code>reflect.ValueOf(&amp;x)</code> 也仅仅是 x 指针的拷贝。实际上，所有通过 <code>reflect.ValueOf(x)</code> 返回的 reflect.Value 都是不可取地址的。但是通过调用 <code>reflect.ValueOf(&amp;x).Elem()</code>，来获取任意变量x对应的可取地址的 Value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span></span><br><span class="line">x = <span class="number">3.1415</span></span><br><span class="line">pv := reflect.ValueOf(&amp;x)</span><br><span class="line">pv = pv.Elem()</span><br><span class="line">pv.SetFloat(<span class="number">7.1</span>) </span><br><span class="line"></span><br><span class="line">fmt.Println(x)   <span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure><h2 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h2><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) StructField</td><td>根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生panic</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量。当类型不是结构体或索引超界时发生panic</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生 panic</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时发生 panic</td></tr><tr><td>FieldByNameFunc( match func(string) bool) (StructField,bool)</td><td>根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生panic</td></tr></tbody></table></div><h3 id="普通结构体"><a href="#普通结构体" class="headerlink" title="普通结构体"></a>普通结构体</h3><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>假设有以下 <code>User struct</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int</span></span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Work    Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">Id           <span class="keyword">int</span></span><br><span class="line">Occupation   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;My Id :%d ,My Name :%s ,My Occupation :%s&quot;</span>,u.Id,u.Name,u.Work.Occupation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFuncHasArgs</span><span class="params">(foo <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;This is number %d \n&quot;</span>, foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来演示的是如何通过反射区打印结构体中的所有对象、打印结构体中的所有字段、调用方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">Work: Worker&#123;</span><br><span class="line">Id: <span class="number">1</span>,</span><br><span class="line">Occupation: <span class="string">&quot;farmer&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(user)</span><br><span class="line">fmt.Println(<span class="string">&quot;get type is: &quot;</span>,getType.Name())  <span class="comment">// get type is:  User</span></span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line">fmt.Println(<span class="string">&quot;get all Fields is &quot;</span>, getValue) <span class="comment">// get all Fields is  &#123;1 Kiosk &#123;1 farmer&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字段进行遍历 获取方法的字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumField();i++ &#123;</span><br><span class="line">field := getType.Field(i)</span><br><span class="line">value := getValue.Field(i).Interface()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: %v = %v \n&quot;</span>,field.Name,field.Type,value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Id: int = 1</span></span><br><span class="line"><span class="comment">Name: string = Kiosk</span></span><br><span class="line"><span class="comment">Work: main.Worker = &#123;1 farmer&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumMethod();i++ &#123;</span><br><span class="line">m := getType.Method(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s : %v\n&quot;</span>,m.Name,m.Type)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ReflectCallFunc : func(main.User)</span></span><br><span class="line"><span class="comment">   ReflectCallFuncHasArgs : func(main.User, int)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="comment">// 有参数调用</span></span><br><span class="line">methodValue := getValue.MethodByName(<span class="string">&quot;ReflectCallFuncHasArgs&quot;</span>)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(<span class="number">2</span>)&#125;</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is number 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数调用</span></span><br><span class="line">methodValue = getValue.MethodByName(<span class="string">&quot;ReflectCallFunc&quot;</span>)</span><br><span class="line">args = <span class="built_in">make</span>([]reflect.Value,<span class="number">0</span>)</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">My Id :1 ,My Name :Kiosk ,My Occupation :farmer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带tag的struct"><a href="#带tag的struct" class="headerlink" title="带tag的struct"></a>带tag的struct</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int</span> <span class="string">`json:&quot;id&quot;   bson:&quot;id&quot;`</span></span><br><span class="line">Name    <span class="keyword">string</span><span class="string">`json:&quot;name&quot; bson:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(user)</span><br><span class="line">fmt.Printf(<span class="string">&quot;get type is: %v \n&quot;</span>,getType.String())  <span class="comment">// get type is:  main.User</span></span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line">fmt.Println(getValue) <span class="comment">// &#123;1 Kiosk&#125;</span></span><br><span class="line"></span><br><span class="line">name := getValue.FieldByName(getType.Field(<span class="number">1</span>).Name).String()</span><br><span class="line">fmt.Printf(<span class="string">&quot;name is %s \n&quot;</span>, name)  <span class="comment">// name is Kiosk</span></span><br><span class="line"></span><br><span class="line">tag := getType.Field(<span class="number">0</span>).Tag</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %v  tag: &#x27;%v&#x27;\n&quot;</span>, getType.Field(<span class="number">0</span>).Name, tag) <span class="comment">// name: Id  tag: &#x27;json:&quot;id&quot;   bson:&quot;id&quot;&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;tag is %s, %s \n&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), tag.Get(<span class="string">&quot;bson&quot;</span>)) <span class="comment">//  tag is id, id </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断反射值的有效性和空"><a href="#判断反射值的有效性和空" class="headerlink" title="判断反射值的有效性和空"></a>判断反射值的有效性和空</h2><p>IsNil()和IsValid() — 判断反射值的空和有效性</p><p>反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。</p><div class="table-container"><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>IsNil() bool</td><td>返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的v== nil操作</td></tr><tr><td>IsValid() bool</td><td>判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*int的空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;var a *int:&quot;</span>, reflect.ValueOf(a).IsNil())  </span><br><span class="line">    <span class="comment">// var a *int: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//nil值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;nil:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid()) </span><br><span class="line">    <span class="comment">// nil: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*int类型的空指针</span></span><br><span class="line">fmt.Println(<span class="string">&quot;(*int)(nil):&quot;</span>, reflect.ValueOf((*<span class="keyword">int</span>)(<span class="literal">nil</span>)).Elem().IsValid()) </span><br><span class="line">    <span class="comment">// (*int)(nil): false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个结构体</span></span><br><span class="line">s := <span class="keyword">struct</span> &#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从结构体中查找一个不存在的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(s).FieldByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的结构体成员: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从结构体中查找一个不存在的方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的方法:&quot;</span>, reflect.ValueOf(s).MethodByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的方法: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个map</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的键:&quot;</span>, reflect.ValueOf(m).MapIndex(reflect.ValueOf(<span class="number">3</span>)).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的键: false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 语言标准库 &lt;a href=&quot;https://golang.org/pkg/reflect/&quot;&gt;reflect&lt;/a&gt; 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。&lt;/p&gt;</summary>
    
    
    
    <category term="programming" scheme="http://kiosk007.top/categories/programming/"/>
    
    
    <category term="Go" scheme="http://kiosk007.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>TLS详解（三）</title>
    <link href="http://kiosk007.top/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://kiosk007.top/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-01-16T08:48:00.000Z</published>
    <updated>2021-01-16T08:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。</p><a id="more"></a><ul><li><a href="https://www.kiosk007.top/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/">TLS 详解一</a></li><li><a href="https://www.kiosk007.top/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/">TLS 详解二</a></li></ul><h1 id="TLS1-3-Feature"><a href="#TLS1-3-Feature" class="headerlink" title="TLS1.3 Feature"></a>TLS1.3 Feature</h1><ul><li><font color="#7B68EE">Speed Benefits of TLS 1.3</font></li></ul><p>TLS1.3 可以使用1RTT建立握手，比1.2版本能节约一个网络来回。</p><p><img style="height:300px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-performance.png"></p><ul><li><font color="#7B68EE">Improved Security With TLS 1.3</font></li></ul><p>TLS1.3 移除了RC4、DES、MD5 等诸多脆弱不安全的算法，目前仅保持了支持AEAD的ECDH类等算法。</p><ul><li><font color="#7B68EE"> 1.3 Browser Support</font></li></ul><p>从 Chrome65 开始，Google公司就可以支持 <a href="http://www.chromium.org/Home/tls13">draft version of TLS 1.3 </a> , 2018年10月的 Chrome70 就完全支持了TLS1.3。同样Firefox63也在同年10月支持了TLS1.3。Microsoft Edge version 76 及 Safari 12.1 on macOS 10.14.4. 也都支持了TLS1.3 。</p><h1 id="The-TLS-handshake"><a href="#The-TLS-handshake" class="headerlink" title="The TLS handshake"></a>The TLS handshake</h1><p>总体握手流程如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">handshake</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c := hs.c</span><br><span class="line"></span><br><span class="line"><span class="comment">// For an overview of the TLS 1.3 handshake, see RFC 8446, Section 2.</span></span><br><span class="line"><span class="keyword">if</span> err := hs.processClientHello(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.checkForResumption(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.pickCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">c.buffering = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerParameters(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="comment">// Note that at this point we could start sending application data without</span></span><br><span class="line"><span class="comment">// waiting for the client&#x27;s second flight, but the application might not</span></span><br><span class="line"><span class="comment">// expect the lack of replay protection of the ClientHello parameters.</span></span><br><span class="line"><span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err  &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.readClientCertificate(); err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> err  &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.readClientFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"></span><br><span class="line">atomic.StoreUint32(&amp;c.handshakeStatus, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/network/TLSDetailAnalysis/tls-1.3.png"></p><h2 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a><font style="color:#4682B4">Client Hello</font></h2><p>由于TLS1.2已经在互联网上存在了10年。网络中大量的网络中间设备都十分老旧，这些网络设备会识别中间的TLS握手头部，所以TLS1.3的出现如果引入了未知的TLS Version 必然会存在大量的握手失败，为了解决这一点，TLS1.3 的握手头部默认是TLS1.2。</p><p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-clienthello.png"></p><p>如果客户端支持TLS1.3 则在 <strong><font style="color:#483D8B">Client Hello</font></strong> 发出时在Extensions中携带 supported_versions 并标明客户端是支持TLS1.3的，同样为了1RTT快速握手，会将客户端Key_share 发送给服务端。Key_Share是客户端提前生成好的公钥信息。其密钥派生过程依赖于密码套件的 HKDF Extract 和 HKDF Expand 函数以及 Hash函数。</p><p>在密钥交换之前，客户端和服务端使用HKDF生成密钥。（它取代了基于HMAC的伪随机密钥生成函数PRF。</p><p>下面用代码过一遍客户端的Client Hello流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> params ecdheParameters</span><br><span class="line"><span class="keyword">if</span> hello.supportedVersions[<span class="number">0</span>] == VersionTLS13 &#123;</span><br><span class="line">hello.cipherSuites = <span class="built_in">append</span>(hello.cipherSuites, defaultCipherSuitesTLS13()...)</span><br><span class="line"></span><br><span class="line">curveID := config.curvePreferences()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> _, ok := curveForCurveID(curveID); curveID != X25519 &amp;&amp; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;tls: CurvePreferences includes unsupported curve&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">params, err = generateECDHEParameters(config.rand(), curveID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">hello.keyShares = []keyShare&#123;&#123;group: curveID, data: params.PublicKey()&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，如果客户端是支持  <font style="color:#483D8B">VersionTLS13</font>, 则在创建 <font style="color:#483D8B"> Client Hello </font> 时,添加TLS1.3支持的秘钥套件，并使用 x25519 曲线和随机数生成 <font style="color:#483D8B"> PublickKey </font>放入 <font style="color:#483D8B"> Client Hello Extension</font> 中的 <font style="color:#483D8B"> KeyShares </font> 中。</p><h2 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a><font style="color:#4682B4">Server Hello</font></h2><p>服务端的TLS Version仍为TLS1.2（实际上后续的TLS版本均为1.2），如果服务端支持TLS1.3，则会在  <font style="color:#483D8B">supported_versions</font> 中的携带TLS1.3，这样后续的会话便均在TLS1.3下通信。</p><p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-serverhello.png"></p><p>服务端会在<font style="color:#483D8B"> Server Hello </font> 中的 <font style="color:#483D8B"> key_share </font> 中携带公钥信息。</p><p>下面是完整的握手过程，BTW <font style="color:red">虽然0RTT是各大博客都吹嘘的TLS1.3亮点，但是0RTT 当前大多数的官方库都还没有实现（Nginx似乎是支持了）</font> ，比如看这里<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hs.clientHello.earlyData &#123;</span><br><span class="line"><span class="comment">// See RFC 8446, Section 4.2.10 for the complicated behavior required</span></span><br><span class="line"><span class="comment">// here. The scenario is that a different server at our address offered</span></span><br><span class="line"><span class="comment">// to accept early data in the past, which we can&#x27;t handle. For now, all</span></span><br><span class="line"><span class="comment">// 0-RTT enabled session tickets need to expire before a Go server can</span></span><br><span class="line"><span class="comment">// replace a server or join a pool. That&#x27;s the same requirement that</span></span><br><span class="line"><span class="comment">// applies to mixing or replacing with any TLS 1.2 server.</span></span><br><span class="line">c.sendAlert(alertUnsupportedExtension)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;tls: client sent unexpected early data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>服务端选择和客户端同样支持的 <font style="color:#483D8B"> CurveID </font>(代码中的 selectedGroup，并且是Client支持的Key Share)。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">params, err := generateECDHEParameters(c.config.rand(), selectedGroup)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.sendAlert(alertInternalError)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">hs.hello.serverShare = keyShare&#123;group: selectedGroup, data: params.PublicKey()&#125;</span><br><span class="line">hs.sharedKey = params.SharedKey(clientKeyShare.data)</span><br><span class="line"><span class="keyword">if</span> hs.sharedKey == <span class="literal">nil</span> &#123;</span><br><span class="line">c.sendAlert(alertIllegalParameter)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;tls: invalid client key share&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样以来，客户端和服务端便直接完成了 <font style="color:#483D8B">ECDHE</font> 密钥交换</p><ul><li>客户端生成随机数x，确定了曲线类型如Golang TLS SDK只支持的 <font style="color:#483D8B"> x25519曲线</font> 即可得方程系数a、b，再调用<code>generateECDHEParameters</code> 获得 <font style="color:#483D8B"> PublicKey Q<sub>1</sub> </font>。客户端将 Q<sub>1</sub> 、a、 b、 P 传给服务端。</li><li>服务端生成随机数y，解析客户端传来的曲线和 Key_Share 对，得到曲线类型 <font style="color:#483D8B"> x25519 </font>既得方程系数a、b，再使用 selectedGroup 和 y 调用<code>generateECDHEParameters</code> 生成 <font style="color:#483D8B"> PublicKey Q<sub>2</sub> </font> ,传给客户端</li><li>这时客户端和服务端可以计算出一个公共的值 <font style="color:#483D8B"> <strong>K</strong> </font></li></ul><p>如下图</p><p><img src="/images/network/TLSDetailAnalysis/ECDHE.png"></p><h3 id="PSK-Pre-Shared-Key"><a href="#PSK-Pre-Shared-Key" class="headerlink" title=" PSK (Pre-Shared Key)"></a><font style="color:#87CEEB"> PSK (Pre-Shared Key)</font></h3><p>这里在接着解析代码之前，先插播一个 TLS1.3 的feature 0RTT是如何实现的。这里介绍一下实现的原理 — <font style="color:#483D8B"> <strong>PSK</strong> </font></p><p>一旦一次握手完成，server 就能给 client 发送一个与一个独特密钥对应的 PSK 密钥，这个密钥来自初次握手。然后 client 能够使用这个 PSK 密钥在将来的握手中协商相关 PSK 的使用。如果 server 接受它，新连接的安全上下文在密码学上就与初始连接关联在一起，从初次握手中得到的密钥就会用于装载密码状态来替代完整的握手。在 TLS 1.2 以及更低的版本中，这个功能由 “session IDs” 和 “session tickets” [RFC5077]来提供。这两个机制在 TLS 1.3 中都被废除了。</p><p>PSK 可以与 (EC)DHE 密钥交换算法一同使用以便使共享密钥具备前向安全，或者 PSK 可以被单独使用，这样是以丢失了应用数据的前向安全为代价。</p><p>下图显示了两次握手，第一次建立了一个 PSK，第二次时使用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">       Client                                               Server</span><br><span class="line"></span><br><span class="line">Initial Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share               --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                       + key_share</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                             &#123;CertificateRequest*&#125;</span><br><span class="line">                                                    &#123;Certificate*&#125;</span><br><span class="line">                                              &#123;CertificateVerify*&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Certificate*&#125;</span><br><span class="line">       &#123;CertificateVerify*&#125;</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">                                 &lt;--------      [NewSessionTicket]</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subsequent Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share*</span><br><span class="line">       + pre_shared_key          --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                  + pre_shared_key</span><br><span class="line">                                                      + key_share*</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 server 通过一个 PSK 进行认证时，它不会发送一个 Certificate 或一个 CertificateVerify 消息。当一个 client 通过 PSK 想恢复会话的时候，它也应当提供一个 “key_share” 给 server，以允许 server 拒绝恢复会话的时候降级到重新回答一个完整的握手流程中。Server 响应 “pre_shared_key” 扩展，使用 PSK 密钥协商建立连接，同时响应 “key_share” 扩展来进行 (EC)DHE 密钥建立，由此提供前向安全。</p><p>当 PKS 在带外提供时，PSK 密钥和与 PSK 一起使用的 KDF hash 算法也必须被提供。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0 RTT"></a><font style="color:#87CEEB">0 RTT</font></h3><p>当 client 和 server 共享一个 PSK（从外部获得或通过一个以前的握手获得）时，TLS 1.3 允许 client 在第一个发送出去的消息中携带数据（”application data”）。Client 使用这个 PSK 来认证 server 并加密 early data 信息，最终实现Application数据的0RTT发送。</p><p>如下图所示，0-RTT 数据在第一个发送的消息中被加入到 1-RTT 握手过程中。握手的其余消息与带 PSK 会话恢复的 1-RTT 握手消息相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">+ early_data</span><br><span class="line">+ key_share*</span><br><span class="line">+ psk_key_exchange_modes</span><br><span class="line">+ pre_shared_key</span><br><span class="line">(Application Data*)     --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                           + pre_shared_key</span><br><span class="line">                                               + key_share*</span><br><span class="line">                                      &#123;EncryptedExtensions&#125;</span><br><span class="line">                                              + early_data*</span><br><span class="line">                                                 &#123;Finished&#125;</span><br><span class="line">                        &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;              --------&gt;</span><br><span class="line">[Application Data]      &lt;-------&gt;        [Application Data]</span><br></pre></td></tr></table></figure><p>上图是 0-RTT 的信息流</p><p>0-RTT 数组安全性比其他类型的 TLS 数据要弱一些，特别是：</p><ol><li>0-RTT 的数据是没有前向安全性的，它使用的是被提供的 PSK 中导出的密钥进行加密的。</li><li>在多个连接之间不能保证不存在重放攻击。普通的 TLS 1.3 1-RTT 数据为了防止重放攻击的保护方法是使用 server 下发的随机数，现在 0-RTT 不依赖于 ServerHello 消息，因此保护措施更差。如果数据与 TLS client 认证或与应用协议里一起验证，这一点安全性的考虑尤其重要。这个警告适用于任何使用 early_exporter_master_secret 的情况。</li></ol><p>参考 <strong><a href="https://halfrost.com/tls_1-3_introduction/">TLS 1.3 Introduction</a></strong> — Halfrost’s Field | 冰霜之地</p><h3 id="checkForResumption-—-Go"><a href="#checkForResumption-—-Go" class="headerlink" title=" checkForResumption — Go"></a><font style="color:#87CEEB"> checkForResumption — Go</font></h3><p>上面2个小节其实就是在介绍 <a href="https://golang.org/src/crypto/tls/handshake_server_tls13.go#226"><code>checkForResumption()</code></a> 这个函数的作用。</p><p>在Client Hello 包的扩展里如果有 <strong>psk_key_exchange_modes</strong> 和  <strong>pre_shared_key</strong> 就表示客户端想要会话复用，即类似TLS1.2的 <strong>Session Ticket</strong> or <strong>Session Id</strong> 的概念。</p><p>如下所示：</p><p><img src="/images/network/TLSDetailAnalysis/tls-1.3-psk_key_exchange_modes.png"></p><font style="color:#483D8B"> **psk_key_exchange_modes**</font>是 psk 密钥交互模式选择. 此处的PSK模式为(EC)DHE下的PSK，客户端和服务器必须提供KeyShare, 如果是仅PSK模式，则服务器不需要提供KeyShare。<img src="/images/network/TLSDetailAnalysis/tls-1.3-pre_shared_key.png"><font style="color:#483D8B"> **pre_shared_key**</font> 是预共享密钥认证机制，相当于session ticket再加一些检验的东西.Identity中包含的是客户端愿意进行协商的服务器身份列表。PSK binder表示已经构建当前PSK与当前握手之间的绑定。下面函数中，服务端会将 <font style="color:#483D8B">identity</font> 解析成 <font style="color:#483D8B">plaintext</font>，<font style="color:#483D8B">plaintext</font>中包含TLS版本、证书、复用秘钥、超时时间 等多个信息，如果unmarshal成功，即可以会话复用，继续向下。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, identity := <span class="keyword">range</span> hs.clientHello.pskIdentities &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= maxClientPSKIdentities &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">plaintext, _ := c.decryptTicket(identity.label)</span><br><span class="line"><span class="keyword">if</span> plaintext == <span class="literal">nil</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">sessionState := <span class="built_in">new</span>(sessionStateTLS13)</span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> ok := sessionState.unmarshal(plaintext); !ok &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">       </span><br><span class="line">       createdAt := time.Unix(<span class="keyword">int64</span>(sessionState.createdAt), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> c.config.time().Sub(createdAt) &gt; maxSessionTicketLifetime &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don&#x27;t check the obfuscated ticket age because it&#x27;s affected by</span></span><br><span class="line"><span class="comment">// clock skew and it&#x27;s only a freshness signal useful for shrinking the</span></span><br><span class="line"><span class="comment">// window for replay attacks, which don&#x27;t affect us as we don&#x27;t do 0-RTT.</span></span><br><span class="line"></span><br><span class="line">pskSuite := cipherSuiteTLS13ByID(sessionState.cipherSuite)</span><br><span class="line"><span class="keyword">if</span> pskSuite == <span class="literal">nil</span> || pskSuite.hash != hs.suite.hash &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">...</span><br><span class="line">psk := hs.suite.expandLabel(sessionState.resumptionSecret, <span class="string">&quot;resumption&quot;</span>,</span><br><span class="line"><span class="literal">nil</span>, hs.suite.hash.Size())</span><br><span class="line">hs.earlySecret = hs.suite.extract(psk, <span class="literal">nil</span>)</span><br><span class="line">binderKey := hs.suite.deriveSecret(hs.earlySecret, resumptionBinderLabel, <span class="literal">nil</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>## <font style="color:#4682B4"> Change Cipher Space</font><p>发送一个 <font style="color:#483D8B"><strong>ChangeCipherSpec record</strong></font> 报文，之后的加密方式将会改变。详见 See RFC 8446, Appendix D.4.</p><h2 id="EncryptedExtensions"><a href="#EncryptedExtensions" class="headerlink" title=" EncryptedExtensions "></a><font style="color:#4682B4"> EncryptedExtensions </font></h2><p>随后 Server 会发来建立 EncryptedExtensions Server 参数: 对 ClientHello 扩展的响应，不需要确定加密参数，而不是特定于各个证书的加密参数。一般ALPN会在这里添加。</p><h2 id="Certificate-amp-amp-Certificate-Verify-amp-amp-Finished"><a href="#Certificate-amp-amp-Certificate-Verify-amp-amp-Finished" class="headerlink" title=" Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished "></a><font style="color:#4682B4"> Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished </font></h2><p>最后，Client 和 Server 交换认证消息。TLS 在每次基于证书的认证时使用相同的消息集，(基于 PSK 的认证是密钥交换中的一个副作用)特别是：</p><ul><li><p><font style="color:#483D8B">Certificate</font>: 终端的证书和每个证书的扩展。 服务器如果不通过证书进行身份验证，并且如果服务器没有发送CertificateRequest（由此指示客户端不应该使用证书进行身份验证），客户端将忽略此消息。 请注意，如果使用原始公钥 [RFC7250] 或缓存信息扩展 [RFC7924]，则此消息将不包含证书，而是包含与服务器长期密钥相对应的其他值。</p></li><li><p><font style="color:#483D8B">CertificateVerify</font>: 使用与证书消息中的公钥配对的私钥对整个握手消息进行签名。如果终端没有使用证书进行验证则此消息会被忽略。</p></li><li><p><font style="color:#483D8B">Finished</font>: 对整个握手消息的 MAC(消息认证码)。这个消息提供了密钥确认，将终端身份与交换的密钥绑定在一起，这样在 PSK 模式下也能认证握手。</p></li></ul><p>接收到 Server 的消息之后，Client 会响应它的认证消息，即 Certificate，CertificateVerify (如果需要), 和 Finished。</p><p>这时握手已经完成，client 和 server 会提取出密钥用于记录层交换应用层数据，这些数据需要通过认证的加密来保护。应用层数据不能在 Finished 消息之前发送数据，必须等到记录层开始使用加密密钥之后才可以发送。需要注意的是 server 可以在收到 client 的认证消息之前发送应用数据，任何在这个时间点发送的数据，当然都是在发送给一个未被认证的对端。</p><h2 id="New-Session-Ticket"><a href="#New-Session-Ticket" class="headerlink" title=" New Session Ticket "></a><font style="color:#4682B4"> New Session Ticket </font></h2><p>实际等同于发送 PSK 数据。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">shouldSendSessionTickets</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> hs.c.config.SessionTicketsDisabled &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t send tickets the client wouldn&#x27;t use. See RFC 8446, Section 4.2.9.</span></span><br><span class="line"><span class="keyword">for</span> _, pskMode := <span class="keyword">range</span> hs.clientHello.pskModes &#123;</span><br><span class="line"><span class="keyword">if</span> pskMode == pskModeDHE &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="tls" scheme="http://kiosk007.top/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>Git Quick Start</title>
    <link href="http://kiosk007.top/2020/12/19/Git-Quick-Start/"/>
    <id>http://kiosk007.top/2020/12/19/Git-Quick-Start/</id>
    <published>2020-12-19T11:11:00.000Z</published>
    <updated>2020-12-19T11:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>只是git入门的简单指南。没什么大不了的 :)</p><a id="more"></a><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br><img src="https://img1.kiosk007.top/static/images/git/git.png" style="height:340px"></p><h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><p><a href="https://git-scm.com/download/linux">安装 Git Linux 版</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install git</span><br><span class="line">$ apt-get install gitk</span><br></pre></td></tr></table></figure><br>gitk 是可以可视化的git客户端工具，更多工具参考 <a href="https://git-scm.com/download/gui/linux">git-gui</a> ，如 <a href="https://juejin.cn/post/6844903904451231757">Gitkraken (小章鱼)</a>、 <a href="https://magit.vc/manual/magit/Installing-from-the-Git-Repository.html#Installing-from-the-Git-Repository">magit</a> 等等</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li><strong>配置 user 信息</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name  <span class="string">&quot;your_name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;your_name@domain.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --local 只对某个分支有效</span></span><br><span class="line"><span class="comment"># --global 对当前用户所有仓库有效</span></span><br><span class="line"><span class="comment"># --system 对系统所有用户有效</span></span><br><span class="line"></span><br><span class="line">$ git config --global core.editor <span class="string">&quot;vim&quot;</span>    <span class="comment"># git 交互改为vim</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><strong>查看config的配置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>工作流</strong>:<br>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p><h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><ul><li><font color="#EEB422">**init 仓库**</font></li></ul><p>创建新文件夹，打开，然后执行 <strong><code>git init</code></strong> 以创建新的 git 仓库。</p><ul><li><font color="#EEB422">**添加 和 提交**</font></li></ul><ol><li>你可以提出更改（把它们添加到暂存区），使用如下命令：<strong><code>git add &lt;filename&gt;</code></strong>  或者  <strong><code>git add *</code></strong></li><li>使用如下命令以实际提交改动：<strong><code>git commit -m &quot;代码提交信息&quot;</code></strong></li><li>现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</li></ol><ul><li><font color="#EEB422">**推送改动**</font></li></ul><ol><li>改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：<strong><code>git push origin master</code></strong> (master 可以换成想要推送的分支)</li><li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<strong><code>git remote add origin &lt;server&gt;</code></strong> , 如此你就能够将你的改动推送到所添加的服务器上去了。</li></ol><h2 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><img src="https://img1.kiosk007.top/static/images/git/branches.png"></p><ul><li>创建一个叫做“feature_x”的分支，并切换过去：<strong><code>git checkout -b feature_x</code></strong></li><li>切换回主分支：<strong><code>git checkout master</code></strong></li><li>删除分支：<strong><code>git branch -d feature_x</code></strong></li><li>将自己的分支推送到远端：<strong><code>git push origin &lt;branch&gt;</code></strong></li></ul><h2 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h2><ul><li><font color="#FF8247">**基本命令**</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line">$ git mv old_filename new_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">$ git rm filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作区的状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为软件发布创建标签, 如v1.0.0</span></span><br><span class="line">$ git tag v1.0.0 1b2e1d63ff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看git提交后日志</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline     <span class="comment"># 一行显示</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 4          <span class="comment"># 查看最近的几次</span></span><br><span class="line">$ git <span class="built_in">log</span> --all --graph <span class="comment"># 以图形化方式显示所有的提交日志</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline --decorate --all  <span class="comment"># 通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签 </span></span><br><span class="line">$ git <span class="built_in">log</span> --author=bob  <span class="comment"># 只看某一个人的提交记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看 diff</span></span><br><span class="line">$ git diff              <span class="comment"># 对比工作区和暂存区的差异</span></span><br><span class="line">$ git diff --cached  <span class="comment"># 对比暂存区和HEAD所含文件(commit)的差异</span></span><br><span class="line">$ git diff -- style.css <span class="comment"># 只查看对某个文件的 diff 差异 (工作区和暂存区)</span></span><br><span class="line">$ git diff tmp master -- &lt;file&gt; <span class="comment"># 比较 tmp 和 master 分支的文件差异(也可以将branch改成commit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 取消提交</span></span><br><span class="line">$ git reset HEAD        <span class="comment"># 取消暂存 （取消 git add）</span></span><br><span class="line">$ git restore --staged &lt;file&gt;  <span class="comment"># 功能同上, 取消暂存 （可以 git status 查看当前的暂存状态）</span></span><br><span class="line"></span><br><span class="line">$ git checkout -- &lt;file&gt;      <span class="comment"># 在工作区的修改撤销到最近一次git add 或 git commit时的内容</span></span><br><span class="line">$ git reset --hard c04b46549  <span class="comment"># 恢复到历史上的某个 commit (工作区和暂存区都会清空)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><font color="#FF8247">**版本管理**</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">$ git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于某个历史版本创建分支(基于 ac886ae 创建一个tmp分支)</span></span><br><span class="line">$ git checkout -b tmp ac886ae </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个分支</span></span><br><span class="line">$ git checkout -d ac886ae  <span class="comment"># 没有merge的分支不能通过 -d 删除</span></span><br><span class="line">$ git checkout -D ac886ae</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###################### commit 相关 ###########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最近一次提交的 commit 信息</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改前几次提交的 commit 信息</span></span><br><span class="line">$ git rebase -i ac224ct   <span class="comment"># 交互式操作，ac224ct 是要修改的commit的父commit</span></span><br><span class="line">将pick改为r  :wq退出，</span><br><span class="line">变更内容     :wq退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="git常见使用"><a href="#git常见使用" class="headerlink" title="git常见使用"></a>git常见使用</h1><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a><font color="#FF4500"><strong>分离头指针</strong></font></h2><p>通常，我们工作在某一个分支上，比如 master 分支。这个时候 master 指针和 HEAD 指针是一起前进的，每做一次提交，这两个指针就会一起向前挪一步。但是在某种情况下（例如 checkout 了某个具体的 commit），master 指针 和 HEAD 指针这种「绑定」的状态就被打破了，变成了分离头指针状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜ git checkout fb7d808</span><br><span class="line">注意：正在切换到 <span class="string">&#x27;fb7d808&#x27;</span>。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 <span class="literal">false</span> 来关闭此建议</span><br><span class="line"></span><br><span class="line">HEAD 目前位于 fb7d808 Learn CSS demo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git 在对于这种没有 branch 的变更会被清除掉。所以如果想要变更最好跟着分支进行变更。</p><h2 id="git-stash-命令实用指南"><a href="#git-stash-命令实用指南" class="headerlink" title="git stash 命令实用指南"></a>git stash 命令实用指南</h2><p>为什么 git stash 很重要，假设Git没有暂存变更命令，当你在有2个分支（A和B）的仓库上工作时，假设这两个分支已经分叉很长时间，并且有不同的头，当你处理A的时候，团队要求修复B分支的一个错误，你迅速将你的修改保存到A分支(但没有提交 commit),并且尝试用 <code>git checkout B</code> 来切到B分支，git 会立即终止这个操作，并报错。“你对以下文件的本地修改会被签出覆盖… …请在切换分之前提交你的修改或者将他们暂存起来”</p><p>在这种情况下有几种方法来分支切换。</p><ul><li>在分支A中创建一个提交（git switch -c），提交并推送你的修改，以修复 B 中的错误。然后签出A，并运行 <code>git reset HEAD</code>, 来恢复修改。</li><li>手动保留不被Git 追踪文件中的改动。</li></ul><p>第二种就不说了，一点也不极客。第一种方法虽然看起来很传统，但是不灵活，因为保存未完成工作的修改会被当做一个检查点，而不是一个仍在进行中的补丁。这就是 <code>git stash</code> 的场景。</p><p><code>git stash</code> 将未提交的改动保存在本地，让你可以进行修改，切换分支及其他的操作。然后当你需要的时候，你可以重新应用这些存储的改动。暂存是本地范围的，不会被<code>git push</code> 推送的远端。</p><p>以下是一次 <code>git stash</code> 的操作顺序</p><ol><li>将修改保存到分支A</li><li>运行 <code>git stash</code></li><li>签出分支B</li><li>修正B分支的错误</li><li>提交并推送到远程</li><li>查看分支A</li><li>运行 <code>git stash pop</code> 来取回暂存的改动。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现将工作区的内容保存到暂存区</span></span><br><span class="line">$ git add *</span><br><span class="line"><span class="comment"># 将暂存区的内容 暂时保存</span></span><br><span class="line">$ git stash   </span><br><span class="line">$ git stash save <span class="string">&quot;message&quot;</span>   <span class="comment"># 功能同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切到历史版本修复bug ... </span></span><br><span class="line"></span><br><span class="line">$ git stash apply  <span class="comment"># 将临时保存区的内容恢复，但不会删除记录，pop会删除。</span></span><br><span class="line">$ git stash pop </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry pick"></a><font color="#FF4500"><strong>cherry pick</strong></font></h2><p>假设你在一个分支上已经做了很多次提交，但你意识到这个分支是错误的，该怎么办。<br>要么切换到正确的分支重复所有的变更。然后重新提交。要么呢就要用到 <code>cherry pick</code> 这个工具。</p><p><code>git cherry-pick</code> 可以将相同的commit提交复制到另一个分支上。就没有必要在不同的分支上做相同的操作。</p><blockquote><p>注意：<code>cherry-pick</code> 出来的提交会在另一个分支中创建带有新hash的提交，</p></blockquote><ul><li>它是如何工作的</li></ul><p>假设有2个分支，<code>toC</code> 和 <code>toB</code>, 现在有个bug在2个版本上都存在。我们在<code>toC</code> 分支上已经修复了这个bug。在 <code>toC</code>分支上运行<code>git log</code>命令，获取这次提交的 hash 值, 简单起见复制 25560 即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 255604842840febb7e11bbb443013fa584e76219 (HEAD -&gt; master, tag: v1.0.1, origin/master, origin/HEAD)</span><br><span class="line">Author: igolaizola &lt;11333576+igolaizola@users.noreply.github.com&gt;</span><br><span class="line">Date:   Thu Sep 26 09:31:17 2019 +0200</span><br></pre></td></tr></table></figure><br>然后切换到<code>toB</code>分支上，将刚刚的bugfix提交合入。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout toB</span><br><span class="line">$ git cherry-pick 25560</span><br></pre></td></tr></table></figure></p><ul><li><p>如果遇到了 “nothing to commit,working tree clean The previous cherry-pick is now empty,possibly due to conflict resolution” 不要惊慌，按照建议运行 <code>git commit --allow-empty</code> 即可。这个将打开你的编辑器，编辑提交信息即可。</p></li><li><p>如果遇到了合并重提，解决冲突后，输入 <code>git cherry-pick --continue</code> 恢复。</p></li></ul><p>参考: <a href="https://mp.weixin.qq.com/s/J7sVxIoIVClEirClBQoUtA">https://mp.weixin.qq.com/s/J7sVxIoIVClEirClBQoUtA</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/156726632">https://zhuanlan.zhihu.com/p/156726632</a></p><h2 id="指定文件不需要git管理"><a href="#指定文件不需要git管理" class="headerlink" title="指定文件不需要git管理"></a><font color="#FF4500"><strong>指定文件不需要git管理</strong></font></h2><p>在项目根目录下创建 <strong><code>.gitignore</code></strong> ,写入不需管理的文件名即可</p><h1 id="git目录功能"><a href="#git目录功能" class="headerlink" title=".git目录功能"></a>.git目录功能</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ .git git:(master) ls   </span><br><span class="line">branches  COMMIT_EDITMSG  config  description  gitk.cache  HEAD  hooks  index  info  logs  objects  refs</span><br></pre></td></tr></table></figure><ul><li><code>HEAD</code>: 当前工作的分支</li><li><code>config</code>: 配置信息，包含着 repository 的配置，包括 remote 的地址，提交时的 email、 username 等等.</li><li><code>refs</code>: 这个目录一般包括三个子文件夹：heads、remotes和tags，heads中的文件标识了项目中的各个分支指向的当前commit</li><li><code>info</code>: 包含仓库的一些信息</li><li><code>hooks</code>: 这个目录存放一些shell脚本，可以设置特定的git命令后出发相应的脚本；在搭建gitweb系统或其他git托管系统会经常用到hook script</li><li><code>logs</code>: 保存所有更新的引用记录</li><li><code>index</code>: 这个文件就是暂存区（stage），是一个二进制文件</li><li><code>description</code>: 仓库的描述信息，主要给gitweb等git托管系统使用</li><li><code>objects</code>: 所有的Git对象都会存放在这个目录中，对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名</li></ul><p>git 中的对象如下图所示，每一个 commit 提交都会包含 tree、committer、blob。其中committer是提交者，tree可粗略理解为目录，blob为文件。<br><img src="https://img1.kiosk007.top/static/images/git/git_commit_tree_blob.png" style="height:350px"></p><p>比如查看一次 commit<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看一次 commit</span></span><br><span class="line">$ git cat-file -p ac886ae797a9ee60962461b50993bc2bd09920fd</span><br><span class="line">tree 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">parent 4f41c2512ce8fcfbde05622c4d0cd75f14708a84</span><br><span class="line">author orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line">committer orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line"></span><br><span class="line">Add CS JS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该commit中的 tree</span></span><br><span class="line">$ git cat-file -p 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">100644 blob dac138d9e013a2e9a10e67d793bd4703c1b86bd1index.css</span><br><span class="line">100644 blob e1d99bb43375f52095059d6d79a9c6d3045c048bindex.html</span><br><span class="line">100644 blob 7b4dcb5b597195d0469fec0787c2a7b7a4656d81index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该tree中的blob</span></span><br><span class="line">$ git cat-file -p 7b4dcb5b597195d0469fec0787c2a7b7a4656d81</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">&quot;My First JavaScript&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="git-备份"><a href="#git-备份" class="headerlink" title="git 备份"></a>git 备份</h1><p><img src="https://img1.kiosk007.top/static/images/git/git_transport.webp" style="height:400px"></p><p>前两个协议是本地协议，后两个是远端托管平台。<br>哑协议传输进度不可见，智能协议传输可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个文件仓库 clone</span></span><br><span class="line"><span class="comment"># 哑协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare /home/kiosk/Project/Git/kiosk_demo/.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 智能协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare file:///home/kiosk/Project/Git/kiosk_demo/.git</span><br></pre></td></tr></table></figure><ul><li><font color="#FF8C00">**创建远程**</font></li></ul><p>可以使用 git remote add 命令将远程 URL 与名称匹配，例如<br><strong><code>git remote add origin  &lt;REMOTE_URL&gt;</code></strong><br>这会将名称 origin 与 REMOTE_URL 关联。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/user/repo.git</span><br><span class="line"><span class="comment"># Set a new remote</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># Verify new remote</span></span><br><span class="line">&gt; origin  https://github.com/user/repo.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/user/repo.git (push)</span><br></pre></td></tr></table></figure><p>远程 name 已存在,此错误消息表示您尝试添加的远程与本地仓库中的远程名称相同。可以尝试修改远程名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 查看现有远程</span></span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote rename origin destination</span><br><span class="line"><span class="comment"># 将远程名称从 &#x27;origin&#x27; 更改为 &#x27;destination&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 验证远程的新名称</span></span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (push)</span><br></pre></td></tr></table></figure><p>若远程的url发生了变化，可以通过<br><strong><code>git remote set-url origin https://github.com/USERNAME/REPOSITORY.git</code></strong><br>修改</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;只是git入门的简单指南。没什么大不了的 :)&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://kiosk007.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>gRPC Quick Start </title>
    <link href="http://kiosk007.top/2020/11/25/gRPC-Quick-Start/"/>
    <id>http://kiosk007.top/2020/11/25/gRPC-Quick-Start/</id>
    <published>2020-11-25T15:37:00.000Z</published>
    <updated>2020-11-25T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RPC 全称 (Remote Procedure Call)，远程过程调用，指的是一台计算机通过网络请求另一台计算机的上服务，从而不需要了解底层网络细节，RPC 是构建在已经存在的协议（TCP/IP，HTTP 等）之上的。<code>gRPC</code> 是云原生计算基金会（CNCF）项目，gRPC 一开始由 google 开发，是一款语言中立、平台中立的服务间通信框架，使用 gRPC 可以使得客户端像调用本地方法一样，调用远程主机提供的服务。可以在任何地方运行，它使客户端和服务器应用程序能够透明地进行通信，并使构建连接系统变得更加容易。</p><a id="more"></a><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><ul><li>gRPC 默认采用 protocol buffer 作为 IDL (Interface Description Lanage) 接口描述语言，服务之间通信的数据序列化和反序列化也是基于 protocol buffer 的，因为 protocol buffer 的特殊性，所以 gRPC 框架是跨语言的通信框架（与编程语言无关性）</li><li>gRPC 是基于 http2 协议实现,多路复用支持通过同一连接发送多个并行请求,双向全双工通信，用于同时发送客户端请求和服务器响应,内置流式传输使请求和响应能够异步流式传输大数据集</li><li>gRPC 并没有直接实现负载均衡和服务发现的功能，但是已经提供了自己的设计思路。已经为命名解析和负载均衡提供了接口。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service Greeter &#123;</span><br><span class="line">   &#x2F;*</span><br><span class="line">   以下 分别是 服务端 推送流， 客户端 推送流 ，双向流。</span><br><span class="line">   *&#x2F;</span><br><span class="line">  rpc GetStream (StreamReqData) returns (stream StreamResData)&#123;&#125;</span><br><span class="line">  rpc PutStream (stream StreamReqData) returns (StreamResData)&#123;&#125;</span><br><span class="line">  rpc AllStream (stream StreamReqData) returns (stream StreamResData)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Protocal-Buffer"><a href="#Protocal-Buffer" class="headerlink" title="Protocal Buffer"></a>Protocal Buffer</h1><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p><a href="https://developers.google.cn/protocol-buffers">Protocol buffers</a> 是一个灵活的、高效的、自动化的用于对结构化数据进行序列化的协议，与XML相比，Protocol buffers序列化后的码流更小、速度更快、操作更简单。</p><p><code>序列化(serialization、marshalling)</code>的过程是指将数据结构或者对象的状态转换成可以存储(比如文件、内存)或者传输的格式(比如网络)。反向操作就是反序列化<code>(deserialization、unmarshalling)</code>的过程。</p><ul><li>二十世纪九十年代后期，XML开始流行，它是一种人类易读的基于文本的编码方式，易于阅读和理解，但是失去了紧凑的基于字节流的编码的优势。</li><li>JSON是一种更轻量级的基于文本的编码方式，经常用在client/server端的通讯中。</li><li>YAML类似JSON，新的特性更强大，更适合人类阅读，也更紧凑。</li></ul><p>除了上面这些和Protobuf，还有许许多多的序列化格式，比如Thrift、Avro、BSON、CBOR、MessagePack, 还有很多非跨语言的编码格式。项目<a href="https://github.com/smallnest/gosercomp">gosercomp</a>对比了各种go的序列化库，包括序列化和反序列的性能，以及序列化后的数据大小。总体来说Protobuf序列化和反序列的性能都是比较高的，编码后的数据大小也不错。</p><font color="blue">如果你并不希望一定要在传输过程中消息数据可读，那么可以用 Protocal Buffer 来代替 Json 。</font><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;      &#x2F;&#x2F; 版本定义</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  int32  id &#x3D; 1;</span><br><span class="line">  string name &#x3D; 2;</span><br><span class="line">  bool   rich &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行指定<code>protobuf</code>的版本，这里是以proto3格式定义。</p><p>第三行 <code>message</code> 表示定义了一个结构体，在这个结构体里，最常见的类型有以下几种</p><ol><li><font color="#FFB90F">数值型</font> ，如 double, float, int32, int64 …</li><li><font color="#FFB90F">布尔型</font>，bool 只有True和False</li><li><font color="#FFB90F">字符型</font>，string 表示任意字符，但是长度不可超过2的32次方</li><li><font color="#FFB90F">字节型</font>，bytes表示任意的byte数组序列，但是长度也不可以超过2的32次方，比如可以用来传递一个图片。</li><li><font color="#FFB90F">枚举型</font>，enum 表示枚举。可独立在 message 之外。可通过 <code>option allow_alias = true;</code> 给枚举定义别名。</li><li>字典型，map类型需要设置键和值的类型。</li><li><font color="#FFB90F">Well-Known类型</font>, Protobuf也提供了定义，比如Timestamp和Duration。这些定义被放在<code>github.com/golang/protobuf/ptypes/</code>。</li></ol><p><strong>引入其它proto文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import  &quot;other.proto&quot;;</span><br><span class="line">import public &quot;other2.proto&quot;;</span><br><span class="line">import weak &quot;other.proto&quot;;</span><br></pre></td></tr></table></figure><br>比较少使用的是public和weak关键字。默认情况下weak引入的文件允许不存在(missing)，只为了google内部使用。public具有传递性，如果你在文件中通过public引入第三方的proto文件，那么引入你这个文件同时也会引入第三方的proto。</p><p><strong>关键字：</strong></p><ol><li><font color="#FFB90F"> option</font> ：option可以用在proto的scope中，或者message、enum、service的定义中。一般常用的就是定义某语言生成后的package名，最常见的用法，如 <code>option go_package = &quot;xxx&quot;;</code></li><li><font color="#FFB90F">repeated</font> : 指定某一个字段可以存放同一个类型的多个数据, 相当于golang里的slice。可采用<code>[packed=true]</code>以实现更高<br>效的编码。<code>repeated int32 samples = 4 [packed=true];</code></li><li><font color="#FFB90F"> reserved</font> : 保护某字段或定义，如在message中指定 数字1 被保护，或变量名 person 被保护。一般用来保护废弃的数字定义。如<code>reserved 5;reserved &quot;salary&quot;;</code> 如果再使用5 或者 salary 则会报错。</li></ol><p><strong>demo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package my.project; </span><br><span class="line"></span><br><span class="line">import &quot;google&#x2F;protobuf&#x2F;timestamp.proto&quot;;</span><br><span class="line"></span><br><span class="line">option go_package &#x3D; &quot;pb&quot;;</span><br><span class="line"></span><br><span class="line">message PersonMessage &#123;</span><br><span class="line">  int32   id &#x3D; 1;</span><br><span class="line">  bool    is_adult &#x3D;2;</span><br><span class="line">  string  name &#x3D; 3;</span><br><span class="line">  float   height &#x3D; 4;</span><br><span class="line">  float   weight &#x3D; 5;</span><br><span class="line">  bytes   avatar &#x3D; 6;</span><br><span class="line">  string  email &#x3D; 7;</span><br><span class="line">  bool    email_verified &#x3D; 8;</span><br><span class="line">  repeated string phone_numbers &#x3D; 9;  &#x2F;&#x2F; packed</span><br><span class="line">  Gender  gender &#x3D; 11;</span><br><span class="line">  Date    birthday &#x3D; 12;</span><br><span class="line">  repeated Address addresses &#x3D; 13;</span><br><span class="line">  google.protobuf.Timestamp lastModified &#x3D; 14;</span><br><span class="line"></span><br><span class="line">  enum Gender &#123;</span><br><span class="line">    option allow_alias &#x3D; true;</span><br><span class="line">    Not_SPECIFIED &#x3D; 0;</span><br><span class="line">    MALE &#x3D; 1;</span><br><span class="line">    FEMALE &#x3D; 2;</span><br><span class="line">    MAN &#x3D; 1;</span><br><span class="line">    WOMAN &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message Address &#123;</span><br><span class="line">    string province &#x3D; 1;</span><br><span class="line">    string city &#x3D; 2;</span><br><span class="line">    string zip_code &#x3D; 3;</span><br><span class="line">    string street &#x3D; 4;</span><br><span class="line">    string number &#x3D; 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reserved 10, 20 to 100, 200 to max;</span><br><span class="line">  reserved &quot;foo&quot;,&quot;bar&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Date &#123;</span><br><span class="line">  int32 year &#x3D; 1;</span><br><span class="line">  int32 month &#x3D; 2;</span><br><span class="line">  int32 day &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Golang-protocol-buffer"><a href="#Golang-protocol-buffer" class="headerlink" title="Golang protocol buffer"></a>Golang protocol buffer</h2><p>定义 <code>.proto</code> 文件后，使用命令<br><code>protoc --protoc_path src/ -go_out=src/ src/person.proto</code> 生成golang 文件</p><p><strong>定义一个pb</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonMessage</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">PersonMessage</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.PersonMessage&#123;</span><br><span class="line">Id: <span class="number">1</span>,</span><br><span class="line">IsAdult: <span class="literal">true</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">Height: <span class="number">177</span>,</span><br><span class="line">Weight: <span class="number">140</span>,</span><br><span class="line">Gender: pb.PersonMessage_MALE,</span><br><span class="line">PhoneNumbers: []<span class="keyword">string</span>&#123;<span class="string">&quot;15667026708&quot;</span>,<span class="string">&quot;17610660213&quot;</span>&#125;,</span><br><span class="line">Email: <span class="string">&quot;weijiaxiang007@foxmail.com&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong> 将 pb 写入文件 </strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToFile</span><span class="params">(filename <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">dataBytes, err := proto.Marshal(pb)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;无法序列化&quot;</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(filename, dataBytes, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;无法写入文件&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;成功写入到文件&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pm := NewPersonMessage()</span><br><span class="line">_ = writeToFile(<span class="string">&quot;person.bin&quot;</span>,pm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong> 从文件读出 pb </strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromFile</span><span class="params">(filename <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">dataBytes, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;读取文件错误&quot;</span>,err.Error()) &#125;</span><br><span class="line"><span class="keyword">if</span> err := proto.Unmarshal(dataBytes, pb); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;反序列化失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pm := &amp;demo.PersonMessage&#123;&#125;</span><br><span class="line">_ = readFromFile(<span class="string">&quot;person.bin&quot;</span>, pm)</span><br><span class="line">fmt.Println(pm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>pb 转 json &amp;&amp; json 转 pb</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toJson</span><span class="params">(pb proto.Message)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">marshaler := jsonpb.Marshaler&#123;Indent: <span class="string">&quot;    &quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">str ,err := marshaler.MarshalToString(pb)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;转换为JSON时发生错误&quot;</span>,err.Error()) &#125;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fromJson</span><span class="params">(in <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> jsonpb.UnmarshalString(in, pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>gogo库</strong></p><p>虽然官方库 <font color="#68228B"><a href="https://github.com/golang/protobuf">golang/protobu</a> </font>提供了对Protobuf的支持，但是使用最多还是第三方实现的库<a href="https://github.com/gogo/protobuf">gogo/protobuf</a>。</p><p>gogo库基于官方库开发，增加了很多的功能，包括：</p><ol><li>快速的序列化和反序列化</li><li>更规范的Go数据结构</li><li>goprotobuf兼容</li><li>可选择的产生一些辅助方法，减少使用中的代码输入</li><li>可以选择产生测试代码和benchmark代码</li><li>其它序列化格式</li></ol><blockquote><p>更多参考github： <a href="http://github.com/gogo/protobuf">http://github.com/gogo/protobuf</a></p></blockquote><h1 id="gRPC-Start"><a href="#gRPC-Start" class="headerlink" title="gRPC Start"></a>gRPC Start</h1><p>进入主题了, gRPC 是Google发布的基于HTTP 2.0传输层协议承载的高性能开源软件框架。提供了支持多种编程语言的、对网络设备进行配置和纳管的方法。</p><p>RPC是远程函数调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间。因此传统的RPC方法调用对于上传和下载较大数据量场景并不适合。同时传统RPC模式也不适用于对时间不确定的订阅和发布模式。为此，gRPC框架针对服务器端和客户端分别提供了流特性。</p><font color="#483D8B">支持 服务端 推送流， 客户端 推送流 ，双向流。</font><p><img alt="Smiley face" height="420" src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_concept_diagram.png"></p><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>gRPC要求 Go 版本 &gt;= 1.6</p><ol><li>安装grpc<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u -v google.golang.org/grpc</span><br></pre></td></tr></table></figure></li><li>安装 Protocol Buffers v3、protoc-gen-go:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -v -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure></li><li>生成grpc代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc -I. --go_out=plugins=grpc:. helloworld.proto</span><br></pre></td></tr></table></figure><h2 id="define-proto"><a href="#define-proto" class="headerlink" title="define proto"></a>define proto</h2></li></ol><p>gRPC需要事先定义proto文件，如下所示。定义完成后需要执行命令 <code>protoc --go_out=plugins=grpc:. message.proto</code> 生成相关的go语言代码。更多详细的操作参考官方例子 <a href="https://grpc.io/docs/languages/go/quickstart/">Quick start - gRPC</a></p><p><a href="/images/network/gRPC/message.proto">点击查看</a></p><h2 id="gRPC-server"><a href="#gRPC-server" class="headerlink" title="gRPC server"></a>gRPC server</h2><p>gRPC服务的启动流程和标准库的RPC服务启动流程类似：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> port  = <span class="string">&quot;:5001&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  log.Fatalln(err.Error() &#125;</span><br><span class="line"><span class="keyword">var</span> options []grpc.ServerOption</span><br><span class="line">options = <span class="built_in">append</span>(options, grpc.HeaderTableSize(<span class="number">2048</span>))</span><br><span class="line"></span><br><span class="line">server := grpc.NewServer(options...)</span><br><span class="line">pb.RegisterEmployeeServiceServer(server, <span class="built_in">new</span>(example.EmployeeService))</span><br><span class="line">log.Printf(<span class="string">&quot;gRPC Server started ...\n Listen on port %s&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">_ = server.Serve(listen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>这里设置监听在 tcp 的 5001 端口.</li><li><code>grpc.ServerOption</code> 可以设置gRPC的服务端监听参数， 这里我仅设置了 H2 的 header 动态表大小。除此之外，如设置 TLS证书载入：<code>grpc.Creds(c credentials.TransportCredentials)</code>。<br>最大并发数、收发最大消息Size等等，详见 <a href="https://godoc.org/google.golang.org/grpc#ServerOption">https://godoc.org/google.golang.org/grpc#ServerOption</a></li><li><code>pb.RegisterEmployeeServiceServer</code> 是proto生成的 message.pb.go 提供的服务端注册方法。<code>example.EmployeeService</code> 是我们后面手动创建的空结构，后面的函数方法都需要基于这个空结构实现。</li><li>server.Serve 将监听套接字传入。</li></ul><p><strong>实现 EmployeeService</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service EmployeeService &#123;</span><br><span class="line">  rpc GetByNo(GetByNoRequest) returns (EmployeeResponse);         &#x2F;&#x2F; 一元请求</span><br><span class="line">  rpc GetAll(GetAllRequest) returns (stream EmployeeResponse);    &#x2F;&#x2F; 客户端推送流</span><br><span class="line">  rpc AddPhoto(stream AddPhotoRequest) returns (AddPhotoResponse); &#x2F;&#x2F; 服务端推送流</span><br><span class="line">  rpc SaveAll(stream EmployeeRequest) returns (stream EmployeeResponse); &#x2F;&#x2F; 双向流</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对应的pb生成代码</span><br><span class="line">&#x2F;&#x2F; EmployeeServiceServer is the server API for EmployeeService service.</span><br><span class="line">type EmployeeServiceServer interface &#123;</span><br><span class="line">GetByNo(context.Context, *GetByNoRequest) (*EmployeeResponse, error)</span><br><span class="line">GetAll(*GetAllRequest, EmployeeService_GetAllServer) error</span><br><span class="line">AddPhoto(EmployeeService_AddPhotoServer) error</span><br><span class="line">SaveAll(EmployeeService_SaveAllServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先需要定义 <code>type EmployeeService struct &#123;&#125;</code> 后面的所有方法都需要基于这个实现，这个也是服务端注册的参数。</p><ul><li><strong>一元请求 <code>GetByNo()</code> </strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">GetByNo</span><span class="params">(ctx context.Context, request *pb.GetByNoRequest)</span> <span class="params">(*pb.EmployeeResponse, error)</span></span> &#123;</span><br><span class="line">log.Println(request.No)</span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line"><span class="keyword">if</span> request.No == e.No &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.EmployeeResponse&#123;</span><br><span class="line">Employee:           &amp;e,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;the employee does not exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>请求参数是 <code>GetByNoRequest</code>， 通过上面的pb定义得知，这个message是有一个No参数。所以可以取出来当请求参数。返回的参数是<code>EmployeeResponse</code>，通过pb定义得知，其返回参数是 <code>Employee</code> 对象。</li></ul><ul><li><strong>服务端返回流 <code>GetAll()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">GetAll</span><span class="params">(request *pb.GetAllRequest, stream pb.EmployeeService_GetAllServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">err := stream.Send(&amp;pb.EmployeeResponse&#123;</span><br><span class="line">Employee: &amp;e,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意，返回的参数是一条流，其流发送的方法也可以使用Send函数，这里是一个循环，将employee对象循环写入这条流中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type EmployeeService_GetAllServer interface &#123;</span><br><span class="line">Send(*EmployeeResponse) error</span><br><span class="line">grpc.ServerStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端推送流 <code>AddPhoto()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">AddPhoto</span><span class="params">(stream pb.EmployeeService_AddPhotoServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">md, ok := metadata.FromIncomingContext(stream.Context())</span><br><span class="line"><span class="keyword">if</span> ok &#123; fmt.Printf(<span class="string">&quot;employee: %s&quot;</span>, md[<span class="string">&quot;no&quot;</span>][<span class="number">0</span>]) &#125;</span><br><span class="line"><span class="keyword">var</span> images []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">data, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;File Size %d\n&quot;</span>, <span class="built_in">len</span>(images))</span><br><span class="line"><span class="keyword">return</span> stream.SendAndClose(&amp;pb.AddPhotoResponse&#123;IsOk: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;File received: %d\n&quot;</span>, <span class="built_in">len</span>(data.Data))</span><br><span class="line">images = <span class="built_in">append</span>(images, data.Data...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实现了客户端将一张图片拆分成 bytes 再一点一点发送给服务端的demo。读到EOF表示成功读完。Data正是在 pb 里定义的<code>AddPhotoRequest</code>的客户端请求内容。</p></li><li><p><strong>双向流 <code>SaveAll()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">SaveAll</span><span class="params">(stream pb.EmployeeService_SaveAllServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">empReq, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">employees = <span class="built_in">append</span>(employees, *empReq.Employee)</span><br><span class="line">time.Sleep(<span class="number">1000</span> * time.Microsecond)</span><br><span class="line">_ = stream.Send(&amp;pb.EmployeeResponse&#123;Employee: empReq.Employee&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _ , emp := <span class="keyword">range</span> employees &#123;</span><br><span class="line">fmt.Println(emp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，服务端每读一份数据，休眠100ms，再将读入的数据原封不动的返回给客户端。</p></li></ul><h2 id="gRPC-client"><a href="#gRPC-client" class="headerlink" title="gRPC client"></a>gRPC client</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> options []grpc.DialOption</span><br><span class="line">options = <span class="built_in">append</span>(options, grpc.WithInsecure())</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;localhost&quot;</span> + port, options...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;can&#x27;t dial server &quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">client := pb.NewEmployeeServiceClient(conn)</span><br><span class="line"><span class="comment">// GetByNo(client)</span></span><br><span class="line"><span class="comment">// getAll(client)</span></span><br><span class="line"><span class="comment">//addPhoto(client)</span></span><br><span class="line">saveAll(client)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端也有一个类似Server端的<code>grpc.DialOption</code>, 这里因为服务端没有使用证书，所以客户端必须添加 <code>WithInsecure</code> 选项。调用 <code>pb.NewEmployeeServiceClient(conn)</code> 会返回一个 Client <code>employeeServiceClient</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> employeeServiceClient <span class="keyword">struct</span> &#123;</span><br><span class="line">cc grpc.ClientConnInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个client拥有之前定义的客户端可调用的 RPC 方法。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; For semantics around ctx use and closing&#x2F;ending streaming RPCs, please refer to https:&#x2F;&#x2F;godoc.org&#x2F;google.golang.org&#x2F;grpc#ClientConn.NewStream.</span><br><span class="line">type EmployeeServiceClient interface &#123;</span><br><span class="line">GetByNo(ctx context.Context, in *GetByNoRequest, opts ...grpc.CallOption) (*EmployeeResponse, error)</span><br><span class="line">GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (EmployeeService_GetAllClient, error)</span><br><span class="line">AddPhoto(ctx context.Context, opts ...grpc.CallOption) (EmployeeService_AddPhotoClient, error)</span><br><span class="line">SaveAll(ctx context.Context, opts ...grpc.CallOption) (EmployeeService_SaveAllClient, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>实现 Client 调用</strong></p><ul><li><strong>一元请求 <code>GetByNo()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetByNo</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">res, err := client.GetByNo(context.Background(), &amp;pb.GetByNoRequest&#123;No: <span class="number">1996</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>传入的参数拥有 <code>GetByNo()</code> 这个方法，直接调用即可。</li></ul><p>抓包可以看到，整个gRPC的调用过程是基于HTTP2的, 本质是发起了一个H2的POST请求, 和传统H2不同的是，response 的 Header帧有2个，结尾处还有一个。第2个表示调用结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stream: HEADERS, Stream ID: 1, Length 80, POST /employee.EmployeeService/GetByNo</span><br><span class="line">    Length: 80</span><br><span class="line">    Type: HEADERS (1)</span><br><span class="line">    Flags: 0x04</span><br><span class="line">    0... .... .... .... .... .... .... .... = Reserved: 0x0</span><br><span class="line">    .000 0000 0000 0000 0000 0000 0000 0001 = Stream Identifier: 1</span><br><span class="line">    [Pad Length: 0]</span><br><span class="line">    Header Block Fragment: 3fe10f8386459960b4d741fd14abe0a6ba0fe8a5dc5b3b98…</span><br><span class="line">    [Header Length: 202]</span><br><span class="line">    [Header Count: 8]</span><br><span class="line">    Header table size update</span><br><span class="line">    Header: :method: POST</span><br><span class="line">    Header: :scheme: http</span><br><span class="line">    Header: :path: /employee.EmployeeService/GetByNo</span><br><span class="line">    Header: :authority: localhost:5001</span><br><span class="line">    Header: content-type: application/grpc</span><br><span class="line">    Header: user-agent: grpc-go/1.33.2</span><br><span class="line">    Header: te: trailers</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_v1.png" alt></p><ul><li><strong>服务端返回流 <code>GetAll()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAll</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">stream, err := client.GetAll(context.Background(), &amp;pb.GetAllRequest&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>服务端返回的流可以使用 <code>stream.Recv()</code> 循环接收。<br><img src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_v2.png" alt></li></ul><ul><li><strong>客户端推送流 <code>AddPhoto()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">imgFile,err := os.Open(<span class="string">&quot;/home/kiosk007/Pictures/2020-09-22_00-15.png&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> imgFile.Close()</span><br><span class="line"></span><br><span class="line">md := metadata.New(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;no&quot;</span>: <span class="string">&quot;1996&quot;</span>&#125;)</span><br><span class="line">context := context.Background()</span><br><span class="line">context = metadata.NewOutgoingContext(context, md)</span><br><span class="line">stream,err := client.AddPhoto(context)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">chunk := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>*<span class="number">24</span>)</span><br><span class="line">chunkSize,err := imgFile.Read(chunk)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chunkSize &lt; <span class="built_in">len</span>(chunk) &#123;</span><br><span class="line">chunk = chunk[:chunkSize]</span><br><span class="line">&#125;</span><br><span class="line">_ = stream.Send(&amp;pb.AddPhotoRequest&#123;Data: chunk&#125;)</span><br><span class="line">&#125;</span><br><span class="line">res, err := stream.CloseAndRecv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.IsOk)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>客户端推送流实现了一个照片流式上传的功能。每次发送 3072字节 (128*24)。</li></ul><ul><li><strong>双向流 <code>SaveAll()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveAll</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">employees := []pb.Employee&#123;</span><br><span class="line">pb.Employee&#123;</span><br><span class="line">Id:                   <span class="number">300</span>,</span><br><span class="line">No:                   <span class="number">5001</span>,</span><br><span class="line">FirstName:            <span class="string">&quot;Monica&quot;</span>,</span><br><span class="line">LastName:             <span class="string">&quot;Geller&quot;</span>,</span><br><span class="line">MonthSalary:          <span class="number">15500</span>,</span><br><span class="line">Status:               pb.EmployeeStatus_RETIRED,</span><br><span class="line">LastModified:         &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix() &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">pb.Employee&#123;</span><br><span class="line">Id:                   <span class="number">301</span>,</span><br><span class="line">No:                   <span class="number">5002</span>,</span><br><span class="line">FirstName:            <span class="string">&quot;Joey&quot;</span>,</span><br><span class="line">LastName:             <span class="string">&quot;Green&quot;</span>,</span><br><span class="line">MonthSalary:          <span class="number">200</span>,</span><br><span class="line">Status:               pb.EmployeeStatus_RESIGNED,</span><br><span class="line">LastModified:         &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix() &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">stream, err := client.SaveAll(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">finishChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res,err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">finishChannel &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">err := stream.Send(&amp;pb.EmployeeRequest&#123;Employee: &amp;e&#125;)</span><br><span class="line">time.Sleep(<span class="number">500</span> * time.Microsecond)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_ = stream.CloseSend()</span><br><span class="line">&lt;- finishChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>参考：</strong></p><ol><li><a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go">Protobuf 终极教程  — 鸟窝</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPC 全称 (Remote Procedure Call)，远程过程调用，指的是一台计算机通过网络请求另一台计算机的上服务，从而不需要了解底层网络细节，RPC 是构建在已经存在的协议（TCP/IP，HTTP 等）之上的。&lt;code&gt;gRPC&lt;/code&gt; 是云原生计算基金会（CNCF）项目，gRPC 一开始由 google 开发，是一款语言中立、平台中立的服务间通信框架，使用 gRPC 可以使得客户端像调用本地方法一样，调用远程主机提供的服务。可以在任何地方运行，它使客户端和服务器应用程序能够透明地进行通信，并使构建连接系统变得更加容易。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="grpc" scheme="http://kiosk007.top/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>基于Nginx的实时音频直播服务</title>
    <link href="http://kiosk007.top/2020/11/16/%E5%9F%BA%E4%BA%8ENginx%E5%AE%9E%E7%8E%B0%E7%9A%84RTMP%E6%9C%8D%E5%8A%A1/"/>
    <id>http://kiosk007.top/2020/11/16/%E5%9F%BA%E4%BA%8ENginx%E5%AE%9E%E7%8E%B0%E7%9A%84RTMP%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-11-16T15:02:00.000Z</published>
    <updated>2020-11-16T15:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在百度云上下了一些学习视频（别想歪..），苦于一台笔记本不方便同时跟着操作变播放，那么既然都有笔记本了，何不搭建一个视频播放服务呢？笔记本使用Nginx搭建一个视频服务器，iPad上使用播放器（Aplayer），不仅是播放还可以直播，这不正契合了当前的高热话题“实时音视频直播技术”么，最近也找了一部分资料，趁着直播的热度在这里总结一下。</p><a id="more"></a><p>  随着互联网用户消费内容和交互方式的升级，支撑这些内容和交互方式的基础设施也正在悄悄发生变革。手机设备拍摄视频能力和网络的升级催生了大家对视频直播领域的关注，吸引了很多互联网创业者或者成熟企业进入该领域。</p><h1 id="直播中的各个环节"><a href="#直播中的各个环节" class="headerlink" title="直播中的各个环节"></a>直播中的各个环节</h1><h2 id="完整的直播流程"><a href="#完整的直播流程" class="headerlink" title="完整的直播流程"></a>完整的直播流程</h2><p><img src="https://img1.kiosk007.top/static/images/live/live.jpg" alt></p><ul><li><font color="red"><code>音视频采集</code></font>: 采集是播放环节中的第一环，iOS 系统因为软硬件种类不多，硬件适配性较好，所以比较简单。Android 则不同，市面上硬件机型非常多，难以做到一个库适配所有硬件。PC 端的采集也跟各种摄像头驱动有关，推荐使用目前市面上最好用的 PC 端开源免费软件 OBS。</li><li><code>音视频处理</code>: 美颜、水印等也都是在这个环节做。目前 iOS 端比较知名的是 GPUImage 这个库，提供了丰富端预处理效果，还可以基于这个库自己写算法实现更丰富端效果。Android 也有 GPUImage 这个库的移植，叫做 android-gpuimage。</li><li><code>音视频编码</code>: iOS 端硬件兼容性较好，可以直接采用硬编。而 Android 的硬编的支持则难得多，需要支持各种硬件机型，推荐使用软编。</li><li><code>推流和传输</code>: 涉及 1、从主播端到服务端 2、从收流服务端到边缘节点 3、从边缘节点到观众端 。推流端和分发端理论上需要支持的并发用户数应该都是亿级的，不过毕竟产生内容的推流端在少数，和消费内容端播放端不是一个量级。对推流稳定性和速度的要求比播放端高很多，这涉及到所有播放端能否看到直播，以及直播端质量如何。</li><li><code>实时音视频转码</code>: 为了让主播推上来的流适配各个平台端各种不同协议，需要在服务端做一些流处理工作，比如转码成不同格式支持不同协议如 RTMP、HLS 和 FLV，一路转多路流来适配各种不同的网络状况和不同分辨率的终端设备。</li><li><code>解码和渲染</code>: 解码和渲染，也即音视频的播放，目前 iOS 端的播放兼容性较好，在延迟可接受的情况下使用 HLS 协议是最好的选择，市面上也提供了能够播放 RTMP 和 HLS 的播放器 SDK。</li></ul><p>参考：<a href="http://www.52im.net/thread-853-1-1.html">《移动端实时音视频直播技术详解》</a></p><p>编码器的介绍可以参考 <a href="http://www.52im.net/thread-965-1-1.html">编码与封装</a>，下面主要说一说“推流和拉流”</p><h2 id="推流和拉流"><a href="#推流和拉流" class="headerlink" title="推流和拉流"></a>推流和拉流</h2><h3 id="推送协议"><a href="#推送协议" class="headerlink" title="推送协议"></a><strong>推送协议</strong></h3><p>推流，指的是把采集阶段封包好的内容传输到服务器的过程。其实就是将现场的视频信号传到网络的过程。</p><p>“推流”对网络要求比较高，如果网络不稳定，直播效果就会很差，观众观看直播时就会发生卡顿等现象，观看体验很是糟糕。</p><p>要想用于推流还必须把音视频数据使用传输协议进行封装，变成流数据。常用的流传输协议有RTSP、RTMP、WebRTC、HLS等，使用RTMP传输的延时通常在1–3秒，对于手机直播这种实时性要求非常高的场景，RTMP也成为手机直播中最常用的流传输协议。</p><p>下面介绍一下以下协议以及他们在直播领域的现状和优缺点：<strong>1、RTMP 2、WebRTC</strong></p><h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a><strong>RTMP</strong></h4><p>RTMP 是 Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash/AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media Server/red5 等。<br>RTMP 是目前主流的流媒体传输协议，广泛用于直播领域，可以说市面上绝大多数的直播产品都采用了这个协议。<br>另外，RTMPT封装在HTTP请求之上，可穿透防火墙；</p><p><strong>优点:</strong></p><blockquote><p>CDN 支持良好，主流的 CDN 厂商都支持；<br>协议简单，在各平台上实现容易。</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>基于 TCP ，传输成本高，在弱网环境丢包率高的情况下问题显著；<br>不支持浏览器推送；<br>Adobe 私有协议，Adobe 已经不再更新。</p></blockquote><h4 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a><strong>WebRTC</strong></h4><p>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的 API。它于 2011 年 6 月 1 日开源并在 Google、Mozilla、Opera 支持下被纳入万维网联盟的 W3C 推荐标准<br><a href="https://webrtc.org.cn/">WebRTC</a> </p><p><strong>目前主要应用于视频会议和连麦中</strong></p><p><strong>优点：</strong></p><blockquote><p>W3C 标准，主流浏览器支持程度高，Google 在背后支撑，并在各平台有参考实现；<br>底层基于 SRTP 和 UDP，弱网情况优化空间大；<br>可以实现点对点通信，通信双方延时低。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>ICE、STUN、TURN 传统 CDN 没有类似的服务提供</p></blockquote><h3 id="拉流协议"><a href="#拉流协议" class="headerlink" title="拉流协议"></a><strong>拉流协议</strong></h3><p>拉流是指服务器已有直播内容，根据协议类型（如RTMP、RTP、RTSP、HTTP等），与服务器建立连接并接收数据，进行拉取的过程。</p><p>拉流端的核心处理在播放器端的解码和渲染，在互动直播中还需集成聊天室、点赞和礼物系统等功能。下面介绍几个常见的拉流协议。</p><h4 id="RTMP-1"><a href="#RTMP-1" class="headerlink" title="RTMP"></a><strong>RTMP</strong></h4><p>没错，推流和拉流都是RTMP所擅长的。现在 PC 市场巨大，PC 主要是 Windows，Windows 的浏览器基本上都支持 Flash。另外RTMP适合长时间播放，曾经有过测试，联系 100 万秒，即 10 天多连续播放没有出现问题。最后 RTMP 的延迟相对较低，一般延时在 1-3s 之间，一般的视频会议，互动式直播，完全是够用的。</p><p>不过，在移动端上，Flash Player 已经被杀绝了，那为啥还会出现这个呢？<br>因为它主要是针对 PC 端的。现在推流协议各大云厂商基本都是直接支持 rtmp 。</p><p><strong>拉流用 rtmp 的话就不太现实了，现在对 flash 支持都不友好了。</strong></p><h4 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a><strong>HLS</strong></h4><p>HLS 是苹果提出的基于HTTP的流媒体传输协议，优点是跨平台性比较好，HTML5可以直接打开播放，移动端兼容性良好，但是缺点是延迟比较高。</p><p>HLS 主要的两块内容是 .m3u8 文件和 .ts 播放文件。接受服务器会将接受到的视频流进行缓存，然后缓存到一定程度后，会将这些视频流进行编码格式化，同时会生成一份 .m3u8 文件和其它很多的 .ts 文件。</p><p>HLS 支持的功能，并不只是分片播放（专门适用于直播），它还包括其他应有的功能。</p><blockquote><p>使用 HTTPS 加密 ts 文件<br>快/倒放<br>广告插入<br>不同分辨率视频切换</p></blockquote><p><strong>HLS 之所以能这么流行，关键在于它的支持度是真的广，所以，对于一般 H5 直播来说，应该是非常友好的。</strong></p><h4 id="HDL-HTTP-FLV"><a href="#HDL-HTTP-FLV" class="headerlink" title="HDL(HTTP-FLV)"></a><strong>HDL(HTTP-FLV)</strong></h4><p>HTTP-FLV 和 RTMPT 类似，都是针对于 FLV 视频格式做的直播分发流。<br>但，两者有着很大的区别：</p><p><strong>相同点：</strong></p><blockquote><p>两者都是针对 FLV 格式<br>两者延时都很低<br>两者都走的 HTTP 通道</p></blockquote><p><strong>不同点：</strong></p><blockquote><p>HTTP-FLV直接发起长连接，下载对应的 FLV 文件<br>头部信息简单</p></blockquote><p>RTMPT握手协议过于复杂。分包，组包过程耗费精力大，因为 RTMP 发的包很容易处理，通常 RTMP 协议会作为视频上传端来处理，然后经由服务器转换为 FLV 文件，通过 HTTP-FLV 下发给用户。</p><p>参考：<a href="https://driverzhang.github.io/post/%E7%9B%B4%E6%92%AD%E5%8D%8F%E8%AE%AErtmphlshttp-flv/">直播协议RTMP、HLS、HTTP FLV</a></p><h1 id="基于Nginx搭建视频服务"><a href="#基于Nginx搭建视频服务" class="headerlink" title="基于Nginx搭建视频服务"></a>基于Nginx搭建视频服务</h1><blockquote><p>系统版本: Ubuntu 20.04 focal<br>Nginx版本:1.17.3<br>Nginx Rtmp模块: nginx-rtmp-module</p></blockquote><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><strong>Nginx</strong></h2><p>我是基于 XPS 上的Ubuntu搭建的，搭建过程之前在 <a href="https://kiosk007.top/2020/04/18/%E8%87%AA%E5%BB%BA-Nginx-%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2/">自建 Nginx 部署</a> 文章中已经提过，这里需要注意的是需要安装 <code>nginx-rtmp-module</code> 模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -m</span></span><br><span class="line">KServer version: KServer/2.3.2</span><br><span class="line">nginx version: nginx/1.17.3</span><br><span class="line">nginx: loaded modules:</span><br><span class="line">nginx:     ngx_core_module (static)</span><br><span class="line">...</span><br><span class="line">nginx:     ngx_rtmp_module (static)</span><br><span class="line">nginx:     ngx_rtmp_core_module (static)</span><br><span class="line">nginx:     ngx_rtmp_cmd_module (static)</span><br><span class="line">nginx:     ngx_rtmp_codec_module (static)</span><br><span class="line">nginx:     ngx_rtmp_access_module (static)</span><br><span class="line">nginx:     ngx_rtmp_record_module (static)</span><br><span class="line">nginx:     ngx_rtmp_live_module (static)</span><br><span class="line">nginx:     ngx_rtmp_play_module (static)</span><br><span class="line">nginx:     ngx_rtmp_flv_module (static)</span><br><span class="line">nginx:     ngx_rtmp_mp4_module (static)</span><br><span class="line">nginx:     ngx_rtmp_netcall_module (static)</span><br><span class="line">nginx:     ngx_rtmp_relay_module (static)</span><br><span class="line">nginx:     ngx_rtmp_exec_module (static)</span><br><span class="line">nginx:     ngx_rtmp_auto_push_module (static)</span><br><span class="line">nginx:     ngx_rtmp_auto_push_index_module (static)</span><br><span class="line">nginx:     ngx_rtmp_notify_module (static)</span><br><span class="line">nginx:     ngx_rtmp_log_module (static)</span><br><span class="line">nginx:     ngx_rtmp_limit_module (static)</span><br><span class="line">nginx:     ngx_rtmp_hls_module (static)</span><br><span class="line">nginx:     ngx_rtmp_dash_module (static)</span><br><span class="line">nginx:     ngx_openssl_module (static)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="视频直播服务"><a href="#视频直播服务" class="headerlink" title="视频直播服务"></a>视频直播服务</h2><p>Nginx本身是一个非常出色的HTTP服务器,FFMPEG是非常好的音视频解决方案.这两个东西通过一个Nginx的模块nginx-rtmp-module,组合在一起即可以搭建一个功能相对比较完善的流媒体服务器. 这个流媒体服务器可以支持RTMP和HLS(Live Http Stream)。</p><p>配置时需要在Nginx的主配置加上一句<code>include /home/work/nginx/rtmp/*.conf;</code>，因为 rtmp 是单独一个块，等价于 http 块。再创建目录 <code>/home/work/nginx/rtmp/</code>，之后 rtmp 的配置会放在该目录下。</p><h3 id="安装FFmpeg"><a href="#安装FFmpeg" class="headerlink" title="安装FFmpeg"></a><strong>安装FFmpeg</strong></h3><p>FFmpeg 是视频处理最常用的开源软件。名称来自MPEG视频编码标准，前面的“FF”代表“Fast Forward”，FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。可以轻易地实现多种视频格式之间的相互转换，FFmpeg的用户有Google，Facebook，Youtube，优酷，爱奇艺，土豆等。可参考阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">FFmpeg 视频处理</a> 这篇文章。</p><p>安装方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure></p><h3 id="RTMP-直播"><a href="#RTMP-直播" class="headerlink" title="RTMP 直播"></a>RTMP 直播</h3><p>在 <code>/home/work/nginx/rtmp/live.conf</code> 里创建如下内容。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">notify_method</span> get;</span><br><span class="line">        <span class="attribute">access_log</span>  /home/work/log/nginx/http_rtmp.log;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line">        <span class="attribute">application</span> rtmplive &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;                <span class="comment"># 开启直播模式</span></span><br><span class="line">            <span class="attribute">allow</span> publish all;      <span class="comment"># 允许从任何源push流</span></span><br><span class="line">            <span class="attribute">allow</span> play all;         <span class="comment"># 允许从任何地方来播放流</span></span><br><span class="line">            <span class="attribute">drop_idle_publisher</span> <span class="number">20s</span>; <span class="comment"># 20秒内没有push，就断开链接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查nginx配置后reload nginx,使之生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /home/work/nginx/sbin/nginx -t</span></span><br><span class="line"><span class="comment"># /home/work/nginx/sbin/nginx -s reload</span></span><br></pre></td></tr></table></figure><p><strong>试验</strong></p><p>使用 ffmpeg 推流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i .&#x2F;Golang从入门到癫狂.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv &#39;rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;room&#39;</span><br></pre></td></tr></table></figure><br>ipad 上去App Store下载 <strong>Aplyer</strong><br><img src="https://img1.kiosk007.top/static/images/live/aplyer.jpeg" style="height:350px"></p><p>打开Aplayer，选择最下方的“网络”，在输入框中输入<code>rtmp://192.168.1.10/live/room</code> 即可观看直播了。</p><h3 id="HLS直播"><a href="#HLS直播" class="headerlink" title="HLS直播"></a>HLS直播</h3><p>配置hls需要有两个步骤</p><ol><li>配置rtmp流产生hls文件</li><li>设置nginx来访问hls文件</li></ol><p><strong>配置rtmp流产生hls文件</strong><br>创建存放hls文件的目录, 确保 Nginx worker 用户可以读写该目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;work&#x2F;data&#x2F;hls</span><br><span class="line">chown work:work &#x2F;home&#x2F;work&#x2F;data&#x2F;hls</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改配置，增加hls相关配置<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>; <span class="comment"># Listen on standard RTMP port</span></span><br><span class="line">        <span class="attribute">notify_method</span> get;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">application</span> hlslive &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;   <span class="comment"># Turn on HLS</span></span><br><span class="line">            <span class="attribute">hls</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">hls_path</span> /home/work/data/hls;</span><br><span class="line">            </span><br><span class="line">            <span class="attribute">allow</span> publish all;          <span class="comment"># 允许从任何源push流</span></span><br><span class="line">            <span class="attribute">allow</span> play all;             <span class="comment"># 允许从任何地方来播放流</span></span><br><span class="line">            <span class="attribute">drop_idle_publisher</span> <span class="number">20s</span>;    <span class="comment"># 20秒内没有push，就断开链接。</span></span><br><span class="line">            <span class="attribute">hls_fragment</span> <span class="number">3</span>;</span><br><span class="line">            <span class="attribute">hls_playlist_length</span> <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>添加了如下两个配置:</p><ul><li><code>hls on</code> : 开启HLS</li><li><code>hls_path /home/work/data/hls</code> : 设置hls目录</li></ul><p>此时使用ffmpeg进行推流后，在/home/work/data/hls目录下，就会有HLS要用到的m3u8和ts文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls</span><br><span class="line">room1-0.ts  room1-1.ts  room1.m3u8</span><br></pre></td></tr></table></figure><p>设置nginx来访问hls文件<br>配置nginx通过http访问hls文件, 在server中添加如下location。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /hls &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Cache-Control&#x27;</span> <span class="string">&#x27;no-cache&#x27;</span>;   <span class="comment"># Disable cache</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># CORS setup</span></span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span> always;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="string">&#x27;Content-Length&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># allow CORS preflight requests</span></span><br><span class="line">        <span class="attribute">if</span> ($request_method = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain charset=UTF-8&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">types</span> &#123;</span><br><span class="line">            application/dash+xml mpd;</span><br><span class="line">            application/vnd.apple.mpegurl m3u8;</span><br><span class="line">            video/mp2t ts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /home/work/data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>然后使用支持 HLS 拉流的播放器输入 <code>http://192.168.1.8:8081/hls/room1.m3u8</code></p><p>参考：<a href="https://www.vultr.com/docs/setup-nginx-rtmp-on-centos-7#Security_Note">Setup Nginx-RTMP on CentOS 7</a></p><h2 id="视频播放服务"><a href="#视频播放服务" class="headerlink" title="视频播放服务"></a>视频播放服务</h2><p>毕竟是已经下载好的视频，这里是不存在直播推流的，那么可以直接播放已经存在的视频。视频的格式最好是 mp4 格式，Nginx 配置文件如下即可：</p><h3 id="mp4"><a href="#mp4" class="headerlink" title="mp4"></a>mp4</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">8088</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#错误日志和访问日志的路径配置</span></span><br><span class="line">   <span class="attribute">access_log</span>  /home/work/log/nginx/http_video.log  jxjson;</span><br><span class="line">   <span class="attribute">error_log</span>   /home/work/log/nginx/video-<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">#项目的路径 </span></span><br><span class="line">   <span class="attribute">root</span> /home/work/data/mp4;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#所有的mp4文件的自动解析</span></span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~ \.mp4$</span> &#123;</span><br><span class="line">      mp4;</span><br><span class="line">      <span class="attribute">mp4_buffer_size</span>     <span class="number">1m</span>;</span><br><span class="line">      <span class="attribute">mp4_max_buffer_size</span> <span class="number">5m</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器输入 <code>192.168.1.8:8088/2-1.mp4</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在百度云上下了一些学习视频（别想歪..），苦于一台笔记本不方便同时跟着操作变播放，那么既然都有笔记本了，何不搭建一个视频播放服务呢？笔记本使用Nginx搭建一个视频服务器，iPad上使用播放器（Aplayer），不仅是播放还可以直播，这不正契合了当前的高热话题“实时音视频直播技术”么，最近也找了一部分资料，趁着直播的热度在这里总结一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://kiosk007.top/categories/Nginx/"/>
    
    
    <category term="点播" scheme="http://kiosk007.top/tags/%E7%82%B9%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>玩转 tshark 命令行工具</title>
    <link href="http://kiosk007.top/2020/11/07/%E7%8E%A9%E8%BD%AC-tshark-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://kiosk007.top/2020/11/07/%E7%8E%A9%E8%BD%AC-tshark-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</id>
    <published>2020-11-07T14:26:00.000Z</published>
    <updated>2020-11-07T14:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>玩转TShark（Wireshark的命令行版）<br>wireshark 是一个伟大的网络问题分析工具，当然它也是有终端命令行工具的。<strong>tshark</strong>就是wireshark的命令行之一。WireShark的功能基本都有，还能组合grep/awk等编程处理分析抓包文件。</p><a id="more"></a><h1 id="wireshark-自带命令集"><a href="#wireshark-自带命令集" class="headerlink" title="wireshark 自带命令集"></a>wireshark 自带命令集</h1><p>Wireshark除了能够手动的分析报文之外，还额外的提供了几个命令行工具，方便开发者日常的报文处理需求，比如批量的合并以及编辑报文。这几个命令都是安装wireshark之后能够直接使用的，同时有的有对应的wireshark GUI 的操作。这些命令分别有<code>tshark</code>、<code>tcpdump</code>、<code>capinfos</code>、<code>dumpcap</code>、<code>text2cap</code>、<code>editcap</code>、<code>reordercap</code>、<code>rawshark</code>、<code>mergecap</code>、<code>pcapfix(需单独安装)</code>。</p><ul><li>tshark：基于终端的Wireshark</li><li>tcpdump：使用“tcpdump”捕获以便使用Wireshark查看</li><li>dumpcap：捕获“dumpcap”以便使用Wireshark查看</li><li>capinfos：打印有关捕获文件的信息</li><li>rawshark：转储和分析网络流量。</li><li>editcap：编辑捕获文件</li><li>mergecap：将多个捕获文件合并为一个</li><li>text2pcap：将ASCII hexdumps转换为网络捕获</li><li>reordercap：重新排序捕获文件</li><li>pcapfix: 修复pcap文件</li></ul><h1 id="pcap"><a href="#pcap" class="headerlink" title="pcap"></a>pcap</h1><h2 id="认识-pcap"><a href="#认识-pcap" class="headerlink" title="认识 pcap"></a>认识 pcap</h2><p>尝试查找网络问题的根源时，有助于查看可能是症状的数据包。为了查看这些数据包，必须首先捕获它们。</p><p>Wireshark默认的存储方式是pcap格式，最新版本的wireshark默认存储方式是pcapng。ng是next generation 的缩写，pcap和pcapng格式文件有是存在一定的差异。</p><p>pcap报文文件结构示意图<br><img src="https://img1.kiosk007.top/static/images/tshark/pcap_file_format.png" alt="pcap_format"></p><ol><li>Global Header是整个文件的文件头，包含文件格式标识，pcap格式版本号等文件指示信息。</li><li>Packet Header是每一片数据报文的头部信息，这些信息都是在形成pcap 报文的过程中由抓包软件wireshark添加的额外信息，例如报文捕获时间等。</li><li>Packet Data是抓取通信过程中的实际数据，包括协议数据和内容数据。</li></ol><p>Wireshark 中对 Global Header 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcap_hdr_s</span> &#123;</span></span><br><span class="line">        guint32 magic_number;   <span class="comment">/* magic number */</span></span><br><span class="line">        guint16 version_major;  <span class="comment">/* major version number */</span></span><br><span class="line">        guint16 version_minor;  <span class="comment">/* minor version number */</span></span><br><span class="line">        gint32  thiszone;       <span class="comment">/* GMT to local correction */</span></span><br><span class="line">        guint32 sigfigs;        <span class="comment">/* accuracy of timestamps */</span></span><br><span class="line">        guint32 snaplen;        <span class="comment">/* max length of captured packets, in octets */</span></span><br><span class="line">        guint32 network;        <span class="comment">/* data link type */</span></span><br><span class="line">&#125; <span class="keyword">pcap_hdr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Wireshark 中对 Packet Header 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcaprec_hdr_s</span> &#123;</span></span><br><span class="line">        guint32 ts_sec;         <span class="comment">/* timestamp seconds */</span></span><br><span class="line">        guint32 ts_usec;        <span class="comment">/* timestamp microseconds */</span></span><br><span class="line">        guint32 incl_len;       <span class="comment">/* number of octets of packet saved in file */</span></span><br><span class="line">        guint32 orig_len;       <span class="comment">/* actual length of packet */</span></span><br><span class="line">&#125; <span class="keyword">pcaprec_hdr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取-pcap"><a href="#获取-pcap" class="headerlink" title="获取 pcap"></a>获取 pcap</h2><ul><li><strong>服务器</strong> :推荐使用 tcpdump or tshark (tshark —color 可以染色哦) 命令行</li><li><strong>个人电脑</strong>: 推荐使用 wireshark </li><li><strong>Android 移动设备</strong>: 推荐使用 <a href="https://github.com/egorovandreyrm/pcap-remote">Pcap Remote</a> (需要在 Google Play 下载) </li><li><strong>iOS 移动设备</strong>: 推荐使用 <code>rvictl -s [设备udid]</code> 方式抓包，参考 <a href="https://www.jianshu.com/p/c67baf5fce6d">Wireshark 抓包iOS设备</a></li></ul><p>更多获取 pcap 方法参考 <a href="https://tshark.dev/capture/">捕获pcap</a></p><h1 id="tshark"><a href="#tshark" class="headerlink" title="tshark"></a>tshark</h1><p><a href="https://www.wireshark.org/docs/man-pages/tshark.html">tshark官方文档</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TShark是一个网络分析工具。它能帮你在实时网络中捕获数据包，或是从预先保存好的捕获文件中读取数据包，或是打印出这些数据包的解码形式到标准输出，再或是把数据包写入到一个文件中。TShark的本地捕获文件格式是pcapng格式，这种pcapng格式也被wireshark和多种其他工具使用。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><a href="https://tshark.dev/packetcraft/arcana/profiles/#-o-keyvalue">-o ${key:value} </a> : 配置首选项中的settings, 一般可配置显示时间戳、是否相关seq number，或者TLS、WPA 解密等。</li></ul><p><img src="/images/tshark/tshark_o.png" style="height:200px"></p><ul><li><a href="https://www.wireshark.org/docs/man-pages/tshark.html">-z ${statistics} </a> : 集各种类型的统计信息, 这里面有一些信息是很有用的，如专家信息、时序统计飞行中的报文、时序丢包都需要这个参数来</li></ul><p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_z.png" style="height:350px"></p><p><strong>其余参数如下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓包接口类</span></span><br><span class="line">-i 设置抓包的网络接口，不设置则默认为第一个非自环接口。</span><br><span class="line">-D 列出当前存在的网络接口。在不了解OS所控制的网络设备时，一般先用“tshark -D”查看网络接口的编号以供-i参数使用。</span><br><span class="line">-f 设定抓包过滤表达式（capture filter expression）。抓包过滤表达式的写法雷同于tcpdump</span><br><span class="line">-s 设置每个抓包的大小，默认为65535，多于这个大小的数据将不会被程序记入内存、写入文件</span><br><span class="line">-p 设置网络接口以非混合模式工作，即只关心和本机有关的流量</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止抓包参数</span></span><br><span class="line">-c 抓取的packet数，在处理一定数量的packet后，停止抓取，程序退出。</span><br><span class="line">-a 设置tshark抓包停止向文件书写的条件，事实上是tshark在正常启动之后停止工作并返回的条件。条件写为<span class="built_in">test</span>:value的形式，如“-a duration:5”表示tshark启动后在5秒内抓包然后停止；“-a filesize:10”表示tshark在输出文件达到10kB后停止；“-a files:n”表示tshark在写满n个文件后停止。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理类</span></span><br><span class="line">-R 设置读取（显示）过滤表达式（<span class="built_in">read</span> filter expression）。不符合此表达式的流量同样不会被写入文件。</span><br><span class="line">-n 禁止所有地址名字解析（默认为允许所有）。</span><br><span class="line">-N 启用某一层的地址名字解析。“m”代表MAC层，“n”代表网络层，“t”代表传输层，“C”代表当前异步DNS查找。如果-n和-N参数同时存在，-n将被忽略。如果-n和-N参数都不写，则默认打开所有地址名字解析。</span><br><span class="line">-d 将指定的数据按有关协议解包输出。如要将tcp 8888端口的流量按http解包，应该写为“-d tcp.port==8888,http”。注意选择子和解包协议之间不能留空格。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类</span></span><br><span class="line">-w 设置raw数据的输出文件。这个参数不设置，tshark将会把解码结果输出到stdout。“-w-”表示把raw输出到stdout。如果要把解码结果输出到文件，使用重定向“&gt;”而不要-w参数。</span><br><span class="line">-F 设置输出raw数据的格式，默认为libpcap。“tshark -F”会列出所有支持的raw格式。</span><br><span class="line">-V 设置将解码结果的细节输出，否则解码结果仅显示一个packet一行的summary。</span><br><span class="line">-x 设置在解码输出结果中，每个packet后面以HEX dump的方式显示具体数据。</span><br><span class="line">-T 设置解码结果输出的格式，包括text,ps,psml和pdml，默认为text。</span><br><span class="line">-E: -E &lt;fieldsoption&gt;=&lt;value&gt;如果-T fields选项指定，使用-E来设置一些属性，比如</span><br><span class="line">　　　　header=y|n</span><br><span class="line">　　　　separator=/t|/s|&lt;char&gt;</span><br><span class="line">　　　　occurrence=f|l|a</span><br><span class="line">　　　　aggregator=,|/s|&lt;char&gt;</span><br><span class="line">-t 设置解码结果的时间格式。“ad”表示带日期的绝对时间，“a”表示不带日期的绝对时间，“r”表示从第一个包到现在的相对时间，“d”表示两个相邻包之间的增量时间（delta）。</span><br><span class="line">-S 在向raw文件输出的同时，将解码结果打印到控制台。</span><br><span class="line">-l 在处理每个包时即时刷新输出。</span><br><span class="line">-X 扩展项。</span><br><span class="line">-q 设置安静的stdout输出（例如做统计时）</span><br><span class="line">-z 设置统计参数。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line">-h 显示命令行帮助。</span><br><span class="line">-v 显示tshark的版本信息。</span><br><span class="line">-o 重载选项</span><br></pre></td></tr></table></figure><h2 id="利用-tshark-打印pcap"><a href="#利用-tshark-打印pcap" class="headerlink" title="利用 tshark 打印pcap"></a>利用 tshark 打印pcap</h2><p>我们通过tcpdump或者wireshark抓到 pcap 文件，接下来就可以利用 <code>tshark</code> 这个强大的命令行工具进行抓包。其中 <code>-o</code>的几个选项可以指定 ssl 解密（需要sslkeylog），<code>-T</code> 指定输出格式，<code>-e</code> 指定都需要输出哪些字段（字段列表参考 <a href="https://www.wireshark.org/docs/dfref/）。输出是将每个Package中指定的字段输出。">https://www.wireshark.org/docs/dfref/）。输出是将每个Package中指定的字段输出。</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tshark -o ssl.keylog_file:./sslkeylog.txt \</span><br><span class="line">-o <span class="string">&quot;ssl.desegment_ssl_records: TRUE&quot;</span> \</span><br><span class="line">-o <span class="string">&quot;ssl.desegment_ssl_application_data: TRUE&quot;</span> \</span><br><span class="line">-e ssl.handshake.ciphersuite \  </span><br><span class="line">-e tcp.analysis.zero_window \</span><br><span class="line">-e http.host \</span><br><span class="line">-e dns.time \</span><br><span class="line">-e tcp.flags.urg \</span><br><span class="line">-e http.request.line \</span><br><span class="line">-e dns.qry.name \</span><br><span class="line">-e ip.version \</span><br><span class="line">-e tcp.analysis.window_full \</span><br><span class="line">-e ipv6.dst \</span><br><span class="line">-e http.request.version \</span><br><span class="line">-e udp.dstport \</span><br><span class="line">-e dns.flags.response \</span><br><span class="line">.... \</span><br><span class="line">-T json -r <span class="string">&quot;./capturedump.pcap&quot;</span></span><br></pre></td></tr></table></figure><br>其余更多的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//打印http协议流相关信息</span><br><span class="line">tshark -s 512 -i eth0 -n -f <span class="string">&#x27;tcp dst port 80&#x27;</span> -Y <span class="string">&#x27;http.host and http.request.uri&#x27;</span> -T fields -e http.host -e http.request.uri -l</span><br><span class="line"></span><br><span class="line">//实时打印当前mysql查询语句</span><br><span class="line">tshark -s 512 -i eth0 -n -f <span class="string">&#x27;tcp dst port 3306&#x27;</span> -Y <span class="string">&#x27;mysql.query&#x27;</span> -T fields -e mysql.query</span><br><span class="line"></span><br><span class="line">//解析MySQL协议</span><br><span class="line">tshark -r ./mysql-compress.cap -o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields -e mysql.caps.cp -e frame.number \</span><br><span class="line">-e frame.time_epoch  -e frame.time_delta_displayed  \</span><br><span class="line">-e ip.src -e tcp.srcport -e tcp.dstport -e ip.dst \</span><br><span class="line">-e tcp.time_delta -e frame.time_delta_displayed \</span><br><span class="line">-e tcp.stream -e tcp.len -e mysql.query</span><br><span class="line"></span><br><span class="line">//抓取详细SQL语句, 快速确认client发过来的具体SQL内容：</span><br><span class="line">sudo tshark -i any -f <span class="string">&#x27;port 3306&#x27;</span> -s 0 -l -w - |strings</span><br><span class="line">sudo tshark -i eth0 -d tcp.port==3306,mysql -T fields -e mysql.query <span class="string">&#x27;port 3306&#x27;</span></span><br><span class="line">sudo tshark -i eth0 -Y <span class="string">&quot;ip.addr==11.163.182.137&quot;</span> -d tcp.port==3306,mysql -T fields -e mysql.query <span class="string">&#x27;port 3306&#x27;</span></span><br><span class="line">sudo tshark -i eth0 -Y <span class="string">&quot;tcp.srcport==62877&quot;</span> -d tcp.port==3001,mysql -T fields -e tcp.srcport -e mysql.query <span class="string">&#x27;port 3001&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查看请求目标信息"><a href="#查看请求目标信息" class="headerlink" title="查看请求目标信息"></a>查看请求目标信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcap -o <span class="string">&#x27;gui.column.format:&quot;Source Net Addr&quot;,&quot;%uns&quot;,&quot;Dest Net Addr&quot;, &quot;%und&quot;&#x27;</span> -Y <span class="string">&quot;ip&quot;</span> | sort | uniq</span><br><span class="line">111.206.101.25 → 192.168.100.115</span><br><span class="line">111.206.4.92 → 192.168.100.115</span><br><span class="line">119.167.215.208 → 192.168.100.115</span><br><span class="line">122.14.230.129 → 192.168.100.115</span><br><span class="line">123.125.102.19 → 192.168.100.115</span><br><span class="line">192.168.100.115 → 111.161.111.119</span><br><span class="line">192.168.100.115 → 111.206.101.25</span><br><span class="line">192.168.100.115 → 111.206.4.92</span><br><span class="line">192.168.100.115 → 119.167.215.208</span><br></pre></td></tr></table></figure><h2 id="查看所有请求对象的传输数据情况"><a href="#查看所有请求对象的传输数据情况" class="headerlink" title="查看所有请求对象的传输数据情况"></a>查看所有请求对象的传输数据情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 统计 ip 情况</span><br><span class="line">$ tshark -r wechat.pcap -q -z conv,ip</span><br><span class="line">// 跟踪一条流打印 16进制数据</span><br><span class="line">$ tshark -r wechat.pcap -q -z <span class="string">&quot;follow,tcp,hex,0&quot;</span> </span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_conv.png" alt="conv"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcap -q -z io,<span class="built_in">stat</span>,1,<span class="string">&quot;COUNT(tcp.analysis.retransmission) tcp.analysis.retransmission&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.fast_retransmission) tcp.analysis.fast_retransmission&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.duplicate_ack) tcp.analysis.duplicate_ack&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.lost_segment) tcp.analysis.lost_segment&quot;</span></span><br></pre></td></tr></table></figure><p>分析整个抓包的吞吐量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -o tcp.desegment_tcp_streams:FALSE -n -q -r wechat.pcapng -z io,stat,1,&quot;BYTES()tcp.stream&#x3D;&#x3D;0&quot;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">| IO Statistics               |</span><br><span class="line">|                             |</span><br><span class="line">| Duration: 50.712225 secs    |</span><br><span class="line">| Interval:  1 secs           |</span><br><span class="line">|                             |</span><br><span class="line">| Col 1: BYTES()tcp.stream&#x3D;&#x3D;0 |</span><br><span class="line">|-----------------------------|</span><br><span class="line">|          |1       |         |</span><br><span class="line">| Interval |  BYTES |         |</span><br><span class="line">|-------------------|         |</span><br><span class="line">|  0 &lt;&gt;  1 |      0 |         |</span><br><span class="line">|  1 &lt;&gt;  2 |      0 |         |</span><br><span class="line">...</span><br><span class="line">|  8 &lt;&gt;  9 | 128301 |         |</span><br><span class="line">|  9 &lt;&gt; 10 | 127132 |         |</span><br><span class="line">| 10 &lt;&gt; 11 | 128667 |         |</span><br><span class="line">| 11 &lt;&gt; 12 | 127749 |         |</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>wireshark 的TCP流图中的吞吐量</p><p><img src="https://img1.kiosk007.top/static/images/tshark/wireshark_throughput.png" style="height:300px"></p><p>对比通过 tshark的 io graph 绘出的图。</p><p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_throughput.png" style="weight:300px"></p><p>同理可以绘 丢包重传、飞行中的报文等。</p><p>对于排查网络延时/应用问题有一些过滤条件是非常有用的：</p><ul><li><code>tcp.analysis.lost_segment</code>：表明已经在抓包中看到不连续的序列号。报文丢失会造成重复的ACK，这会导致重传。</li><li><code>tcp.analysis.duplicate_ack</code>：显示被确认过不止一次的报文。大量的重复ACK是TCP端点之间高延时的迹象。</li><li><code>tcp.analysis.retransmission</code>：显示抓包中的所有重传。如果重传次数不多的话还是正常的，过多重传可能有问题。这通常意味着应用性能缓慢和/或用户报文丢失。</li><li><code>tcp.analysis.window_update</code>：将传输过程中的TCP window大小图形化。如果看到窗口大小下降为零，这意味着发送方已经退出了，并等待接收方确认所有已传送数据。这可能表明接收端已经不堪重负了。</li><li><code>tcp.analysis.bytes_in_flight</code>：某一时间点网络上未确认字节数。未确认字节数不能超过你的TCP窗口大小（定义于最初3此TCP握手），为了最大化吞吐量你想要获得尽可能接近TCP窗口大小。如果看到连续低于TCP窗口大小，可能意味着报文丢失或路径上其他影响吞吐量的问题。</li><li><code>tcp.analysis.ack_rtt</code>：衡量抓取的TCP报文与相应的ACK。如果这一时间间隔比较长那可能表示某种类型的网络延时（报文丢失，拥塞，等等）。</li></ul><h2 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h2><ul><li>分析SQL查询的时间分布</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">tshark -r gege_drds.pcap \</span><br><span class="line">-Y <span class="string">&quot;mysql.query or (tcp.srcport==3306  and tcp.len&gt;60)&quot;</span> \</span><br><span class="line">-o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields \</span><br><span class="line">-e frame.number -e frame.time_epoch  \</span><br><span class="line">-e frame.time_delta_displayed  \</span><br><span class="line">-e ip.src -e tcp.srcport -e tcp.dstport -e ip.dst \</span><br><span class="line">-e tcp.time_delta -e tcp.stream -e tcp.len \</span><br><span class="line">| awk <span class="string">&#x27;BEGIN &#123; \</span></span><br><span class="line"><span class="string">sum0=0;sum3=0;sum10=0;sum30=0;sum50=0; \</span></span><br><span class="line"><span class="string">sum100=0;sum300=0;sum500=0;sum1000=0;\</span></span><br><span class="line"><span class="string">sumo=0;count=0;sum=0</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">&#123; \</span></span><br><span class="line"><span class="string">rt=$8; \</span></span><br><span class="line"><span class="string">if(rt&gt;=0.000) sum=sum+rt; count=count+1; \</span></span><br><span class="line"><span class="string">if(rt&lt;=0.000) sum0=sum0+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.003) sum3=sum3+1 ;\</span></span><br><span class="line"><span class="string">else if(rt&lt;0.01) sum10=sum10+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.03) sum30=sum30+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.05) sum50=sum50+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.1) sum100=sum100+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.3) sum300=sum300+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.5) sum500=sum500+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 1) sum1000=sum1000+1; \</span></span><br><span class="line"><span class="string">else sum=sum+1 ; \</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">END &#123; printf &quot;-------------\n3ms:\t%s \n10ms:\t%s \n30ms:\t%s \n50ms:\t%s \n100ms:\t%s \n300ms:\t%s \n500ms:\t%s \n1000ms:\t%s \n&gt;1s:\t %s\n-------------\navg: %.6f \n&quot; , sum3,sum10,sum30,sum50,sum100,sum300,sum500,sum1000,sumo,sum/count;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"> -------------</span><br><span class="line">3ms:    145037 </span><br><span class="line">10ms:    78811 </span><br><span class="line">30ms:    7032 </span><br><span class="line">50ms:    2172 </span><br><span class="line">100ms:    1219 </span><br><span class="line">300ms:    856 </span><br><span class="line">500ms:    449 </span><br><span class="line">1000ms:118</span><br><span class="line">&gt;1s:    0</span><br><span class="line">-------------</span><br><span class="line">avg: 0.005937 </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>分析每个包的response time</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r rsb2.cap -o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields -e frame.number -e frame.time_epoch \</span><br><span class="line">-e ip.src -e ip.dst -e tcp.stream -e tcp.len \</span><br><span class="line">-e tcp.analysis.initial_rtt -e tcp.time_delta</span><br><span class="line"></span><br><span class="line">14811465269331.308138000100.98.199.3610.25.92.1330200.002276000</span><br><span class="line">14821465269331.30818600010.25.92.13    100.98.199.36361110.000063000</span><br><span class="line">14831465269331.308209000100.98.199.3610.25.92.1349600.004950000</span><br><span class="line">14841465269331.308223000100.98.199.3610.25.92.1351300.000000000</span><br><span class="line">14851465269331.308238000100.98.199.3610.25.92.1332600.055424000</span><br><span class="line">14861465269331.308246000100.98.199.3610.25.92.1351400.000000000</span><br><span class="line">14871465269331.30826100010.25.92.71    10.25.92.134800.000229000</span><br><span class="line">14881465269331.308277000100.98.199.3610.25.92.1325400.055514000</span><br></pre></td></tr></table></figure><ul><li>分析rtt时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcapng -q -z \</span><br><span class="line">io,<span class="built_in">stat</span>,5,<span class="string">&quot;MIN(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span>,\</span><br><span class="line"><span class="string">&quot;MAX(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span>,\</span><br><span class="line"><span class="string">&quot;AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br><span class="line"></span><br><span class="line">========================================================</span><br><span class="line">| IO Statistics                                        |</span><br><span class="line">|                                                      |</span><br><span class="line">| Duration: 50.712225 secs                             |</span><br><span class="line">| Interval:  5 secs                                    |</span><br><span class="line">|                                                      |</span><br><span class="line">| Col 1: MIN(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|     2: MAX(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|     3: AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|------------------------------------------------------|</span><br><span class="line">|          |1         |2         |3         |          |</span><br><span class="line">| Interval |    MIN   |    MAX   |    AVG   |          |</span><br><span class="line">|-------------------------------------------|          |</span><br><span class="line">|  0 &lt;&gt;  5 | 0.000000 | 0.000000 | 0.000000 |          |</span><br><span class="line">|  5 &lt;&gt; 10 | 0.000987 | 0.358817 | 0.293383 |          |</span><br><span class="line">| 10 &lt;&gt; 15 | 0.001537 | 1.125008 | 0.336217 |          |</span><br><span class="line">| 15 &lt;&gt; 20 | 0.001598 | 0.745323 | 0.632126 |          |</span><br><span class="line">| 20 &lt;&gt; 25 | 0.002196 | 1.454920 | 0.584168 |          |</span><br><span class="line">| 25 &lt;&gt; 30 | 0.002674 | 0.892343 | 0.771408 |          |</span><br><span class="line">| 30 &lt;&gt; 35 | 0.001505 | 1.406873 | 1.066937 |          |</span><br><span class="line">| 35 &lt;&gt; 40 | 0.001333 | 1.372204 | 1.267557 |          |</span><br><span class="line">| 40 &lt;&gt; 45 | 0.001366 | 1.410311 | 1.204430 |          |</span><br><span class="line">| 45 &lt;&gt; 50 | 0.001513 | 1.360609 | 1.008420 |          |</span><br><span class="line">| 50 &lt;&gt; Dur| 0.001609 | 1.378431 | 0.956597 |          |</span><br><span class="line">========================================================</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="tshark-抓包"><a href="#tshark-抓包" class="headerlink" title="tshark 抓包"></a>tshark 抓包</h1><p>最后让我们来用伟大的tshark抓包吧，快放弃古老的 tcpdump。</p><p>执行 <code>sudo tshark -Y &#39;ip.addr == 8.8.8.8&#39; --color</code><br>会在终端以wireshark的风格开始抓包。<br><img src="https://img1.kiosk007.top/static/images/tshark/tshark_capture.png" alt></p><p>参考：</p><ul><li><a href="https://plantegg.github.io/2019/06/21/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82%E6%8A%93%E5%8C%85--WireShark%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88tshark/">就是让你懂抓包—WireShark之命令行版tshark</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;玩转TShark（Wireshark的命令行版）&lt;br&gt;wireshark 是一个伟大的网络问题分析工具，当然它也是有终端命令行工具的。&lt;strong&gt;tshark&lt;/strong&gt;就是wireshark的命令行之一。WireShark的功能基本都有，还能组合grep/awk等编程处理分析抓包文件。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式（Design Pattern）</title>
    <link href="http://kiosk007.top/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Pattern%EF%BC%89/"/>
    <id>http://kiosk007.top/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Pattern%EF%BC%89/</id>
    <published>2020-10-24T08:08:00.000Z</published>
    <updated>2020-10-24T08:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><a id="more"></a><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>“设计模式”总的来说有设计原则6个.</p><ul><li><strong>单一职责原则(Single Responsibility Principle, SRP)</strong> : 每个模块或类都应该对软件提供的功能的一部分负责，而这个责任应该完全由类来封装。它的所有服务都应严格遵守这一职责。</li><li><strong>开闭原则(Open Close Principle, OCP)</strong> : 软件中的对象(类、模块、函数等)对扩展是开放的，对修改是封闭的。</li><li><strong>里氏替换原则(Liskov Substitution Principle, LSP)</strong> : 所有使用基类的地方必须能透明地使用其子类的对象</li><li><strong>依赖倒转原则(Dependence Inversion Principle, DIP)</strong> : 是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</li><li><strong>接口隔离原则(Interface Segregation Principle, ISP)</strong> : 客户端不应该依赖它不需要的接口。</li><li><strong>迪米特法则(Law of Demeter, LoD), 最少知识原则(Principle of Least Knowledge)</strong> : 1. 每个对象应该对其他对象尽可能最少的知道 2. 每个对象应该仅和其朋友通信；不和陌生人通信 3. 仅仅和直接朋友通信</li></ul><hr><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 (Singleton)"></a>单例模式 (Singleton)</h2><ul><li><font color="#200000">定义以及使用场景</font></li></ul><ol><li>确保某一个类只有一个实例，而且向整个系统提供这个实例</li><li>确保某个类有且仅有一个对象的场景，避免产生多个对象消耗过多的资源；或者某种类型的对象应该有且只有一个。（如 Logger 实例、Config 实例等）</li></ol><ul><li><font color="#200000">实现单例模式的几个关键点</font></li></ul><ol><li>构造函数不对外开放，一般为private</li><li>通过一个静态方法或者枚举返回单例类对象</li><li>确保单例类的对象有且只有一个，尤其是在多线程环境下</li><li>确保单例类对象在反序列化时不会重新构建对象</li></ol><ul><li><font color="#200000">饥汉模式</font></li></ul><p>直接创建好对象，这样不需要判断为空，同时也是线程安全。唯一的缺点是在导入包的同时会创建该对象，并持续占有在内存中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance Tool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="#200000"> 懒汉模式 (Lazy Loading) </font></li></ul><p>只有需要时才会初始化，在一定程度上节约了资源。如果不加锁的话非线程安全，即在多线程下可能会创建多次对象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private</span></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// public</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">instance = &amp;singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="#200000"> DCL(双重检查)模式 (推荐) </font></li></ul><p>DCL的优点就是资源利用率高，只有第一次执行getInstance才会初始化。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> instance Tool</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第一次判断不加锁，第二次加锁保证线程安全，一旦对象建立后,获取对象就不用加锁了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">            instance = <span class="built_in">new</span>(Tool)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在golang中还可以使用 <code>sync.Once</code> 保证单例。</p><pre><code>var once sync.Oncefunc GetInstance() *Tool &#123;    once.Do(func() &#123;        instance = new(Tool)    &#125;)    return instance&#125;</code></pre><hr><h2 id="工厂方法模式-Factory-method"><a href="#工厂方法模式-Factory-method" class="headerlink" title="工厂方法模式(Factory method)"></a>工厂方法模式(Factory method)</h2><ul><li><font color="#808080"> 定义以及使用场景</font></li></ul><p>创建一个用户创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p><p><strong>使用场景</strong>：</p><ol><li>工厂方法模式通过依赖抽象来达到解耦的效果，并且将实例化的任务交给子类去完成，有非常好的扩展性</li><li>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂方法</li><li>工厂方法模式的应用非常广泛，然而缺点也很明显，就是每次我们为工厂方法添加新的产品时，都需要编写一个新的产品类，所以要根据实际情况来权衡是否要用工厂方法模式</li></ol><p>类似我要造汽车，将造汽车的通用的几个方法定义好，就可以创建一个接口。任何实现了这套造汽车标准的厂商都可以被初始化。并造出一辆汽车。</p><ul><li><font color="#808080"> 举例实现工厂方法模式 </font></li></ul><p>假设我们在做一款小型翻译软件，软件可以将德语、英语、日语都翻译成目标中文，并显示在前端。</p><ul><li><font color="#200000"> 简单工厂模式 </font></li></ul><p>我们会有三个具体的语言翻译结构体，或许以后还有更多，但现在分别是GermanTranslater、EnglishTranslater、JapaneseTranslater，他们都共同实现了一个接口Translator。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻译接口</span></span><br><span class="line"><span class="keyword">type</span> Translator <span class="keyword">interface</span> &#123;</span><br><span class="line">Translate(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//德语翻译类</span></span><br><span class="line"><span class="keyword">type</span> GermanTranslator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*GermanTranslator)</span> <span class="title">Translate</span><span class="params">(words <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;德语&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//英语翻译类</span></span><br><span class="line"><span class="keyword">type</span> EnglishTranslator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*EnglishTranslator)</span> <span class="title">Translate</span><span class="params">(words <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;英语&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在程序入口获取用户输入的文本，并将其翻译</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lan <span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s ,%s&quot;</span>, <span class="string">&quot;以下是可翻译的语言种类，请输入代表数字&quot;</span>, <span class="string">&quot;1：德语、2：英语&quot;</span>)</span><br><span class="line">_, _ = fmt.Scanln(&amp;lan)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入要翻译成中文的文本：&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> inputWords <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;inputWords)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> translator Translator</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的语言种类，实例化不同的翻译类</span></span><br><span class="line"><span class="keyword">switch</span> lan &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">translator = <span class="built_in">new</span>(GermanTranslator)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">translator = <span class="built_in">new</span>(EnglishTranslator)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;no such translator&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(translator.Translate(inputWords))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ol><li>违背了开闭原则，以后还可能有法语、俄语、阿拉伯语等其他翻译器，每一次添加翻译器都要在客户端代码增加对应的switch分支，维护成本高。倘若还有不止一处调用了创建逻辑，还要维护多处代码。</li><li>违背了单一职责原则，客户端处理类的职责应该只是负责接收用户的输入并将其打印，现在还负责翻译类的创建逻辑，导致这个类的职责过多。</li></ol><p>改造</p><pre>// 工厂函数func CreateTranslator(lan int) Translator {    var translator Translator    switch lan {    case 1:        translator = new(GermanTranslator)    case 2:        translator = new(EnglishTranslator)    default:        panic("no such translator")    }    return translator}// 主函数...    fmt.Println("请输入要翻译成中文的文本：")    var inputWords string    fmt.Scanln(&inputWords)    //客户端只关注如何获取翻译类，而不用关注创建翻译类的细节    translator:=CreateTranslator(lan)    fmt.Println(translator.Translate(inputWords))...</pre><hr><h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式(Builder)"></a>建造者模式(Builder)</h2><ul><li><font color="#808080">**定义以及使用场景**</font></li></ul><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>使用场景：</strong></p><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果却又不相同时<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的结果，这个时候使用建造者模式非常合适</li><li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时</li></ol><blockquote><p><strong>Product</strong> 产品类——产品的抽象类<br><strong>Builder</strong> 抽象Builder类，规范产品的组建，一般由子类实现具体的组建过程<br><strong>ConcreteBuilder</strong> 具体的Builder类<br><strong>Director</strong> 统一组装过程</p></blockquote><ul><li><font color="#200000">**举个例子**</font></li></ul><p>我们需要创建汽车，而汽车有轮胎的个数以及车身的颜色可定制，那么用Builder模式可以这样。</p><p>我们的目标是建一辆车</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一辆车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Wheels <span class="keyword">string</span></span><br><span class="line">Chassis <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Builder Complete ...&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Wheels : %s Chassis: %s \n&quot;</span>, c.Wheels, c.Chassis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计出完整的建设规划</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为建造者实现 Builder 接口</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">NewProduct()       <span class="comment">// 创建一个空产品</span></span><br><span class="line">BuildWheels()      <span class="comment">// 建造轮子</span></span><br><span class="line">BuildChassis()    <span class="comment">// 建造底盘</span></span><br><span class="line">GetResult() <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 获取建造好的产品</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照Builder规划一个大型项目构造者CarBuilder, 包含如何具体实现Build</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义汽车建造项目 CarBuilder</span></span><br><span class="line"><span class="keyword">type</span> CarBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">Car *Car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> cb.Car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">NewProduct</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car = <span class="built_in">new</span>(Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">BuildWheels</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car.Wheels = <span class="string">&quot;米其林轮胎&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">BuildChassis</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car.Chassis = <span class="string">&quot;沃尔沃底盘&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面要把具体建造者传入指挥者:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把建造者传入指挥者</span></span><br><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span> &#123;</span><br><span class="line">builder Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">SetBuilder</span><span class="params">(builder Builder)</span></span> &#123;</span><br><span class="line">d.builder = builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建造实施</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">CarBuilderImpl</span><span class="params">()</span> *<span class="title">Car</span></span> &#123;</span><br><span class="line">d.builder.NewProduct()</span><br><span class="line">d.builder.BuildChassis()</span><br><span class="line">d.builder.BuildWheels()</span><br><span class="line"><span class="keyword">return</span> d.builder.GetResult().(*Car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整过程</p><pre>func main() {    // 创建一个指挥者    director := new(Director)    // 创建建造者    builder := new(CarBuilder)    director.SetBuilder(builder)    car := director.CarBuilderImpl()    car.Show()}</pre><hr><h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h2><ul><li><font color="#808080">**定义以及使用场景**</font></li></ul><p>原型模式用于创建重复的对象。当一个类在创建时开销比较大时(比如大量数据准备，数据库连接)，我们可以缓存该对象，当下一次调用时，返回该对象的克隆。</p><p><strong>使用场景</strong></p><ol><li>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗</li><li>原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好滴体现其优点</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝</li></ol><ul><li><font color="#200000">**举个例子**</font></li></ul><p>定义一个原型管理器</p><pre>// 样品（原型）Clone能力约定类type Cloneable interface {    Clone() Cloneable}// 样品（原型）管理器类type PrototypeManager struct {    prototypes map[string]Cloneable}func (that *PrototypeManager) Set( cloneName string, cloneable Cloneable) {    that.prototypes[cloneName] = cloneable}func (that *PrototypeManager) Get(cloneName string) (prototype Cloneable, err error) {    if prototype, ok:=that.prototypes[cloneName]; ok {        return prototype, nil    } else {        return nil, errors.New(fmt.Sprintf("%s 不存在", cloneName))    }}</pre><p>获取一个样品（原型）管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个样品（原型）管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrototypeManager</span> <span class="params">()</span> *<span class="title">PrototypeManager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PrototypeManager&#123;</span><br><span class="line">prototypes:<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Cloneable),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manager *PrototypeManager</span><br></pre></td></tr></table></figure><p>定义一个样品原型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个样品（原型） 实现 Clone 方法 相当于把自己做成了一个样品</span></span><br><span class="line"><span class="keyword">type</span> PT <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(that *PT)</span> <span class="title">Clone</span><span class="params">()</span> <span class="title">Cloneable</span></span> &#123;</span><br><span class="line">temp := *that</span><br><span class="line"><span class="keyword">return</span> &amp;temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><pre>func Test() {    prototypeOne,_ := manager.Get("prototypeOne")    prototypeTwo := prototypeOne.Clone()    prototypeThree := prototypeOne.Clone()    fmt.Printf(" prototypeOne地址:%v \n " +        "prototypeTwo地址: %v \n " +        "prototypeThree地址: %v \n", &prototypeOne, &prototypeTwo, &prototypeThree)}func main() {    manager = NewPrototypeManager()    pt1 := &PT{}    manager.Set("prototypeOne", pt1)    Test()}// 输出 prototypeOne地址:   0xc000010200  prototypeTwo地址:   0xc000010210  prototypeThree地址: 0xc000010220 </pre><hr><h2 id="过滤器模式-Pipe-filter"><a href="#过滤器模式-Pipe-filter" class="headerlink" title="过滤器模式 (Pipe-filter)"></a>过滤器模式 (Pipe-filter)</h2><ul><li><font color="#808080">**定义以及使用场景**</font></li></ul><p>对一数据需要经过顺序的多个过滤器函数处理。</p><p><strong>使用场景</strong></p><ol><li>多个对象可以处理同一请求，其架构适用于 解析，过滤，处理，返回这样的架构，如数据分析。</li><li>在请求处理者不明确的情况下向多个对象中的一个提交一个请求需要动态指定一组对象处理请求<br><img style="height:320px" src="https://img1.kiosk007.top/static/images/design_pattern/pipe_filter.webp"></li></ol><ul><li><font color="#200000">**举个例子**</font></li></ul><p>下面的例子是一个将 字符串“1，2，3” 按逗号切分后，再字符转数字相加的过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1,2,3&quot;</span> --&gt; [SplitFilter] --&gt; [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>] --&gt; [ToIntFilter] --&gt; [1,2,3] -&gt; [SumFilter] --&gt; 6</span><br></pre></td></tr></table></figure><p>首先实现一个 filter 的接口。该接口定义了数据的来源接口，输出接口，该filter接口必须拥有的处理方法, 所有的过滤器必须参考这个接口实现。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request is the input of the filter</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response is the output of the filter</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter interface is the definition of the data processing components</span></span><br><span class="line"><span class="comment">// Pipe-Filter structure</span></span><br><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(data Request) (Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现SplitFilter，SplitFilter必须实现处理器Process。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SplitFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SplitFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">    delimiter <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSplitFilter</span><span class="params">(delimiter <span class="keyword">string</span>)</span> *<span class="title">SplitFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SplitFilter&#123;delimiter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SplitFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    str, ok := data.(<span class="keyword">string</span>) <span class="comment">//检查数据格式/类型，是否可以处理</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, SplitFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    parts := strings.Split(str, sf.delimiter)</span><br><span class="line">    <span class="keyword">return</span> parts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现ToIntFilter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ToIntFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ToIntFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToIntFilter</span><span class="params">()</span> *<span class="title">ToIntFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ToIntFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tif *ToIntFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    parts, ok := data.([]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ToIntFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">        s, err := strconv.Atoi(part)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 SumFilter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SumFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []int&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SumFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSumFilter</span><span class="params">()</span> *<span class="title">SumFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SumFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SumFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    elems, ok := data.([]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, SumFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">        ret += elem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个pipe-line， 目的是为了将所有的filter串起来。循环遍历整个filter并执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewStraightPipeline create a new StraightPipelineWithWallTime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStraightPipeline</span><span class="params">(name <span class="keyword">string</span>, filters ...Filter)</span> *<span class="title">StraightPipeline</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;StraightPipeline&#123;</span><br><span class="line">        Name:    name,</span><br><span class="line">        Filters: &amp;filters,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StraightPipeline is composed of the filters, and the filters are piled as a straigt line.</span></span><br><span class="line"><span class="keyword">type</span> StraightPipeline <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Filters *[]Filter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process is to process the coming data by the pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *StraightPipeline)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> _, filter := <span class="keyword">range</span> *f.Filters &#123;</span><br><span class="line">        ret, err = filter.Process(data)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret, err</span><br><span class="line">        &#125;</span><br><span class="line">        data = ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行</p><pre>func main() {    spliter := pipe_filter.NewSplitFilter(",")    converter := pipe_filter.NewToIntFilter()    sum := pipe_filter.NewSumFilter()    sp := pipe_filter.NewStraightPipeline("p1", spliter, converter, sum)    ret, err := sp.Process("1,2,3")    if err != nil {        log.Fatal(err)    }    if ret != 6 {        log.Fatalf("The expected is 6, but the actual is %d", ret)    }    fmt.Println(ret)}执行结果：6</pre><hr><h2 id="微内核模式-Micro-Kernel"><a href="#微内核模式-Micro-Kernel" class="headerlink" title="微内核模式 (Micro Kernel)"></a>微内核模式 (Micro Kernel)</h2><ul><li><font color="#808080"> 定义以及使用场景 </font></li></ul><p>可以将 微核心架构理解成一个 核心要添加新功能就是加插件。其特点为 易扩展，错误隔离，保持架构的一致性。</p><p><strong>使用场景</strong></p><ol><li>如Nginx，启动前可以加载多个某块功能在应用上，不需要的时候可以剔除，但不影响整个应用的生命周期，适合一个应用的整体架构设计</li></ol><ul><li><font color="#200000"> 举个例子 </font></li></ul><p><strong>Agent</strong>: agent 相当于一个注册中心，所有要Agent去做的事情都注册到Agent里面来，注册进Agent的操作叫做 Collector 。每个Collector有一个名字。用map存储。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Agent <span class="keyword">struct</span> &#123;</span><br><span class="line">    collectors <span class="keyword">map</span>[<span class="keyword">string</span>]Collector  <span class="comment">//  注册进 Agent的collector</span></span><br><span class="line">    evtBuf     <span class="keyword">chan</span> Event            <span class="comment">//  collector 回传给 Agent 的事件</span></span><br><span class="line">    cancel     context.CancelFunc <span class="comment">//  任务取消的方法</span></span><br><span class="line">    ctx        context.Context    <span class="comment">//  任务取消的上下文</span></span><br><span class="line">    state      <span class="keyword">int</span>                <span class="comment">//  Agent 的运行状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Collector</strong>: Collector 是一个执行器，是需要注册进上面的Agent的。每个Collector需要实现 Init，Start，Stop，Destroy 方法，到时候由 Agent 统一进行Init，Start等操作，这里在Init中提到了 EventReceiver，所有的Collector在初始化的时候传入一个事件接收源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Collector <span class="keyword">interface</span> &#123;</span><br><span class="line">    Init(evtReceiver EventReceiver) error    <span class="comment">// Collector 将收集到的数据回传到 Agent （任何实现EventReceiver的对象）</span></span><br><span class="line">    Start(agtCtx context.Context) error      <span class="comment">// 启动所有的Collector（参数为agent中的取消上下文）</span></span><br><span class="line">    Stop() error                              <span class="comment">//   停止</span></span><br><span class="line">    Destroy() error                           <span class="comment">//   摧毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Event</strong>: Agent 实现了 OnEvent 方法，所以Agent 可以作为上面Init 方法的参数，作为事件的接收者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">    Source  <span class="keyword">string</span>   <span class="comment">// 事件源</span></span><br><span class="line">    Content <span class="keyword">string</span>   <span class="comment">// 事件内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EventReceiver <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnEvent(evt Event)  <span class="comment">// 实现OnEvent 既可以作为 EventReciver来接收事件 如下面的 Agent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">OnEvent</span><span class="params">(evt Event)</span></span> &#123;</span><br><span class="line">    agt.evtBuf &lt;- evt  <span class="comment">// Agent 可以来接收事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>开始起一个微内核</strong>: 整个 微内核的架构就是这样了，刚才提到了，Agent会统一对注册进去的Collector进行初始化（Init），启动（Start），停止（Stop）的操作。 所以这里还差一个注册函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">RegisterCollector</span><span class="params">(name <span class="keyword">string</span>, collector Collector)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line">        <span class="keyword">return</span> WrongStateError</span><br><span class="line">    &#125;</span><br><span class="line">    agt.collectors[name] = collector   <span class="comment">// agent map注册</span></span><br><span class="line">    <span class="keyword">return</span> collector.Init(agt)  <span class="comment">// 注册完立即进行Init 操作。且事件接收者为Agent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>启动、停止、摧毁</strong><br>启动会将所有的Controller都拉起来，同理停止和摧毁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> agt.state != Waiting &#123;     <span class="comment">// 状态不对，直接报错</span></span><br><span class="line">        <span class="keyword">return</span> WrongStateError</span><br><span class="line">    &#125;</span><br><span class="line">    agt.state = Running    <span class="comment">// 启动了，更改状态</span></span><br><span class="line">    agt.ctx, agt.cancel = context.WithCancel(context.Background())  <span class="comment">// 来一个取消的上下文和取消函数</span></span><br><span class="line">    <span class="keyword">go</span> agt.EventProcessGroutine()    <span class="comment">// 收集事件 (具体业务了)</span></span><br><span class="line">    <span class="keyword">return</span> agt.startCollectors()    <span class="comment">//  启动所有的Collector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的收集具体的业务事件。这里的事件是由各个 collector 上报的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">EventProcessGroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> evtSeg [<span class="number">10</span>]Event</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> evtSeg[i] = &lt;-agt.evtBuf:   <span class="comment">// 将 collector 收集的事件放到 evtBuf 中</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-agt.ctx.Done():           <span class="comment">// 执行上下文完成，结束 </span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(evtSeg)   <span class="comment">// 当 collector 收集的事件满 10 个，打印一次。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Agent 来拉起所有的 Collectors</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">startCollectors</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">var</span> errs CollectorsError</span><br><span class="line">    <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, collector Collector, ctx context.Context)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">            &#125;()</span><br><span class="line">            err = collector.Start(ctx)</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                errs.CollectorErrors = <span class="built_in">append</span>(errs.CollectorErrors,</span><br><span class="line">                    errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(name, collector, agt.ctx)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorErrors) == <span class="number">0</span> &#123;     <span class="comment">// 这里需要判断有没有错误，确定没有错误，返回nil。否则其实返回的也不是nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模拟</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DemoCollector <span class="keyword">struct</span> &#123;      <span class="comment">// 示例 Collector</span></span><br><span class="line">    evtReceiver microkernel.EventReceiver   <span class="comment">// 事件发给这里</span></span><br><span class="line">    stopChan    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;    <span class="comment">// 用来停止该Collector</span></span><br><span class="line">    name        <span class="keyword">string</span>    <span class="comment">// Collector 名字</span></span><br><span class="line">    content     <span class="keyword">string</span>    <span class="comment">// Collector 的要做的内容（假设，这个根据业务场景，都不一定是string）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCollect</span><span class="params">(name <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> *<span class="title">DemoCollector</span></span> &#123;   <span class="comment">// 创建一个 Collect</span></span><br><span class="line">    <span class="keyword">return</span> &amp;DemoCollector&#123;</span><br><span class="line">        stopChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        name:     name,</span><br><span class="line">        content:  content,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Init</span><span class="params">(evtReceiver microkernel.EventReceiver)</span> <span class="title">error</span></span> &#123;   <span class="comment">// 初始化一个这个 Collect</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;initialize collector&quot;</span>, c.name)</span><br><span class="line">    c.evtReceiver = evtReceiver    <span class="comment">// Agent 作为数据的上报源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Start</span><span class="params">(agtCtx context.Context)</span> <span class="title">error</span></span> &#123;   <span class="comment">// 拉起一个 Collect</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;start collector&quot;</span>, c.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;    <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-agtCtx.Done():      <span class="comment">// 收到 Done 了</span></span><br><span class="line">            c.stopChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="comment">// 停掉该 Collect （Stop 方法那里会等 stopChan 这个信号）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">            c.evtReceiver.OnEvent(microkernel.Event&#123;c.name, c.content&#125;) <span class="comment">// 向 Agent 上报事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;stop collector&quot;</span>, c.name)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-c.stopChan:   <span class="comment">// 收到停止信号了，停掉</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// 一般停完再做点啥，在这做些善后吧</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;failed to stop for timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Destroy</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(c.name, <span class="string">&quot;released resources.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error = <span class="literal">nil</span></span><br><span class="line">    agt := microkernel.NewAgent(<span class="number">100</span>)</span><br><span class="line">    c1 := NewCollect(<span class="string">&quot;c1&quot;</span>, <span class="string">&quot;1a&quot;</span>)</span><br><span class="line">    c2 := NewCollect(<span class="string">&quot;c2&quot;</span>, <span class="string">&quot;2b&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err = agt.RegisterCollector(<span class="string">&quot;c1&quot;</span>, c1);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = agt.RegisterCollector(<span class="string">&quot;c2&quot;</span>, c2);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = agt.Start();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err = agt.Stop();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ERR:</span><br><span class="line">    fmt.Println(<span class="string">&quot;An Error Occur :&quot;</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 (Command)"></a>命令模式 (Command)</h2><ul><li><font color="#808080">**定义以及使用场景**</font></li></ul><p>它可将请求或简单操作转换为一个对象。此类转换让你能够延迟进行或远程执行请求， 还可将其放入队列中。</p><p><strong>使用场景</strong></p><ol><li>需要抽象出待执行的行动，然后以参数的形式提供出来——类似于过程设计中的回调机制，而命令模式正是回调机制的一个面向对象的代替品。</li><li>在不同的时刻指定、排列和执行请求，一个命令对象可以有与初始请求无关的生存期</li><li>需要支持事务操作</li></ol><ul><li><font color="#200000">**举个例子**</font></li></ul><p><strong>电视遥控器</strong>:</p><p>遥控器从实现 ON 命令对象并以电视机作为接收者入手。 当在此命令上调用 execute执行方法时， 方法会调用 TV.on打开电视函数。 最后的工作是定义请求者： 这里实际上有两个请求者： 遥控器和电视机。 两者都将嵌入 ON 命令对象。</p><ul><li>实现 command 和 device </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command define</span></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">interface</span> &#123;</span><br><span class="line">execute()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> button <span class="keyword">struct</span> &#123;</span><br><span class="line">command command</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *button)</span> <span class="title">press</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.command.execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// device define ， 设备可执行的命令</span></span><br><span class="line"><span class="keyword">type</span> device <span class="keyword">interface</span> &#123;</span><br><span class="line">on()</span><br><span class="line">off()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现要执行命令</span></span><br><span class="line"><span class="keyword">type</span> onCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">device device</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *onCommand)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.device.on()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> offCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">device device</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *offCommand)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.device.off()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建命令的发出者和执行者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令的执行者</span></span><br><span class="line"><span class="keyword">type</span> tv <span class="keyword">struct</span> &#123;</span><br><span class="line">isRunning <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tv)</span> <span class="title">on</span><span class="params">()</span></span> &#123;</span><br><span class="line">t.isRunning = <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Turning tv on&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tv)</span> <span class="title">off</span><span class="params">()</span></span> &#123;</span><br><span class="line">t.isRunning = <span class="literal">false</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Turning tv off&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行者就是按下按钮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tv := &amp;tv&#123;&#125;</span><br><span class="line"></span><br><span class="line">onButton := &amp;button&#123;</span><br><span class="line">command: &amp;onCommand&#123; device: tv &#125;,</span><br><span class="line">&#125;</span><br><span class="line">onButton.press()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
    <category term="design pattern" scheme="http://kiosk007.top/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>算法 - (二叉树)</title>
    <link href="http://kiosk007.top/2020/10/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://kiosk007.top/2020/10/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-10-17T02:44:00.000Z</published>
    <updated>2020-10-17T02:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。以下会以几道 LeetCode 巩固自己的基础</p><a id="more"></a><p><a href="https://leetcode-cn.com/leetbook/detail/data-structure-binary-tree/?utm_campaign=leetbook&amp;utm_medium=%E9%A2%98%E5%BA%93&amp;utm_source=leetcode-cn&amp;utm_term=%E9%A2%98%E5%BA%93%E9%A1%B5%E6%A0%87%E7%AD%BE&amp;gio_link_id=q9A0Bxko">leetcode 树</a></p><h1 id="生成一个二叉树"><a href="#生成一个二叉树" class="headerlink" title="生成一个二叉树"></a>生成一个二叉树</h1><h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">Val int</span><br><span class="line">Left *TreeNode</span><br><span class="line">Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的工厂模式"><a href="#二叉树的工厂模式" class="headerlink" title="二叉树的工厂模式"></a>二叉树的工厂模式</h2><ul><li>创建节点、打印节点、设置节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">Print</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Print(node.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">SetVal</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">node.Val = val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">Add</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val &lt; node.Val &#123;</span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Left = CreateNode(val)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">node.Left.Add(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Right = CreateNode(val)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">node.Right.Add(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/">动画演示</a><br><img src="https://img1.kiosk007.top/static/images/leetcode/tree_1.jpg"></p><ul><li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p></li><li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p></li><li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = <span class="built_in">print</span> r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：(中序排列结果为有序数组)</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;<span class="built_in">print</span> r-&gt;inOrder(r-&gt;right) </span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;<span class="built_in">print</span> r</span><br></pre></td></tr></table></figure><h2 id="LC二叉树-前序遍历"><a href="#LC二叉树-前序遍历" class="headerlink" title="LC二叉树 前序遍历"></a>LC二叉树 前序遍历</h2><p>例题链接：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span> <span class="title">preorderTraversal</span><span class="params">(f <span class="keyword">func</span>(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f(root)</span><br><span class="line">root.Left.preorderTraversal(f)</span><br><span class="line">root.Right.preorderTraversal(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line">list = <span class="built_in">append</span>(list, root.Val)</span><br><span class="line">resLeft := preorderTraversal(root.Left)</span><br><span class="line">resRight := preorderTraversal(root.Right)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(list, resLeft...), resRight...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 channel 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TraversalTreeWithChannel</span><span class="params">(rootNode *TreeNode)</span> <span class="params">(out <span class="keyword">chan</span> *TreeNode)</span></span> &#123;</span><br><span class="line">out = <span class="built_in">make</span>(<span class="keyword">chan</span> *TreeNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rootNode.preorderTraversal(<span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">out &lt;- node</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">treeRoot := CreateNode(<span class="number">0</span>)</span><br><span class="line">treeRoot.Add(<span class="number">1</span>)</span><br><span class="line">treeRoot.Add(<span class="number">2</span>)</span><br><span class="line">fmt.Println(preorderTraversal(treeRoot))</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line">treeRoot.preorderTraversal(<span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">cnt++</span><br><span class="line">node.Print()</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;All Count: &quot;</span>, cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过通道的方式遍历二叉树</span></span><br><span class="line">out := TraversalTreeWithChannel(treeRoot)</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> out &#123;</span><br><span class="line">c.Print()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树的层次遍历（BFS广度优先遍历）"><a href="#二叉树的层次遍历（BFS广度优先遍历）" class="headerlink" title="二叉树的层次遍历（BFS广度优先遍历）"></a>二叉树的层次遍历（BFS广度优先遍历）</h2><p>例题链接：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/</a></p><p>题解：<br>创建一个先进先出的队列，从最顶层的节点依次加入节点，并遍历该层，每遍历该层的一个节点，把该层的子节点加入的队列的后面，这样就可以实现层次遍历，如果要蛇形遍历也是一个道理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> level [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line">queue := list.New()  <span class="comment">// 一个先进先出的队列,所有的元素需要依次进队</span></span><br><span class="line">queue.PushFront(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> curLevel []<span class="keyword">int</span></span><br><span class="line">curLevelLength := queue.Len()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; curLevelLength; i++ &#123;</span><br><span class="line">node := queue.Remove(queue.Back()).(*TreeNode)</span><br><span class="line">curLevel = <span class="built_in">append</span>(curLevel, node.Val)</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;  <span class="comment">// 下一层遍历做准备, 把当前节点的子节点都加进去</span></span><br><span class="line">queue.PushFront(node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue.PushFront(node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">level = <span class="built_in">append</span>(level, curLevel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="剑指Offer-判断平衡二叉树"><a href="#剑指Offer-判断平衡二叉树" class="headerlink" title="剑指Offer - 判断平衡二叉树"></a>剑指Offer - 判断平衡二叉树</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a></li><li>思路：平衡二叉树的判断方式即某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br>而一个数的高度为左子树和右子树中最高的。即只要比对左右子树的高度即可判断是否为平衡二叉树。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTreeDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(getTreeDepth(root.Left)), <span class="keyword">float64</span>(getTreeDepth(root.Right)))) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">left := getTreeDepth(root.Left)</span><br><span class="line">right := getTreeDepth(root.Right)</span><br><span class="line">    <span class="comment">// 判断左子树和右子树的绝对差值小于1 且 左子树 和 右子树 也满足平衡</span></span><br><span class="line"><span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(left) - <span class="keyword">float64</span>(right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-235-二叉搜索树的公共祖先"><a href="#No-235-二叉搜索树的公共祖先" class="headerlink" title="No.235 二叉搜索树的公共祖先"></a>No.235 二叉搜索树的公共祖先</h2><ul><li><p>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p></li><li><p>思路：</p><ul><li>通过搜索的方式查找节点，并记录所有节点，查到2个点之后，比对两个查找链路上的最后一个公共节点即可</li><li>判断P,Q 两个节点如果在都小于root，则公共节点一定是在左子树，反之同理。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || root == q || root == p &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.Val &lt;= root.Val &amp;&amp; q.Val &lt;= root.Val &#123;   <span class="comment">//p和q都小于root,公共祖先节点一定在root的左边</span></span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root.Left,p,q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.Val &gt;= root.Val &amp;&amp; q.Val &gt;= root.Val &#123;   <span class="comment">//p和q都大于root,公共祖先节点一定在root的右边</span></span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root.Right,p,q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-112-路径总和"><a href="#No-112-路径总和" class="headerlink" title="No.112 路径总和"></a>No.112 路径总和</h2><ul><li>链接：<a href="https://leetcode-cn.com/submissions/detail/23501756/">https://leetcode-cn.com/submissions/detail/23501756/</a></li><li>思路：这种类似与 二叉树的深度遍历DFS肯定是要用到递归了。。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sum == root.Val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.Left, sum-root.Val) || hasPathSum(root.Right, sum-root.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。以下会以几道 LeetCode 巩固自己的基础&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>算法 - (数组、链表)</title>
    <link href="http://kiosk007.top/2020/09/26/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/"/>
    <id>http://kiosk007.top/2020/09/26/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</id>
    <published>2020-09-26T02:58:00.000Z</published>
    <updated>2020-09-26T02:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组、链表是编程语言中最常见的数据结构，也是最基础的数据结构。以下会以几道 LeetCode 巩固自己的基础</p><a id="more"></a><h1 id="结构对比"><a href="#结构对比" class="headerlink" title="结构对比"></a>结构对比</h1><p>数组和链表各有各的优势，比如数组的随机插入和删除都是O(n)的，可谓是很低效了。但是数组的查找是是O(1)，直接指定下标即可找到对应的元素。而链表必须遍历，也就是想要查找你一个元素的时间复杂度是 O(n)。所以数组和链表各有各的优势，互相补充。</p><div class="table-container"><table><thead><tr><th>数据结构</th><th style="text-align:right">操作</th><th style="text-align:center">时间复杂度</th></tr></thead><tbody><tr><td>数组</td><td style="text-align:right">prepend</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">append</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">lookup</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">insert</td><td style="text-align:center">O(n)</td></tr><tr><td></td><td style="text-align:right">delete</td><td style="text-align:center">O(n)</td></tr><tr><td></td><td style="text-align:right">—</td><td style="text-align:center">—</td></tr><tr><td>链表</td><td style="text-align:right">prepend</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">append</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">lookup</td><td style="text-align:center">O(n)</td></tr><tr><td></td><td style="text-align:right">insert</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">delete</td><td style="text-align:center">O(1)</td></tr></tbody></table></div><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">int</span></span><br><span class="line">b = <span class="built_in">append</span>(c, <span class="number">11</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, a...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// make( []Type, size, cap )</span></span><br><span class="line"><span class="comment">// 其中 Type 是指切片的元素类型，</span></span><br><span class="line"><span class="comment">// size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，</span></span><br><span class="line"><span class="comment">// 这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)  </span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义单链表</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;     </span><br><span class="line">Val <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *ListNode)</span> <span class="title">add</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ln == <span class="literal">nil</span> &#123;</span><br><span class="line">ln = &amp;ListNode&#123;Val: v,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ln.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">ln = ln.Next</span><br><span class="line">&#125;</span><br><span class="line">ln.Next = &amp;ListNode&#123;Val: v,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *ListNode)</span> <span class="title">traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ln != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>,ln.Val)</span><br><span class="line">ln = ln.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="No-1-两数之和"><a href="#No-1-两数之和" class="headerlink" title="No.1 两数之和"></a>No.1 两数之和</h3><ul><li>链接：<a href="https://leetcode-cn.com/problems/two-sum/submissions/">https://leetcode-cn.com/problems/two-sum/submissions/</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line"><span class="keyword">if</span> index, ok := tmp[target-nums[i]]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;index,i&#125;</span><br><span class="line">&#125;</span><br><span class="line">tmp[nums[i]] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="No-26-删除排序数组中的重复项"><a href="#No-26-删除排序数组中的重复项" class="headerlink" title="No.26 删除排序数组中的重复项"></a>No.26 删除排序数组中的重复项</h3><ul><li>链接: <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></li><li>思路1：<strong>双指针法</strong> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/26-shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xia-89/">题解动画</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">j++</span><br><span class="line">nums[j] = nums[i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路2： <strong>*旋转数组法</strong> 旋转数组应该是我比较喜欢的一种方式，比较简单，那就是数组翻转2次，可以将首位数转到末尾曲，重复项判断刚好使用这种方式，<font style="color:red">对于移动数组类的题是比较通吃的一个方法</font>问题就是时间复杂度比较大<br><a href="https://img1.kiosk007.top/static">https://img1.kiosk007.top/static</a><img src="/images/leetcode/list_1.jpeg" style="height:300px"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversal</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; length &gt; <span class="number">1</span> &amp;&amp; i &lt; length/<span class="number">2</span>; i ++ &#123;</span><br><span class="line">nums[i],nums[length<span class="number">-1</span>-i] = nums[length<span class="number">-1</span>-i],nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i ++ &#123;</span><br><span class="line"><span class="keyword">if</span> i + <span class="number">1</span> &lt; length &amp;&amp; nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">reversal(nums[i+<span class="number">1</span>:length])</span><br><span class="line">reversal(nums[i+<span class="number">1</span>:length<span class="number">-1</span>])</span><br><span class="line">length = length - <span class="number">1</span></span><br><span class="line">i = i - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h3 id="No-21-合并两个链表"><a href="#No-21-合并两个链表" class="headerlink" title="No.21 合并两个链表"></a>No.21 合并两个链表</h3><ul><li>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/">https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/</a></li><li>思路1: <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">迭代法</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">tmp := &amp;ListNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">prev := tmp</span><br><span class="line"><span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt; l2.Val&#123;</span><br><span class="line">prev.Next = l1</span><br><span class="line">prev = prev.Next</span><br><span class="line"></span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">prev.Next = l2</span><br><span class="line">prev = prev.Next</span><br><span class="line"></span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">prev.Next = l2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">prev.Next = l1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-83-删除排序链表重复项"><a href="#No-83-删除排序链表重复项" class="headerlink" title="No.83 删除排序链表重复项"></a>No.83 删除排序链表重复项</h2></li><li>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></li><li>思路1：题解感觉和我差不太多，我的思路是先把重复项移到尾端，然后cur 指针指向重复项的尾端就好了。但不知道为啥 8ms 打败 7.3% 。理论就是 O(N) 啊。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur := &amp;ListNode&#123;&#125; </span><br><span class="line">tmp := cur   <span class="comment">// 记录链表头</span></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> head.Next != <span class="literal">nil</span> &amp;&amp; head.Val == head.Next.Val &#123;</span><br><span class="line"> head = head.Next</span><br><span class="line">&#125;</span><br><span class="line">cur.Next = head</span><br><span class="line">cur = cur.Next</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-141-环形链表"><a href="#No-141-环形链表" class="headerlink" title="No.141 环形链表"></a>No.141 环形链表</h2></li><li>链接: <a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></li><li>思路1：这道题思路非常简单，就是快慢指针，慢指针每次前进一步，快指针每次前进两步。如果存在环快指针一定会追上慢指针，<strong>问题就是边界条件太多，需要仔细判断。</strong></li><li>思路2：hash表存已有的数据做对比，这个最简单，不演示啦~</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow := head</span><br><span class="line">fast := head.Next</span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line"><span class="keyword">if</span> slow == fast &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-206-反转链表"><a href="#No-206-反转链表" class="headerlink" title="No.206 反转链表"></a>No.206 反转链表</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></li><li>思路1：<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/206-fan-zhuan-lian-biao-shuang-zhi-zhen-fa-di-gui-/">双指针</a>  本质还是遍历 head， 上面的<code>next := head.Next</code>和下面的<code>head = next</code> 就是为了遍历， 中间的三行是 当前head的节点的下一个指向之前，cur即为当前head节点，cur 成为历史 prev</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prev *ListNode = <span class="literal">nil</span></span><br><span class="line">cur := prev</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">next := head.Next  <span class="comment">// 存下一个</span></span><br><span class="line"></span><br><span class="line">head.Next = prev <span class="comment">// haed 的Next指向 prev</span></span><br><span class="line">cur = head       <span class="comment">// cur 就是 head</span></span><br><span class="line">prev = cur <span class="comment">// cur 成为 prev</span></span><br><span class="line"></span><br><span class="line">head = next   <span class="comment">// head 前进</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个-LRU-缓存"><a href="#实现一个-LRU-缓存" class="headerlink" title="实现一个 LRU 缓存"></a>实现一个 LRU 缓存</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lru</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/list&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MemoryOverFlow<span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">MemorySizeError<span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">NotFoundObject<span class="keyword">int</span> = <span class="number">11</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lruErrorName = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">MemoryOverFlow:      <span class="string">&quot;MemoryOverFlow&quot;</span>,</span><br><span class="line">MemorySizeError:  <span class="string">&quot;MemorySizeError&quot;</span>,</span><br><span class="line">NotFoundObject:  <span class="string">&quot;NotFoundObject&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录存储数据的大小</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">Len() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储的对象</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key <span class="keyword">string</span></span><br><span class="line">value Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">maxBytes <span class="keyword">int64</span>        <span class="comment">// 最大使用内存</span></span><br><span class="line">nBytes  <span class="keyword">int64</span>        <span class="comment">// 当前已使用内存</span></span><br><span class="line">ll *list.List         <span class="comment">// 链表存储淘汰关系</span></span><br><span class="line">cache  <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element   <span class="comment">//节点放到字典中，加速查找</span></span><br><span class="line">OnEvicted  <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value Value)</span>   //某条记录被删除时候的回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateLRUCache</span><span class="params">(maxByte <span class="keyword">int64</span>,evicted <span class="keyword">func</span>(<span class="keyword">string</span>,Value)</span>) *<span class="title">Cache</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">maxBytes:  maxByte,</span><br><span class="line">nBytes:    <span class="number">0</span>,</span><br><span class="line">ll:        <span class="built_in">new</span>(list.List),</span><br><span class="line">cache:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element),</span><br><span class="line">OnEvicted: evicted,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value Value,err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class="line">c.ll.MoveToFront(ele)</span><br><span class="line"><span class="keyword">return</span> ele.Value.(*entry).value, <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(lruErrorName[NotFoundObject])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">string</span>, value Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断是否可以加入(太大会把所有缓存冲掉)</span></span><br><span class="line"><span class="keyword">if</span> c.isOutOfMaxMemory(value.Len()) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(lruErrorName[MemoryOverFlow])   <span class="comment">// 内存不足以添加该缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断缓存中已有该键, 更新</span></span><br><span class="line"><span class="keyword">if</span> v, ok := c.cache[key]; ok &#123;</span><br><span class="line">oldValue := v.Value.(*entry)</span><br><span class="line"><span class="comment">// 可以加入,将该键移动到队头</span></span><br><span class="line">c.ll.MoveToFront(v)</span><br><span class="line">c.cache[oldValue.key] = &amp;list.Element&#123;Value: &amp;entry&#123;key,value&#125;&#125;</span><br><span class="line">c.nBytes = c.nBytes - oldValue.value.Len() + value.Len()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有该键,第一次添加</span></span><br><span class="line">ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">c.cache[key] = ele</span><br><span class="line">c.nBytes = c.nBytes + value.Len()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若内存不够，需要循环删除掉最老的</span></span><br><span class="line"><span class="keyword">for</span> c.maxBytes != <span class="number">0</span> &amp;&amp; c.maxBytes &lt; c.nBytes &#123;</span><br><span class="line"><span class="keyword">if</span> err := c.RemoveOldest(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">oldest := c.ll.Back()</span><br><span class="line"><span class="keyword">if</span> oldest != <span class="literal">nil</span> &#123;</span><br><span class="line">oldestEntry := oldest.Value.(*entry)</span><br><span class="line">c.ll.Remove(oldest) <span class="comment">// 删除链表节点</span></span><br><span class="line">c.nBytes = c.nBytes - oldestEntry.value.Len() <span class="comment">// 删除字节长度</span></span><br><span class="line"><span class="built_in">delete</span>(c.cache, oldestEntry.key)  <span class="comment">// 删除字典</span></span><br><span class="line"><span class="keyword">if</span> c.nBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(lruErrorName[MemorySizeError])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">c.OnEvicted(oldestEntry.key, oldestEntry.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(c.ll.Len())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">isOutOfMaxMemory</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> size &gt; c.maxBytes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GeeByte <span class="keyword">struct</span> &#123;</span><br><span class="line">Value []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GeeByte)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(g.Value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLruCache</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">lruObject := lru.CreateLRUCache(<span class="number">20</span>, <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value lru.Value)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 被删除了, 释放了 %d 字节的空间\n&quot;</span>, key, value.Len())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">_ = lruObject.Add(<span class="string">&quot;key1&quot;</span>, GeeByte&#123;[]<span class="keyword">byte</span>(<span class="string">&quot;Hello, Golang&quot;</span>)&#125;)</span><br><span class="line">_ = lruObject.Add(<span class="string">&quot;key2&quot;</span>, GeeByte&#123;[]<span class="keyword">byte</span>(<span class="string">&quot;Hello, ByteDance&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value, err := lruObject.Get(<span class="string">&quot;key2&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>,value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组、链表是编程语言中最常见的数据结构，也是最基础的数据结构。以下会以几道 LeetCode 巩固自己的基础&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>systemd 基本概念</title>
    <link href="http://kiosk007.top/2020/09/20/systemd-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://kiosk007.top/2020/09/20/systemd-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-09-20T15:29:00.000Z</published>
    <updated>2020-09-20T15:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>systemd 是 PID 为1的一个程序，负责初始化系统。所有的程序不是systemd直接启动就是由systemd的子系统启动。systemd是内核直接启动，所以信号9(KILL)对systemd也无效。</p><p>systemd 使用Linux控制组跟踪进程，维护安装和自动挂载点，并实现基于事务性依赖关系的详尽服务控制逻辑。其他部分包括日志记录守护程序，用于控制基本系统配置的实用程序，例如主机名，日期，区域设置，维护已登录用户和正在运行的容器和虚拟机的列表，系统帐户，运行时目录和设置，以及用于管理简单网络的守护程序配置，网络时间同步，日志转发和名称解析。</p><a id="more"></a><p><img src="https://img1.kiosk007.top/static/images/systemd/systemd.png" style="height:400px"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="对比-systemV"><a href="#对比-systemV" class="headerlink" title="对比 systemV"></a>对比 systemV</h2><p>从CentOS 7.x 以后，Red Hat 系列的 distribution 放弃沿用多年的System V 开机启动服务的流程. systemd 也是当年我从6.x 到 7.x 过度时感觉到最大的变化了，直到今天，MySQL的启动脚本还是可以通过 <code>service mysqld start</code> 启动的，但是升级到 CentOS 7.x 之后，就变成了 <code>systemd start mysqld</code> 了。当然还有经典的<code>init 0</code>的关机指令。</p><p>相比于 initd，systemd有以下几个大的进步。</p><ul><li><font color="blue">并行启动</font>：旧的 init 启动脚本是一项一项任务依序启动的模式，因此不相依的服务也是得要一个一个的等待。systemd可以让所有的服务同时启动，因此你会发现到，系统启动的速度变快了！</li><li><font color="blue">一经要求就回应的on-demand启动方式</font>：systemd全部就是仅有一只systemd服务搭配systemctl指令来处理，无须其他额外的指令来支援。不像systemV还要init, chkconfig, service…等等指令。此外， systemd由于常驻记忆体，因此任何要求(on-demand)都可以立即处理后续的daemon启动的任务。</li><li><font color="blue">服务相依性的自我检查</font>：由于systemd可以自订服务相依性的检查，因此如果B服务是架构在A服务上面启动的，那当你在没有启动A服务的情况下仅手动启动B服务时， systemd会自动帮你启动A服务。</li><li><font color="blue">依daemon功能分类</font>：systemd下管理的服务非常多，为了厘清所有服务的功能，因此，首先systemd先定义所有的服务为一个服务单位(unit)，并将该unit归类到不同的服务类型(type)去。旧的init仅分为stand alone与super daemon，systemd将服务单位(unit)区分为service, socket, target, path, snapshot, timer等多种不同的类型(type)，方便管理员的分类与记忆。</li><li><font color="blue">将多个daemons集合成为一个群组</font>：如同systemV的init里头有个runlevel的特色，systemd亦将许多的功能集合成为一个所谓的target项目，这个项目主要在设计操作环境的建置，所以是集合了许多的daemons，亦即是执行某个target就是执行好多个daemon的意思！</li><li><font color="blue">向下相容旧有的init服务脚本</font>：基本上， systemd是可以相容于init的启动脚本的，因此，旧的init启动脚本也能够透过systemd来管理，这也是为什么到现在还可以使用<code>serivce mysqld start</code> 这样命令的原因。</li></ul><blockquote><p><strong>综上可知，systemd 已经足够强大，可以管理一个进程的生命周期，如果是自己写的一套代码完全可以交给systemd 来维护呀，以前公司使用 <a href="https://ruby-china.org/topics/21354">god</a>(进程监控守护工具) 来管理服务，god 提供了服务启动、服务宕机自动拉起、环境变量和chroot、服务资源限制、定时任务等，但是systemd 的出现已经足够替代 god 这样的第三方服务，systemd 已经足够实现服务托管。</strong></p></blockquote><p><img src="https://img1.kiosk007.top/static/images/systemd/systemd_components2.png" style="height:400px"></p><h2 id="systemd-的配置文件"><a href="#systemd-的配置文件" class="headerlink" title="systemd 的配置文件"></a>systemd 的配置文件</h2><p>基本上， systemd 将过去所谓的daemon 执行脚本通通称为一个服务单位(unit)，而每种服务单位依据功能来区分时，就分类为不同的类型(type)。在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p><ul><li><font color="blue">automount</font>：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li><li><font color="blue">device</font>：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li><li><font color="blue">mount</font>：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li><li><font color="blue">path</font>：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li><li><font color="blue">scope</font>：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li><li><font color="blue">service</font>：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li><li><font color="blue">slice</font>：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li><li><font color="blue">snapshot</font>：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li><li><font color="blue">socket</font>：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li><li><font color="blue">swap</font>：定义一个用户做虚拟内存的交换分区</li><li><font color="blue">target</font>：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式。其实是一群unit 的集合，例如上面表格中谈到的multi-user.target 其实就是一堆服务的集合～也就是说， 选择执行multi-user.target 就是执行一堆其他.service 或/及.socket 之类的服务就是了！</li><li><font color="blue">timer</font>：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li></ul><p><strong>文件目录</strong><br>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p><ul><li><font color="blue">/etc/systemd/system/</font>：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能。</li><li><font color="blue">/run/systemd/system/</font>：系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li><font color="blue">/usr/lib/systemd/system/</font>：每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li></ul><p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p><h1 id="Systemd-Service-Unit"><a href="#Systemd-Service-Unit" class="headerlink" title="Systemd Service Unit"></a>Systemd Service Unit</h1><h2 id="Unit-文件结构"><a href="#Unit-文件结构" class="headerlink" title="Unit 文件结构"></a>Unit 文件结构</h2><p>一般可以使用 <font style="color=blue">systemctl cat networking</font> 查看 Unit 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Hello World</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker <span class="built_in">kill</span> busybox1</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm busybox1</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c <span class="string">&quot;while true; do echo Hello World; sleep 1; done&quot;</span></span><br><span class="line">ExecStop=<span class="string">&quot;/usr/bin/docker stop busybox1&quot;</span></span><br><span class="line">ExecStopPost=<span class="string">&quot;/usr/bin/docker rm busybox1&quot;</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><strong><font style="color:red"><code>[Unit]</code></font></strong> 区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p><blockquote><ul><li><code>Description</code>：简短描述</li><li><code>Documentation</code>：文档地址</li><li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li><li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li><li><code>BindsTo</code>：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li><li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li><li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li><li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li><li><code>Condition</code>：当前 Unit 运行必须满足的条件，否则不会运行</li><li><code>Assert</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li></ul></blockquote><p><strong><font style="color:red"><code>[Service]</code></font></strong> 区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><blockquote><ul><li><code>Type</code>：定义启动时的进程行为。它有以下几种值。</li><li><code>Type=simple</code>：默认值，执行ExecStart指定的命令，启动主进程</li><li><code>Type=forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li><li><code>Type=oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li><li><code>Type=dbus</code>：当前服务通过D-Bus启动</li><li><code>Type=notify</code>：当前服务启动完毕，会通知Systemd，再继续往下执行</li><li><code>Type=idle</code>：若有其他任务执行完毕，当前服务才会运行</li><li><code>ExecStart</code>：启动当前服务的命令</li><li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li><li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li><li><code>ExecReload</code>：重启当前服务时执行的命令</li><li><code>ExecStop</code>：停止当前服务时执行的命令</li><li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li><li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li><li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li><li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li><li><code>Environment</code>：指定环境变量</li><li><code>EnvironmentFile</code>：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li><li><code>Nice</code>：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li><li><code>WorkingDirectory</code>：指定服务的工作目录</li><li><code>RootDirectory</code>：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li><li><code>User</code>：指定运行服务的用户</li><li><code>Group</code>：指定运行服务的用户组</li><li><code>MountFlags</code>：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private<ul><li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li><li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li><li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上</li></ul></li><li><code>LimitCPU</code> / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li></ul></blockquote><p><strong><font style="color:red"><code>[Install]</code></font></strong> 通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><blockquote><ul><li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</li><li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</li><li><code>Alias</code>：当前 Unit 可用于启动的别名</li><li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li></ul></blockquote><p><strong>Unit 配置文件的完整字段清单，请参考 <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">官方文档</a>。</strong></p><h2 id="Unit-管理"><a href="#Unit-管理" class="headerlink" title="Unit 管理"></a>Unit 管理</h2><p><font style="color:blue">systemctl list-units </font>命令可以查看当前系统的所有 Unit 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出正在运行的 Unit</span></span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有没有运行的 Unit</span></span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有加载失败的 Unit</span></span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看开机自启动的 service</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span> service |grep enabled</span><br></pre></td></tr></table></figure></p><h1 id="Systemd-Target"><a href="#Systemd-Target" class="headerlink" title="Systemd Target"></a>Systemd Target</h1><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p><p>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的所有 Target</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动时的默认 Target</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动时的默认 Target</span></span><br><span class="line">$ sudo systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span></span><br><span class="line"><span class="comment"># systemctl isolate 命令改变这种行为，</span></span><br><span class="line"><span class="comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure><p>Target 与 传统 RunLevel 的对应关系如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Traditional runlevel      New target name     Symbolically linked to...</span><br><span class="line"></span><br><span class="line">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</span><br><span class="line">Runlevel 1           |    runlevel1.target -&gt; rescue.target</span><br><span class="line">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</span><br><span class="line">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</span><br><span class="line">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</span><br><span class="line">Runlevel 5           |    runlevel5.target -&gt; graphical.target</span><br><span class="line">Runlevel 6           |    runlevel6.target -&gt; reboot.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>它与<font style="color:blue">init</font>进程的主要差别如下。</p><p>（1）默认的 RunLevel（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p><p>（2）启动脚本的位置，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p><p>（3）配置文件的位置，以前init进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p><h1 id="Systemd-管理"><a href="#Systemd-管理" class="headerlink" title="Systemd 管理"></a>Systemd 管理</h1><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p><font style="color:blue"> systemctl </font> 是 Systemd 的主命令，用于管理系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU停止工作</span></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停系统</span></span><br><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入冬眠状态</span></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入交互式休眠状态</span></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure><h2 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h2><p><font style="color:blue"> systemd-analyze </font> 命令用于查看启动耗时。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure></p><h2 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h2><p><font style="color:blue"> hostnamectl </font> 命令用于查看当前主机的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure><h2 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h2><p><font style="color:blue"> localectl </font> 命令用于查看本地化设置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ sudo localectl set-locale LANG=en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure></p><h2 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h2><p><font style="color:blue"> timedatectl </font>命令用于查看当前时区设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ sudo timedatectl set-timezone America/New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure><h2 id="loginctl"><a href="#loginctl" class="headerlink" title="loginctl"></a>loginctl</h2><p><font style="color:blue"> loginctl </font> 命令用于查看当前登录的用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<font style="color:blue"><code>journalctl</code></font>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since=<span class="string">&quot;2012-10-30 18:17:16&quot;</span></span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;20 min ago&quot;</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;2015-01-10&quot;</span> --until <span class="string">&quot;2015-01-11 03:00&quot;</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">&quot;1 hour ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部的最新10行日志</span></span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"> -o json-pretty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">systemd 入门教程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;systemd 是 PID 为1的一个程序，负责初始化系统。所有的程序不是systemd直接启动就是由systemd的子系统启动。systemd是内核直接启动，所以信号9(KILL)对systemd也无效。&lt;/p&gt;
&lt;p&gt;systemd 使用Linux控制组跟踪进程，维护安装和自动挂载点，并实现基于事务性依赖关系的详尽服务控制逻辑。其他部分包括日志记录守护程序，用于控制基本系统配置的实用程序，例如主机名，日期，区域设置，维护已登录用户和正在运行的容器和虚拟机的列表，系统帐户，运行时目录和设置，以及用于管理简单网络的守护程序配置，网络时间同步，日志转发和名称解析。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://kiosk007.top/categories/Linux/"/>
    
    
    <category term="devops" scheme="http://kiosk007.top/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 调度对象</title>
    <link href="http://kiosk007.top/2020/08/22/Kubernetes-Pod/"/>
    <id>http://kiosk007.top/2020/08/22/Kubernetes-Pod/</id>
    <published>2020-08-22T01:53:00.000Z</published>
    <updated>2020-08-22T01:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在容器的世界中，Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统，而如果仅仅是这样的化，容器是没有价值的，因为这样很难实现线上生产环境迁移到容器集群中，线上环境复杂多变，多个服务需要通过本地socket通信或者通过文件交互内容，所以在 k8s 中，pod才是最小的调度单元。</p><a id="more"></a><p>Pod是Kubernetes创建或部署的最小/最简单的基本单位，一个Pod代表集群上正在运行的一组进程。Pod 在 k8s 中扮演着重要的角色：<strong>容器的设计模式</strong>。</p><blockquote><p>Docker是Kubernetes Pod中最常见的runtime ，Pods也支持其他容器runtimes。</p></blockquote><h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><strong>首先要了解的一个事实是 Pod 只是一个逻辑概念，简单的理解是一组超亲密关系的容器</strong></p><p>这些容器共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。<br>在Docker中就有诸如 <code>$ docker run --net=B --volumes-from=B -name =A ...</code> 这样的命令可以让多个容器共享一个Namespace。</p><p>没错既然需要共享，那么就需要有容器的启动顺序，先启动一个基础容器，再将后启动的容器共享该基础容器的Namespace。<br><img src="https://img1.kiosk007.top/static/images/k8s/k8s_infra1.png" style="height:400px"></p><p>正如上图所示，在其他容器启动之前会先启动一个infra容器，infra容器一定只占用很少的资源，这个容器叫做‘k8s.gcr.io/pause’。这个镜像使用汇编编写，永远处于“暂停”状态，而infra容器提供基础的Namespace环境供该Pod里的其他容器共享。</p><p>所以，对于同一个Pod的里的所有容器来讲，他们的进出流量可以认为是通过 infra 容器完成的。<strong>之后如果要给k8s开发一个网络插件，应该考虑配置该Pod的Network Namesapce，Infra容器的rootfs里几乎什么东西都没有</strong></p><p>Pod 只是 k8s 里面的一个概念，提供的是一个编排思想，而不是具体的技术方案，比如 Mirantis 公司的 <a href="https://github.com/Mirantis/virtlet">virtlet</a> , 可以实现一个带有 systemd 进程的容器，来模拟传统的操作系统。</p><h2 id="Pod-配置文件"><a href="#Pod-配置文件" class="headerlink" title="Pod 配置文件"></a>Pod 配置文件</h2><p>Pod的创建时基于k8s 的配置文件 — yaml 文件创建的，这样的好处是可以记录每一个Pod的基础信息,<strong>凡是调度、网络、存储、安全相关的属性，基本上都是Pod级别的</strong></p><p>下面是Pod中的几个重要字段的含义和用法。具体更多的用法可以参考 <code>$GOPATH/src/k8s.io/kubernetes/vendor/k8s.io/api/core/v1/types.go</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1    # 版本号</span><br><span class="line">kind: Pod         # Pod</span><br><span class="line">metadata:         # 元数据</span><br><span class="line">  name: nginx     # Pod名称</span><br><span class="line">  namespace: string    # Pod所属的命名空间</span><br><span class="line">  labels:         # 自定义标签</span><br><span class="line">    - name: string   # 自定义标签名字</span><br><span class="line">  annotations:       # 自定义注释列表</span><br><span class="line">    - name: string </span><br><span class="line">spec:          # Pod中容器的详细定义</span><br><span class="line">  hostNetwork: true   # 共享宿主机网络</span><br><span class="line">  hostIPC: true       # 共享宿主机IPC</span><br><span class="line">  hostPID: true       # 共享宿主机PID</span><br><span class="line">  shareProcessNamespace: true   # Pod间共享PID</span><br><span class="line">  nodeSelector:       # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">  imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br><span class="line">    - name: string</span><br><span class="line">   disktype: ssd        </span><br><span class="line">  hostAliases:        # 设置 &#x2F;etc&#x2F;hosts</span><br><span class="line">   - ip: &quot;10.1.2.3&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.remote&quot;</span><br><span class="line">    - &quot;bar.remote&quot;</span><br><span class="line">  restartPolicy: [Always | Never | OnFailure]  # Pod的重启策略</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: shell</span><br><span class="line">    image: busybox</span><br><span class="line">    stdin: true</span><br><span class="line">    tty: true</span><br></pre></td></tr></table></figure><ul><li><strong>spec</strong></li></ul><p><strong>nodeSeletor</strong> 是一个供用户将 Pod 与 Node 进行绑定的字段<br>这样的配置意味着该Pod只能运行在携带了“disktype：ssd”标签（Label）的节点上；否则会调度失败。</p><p><strong>hostAliases</strong> 定义了Pod中的 hosts 文件（比如 /etc/hosts）里的内容<br>在k8s中如果想要设置hosts文件的内容一定要通过这种方式，否则，Pod被删除重建后，kubelet会自动覆盖掉修改过的内容。</p><p><strong>restartPolicy</strong> ，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod。</p><blockquote><p>Pod在恢复过程中，永远是发生在当前的Node节点上，而不会去别的节点。如果想要Pod出现在其他可用节点，就需要使用 Deployment 这样的调度器来管理Pod，</p></blockquote><ul><li><strong>Namespace共享</strong></li></ul><p>凡是和Namespace相关的内容那么也一定是Pod级别的，Pod的设计就是要让Pod里的容器共享Namesapce，<code>shareProcessNamespace: true</code> 这条指令就可以实现Pod内的容器共享PID Namespace。</p><blockquote><p>创建Pod之后可以通过 <code>kubectl attach -it nginx -c shell</code> 后就可以通过ps 命令查看该Pod中的所有进程。</p></blockquote><p>同样添加 <code>hostNetwork</code>、<code>hostIPC</code>、<code>hostPID</code> 即可共享宿主机资源。</p><ul><li><strong>容器 &amp;&amp; 镜像</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:     # Pod中容器列表</span><br><span class="line">  - name: demo    # 容器名</span><br><span class="line">    image: nginx:1.19.2</span><br><span class="line">    command: [string]    # 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">    args: [string]       # 容器的启动命令参数列表</span><br><span class="line">    workingDir: string   # 容器的工作目录</span><br><span class="line">    imagePullPolicy: [Always | Never | IfNotPresent] # 容器拉取策略</span><br><span class="line">    nodeSelector: obeject  # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">    lifecycle:      # 容器生命周期</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; &#x2F;usr&#x2F;share&#x2F;message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]</span><br><span class="line">    volumes:       #在该pod上定义共享存储卷列表</span><br><span class="line">    - name: string     #共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">      emptyDir: &#123;&#125;     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br><span class="line">      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br><span class="line">        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录</span><br><span class="line">      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span><br><span class="line">        scretname: string  </span><br><span class="line">        items:     </span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br><span class="line">        name: string</span><br><span class="line">        items:</span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">    volumeMounts:    #挂载到容器内部的存储卷配置</span><br><span class="line">    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br><span class="line">      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符</span><br><span class="line">      readOnly: boolean    #是否为只读模式</span><br><span class="line">    ports:       #需要暴露的端口库号列表</span><br><span class="line">    - name: string     #端口号名称</span><br><span class="line">      containerPort: int   #容器需要监听的端口号</span><br><span class="line">      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同</span><br><span class="line">      protocol: string     #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    env:       #容器运行前需设置的环境变量列表</span><br><span class="line">    - name: string     #环境变量名称</span><br><span class="line">      value: string    #环境变量的值</span><br><span class="line">    resources:       #资源限制和请求的设置</span><br><span class="line">      limits:      #资源限制的设置</span><br><span class="line">        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br><span class="line">        memory: string     #内存限制，单位可以为Mib&#x2F;Gib，将用于docker run --memory参数</span><br><span class="line">      requests:      #资源请求的设置</span><br><span class="line">        cpu: string    #Cpu请求，容器启动的初始可用数量</span><br><span class="line">        memory: string     #内存请求，容器启动的初始可用数量</span><br><span class="line">    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span><br><span class="line">      exec:      #对Pod容器内检查方式设置为exec方式</span><br><span class="line">        command: [string]  #exec方式需要制定的命令或脚本</span><br><span class="line">      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式</span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged:false</span><br></pre></td></tr></table></figure><p><strong>ImagePullPolicy</strong> 定义了镜像拉取的策略，是一个Container级别的属性，默认值是Always，即每次创建Pod都重新拉取一次镜像，如果被定义为Never或者 ifNotPresent 时，则意味着Pod永远不会主动拉取这个镜像，或者只有宿主机不存在这个镜像时才会拉取。</p><p><strong>Lifecycle</strong> 定义了容器生命周期的一些钩子，可以执行容器启动前启动后的一些命令，</p><ul><li><strong>Projected Volume</strong></li></ul><p>在 k8s 中有一种特殊的Volume，叫做Projected Volume，存在的意义不是为了存放容器内的数据，也不是用来做数据交换，<strong>而是提供预先准备好的数据，所以从容器的角度来看就仿佛是被 k8s “投射”（Project）进入容器的，这正是Projected Volume 的含义。</strong></p><p>到目前为止，k8s共支持4种 Projected Volume.</p><ol><li>Secret   (例如加载数据库密码等)</li><li>ConfigMap   (例如加载配置文件等)</li><li>Downward API  (暴露Pod的meta信息给容器)</li><li>ServiceAccountToken  (保存授权信息)</li></ol><p>以Secret为例，其存在的意义其实就是将一些重要的数据投射进容器，比如数据库密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-projected-volume </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - &quot;86400&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: &quot;&#x2F;projected-volume&quot;</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: user</span><br><span class="line">      - secret:</span><br><span class="line">          name: pass</span><br></pre></td></tr></table></figure><p>数据库的用户名和密码，正是以Secret对象交付给 k8s 保存的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat .&#x2F;username.txt</span><br><span class="line">admin</span><br><span class="line">$ cat .&#x2F;password.txt</span><br><span class="line">c1oudc0w!</span><br><span class="line"></span><br><span class="line">$ kubectl create secret generic user --from-file&#x3D;.&#x2F;username.txt</span><br><span class="line">$ kubectl create secret generic pass --from-file&#x3D;.&#x2F;password.txt</span><br><span class="line"></span><br><span class="line">$ kubectl get secrets</span><br><span class="line">NAME           TYPE                                DATA      AGE</span><br><span class="line">user          Opaque                                1         51s</span><br><span class="line">pass          Opaque                                1         51s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以通过yaml文件的格式创建Secret对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  user: YWRtaW4&#x3D;</span><br><span class="line">  pass: MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>Pod 看似复杂的API对象，实际上是容器的进一步抽象和封装。而控制器（Deployment）则是控制Pod的抽象。有了控制器，我们可以定义需要2个pod，当pod个数不够时，自动创建pod直到pod个数满足配置文件 replicas 里 定义的个数。</p><p>在 k8s 架构中，有一个叫做 kube-controller-manager 的组件，这个组件负责了k8s集群中的集群属性。使用Deployment控制的pod在生产环境才有意义。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>定义Deployment来创建Pod和ReplicaSet</li><li>滚动升级和回滚应用</li><li>扩容和缩容</li><li>暂停和继续Deployment</li></ol><p>Deployment 本质也是从Etcd中获取到所有携带了“app：nginx” 标签的Pod，统计其数量，并根据 ReplicaSet 字段进行调整。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1   </span><br><span class="line">kind: Deployment                 </span><br><span class="line">metadata:</span><br><span class="line">  name: string         # Deployment名称</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3            # 目标副本数量</span><br><span class="line">  revisonHistoryLimit: 0 # 控制历史版本个数，0的话就没办法再进行回滚操作</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:       # 滚动更新</span><br><span class="line">      maxSurge: 1        # 滚动升级时最大同时升级1个pod</span><br><span class="line">      maxUnavailable: 1  # 滚动升级时最大允许不可用的pod个数</span><br><span class="line">  template:         </span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: string      # 模板名称</span><br><span class="line">    sepc:                # 定义容器模板，该模板可以包含多个容器</span><br><span class="line">      containers:                               </span><br><span class="line">        - name: string                                 </span><br><span class="line">          image: string </span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 8080  # 对service暴露端口</span><br></pre></td></tr></table></figure><p><strong>template</strong> Deployment里的template 字段和一个标准的Pod对象的API定义丝毫不差，而所有被这个Deployment管理的Pod实例就是根据这个template创建出来的。</p><ul><li><strong>ReplicaSet 对象</strong></li></ul><p>滚动更新不仅仅是 Deployment 中的一个字段，而是可以单独作为一个 k8s 中的重要的 API 对象。一个 ReplicaSet 对象，其实就是由副本数目的定义和一个Pod模板的组成。其实ReplicaSet是Deployment的一个子集。</p><p>滚动更新的过程可以通过 <code>kubectl rollout status xxx(deployment)</code>指令查看。或者 <code>kubectl describe deployment xxx(deployment)</code> 查看<br>，当修改了Pod 模板之后，Deployment Controller 会使用这个修改过的Pod模板，创建一个新的 ReplicaSet （hash=173242546624），这个新的 ReplicaSet 的初始化Pod的副本数是 0 。然后会扩展出一个新的Pod集群。</p><ol><li>想要查看replicaSet 对象 <code>kubectl get rs</code> </li><li>想要查看滚动升级历史 <code>kubectl rollout history xxx(deployment)</code></li><li>想要回滚升级至历史版本2 <code>kubectl rollout undo xxx(deployment) --revision=2</code></li><li>暂停更新和恢复 <code>kubectl rolllout pause xxxx</code> 和 <code>kubectl roolout resume xxxx</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在容器的世界中，Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统，而如果仅仅是这样的化，容器是没有价值的，因为这样很难实现线上生产环境迁移到容器集群中，线上环境复杂多变，多个服务需要通过本地socket通信或者通过文件交互内容，所以在 k8s 中，pod才是最小的调度单元。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://kiosk007.top/categories/k8s/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu20.04 部署 Kubernetes (k8s)</title>
    <link href="http://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/"/>
    <id>http://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/</id>
    <published>2020-07-24T13:47:00.000Z</published>
    <updated>2020-07-24T13:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Kubernetes（k8s）是一个免费的开源容器编排工具。它用于部署，扩展和管理基于容器的应用程序。在这篇文章中，这里将演示如何安装Kubernetes集群的Ubuntu 20.04 LTS服务器使用（Focal Fossa）kubeadm。在实验室设置中，我使用了三台Ubuntu 20.04 LTS服务器。<br><a id="more"></a></p><hr><p>以下为搭建环境。</p><ul><li>ubuntu 20.04 TLS Server</li><li>Minimum of 2 GB RAM</li><li>10 GB Free Space on /var</li><li>Privileged user with sudo rights</li></ul><p>结构：</p><ul><li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-master – 172.16.101.131</li><li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-node0 – 172.16.101.132</li><li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-node1 – 172.16.101.133</li></ul><p><img src="/images/k8s/k8s.png"></p><h1 id="安装-kubernetes"><a href="#安装-kubernetes" class="headerlink" title="安装 kubernetes"></a>安装 kubernetes</h1><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><h3 id="Step1-设置-hostname-amp-amp-增加解析-etc-hosts"><a href="#Step1-设置-hostname-amp-amp-增加解析-etc-hosts" class="headerlink" title="Step1) 设置 hostname &amp;&amp; 增加解析 /etc/hosts"></a>Step1) 设置 hostname &amp;&amp; 增加解析 /etc/hosts</h3><p>使用 <font color="Blue">hostnamectl </font> 为每一个节点命令设置 hostname , 示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-master&quot;     &#x2F;&#x2F; Run this command on master node</span><br><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-node0&quot;     &#x2F;&#x2F; Run this command on node-0</span><br><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-node1&quot;     &#x2F;&#x2F; Run this command on node-1</span><br></pre></td></tr></table></figure><p>在 <font color="Blue"> /etc/hosts </font> 下添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">172.16.101.131 k8s-master</span><br><span class="line">172.16.101.132 k8s-node0</span><br><span class="line">172.16.101.132 k8s-node1</span><br><span class="line"></span><br><span class="line">172.16.101.131 api-server.k8s.top  # kube API Server Lb</span><br></pre></td></tr></table></figure><h3 id="Step2-确保禁止掉swap分区-amp-amp-确保时间对齐-amp-amp-开启ip转发"><a href="#Step2-确保禁止掉swap分区-amp-amp-确保时间对齐-amp-amp-开启ip转发" class="headerlink" title="Step2) 确保禁止掉swap分区 &amp;&amp; 确保时间对齐 &amp;&amp; 开启ip转发"></a>Step2) 确保禁止掉swap分区 &amp;&amp; 确保时间对齐 &amp;&amp; 开启ip转发</h3><p>K8s的要求，在每个宿主机上关闭 swap，swap会将不活跃匿名页写入磁盘，降低应用程序的性能。使用 <font color="blue"> swapoff -a </font> 来关掉 swap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"># &#x2F;swap.img      none    swap    sw      0       0</span><br></pre></td></tr></table></figure><br>每个宿主机上都要确保时区和时间是正确的。如果时区不正确，请使用下面的命令来修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><br>永久开启ip转发功能，编辑 “<font color="blue"> /etc/sysctl.d/k8s.conf </font>“ 添加 “<strong>net.ipv4.ip_forward=1</strong>” ，加载 “<strong>br_netfilter</strong>” 模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><h3 id="Step3）安装-docker-Container-Runtime-到三个节点"><a href="#Step3）安装-docker-Container-Runtime-到三个节点" class="headerlink" title="Step3）安装 docker (Container Runtime) 到三个节点"></a>Step3）安装 docker (Container Runtime) 到三个节点</h3><p>在三台机器分别执行如下命令。Ubuntu 20.04 提供的这个包也很新（目前是docker 19.03）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install docker.io -y</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 docker 运行状态，docker 版本</span></span><br><span class="line">systemctl status docker</span><br><span class="line">docker info</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>文件驱动默认由<code>systemd</code>改成<code>cgroupfs</code>.而我们安装的docker使用的文件驱动是systemd, 造成不一致, 导致镜像无法启动</p><p>修改或创建 <font color="blue"> /etc/docker/daemon.json </font>，加入下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>重启docker <code>systemctl restart docker</code>.</p><blockquote><p>不然会遇到 failed to create kubelet: misconfiguration: kubelet cgroup driver: “cgroupfs” is different from docker cgroup driver: “systemd” 错误</p></blockquote><p>参考：<a href="https://www.cnblogs.com/hongdada/p/9771857.html">https://www.cnblogs.com/hongdada/p/9771857.html</a></p><h2 id="安装k8s-master"><a href="#安装k8s-master" class="headerlink" title="安装k8s master"></a>安装k8s master</h2><p>以下的操作只在master宿主机上执行，适合中国大陆地区使用（因为弃用谷歌的源和repo，转而使用阿里云的镜像）：</p><h3 id="Step1）安装kubeadm-kubeadm-kubectl"><a href="#Step1）安装kubeadm-kubeadm-kubectl" class="headerlink" title="Step1）安装kubeadm kubeadm kubectl"></a>Step1）安装kubeadm kubeadm kubectl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https curl</span><br><span class="line"></span><br><span class="line">curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;<span class="string">EOF </span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br><span class="line"><span class="comment"># 标记该软件包不被自动更新</span></span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h3 id="Step2）通过-kubeadm-Kubernetes-初始化集群-from-master-node"><a href="#Step2）通过-kubeadm-Kubernetes-初始化集群-from-master-node" class="headerlink" title="Step2）通过 kubeadm Kubernetes 初始化集群 (from master node)"></a>Step2）通过 kubeadm Kubernetes 初始化集群 (from master node)</h3><p>查看完整配置选项 <a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vim .&#x2F;kubeadm-config.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.18.6</span><br><span class="line">imageRepository: registry.aliyuncs.com&#x2F;k8sxio</span><br><span class="line">controlPlaneEndpoint: &quot;api-server.k8s.top:6443&quot;</span><br><span class="line">apiServer:</span><br><span class="line">  certSANs:</span><br><span class="line">  - &quot;k8s-master&quot;</span><br><span class="line">  - &quot;api-server.k8s.top&quot;</span><br><span class="line">  - &quot;172.16.101.131&quot;</span><br><span class="line">networking:</span><br><span class="line">  serviceSubnet: &quot;10.96.0.0&#x2F;16&quot;</span><br><span class="line">  podSubnet: &quot;10.100.0.1&#x2F;16&quot;</span><br><span class="line">  dnsDomain: &quot;cluster.local&quot;</span><br><span class="line">controllerManagerExtraArgs:  </span><br><span class="line">  horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;  </span><br><span class="line">  horizontal-pod-autoscaler-sync-period: &quot;10s&quot;  </span><br><span class="line">  node-monitor-grace-period: &quot;10s&quot;</span><br><span class="line">apiServerExtraArgs:  </span><br><span class="line">  runtime-config: &quot;api&#x2F;all&#x3D;true&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># kubeadm init</span><br><span class="line"># 根据您服务器网速的情况，您需要等候 3 - 10 分钟</span><br><span class="line">kubeadm init --config&#x3D;kubeadm-config.yaml --upload-certs -v 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Kubernetes 集群默认需要加密方式访问。</span><br><span class="line"># 所以，这几条命令，就是将刚刚部署生成的 Kubernetes 集群的安全配置文件，保存到当前用户的.kube 目录下，</span><br><span class="line"># kubectl 默认会使用这个目录下的授权信息访问 Kubernetes 集群。如果不这么做的话，我们每次都需要通过 </span><br><span class="line"># export KUBECONFIG 环境变量告诉 kubectl 这个安全配置文件的位置。</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>podSubnet: Kubernetes</code> 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中</li><li><code>horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;:</code> kube-controller-manager 能够使用自定义资源（Custom Metrics）进行自动水平扩展。</li><li><code>controlPlaneEndpoint</code> 负载均衡器的地址始终与kubeadm相连接（方便kubeapi-server 横向扩展），既然是lb，那么最好不要填 k8s-master的hostname了，这里我写的是 <font color="red">api-server.k8s.top:6443 </font> </li><li><code>upload-certs</code> 将控制平面证书上传到 kubeadm-certs Secret。</li><li><code>-v 6</code> 更可能输出详细的日志，建议开启。</li></ul><p>初始化完成之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You can now join any number of the control-plane node running the following command on each as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join api-server.k8s.top:6443 --token km8rml.3mnits2sbfh2srex \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3 \</span><br><span class="line">    --control-plane --certificate-key 619272158ec6c0a14c0539e032f5686df4d6c5576aa549412098ca50592315e6</span><br><span class="line"></span><br><span class="line">Please note that the certificate-key gives access to cluster sensitive data, keep it secret!</span><br><span class="line">As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use</span><br><span class="line">&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join api-server.k8s.top:6443 --token km8rml.3mnits2sbfh2srex \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3 </span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>查看Master节点的初始化状态 （only exec on master）</strong><br>执行<font color="blue"> kubectl get nodes -o wide </font> 可以看到我们的容器当前属于 NotReady 状态。NodeNotReady 的原因在于，我们尚未部署任何网络插件。通过 kubectl 检查这个节点上各个系统 Pod 的状态。可以看到，CoreDNS、kube-controller-manager 等依赖于网络的 Pod 都处于 Pending 状态，即调度失败。这当然是符合预期的：因为这个 Master 节点的网络尚未就绪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get nodes -o wide</span><br><span class="line">NAME         STATUS     ROLES    AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE           KERNEL-VERSION     CONTAINER-RUNTIME</span><br><span class="line">k8s-master   NotReady   master   22m   v1.18.6   172.16.101.131   &lt;none&gt;        Ubuntu 20.04 LTS   5.4.0-42-generic   docker:&#x2F;&#x2F;19.3.8</span><br><span class="line"></span><br><span class="line"># kubectl get pod -n kube-system -o wide</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-66db54ff7f-s4696             0&#x2F;1     Pending   0          26m   &lt;none&gt;           &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66db54ff7f-xxtvz             0&#x2F;1     Pending   0          26m   &lt;none&gt;           &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-k8s-master                      1&#x2F;1     Running   1          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-k8s-master            1&#x2F;1     Running   0          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-k8s-master   1&#x2F;1     Running   2          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-lvrkh                     1&#x2F;1     Running   0          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-k8s-master            1&#x2F;1     Running   2          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p><strong>安装网络插件</strong>&lt;/br&gt;<br>安装 calico 网络插件&lt;/br&gt;<br>参考文档 <a href="https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises">https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;kuboard.cn&#x2F;install-script&#x2F;calico&#x2F;calico-3.13.1.yaml</span><br><span class="line">kubectl apply -f calico-3.13.1.yaml</span><br></pre></td></tr></table></figure></p><h2 id="安装k8s-Worker"><a href="#安装k8s-Worker" class="headerlink" title="安装k8s Worker"></a>安装k8s Worker</h2><p>Kubernetes 的 Worker 节点跟 Master 节点几乎是相同的，它们运行着的都是一个 kubelet 组件。唯一的区别在于，在 kubeadm init 的过程中，kubelet 启动后，Master 节点上还会自动运行 kube-apiserver、kube-scheduler、kube-controller-manger 这三个系统 Pod。</p><p>所以，相比之下，部署 Worker 节点反而是最简单的，只需要两步即可完成。&lt;/br&gt;<br>第一步，在所有 Worker 节点(node0 node1)上执行“安装 kubeadm”。&lt;/br&gt;<br>第二步，执行部署 Master 节点时生成的 kubeadm join 指令：&lt;/br&gt;</p><p>操作在 worker 节点（k8s-node0 k8s-node1）之上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 第一步骤：安装</span><br><span class="line">curl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list &lt;&lt;EOF </span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F; kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt-get install -y kubeadm</span><br><span class="line">apt-mark hold kubeadm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二步： 加入（初始化完成时的输出）</span><br><span class="line"></span><br><span class="line">kubeadm join api-server.k8s.top:6443 --token n9ksnt.zgxthovqoyl2weyq     --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第三步： 添加环境变量</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">cp -i &#x2F;etc&#x2F;kubernetes&#x2F;kubelet.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>不记得安装后的输出的话可以在 master节点执行 <font color="blue">kubeadm token create —print-join-command</font> 查看，该 token 的有效时间为 2 个小时，2小时内，您可以使用此 token 初始化任意数量的 worker 节点。</p></blockquote><p>参考：</p><ul><li><a href="https://www.kuboard.cn/install/install-k8s.html">使用kubeadm安装kubernetes_v1.18.x</a></li><li><a href="https://zhuanlan.zhihu.com/p/138554103">基于Ubuntu 20.04安装Kubernetes 1.18</a></li><li><a href="https://www.bookstack.cn/read/k8s-1.18-reference/e8ce7efca72fde85.md">Kubernetes v1.18 参考指南</a></li></ul><h2 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h2><h3 id="部署-Dashboard-可视化插件"><a href="#部署-Dashboard-可视化插件" class="headerlink" title="部署 Dashboard 可视化插件"></a>部署 Dashboard 可视化插件</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>由于 Dashboard 是一个 Web Server，很多人经常会在自己的公有云上无意地暴露 Dashboard 的端口，从而造成安全隐患。所以，1.7 版本之后的 Dashboard 项目部署完成后，默认只能通过 Proxy 的方式在本地访问。具体的操作，你可以查看 <a href="https://github.com/kubernetes/dashboard">Dashboard</a> 项目的官方文档。</p><p>Dashboard 向 Kubernetes 集群部署容器化应用诊断容器化应用的问题</p><ul><li>管理集群的资源</li><li>查看集群上所运行的应用程序</li><li>创建、修改Kubernetes 上的资源（例如 Deployment、Job、DaemonSet等）</li><li>展示集群上发生的错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.0.3&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后可以使用 <code>kubectl get pods</code> 命令来查看部署状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">...</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-6b4884c9d5-gs97j   1&#x2F;1     Running   0          100m</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-7f99b75bf4-h576c        1&#x2F;1     Running   0          100m</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>首先创建一个叫 <font color="blue"> admin-user </font> 的服务账号，并放在 <font color="blue">kubernetes-dashboard</font> 名称空间下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># admin-user.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>执行 <font color="blue"> kubectl create </font> 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f admin-user.yaml</span><br></pre></td></tr></table></figure></p><h4 id="绑定角色"><a href="#绑定角色" class="headerlink" title="绑定角色"></a>绑定角色</h4><p>默认情况下，kubeadm 创建集群时已经创建了admin角色，我们直接绑定即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># admin-user-role-binding.yaml</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>执行 <font color="blue">kubectl create </font>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f  admin-user-role-binding.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h4><p>们需要找到新创建的用户的Token，以便用来登录dashboard：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;&#123;print $1&#125;&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>Kubernetes API服务器是公开的，并可以从外部访问，那我们可以直接使用API Server的方式来访问，也是比较推荐的方式。</p><p>Dashboard的访问地址为：<a href="https://172.16.101.131:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/node/k8s-node1?namespace=default">https://172.16.101.131:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/node/k8s-node1?namespace=default</a></p><p>但是直接访问会是403<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;services \&quot;https:kubernetes-dashboard:\&quot; is forbidden: User \&quot;system:anonymous\&quot; cannot get services&#x2F;proxy in the namespace \&quot;kube-system\&quot;&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;https:kubernetes-dashboard:&quot;,</span><br><span class="line">    &quot;kind&quot;: &quot;services&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是因为最新版的k8s默认启用了RBAC，并为未认证用户赋予了一个默认的身份：<font color="blue">anonymous</font><br>对于API Server来说，它是使用证书进行认证的，我们需要先创建一个客户端证书：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 生成client-certificate-data</span><br><span class="line">grep &#39;client-certificate-data&#39; ~&#x2F;.kube&#x2F;config | head -n 1 | awk &#39;&#123;print $2&#125;&#39; | base64 -d &gt;&gt; kubecfg.crt</span><br><span class="line"></span><br><span class="line"># 生成client-key-data</span><br><span class="line">grep &#39;client-key-data&#39; ~&#x2F;.kube&#x2F;config | head -n 1 | awk &#39;&#123;print $2&#125;&#39; | base64 -d &gt;&gt; kubecfg.key</span><br><span class="line"></span><br><span class="line"># 生成p12</span><br><span class="line">openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name &quot;kubernetes-client&quot;</span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/k8s/k8s_dashboard.png"></p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/RainingNight/p/deploying-k8s-dashboard-ui.html">kubernetes-dashboard(1.8.3)部署与踩坑</a></li></ul><h3 id="部署持久化存储插件-rock"><a href="#部署持久化存储插件-rock" class="headerlink" title="部署持久化存储插件 rock"></a>部署持久化存储插件 rock</h3><p>Rook 项目是一个基于 Ceph 的 Kubernetes 存储插件（它后期也在加入对更多存储实现的支持）。不过，不同于对 Ceph 的简单封装，Rook 在自己的实现中加入了水平扩展、迁移、灾难备份、监控等大量的企业级功能，使得这个项目变成了一个完整的、生产级别可用的容器存储插件。</p><blockquote><p>友情提示，这玩意巨占空间，如果是本地虚拟机搭建的话需要磁盘稍微再大点。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/common.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/operator.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/cluster.yaml</span><br></pre></td></tr></table></figure><h2 id="通过-Taint-Toleration-调整-Master-执行-Pod-的策略-附加"><a href="#通过-Taint-Toleration-调整-Master-执行-Pod-的策略-附加" class="headerlink" title="通过 Taint/Toleration 调整 Master 执行 Pod 的策略 (附加)"></a>通过 Taint/Toleration 调整 Master 执行 Pod 的策略 (附加)</h2><p>默认情况下 Master 节点是不允许运行用户 Pod 的。而 Kubernetes 做到这一点，依靠的是 Kubernetes 的 Taint/Toleration 机制。</p><p>原理非常简单：一旦某个节点被加上了一个 Taint，即被“打上了污点”，那么所有 Pod 就都不能在这个节点上运行，因为 Kubernetes 的 Pod 都有“洁癖”。除非，有个别的 Pod 声明自己能“容忍”这个“污点”，即声明了 Toleration，它才可以在这个节点上运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建 taint</span><br><span class="line">kubectl taint nodes k8s-nodeXX foo&#x3D;bar:NoSchedule</span><br><span class="line"></span><br><span class="line"># 删除 taint</span><br><span class="line">kubectl taint nodes k8s-nodeXX foo&#x3D;bar:NoSchedule-</span><br></pre></td></tr></table></figure><p>master 默认已经有了一个 taint。即<font color="blue"> role.kubernetes.io/master:NoSchedule</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node k8s-master</span><br><span class="line">Name:               k8s-master</span><br><span class="line">Roles:              master</span><br><span class="line">...</span><br><span class="line">CreationTimestamp:  Sat, 25 Jul 2020 09:44:07 +0800</span><br><span class="line">Taints:             node-role.kubernetes.io&#x2F;master:NoSchedule</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="创建-k8s容器化应用"><a href="#创建-k8s容器化应用" class="headerlink" title="创建 k8s容器化应用"></a>创建 k8s容器化应用</h1><p>这里创建一个Nginx, 准备一个 <font color="blue"> nginx-deployment.yaml </font> 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.19.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &quot;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&quot;</span><br><span class="line">          name: nginx-vol</span><br><span class="line">      volumes:</span><br><span class="line">      - name: nginx-vol</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &quot;&#x2F;root&#x2F;data&quot;</span><br></pre></td></tr></table></figure><ul><li><code>spec.replicas</code>：Pod 副本个数 ：2</li><li><code>spec.containers.image</code>: 容器镜像 ：Nginx:latest</li><li><code>containerPort</code>: 容器端口：80</li><li><code>volumes.emptyDir</code>: 不显式声明宿主机目录的 Volume。所以，Kubernetes 也会在宿主机上创建一个临时目录，这个目录将来就会被绑定挂载到容器所声明的 Volume 目录上。当然，Kubernetes 也提供了显式的 Volume 定义，它叫作 hostPath。比如下面的这个 YAML 文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...   </span><br><span class="line">   volumes:</span><br><span class="line">     - name: nginx-vol</span><br><span class="line">       hostPath: </span><br><span class="line">         path:  &quot; &#x2F;var&#x2F;data&quot;</span><br></pre></td></tr></table></figure>使用 kubectl create 创建这个容器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure><p>查看运行状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l app&#x3D;nginx</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-d4544f9cb-b24wq   1&#x2F;1     Running   0          5m13s</span><br><span class="line">nginx-deployment-d4544f9cb-f88bk   1&#x2F;1     Running   0          5m13s</span><br><span class="line"></span><br><span class="line"># 查看一个 API 对象的细节，通过 Events 字段</span><br><span class="line">kubectl describe pod nginx-deployment-d4544f9cb-b24wq</span><br></pre></td></tr></table></figure><br>查看API对象细节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod nginx-deployment-57f45cfc58-9fpzt</span><br><span class="line">Name:         nginx-deployment-57f45cfc58-9fpzt</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         k8s-node1&#x2F;172.16.101.133</span><br><span class="line">Start Time:   Sat, 25 Jul 2020 18:00:01 +0800</span><br><span class="line">Labels:       app&#x3D;nginx</span><br><span class="line">              pod-template-hash&#x3D;57f45cfc58</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>在 kubectl describe 命令返回的结果中，可以看到这个 Pod 的详细信息，比如它的 IP 地址等等。其中，有一个部分值得你特别关注，就是 <strong>Events（事件）</strong>。</p><p>在 Kubernetes 执行的过程中，对 API 对象的所有重要操作，都会被记录在这个对象的 Events 里，并且显示在 kubectl describe 指令返回的结果中。</p><p>如果 pod 信息有改变，比如想要将Nginx的版本换成1.18。修改完 yaml 文件后，只需要执行<code>kubectl apply -f nginx-deployment.yaml</code> 即可。</p><p><strong>进入到pod中，即这个namesapce中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it  nginx-deployment-57f45cfc58-9fpzt -- &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><br><strong>从 Kubernetes 集群中删除这个 Nginx Deployment </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure></p><h1 id="k8s-的最小调度单元-pod"><a href="#k8s-的最小调度单元-pod" class="headerlink" title="k8s 的最小调度单元 pod"></a>k8s 的最小调度单元 pod</h1><p>前面已经完全搭建起来了一个 k8s 集群，并跑起来了第一个Nginx服务。但是这距离线上的生成环境还差的很远。</p><p>试想一下，Nginx 假设需要为静态资源前端文件提供服务部署能力，那么该如何实现呢？将前端文件内容和Nginx绑定部署？这显然是不合适的。</p><p>Linux 下的很多服务其实也是多个进程相互协作的，比如两个进程是通过本地socket通信的，那么就必须让两个进程处于同一个 namespace中，而在docker的世界，容器即进程，也就是一个容器跑着一个进程。</p><blockquote><p>再次强调一下：容器的“单进程模型”，并不是指容器里只能运行“一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程。可是，用户编写的应用，并不能够像正常操作系统里的 init 进程或者 systemd 那样拥有进程管理的功能。比如，你的应用是一个 Java Web 程序（PID=1），然后你执行 docker exec 在后台启动了一个 Nginx 进程（PID=3）。可是，当这个 Nginx 进程异常退出的时候，你该怎么知道呢？这个进程退出后的垃圾收集工作，又应该由谁去做呢？</p></blockquote><p>这就需要多个容器组成一个pod，pod里的容器可以共享namespace，比如共享<code>network namespace</code>或者共享volume的<code>mnt namesapce</code>。这就像 <code>docker run --net=B --volumes-from=B --name=A image-A ...</code>这样的联盟式容器一样的操作。</p><p>在k8s中，需要有一个初始的容器来提供初始化的环境，这个容器（k8s.grc.io/pause）会最先启动,并提供初始的各种namesapce环境，infra容器所占用的资源是最小的。<strong>k8s.gcr.io/pause</strong> 这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有 100~200 KB 左右。<br><img src="/images/k8s/k8s_infra.png" style="height:400px"></p><p>如果要开发容器的网络插件，也就是针对这个infra容器的，而不是应用本身的容器。</p><p>在web场景中经常即需要war包也需要运行war包的tomcat web服务器。web包需要放在tomcat的webapp下运行。<br>如果用容器去可能的2个实现方法是。</p><ol><li>把 WAR 包直接放在 Tomcat 镜像的 webapps 目录下，做成一个新的镜像运行起来。可是，这时候，如果你要更新 WAR 包的内容，或者要升级 Tomcat 镜像，就要重新制作一个新的发布镜像，非常麻烦。</li><li>压根儿不管 WAR 包，永远只发布一个 Tomcat 容器。不过，这个容器的 webapps 目录，就必须声明一个 hostPath 类型的 Volume，从而把宿主机上的 WAR 包挂载进 Tomcat 容器当中运行起来。不过，这样你就必须要解决一个问题，即：如何让每一台宿主机，都预先准备好这个存储有 WAR 包的目录呢？这样来看，你只能独立维护一套分布式存储系统了。</li></ol><p>有了 Pod 之后，这样的问题就很容易解决了。我们可以把 WAR 包和 Tomcat 分别做成镜像，然后把它们作为一个 Pod 里的两个容器“组合”在一起。<br>这里定义了2个容器 <code>war</code> 和 <code>tomcat</code>。war容器只专心提供war包，而tomcat基<br>本不变。不过，<code>war</code> 容器的类型不再是一个普通容器，而是一个 <strong>Init Container</strong> 类型的容器。Init Container 类型的 WAR 包容器启动后，执行了<code>cp /sample.war /app</code>，把应用的 WAR 包拷贝到 /app 目录下，然后退出。</p><ul><li>这种组合即“sidecar”，sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。</li></ul><blockquote><p>Init Container 定义的容器，都会比 spec.containers 定义的用户容器先启动。并且，Init Container 容器会按顺序逐一启动，而直到它们都启动并且退出了，用户容器才会启动。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: javaweb-2</span><br><span class="line">spec:</span><br><span class="line">  initContainers:</span><br><span class="line">  - image: geektime&#x2F;sample:v2</span><br><span class="line">    name: war</span><br><span class="line">    command: [&quot;cp&quot;, &quot;&#x2F;sample.war&quot;, &quot;&#x2F;app&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &#x2F;app</span><br><span class="line">      name: app-volume</span><br><span class="line">  containers:</span><br><span class="line">  - image: geektime&#x2F;tomcat:7.0</span><br><span class="line">    name: tomcat</span><br><span class="line">    command: [&quot;sh&quot;,&quot;-c&quot;,&quot;&#x2F;root&#x2F;apache-tomcat-7.0.42-v2&#x2F;bin&#x2F;start.sh&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &#x2F;root&#x2F;apache-tomcat-7.0.42-v2&#x2F;webapps</span><br><span class="line">      name: app-volume</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      hostPort: 8001 </span><br><span class="line">  volumes:</span><br><span class="line">  - name: app-volume</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kubernetes（k8s）是一个免费的开源容器编排工具。它用于部署，扩展和管理基于容器的应用程序。在这篇文章中，这里将演示如何安装Kubernetes集群的Ubuntu 20.04 LTS服务器使用（Focal Fossa）kubeadm。在实验室设置中，我使用了三台Ubuntu 20.04 LTS服务器。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://kiosk007.top/categories/k8s/"/>
    
    
    <category term="k8s" scheme="http://kiosk007.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Android 信任自签名证书</title>
    <link href="http://kiosk007.top/2020/07/22/Android-%E4%BF%A1%E4%BB%BB%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/"/>
    <id>http://kiosk007.top/2020/07/22/Android-%E4%BF%A1%E4%BB%BB%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/</id>
    <published>2020-07-22T15:23:00.000Z</published>
    <updated>2020-07-22T15:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前的文章 <a href="https://kiosk007.top/2020/05/30/VMTrafficShark-%E8%87%AA%E5%88%B6%E5%BC%B1%E7%BD%91%E6%A8%A1%E6%8B%9F%E5%99%A8/">VMTrafficShark 自制弱网模拟器</a> 中介绍了如何搭建一个弱网模拟器，并且进行弱网模拟，中间人，劫持重放测试等等。对了这里一般的测试设备是Android手机，那么这篇文章介绍一下Android 手机应该如何支持自签名证书。</p><h2 id><a href="#" class="headerlink" title></a><a id="more"></a></h2><h1 id="Android-root"><a href="#Android-root" class="headerlink" title="Android root"></a>Android root</h1><p>Android 本身可以理解为一个Linux操作系统的终端，只是没有root权限，普通用户 <code>adb</code> 连上之后只有普通用户的权限。而root不是那么容易的，这里推荐 <code>Magisk Root</code> 这款软件，目前我的 Mi3， RedMi Note 8 Pro 都是已经root了的（曾经是米粉…）</p><p>甩几个链接参考</p><ul><li><a href="https://www.magiskroots.com/">Magic Mask To Enhance Your Default Android | The First Systemless Root Tool</a></li><li><a href="https://devsjournal.com/how-to-setup-magisk-manager-on-rooted-android-device-to-hide-root.html#:~:text=Installing%20Magisk%20Root%20via%20TWRP%3A%201%20Make%20sure,Zip%20and%20confirm%20flashing.%20...%20More%20items...%20">How To Setup Magisk Manager On Rooted Android Device To Hide “Root”</a></li><li><a href="https://c.mi.com/thread-1808315-1-0.html">How to Root Xiaomi Redmi Note 5</a></li></ul><h1 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h1><h2 id="X509-证书简介"><a href="#X509-证书简介" class="headerlink" title="X509 证书简介"></a>X509 证书简介</h2><p>首先介绍一下证书体系吧</p><p>公钥基础设施（PKI）是一种用于验证网络世界中的用户和设备的技术。基本思想是让一个或多个受信方对数据进行数字签名，以证明特定的加密密钥属于特定的用户或设备。然后该密钥可以用作证明该用户的身份。</p><p>而 x509 正是当下最常见的证书标准，<a href="https://tools.ietf.org/html/rfc5280">RFC5280</a> 阐述了IETF对X509证书的定义。x509证书的格式在google chrome 浏览器地址栏左边的小锁即可查看。</p><p>以cloudflare的官网域名 <a href="https://1.1.1.1">https://1.1.1.1</a> 举例（没错，还有ip证书）</p><p><strong>第一组详细信息包括有关主题的信息，包括公司名称和地址以及证书旨在保护的网站的通用名称（Fully Qualified Domain Name）</strong><br><img src="https://img1.kiosk007.top/static/images/network/AndroidRoot/cert_fqdn.png" style="height:450px"></p><p><strong>向下滑动，是发行者的信息（Issuer）, 这里可以看到签发者是 DigiCert。在颁发者下方，我们可以看到证书的序列号，X.509版本（3），签名算法以及指定证书有效期的日期。</strong><br><img src="https://img1.kiosk007.top/static/images/network/AndroidRoot/cert_sign.png" style="height:450px"></p><p><strong>X.509 v3证书还包括一组扩展，这些扩展在证书使用方面提供了更多的灵活性。例如，主题备用名称扩展名允许证书绑定到多个身份。（因此，有时将多域证书称为 <a href="https://www.ssl.com/faqs/what-is-a-san-certificate/">SAN</a> 证书）。这里提供了很多其他域名，这里还可以提供ip地址,可以看到 cloudflare 的1.1.1.1</strong></p><p><img src="https://img1.kiosk007.top/static/images/network/AndroidRoot/cert_san.png" style="height:450px"></p><h2 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h2><ul><li>.DER .CER，文件是二进制格式，只保存证书，不保存私钥。</li><li>.PEM，一般是文本格式，可保存证书，可保存私钥。</li><li>.CRT，可以是二进制格式，可以是文本格式，与 .DER 格式相同，不保存私钥。</li><li>.PFX .P12，二进制格式，同时包含证书和私钥，一般有密码保护。</li><li>.JKS，二进制格式，同时包含证书和私钥，一般有密码保护。</li></ul><h2 id="利用-Mitm-的-Root-CA-制作自签名证书"><a href="#利用-Mitm-的-Root-CA-制作自签名证书" class="headerlink" title="利用 Mitm 的 Root CA 制作自签名证书"></a>利用 Mitm 的 Root CA 制作自签名证书</h2><p><a href="https://docs.mitmproxy.org/stable/">mitmproxy</a> 是一款中间人工具，通过代理来实现https流量嗅探。</p><p>安装好 mitmproxy 后再家目录下就放着 mitm 的root ca。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ls ~/.mitmproxy</span><br><span class="line">mitmproxy-ca-cert.cer  mitmproxy-ca-cert.p12  mitmproxy-ca-cert.pem  mitmproxy-ca.p12  mitmproxy-ca.pem  mitmproxy-dhparam.pem</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这里我们取 <code>mitmproxy-ca.pem</code> 这个文件制作自签名证书。</p><h3 id="分离CA证书和私钥"><a href="#分离CA证书和私钥" class="headerlink" title="分离CA证书和私钥"></a>分离CA证书和私钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  mkdir mitm &amp;&amp; <span class="built_in">cd</span> mitm</span><br><span class="line">➜  cp ~/.mitmproxy/mitmproxy-ca.pem .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离私钥</span></span><br><span class="line">➜  openssl pkey -<span class="keyword">in</span> mitmproxy-ca.pem -out mitmproxy-ca-private.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有证书，包括CA Chain</span></span><br><span class="line">➜  openssl crl2pkcs7 -nocrl -certfile mitmproxy-ca.pem | openssl pkcs7 -print_certs -out mitmproxy-ca-certificate.cert</span><br></pre></td></tr></table></figure><h3 id="创建自签名证书"><a href="#创建自签名证书" class="headerlink" title="创建自签名证书"></a>创建自签名证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成证书私钥（your-domain.com 换成你要签名的域名）</span></span><br><span class="line">➜  openssl genrsa -out your-domain.com.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书请求文件(并按要求填写 CN、SPN、LN等，不想填就全部回车)</span></span><br><span class="line">➜  openssl req -new -key your-domain.com.key -out your-domain.com.csr</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Chrome 58 之后，改为使用 SAN(Subject Alternative Name) 检查域名的一致性。</p><p>而 SAN 属于 x509 扩展里面的内容，所以我们需要通过 -extfile 参数来指定存放扩展内容的文件。创建一个 your-domain.com.ext 文件用来保存 SAN 信息，通过指定多个 DNS 从而可以实现多域名证书。<br>参考：<a href="http://wiki.cacert.org/FAQ/subjectAltName">FAQ/subjectAltName (SAN)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  vim your-domain.com.ext</span><br><span class="line">[req]</span><br><span class="line">req_extensions = v3_req</span><br><span class="line"></span><br><span class="line">[v3_req]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = your-domain.com.</span><br><span class="line">DNS.2 = *.your-domain.com.</span><br><span class="line">IP.1 = 127.0.0.1</span><br><span class="line">IP.2 = 192.168.0.107</span><br></pre></td></tr></table></figure><p>使用 mitm 的CA 公私钥对 签署自己域名的证书。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  openssl x509 -req -sha256 -<span class="keyword">in</span> your-domain.com.csr \</span><br><span class="line">-CA mitmproxy-ca-certificate.cert \</span><br><span class="line">-CAkey mitmproxy-ca-private.key \</span><br><span class="line">-CAcreateserial \</span><br><span class="line">-out your-domain.com.crt \</span><br><span class="line">-days 365 \</span><br><span class="line">-extfile kiosk007.top.ext \</span><br><span class="line">-extensions v3_req</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>至此，自签名证书已经生成完毕，自签名的证书为 <code>your-domain.crt</code> , 自签名的私钥为 <code>your-domain.key</code> 。只需要将 <code>mitmproxy-ca-certificate.cert</code> 导入到Android手机中，手机便会信任由这个root 证书签名的证书，如刚才的 <code>your-domian.crt</code></p><h2 id="导入根证书到Android手机"><a href="#导入根证书到Android手机" class="headerlink" title="导入根证书到Android手机"></a>导入根证书到Android手机</h2><h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到hash值</span></span><br><span class="line">➜  openssl x509 -subject_hash_old -<span class="keyword">in</span> mitmproxy-ca-certificate.cert |head -n 1</span><br><span class="line">➜  cp mitmproxy-ca-certificate.cert &lt;Certificate_Hash&gt;.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装到Android机"><a href="#安装到Android机" class="headerlink" title="安装到Android机"></a>安装到Android机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  adb push c8750f0d.0 /sdcard/</span><br><span class="line">➜  adb shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手机中操作</span></span><br><span class="line">begonia:/ $ su root</span><br><span class="line">:/ <span class="comment"># mount -o rw,remount /</span></span><br><span class="line">:/ <span class="comment"># mv /sdcard/c8750f0d.0 /system/etc/security/cacerts/</span></span><br><span class="line">:/ <span class="comment"># chmod 644 /system/etc/security/cacerts/c8750f0d.0</span></span><br><span class="line">:/ <span class="comment"># chown root:root /system/etc/security/cacerts/c8750f0d.0</span></span><br><span class="line">:/ <span class="comment"># mount -o ro,remount /</span></span><br><span class="line">:/ <span class="comment"># reboot</span></span><br><span class="line">➜  </span><br><span class="line">➜  </span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.ssl.com/faqs/what-is-an-x-509-certificate/">What Is an X.509 Certificate?</a></li><li><a href="https://www.ssh.com/pki/">PKI - Public Key Infrastructure</a></li><li><a href="https://blog.freessl.cn/ssl-cert-format-introduce/">SSL 证书格式普及，PEM、CER、JKS、PKCS12</a></li></ul><h1 id="Android-ssh-终端-附加"><a href="#Android-ssh-终端-附加" class="headerlink" title="Android ssh 终端 (附加)"></a>Android ssh 终端 (附加)</h1><p>这一步主要是可以通过ssh操作终端（已经和信任自签名证书无关了哈，只是附加的。哈哈），因为<code>adb shell</code>实在是太难操作了。</p><p>这里先安装 Termux （可以在 google play 或者 豌豆荚下载）</p><p>安装 Termux 之后，安装sshd<br>手机上操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkg install openssh -y</span><br><span class="line"># start ssh</span><br><span class="line">sshd</span><br></pre></td></tr></table></figure><br>配置远程登录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># PC copy ssh 公钥 (没有的化，执行 ssh-keygen 生成)</span><br><span class="line">➜  copy id_rsa.pub</span><br><span class="line"></span><br><span class="line"># Termux 粘贴公钥</span><br><span class="line">cd .ssh</span><br><span class="line">vim authorized_keys</span><br><span class="line">粘贴保存</span><br><span class="line"></span><br><span class="line">查看当前用户，后面登录用</span><br><span class="line">whoami</span><br><span class="line"></span><br><span class="line"># PC 上配置端口转发</span><br><span class="line">（如果是远程的话配置一下 adb connect xxxxxx:xxx）</span><br><span class="line">➜  adb forward --list</span><br><span class="line">➜  adb forward --remove-all</span><br><span class="line">➜  adb forward tcp:8022 tcp:8022</span><br><span class="line">➜  ssh u0_a221@127.0.0.1 -p 8022</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>Tips: 界面左滑，长按 <code>KEYBOARD</code> 可以出现辅助按钮， ESC、CTR、ALT 等。再次单按 <code>KEYBOARD</code> 可出现键盘。</p></blockquote><p><img src="https://img1.kiosk007.top/static/images/network/AndroidRoot/android_root.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的文章 &lt;a href=&quot;https://kiosk007.top/2020/05/30/VMTrafficShark-%E8%87%AA%E5%88%B6%E5%BC%B1%E7%BD%91%E6%A8%A1%E6%8B%9F%E5%99%A8/&quot;&gt;VMTrafficShark 自制弱网模拟器&lt;/a&gt; 中介绍了如何搭建一个弱网模拟器，并且进行弱网模拟，中间人，劫持重放测试等等。对了这里一般的测试设备是Android手机，那么这篇文章介绍一下Android 手机应该如何支持自签名证书。&lt;/p&gt;
&lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://kiosk007.top/categories/Linux/"/>
    
    
    <category term="Certificate" scheme="http://kiosk007.top/tags/Certificate/"/>
    
  </entry>
  
  <entry>
    <title>理解协程</title>
    <link href="http://kiosk007.top/2020/07/18/%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"/>
    <id>http://kiosk007.top/2020/07/18/%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-07-18T08:30:00.000Z</published>
    <updated>2020-07-18T08:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>协程</strong> 在如今在高并发场景下最容易提到的一个技术，协程即能暂停执行以在之后恢复的函数。。下面是关于 <a href="https://en.cppreference.com/w/cpp/language/coroutines">GCC11 编辑器</a> 对协程的介绍 （ A coroutine is a function that can suspend execution to be resumed later. Coroutines are stackless: they suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. ）</p><a id="more"></a><hr><p>试想以下场景，百万级别的高并发场景下，如何实现用户访问静态资源的Web服务，需要的工作如下</p><ol><li>通过网络调用远程服务来进行身份验证</li><li>检查Memcache中是否存在相关的资源 </li><li>将请求的资源从磁盘中读取数据放入 HTTP Body的 Buffer中 </li><li>再将访问记录插入到MySQL数据库中。</li></ol><p>那么都有哪些技术呢？</p><ul><li>多进程？进程是操作系统资源分配（内存，显卡，磁盘）的最小单位。多进程面临着 CPU 寄存器和程序计数器等上下文的切换。</li><li>多线程？线程是执行调度（即cpu调度）的最小单位（cpu看到的都是线程而不是进程）。计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位)　一个进程可以有一个或多个线程，线程之间共享进程的资源。</li></ul><p>如果使用阻塞API写同步代码将最简单，但是一个线程同一时间只能处理一个请求，也就是每新建一个链接就需要新创建一个线程去处理，而CPU在处理越来越多的请求时，会切换线程来服务其他的线程,这样的做法能满足我们高并发的需求吗？</p><p><img src="https://img1.kiosk007.top/static/images/coroutines/mutli_pthread.jpeg"></p><p>无论是多进程还是多线程都有以下问题。</p><ul><li><font color="red">资源消耗的问题</font>: 比如 64 位Linux为每个线程的栈分配了8MB 的内存，C库还预分配了６４MB的内存池，在同时存在数十万的连接情况下没有足够的内存开启如此之多的线程。</li><li><font color="red">上下文切换</font>：CPU资源消耗，<strong>当调度到阻塞的方法时，内核为了让CPU充分工作，也会切换到其他的线程执行</strong>　进程的切换会有很多寄存器，堆栈的切换，也会造成缓存命中率差，线程虽然切换会轻量一些，但还是会存在部分私有数据和寄存器数据的切换。一次的切换成本也会在几十纳秒到几微秒间。</li></ul><p>那么该怎样实现高并发？如果将本来应该由内核实现的请求切换工作，交给用户态的代码完成就能实现切换成本的降低，异步化改造依赖ＩＯ多路复用机制和非阻塞，然而写异步化代码很容易出错。异步化改造需要将阻塞的函数通过非阻塞的系统调用拆分成２个函数，第一个函数显式调用，第二个函数多路复用的调用。所以异步化改造程序是很复杂的。<br><img src="https://img1.kiosk007.top/static/images/coroutines/coroutine.jpeg"></p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程出现了，在异步化之上包了一层外衣，这就是异步框架。协程与异步编程的<strong>相似的地方</strong>在于他们都使用了非阻塞的系统调用与内核交互。把切换请求的实现放到了用户态。<strong>不同的地方</strong>在于协程把异步化中的两段函数封装成了一个阻塞的协程函数。这也是对用户友好的编程格式。函数在执行时，调用的协程无感知的放弃执行权，由协程框架切换到准备就绪的其他协程上。当这个函数满足执行条件时，协程框架再选择合适的时机，切换回它所在的协程执行。</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>协程不需要什么“回调函数”，它允许用户调用“阻塞的函数”，即用同步编程的方式去写业务逻辑。解决了异步化通过大量的回调函数来完成请求函数的切换的复杂编程方式。</p><p><img src="https://img1.kiosk007.top/static/images/coroutines/coroutine_stack.png"><br>实际上，<strong>用户态的代码协程切换和内核协程切换的原理是一样的</strong>，内核通过管理CPU的寄存器来切换线程，而协程的切换是将内核的工作移到了协程框架实现而已，创建协程时，会从进程的堆中分配一段内存作为协程的栈。线程的栈有8MB，而协程的栈只有几十ＫＢ，并且Ｃ库的内存池也不会为协程预分配内存，因为它感知不到协程的存在。这样以来协程需要的内存空间就十分少了，几十万的并发也不需要很多的内存消耗</p><blockquote><p><strong>当然：栈缩小了，就尽量不要在协程中使用递归函数了</strong></p></blockquote><p>由此可见，协程就是用户态的线程。协程框架在用户空间做了线程切换等内核要做的事情。另外协程封装了所有阻塞的系统调用，例如<code>sleep()</code>函数会让当前的线程休眠，而线程一旦休眠，协程也就无法执行了。（协程是工作于线程之上的）。这就需要内核来唤醒sleep函数，协程化改造之后，<code>sleep()</code>函数只会让当前的协程休眠，由协程框架在指定时间后唤醒协程。</p><p><strong>所以协程的高性能就是建立在所有的切换由用户态代码实现，这就要求协程的生态是完整的，要覆盖所有组件。</strong>如果一个协程框架没有考虑到如<code>sleep()</code>函数的协程化改造，就会造成线程休眠，线程休眠就会造成在线程之上的协程也伴随着休眠。</p><h2 id="协程-线程"><a href="#协程-线程" class="headerlink" title="协程+线程"></a>协程+线程</h2><p>实际上面对当下服务器动辄几百核的多核CPU架构，线程也就需要和协程结合起来使用，因为协程的载体是线程。而CPU的执行对象是线程，线程在同一时刻只能拥有一颗CPU，那么好的设计是开启更多的线程，然后将协程分布在这些线程之上，这样就能充分的利用CPU资源。</p><p>除此之外，为了让协程获得更多的CPU时间，只要所在线程的优先级调高即可，甚至可以将CPU绑定到某个CPU上，增加协程执行时命中CPU的缓存几率。（要知道CPU的三级缓存SRAM是要比内存DRAM快很多的，如果多个线程频繁在不同的CPU切换来切换去就会造成缓存命中率低下，TLB根本起不到作用）</p><p>很多的协程库只提供了创建、挂起、恢复执行的基本方法，并没有协程框架的概念出现，这就需要业务在代码中自行实现调度协程。在协程的运行条件不满足需求时，多路复用框架会将它挂起，并根据优先级策略选择另一个协程执行。也就是不只是选择协程库，还需要结合IO多路复用的协程框架，这样就可以加快开发的速度。</p><p>比如OpenResty中的<code>cosocket</code>，<code>cosocket = coroutine + socket</code> ，<code>cosocket</code>利用lua的协程特性支持，又结合了Nginx事件机制。遇到网络I/O就会交出控制权（yield），把网络事件注册到Nginx的事件监听表中，并把权限重新交给Nginx，当有Nginx事件达到触发条件，会唤醒对应的协程继续处理（resume）</p><h2 id="golang协程"><a href="#golang协程" class="headerlink" title="golang协程"></a>golang协程</h2><p>Go在语言级别支持了协程（Goroutine）来实现高并发。作为程序员不必再考虑 像<code>Python</code> 那样引入一个异步协程库，利用其代码来实现异步协程化。</p><p>Goroutine天生对协程的完美支持，也让Goroutine传承了协程本身的优良特性。<br>Goroutine堆栈只有几十kb。如果某一线程之上的协程不幸发生阻塞，那么系统可以将其与协程移动到新的线程上执行，这一切不用程序员关心。多个协程之间通信的管道。信道可以防止多个协程访问共享内存时发生资源争抢的问题。(但是注意：多个goroutine 访问一个map时一定需要加锁！！)</p><p>在GO1.14之前golang的协程还是<code>非抢占式调度</code>.而在1.14之后，协程添加了一个重要的特性便是<code>抢占式调度</code>。</p><ul><li>非抢占式调度</li></ul><p>非抢占式的含义就是其他任务不会抢我的cpu，而是等待我主动让出去。别的goroutine才可以执行。而io等操作会主动让出去goroutine的执行权。如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">20</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i&lt; <span class="number">20</span>;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                a[i]++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.13 版本下的Go SDK 执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  go version</span><br><span class="line">go version go1.13.14 linux&#x2F;amd64</span><br><span class="line">➜  go run main.go</span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/coroutines/goroutine_NonPreemptive.png"></p><p>这个程序会卡住。因为main函数也是一个goroutine。而程序中对一个变量++ 是不会交出控制权的（io操作可以交出控制权，如fmt.println，一次IO系统调用等，或者手动交出控制权<code>runtime.Gosched()</code>），所以main也得不到运行了，可以看到这段程序死机了。可以看到，我是8核CPU，这个程序在执行时发生了死循环，占用CPU 738%(约等于800%)对应8个核。</p><ul><li>抢占式调度</li></ul><p><strong>Go1.14 引入了基于系统信号的抢占式调度</strong>, 在抢占式情况下，如果一个goroutine运行时间过长，它就会被剥夺运行权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ go version</span><br><span class="line">go version go1.14.5 linux/amd64</span><br><span class="line">➜ go run main.go </span><br><span class="line">[223473156 204013472 207617086 235368900 147990153 216776090 245417848 278086836 299956269 268087158]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次用1.14 的go sdk可以看到程序快速的输出了最终++的答案，抢占式下，一个goroutine不能一直占CPU不放。</p><blockquote><p>垃圾回收器是需要stop the world的。如果垃圾回收器想要运行了，那么它必须先通知其它的goroutine合作停下来，这会造成较长时间的等待时间。考虑一种很极端的情况，所有的goroutine都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。(非抢占式存在这种情况，而抢占式不存在)</p></blockquote><h3 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h3><p><strong>M，P，G</strong></p><p>Go 的调度器内部有三个十分重要的结构，M，P，G。(M&gt;P 如上个例子的 6 个M，4个P)</p><ul><li>M 表示真正的内核OS线程，和POSIX里的thread差不多，真正干活的人。</li><li>P 局部的调度器，使go代码在一个线程上跑，它是实现从N:1 （多个用户线程在一个内核线程上跑）到 N:M 映射的关键。</li><li>G 代表一个 goroutine，它有自己的栈，用于调度。</li></ul><p><img src="https://img1.kiosk007.top/static/images/coroutines/MPG.wepb"></p><p>上图表示有两个物理线程M，每个M都拥有一个context（P），每一个P上又拥有一个正在运行的G和很多等待运行的G。<br>P 的总数量可以通过 GOMAXPROCS() 设置。它表示真正的并发量，即有多少个goroutine可以同时运行。<br>上面等待的（灰色）goroutine处于ready的就绪态。而每个P都维护着一个队列（runqueue）</p><p><img src="https://img1.kiosk007.top/static/images/coroutines/MPG_block.webp"></p><p>当一个OS线程M0陷入阻塞时（如上图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。</p><p>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，<br>如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。</p><p><img src="https://img1.kiosk007.top/static/images/coroutines/MPG_banlance.webp"></p><p>某一个P所分配的任务G很快被执行完了（分配不均），这就导致一个context P 闲着，如果 global runqueue 上没有 G 了，那么它会偷其他P 的G。一般偷的话会偷一半。确保每个OS线程都能得到充分的使用。</p><blockquote><p>这段参考知乎 <a href="https://www.zhihu.com/question/20862617">Golang 的 goroutine 是如何实现的？</a> Yi Wang 的回答</p></blockquote><p>以刚才上面的代码为例。我是8核CPU，这里的线程却创建了10个线程，TID 为74261和74262 是空闲的。而实际跑的是8个线程，这对应了 20 个 G （goroutine）、10个M、8个P。<br>（如下图）<br><img src="https://img1.kiosk007.top/static/images/coroutines/goroutine_dispatch.png"></p><p>还有其他语言的异步协程库，比如python通过 syncio 包实现协程，而c++也有阿里大神多隆写的 libeasy 。但是都不如 go 的原生支持来的方便。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;协程&lt;/strong&gt; 在如今在高并发场景下最容易提到的一个技术，协程即能暂停执行以在之后恢复的函数。。下面是关于 &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/coroutines&quot;&gt;GCC11 编辑器&lt;/a&gt; 对协程的介绍 （ A coroutine is a function that can suspend execution to be resumed later. Coroutines are stackless: they suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. ）&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://kiosk007.top/categories/Linux/"/>
    
    
    <category term="golang" scheme="http://kiosk007.top/tags/golang/"/>
    
    <category term="协程" scheme="http://kiosk007.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>docker 容器技术基础</title>
    <link href="http://kiosk007.top/2020/07/11/docker-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://kiosk007.top/2020/07/11/docker-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-10T16:32:00.000Z</published>
    <updated>2020-07-10T16:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://hijiangtao.github.io/2018/04/17/Docker-in-Action/">docker</a> 容器是随着PaaS技术的普及随之诞生的，Docker公司推出了docker并通过“容器镜像”解决了容器打包的根本性难题。而容器本身没有价值，有价值的是“容器编排技术”。Docker项目则通过容器技术解决了应用打包的根本性难题。</p><a id="more"></a><hr><p>为什么在开头就放出了 “容器本身没有价值” 的大话呢？</p><p>因为容器本身只是一个沙盒技术，其使用<strong>Cgroups</strong>和<strong>Namespace</strong>技术创建出来一个隔离环境，而docker项目之所以能得到如此之高的关注也是因为他解决了应用打包和发布这个困扰运维人员的多年的技术难题。能够把应用装到集装箱内方便搬来搬去才是PaaS的最理想状态。</p><p>Docker本身所用到的隔离技术也并不是什么黑科技，都是把已有的功能翻出来拼装了一下而已。<strong>容器的本质是一个“单进程”模型，本质是一个特殊的进程而已</strong></p><blockquote><p>Docker 容器技术由 Namespace、Cgroups、rootfs 三种技术构建出,其中Namespace、Cgroups 构建了容器的动态视图（称为 运行时），rootfs构建了容器的静态视图。</p></blockquote><h1 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h1><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p><strong>Namespace</strong>是Linux很早版本就实现的一个系统调用，他可以实现新创建一个进程的时候，为这个进程创建一个沙盒，比如让新的进程以为自己是1号PID进程，或者是让自己以为自己有一个新的网卡等等。</p><p>Linux创建新进程的时候有一个可选参数，加上 <strong>CLONE_NEWPID</strong> 就可以让创建的进程拥有一个全新的进程空间，在宿主机的真实进程空间，其PID还是那个PID，但是新进程自己认为自己是当前空间里的1号进程。他们无法看到真实的进程空间。也无法看到其他Namespace里的进程空间。</p><p><code>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</code></p><p>类似的参数还有</p><ul><li><code>CLONE_NEWNS</code>: 用于指定Mount Namespace (挂载点)</li><li><code>CLONE_NEWUTS</code>: 用于指定UTS Namespace (HOSTNAME和DOMAIN)</li><li><code>CLONE_NEWIPC</code>: 用于指定IPC Namespace (共享内存、信号量和消息队列)</li><li><code>CLONE_NEWPID</code>: 用于指定PID Namespace (进程号)</li><li><code>CLONE_NEWNET</code>: 用于指定Network Namespace （网络）</li><li><code>CLONE_NEWUSER</code>: 用于指定User Namespace  （用户）</li></ul><p>用户可以在<strong>/proc/$pid/ns</strong>文件下看到本进程所属的Namespace的文件信息。</p><p>比如使用 <code>docker run -it busybox /bin/sh</code> 启动一个容器，然后在另外一个终端看到</p><p><img src="https://img1.kiosk007.top/static/images/docker/docker_namespace.png"></p><p>同样，Linux也提供了其他系统调用，可以让其他进程加入到一个Namespace中，<code>int setns(int fd, int nstype);</code>，这也为之后的联盟式容器创造了可能。即多个进程使用相同的Namespace。系统调用<code>int unshare(int flags);</code>也为相同Namespace分家提供了技术支持。</p><p>所以，Docker容器这个听起来高端大气的概念，只不过是在创建容器进程时，指定了这个进程一组Namespace参数而已。</p><p>比如我们启动了一个容器。可以使用 <code>docker exec -it xxxxx /bin/bash</code> 进入到这个容器中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 25 </span><br><span class="line">83488</span><br><span class="line"></span><br><span class="line">➜  sudo ls -l /proc/`docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 25`/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 ipc -&gt; <span class="string">&#x27;ipc:[4026532521]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 mnt -&gt; <span class="string">&#x27;mnt:[4026532519]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:14 net -&gt; <span class="string">&#x27;net:[4026532586]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 pid -&gt; <span class="string">&#x27;pid:[4026532522]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 pid_for_children -&gt; <span class="string">&#x27;pid:[4026532522]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 uts -&gt; <span class="string">&#x27;uts:[4026532520]&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个进程的所有Linux Namespace，都在/proc/[pid 进程号]/ns 下有一个虚拟文件，并且链接到真实的Namespace上。这样其他进程就可以加入一个已经存在的Namespace中。这也为了之后的pod（联盟式容器）打下基础。如 <code>docker run -it  -net container:25836f0da751  busybox ifconfig</code>。这就是起一个容器，但是network namespace 用和 258xx 这个容器用一个。</p><p><strong>Namespace的问题</strong></p><p>既然容器技术只是一个特殊的进程被隔离而已，那么其缺点就很明显了，那就是容器的<strong>“隔离不彻底”</strong>。</p><font color="red">第一，容器既然是运行在宿主机上的一种特殊进程，那么多个进程还是共享同一个操作系统的内核（注意这里是Linux 内核 ，Mac和Windows上的容器首先是运行在Docker Machine上的，说白了运行在Linux虚拟机上）</font><font color="red">第二，容器并不是所有资源都可以Namespace化的，典型的不能被Namespace的例子就是：时间</font><font color="red">第三，由于避免不了多个容器共享宿主机内核的事实，那么就意味着容器的越狱比虚拟机简单的多了，一些危险的系统调用需要被监管加固</font><p>正是上述的问题，Docker的安全性会很差，一般不会直接把Docker暴露在公网上。</p><p>Refer:</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/73248894">浅谈Linux Namesapce机制 (知乎)</a></p></blockquote><h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>上面提到容器只是一个特殊的进程而已，那么这个容器进程和宿主机上其他的普通进程是平等的。如果容器进程可以占用宿主机全部资源的话，这显然不符合沙盒技术的特征。<strong>而Cgroups则正是 Linux 内核中用来限制资源的功能。</strong> </p><p>Cgroups 的本质是给进程挂上钩子 (hooks) ,当Task的运行涉及到某个资源的时就触发钩子上所携带的subsystem检测。最终进行资源限制和优先级分配。</p><p><img src="https://img1.kiosk007.top/static/images/docker/docker-cgroups.jpg"></p><p><strong>Cgroups全称是 Linux Control Group, 他最主要的作用就是限制一个进程组能够使用的资源上限，包括CPU，内存，磁盘，网络带宽等</strong></p><p>Cgroups 给用户直接暴露出来的操作接口是文件系统，即以文件和目录的方式组织在操作系统的 <code>/sys/fs/cgroups</code> 路径下，在这个路径下有很多诸如 <code>cpuset</code>、<code>cpu</code>、<code>memory</code> 这样的子目录。这些就是当前操作系统下可以被限制的资源类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>怎么样去限制一个进程的资源呢？需要在这些目录之下再创建一个目录，如进入 <code>/sys/fs/cgroup/cpu</code> 目录下。创建目录 container 。这样一个目录，操作系统会自动在这个目录下生成子系统对应的资源限制文件。<br><img src="https://img1.kiosk007.top/static/images/docker/cgroups.png"></p><p>这下，我们创建一个死循环，将CPU吃满，记录该进程的PID。向 container 组里的 cfs_quota 文件写入 2ms，这意味着每 100ms 内的单位时间内，被该控制组限制的进程只能使用2ms的CPU时间，即只能用到2%的计算力。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># echo 2000 &gt; cpu.cfs_quota_us </span></span><br><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># echo 4918 &gt; tasks </span></span><br><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>打开htop指令可以看到刚才的死循环只有2%的CPU占用。</p><blockquote><p>实验完成后可以使用  <code>cgdelete -r cpu:container</code> 删除</p></blockquote><p>这样就可以理解 Linux Cgroups 的设计，其限制进程的方式也是简单粗暴，为一个子目录系统上添加一组资源限制文件的组合即可。在docker容器中，也可以直接通过命令来查看。</p><p><code>docker run -it --cpu-period=100000 --cpu-quota=20000 busybox /bin/sh</code></p><p><img src="https://img1.kiosk007.top/static/images/docker/cgroups_docker.png"></p><p><strong>Cgroups 的问题</strong><br>容器的Cgroups只是限制了某个进程的使用资源而已，而进程本身看到的资源还是宿主机的资源。</p><font color="red"> /proc 文件系统并不知道 Cgroups 给某个进程做了什么限制。这就会造成在容器中使用 top,free,df 等命令看到的全部是宿主机上的资源。这会给应用的运行带来非常大的困惑。</font><p>不过在生产环境，已经有 <strong><code>lxcfs</code></strong> 这样的技术可以修正这种偏差。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ apt install -y lxcfs</span><br><span class="line">$ systemctl start lxcfs</span><br><span class="line">$ docker run -it -m 500m  \</span><br><span class="line">      -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/<span class="built_in">stat</span>:/proc/<span class="built_in">stat</span>:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/swaps:/proc/swaps:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw \</span><br><span class="line">      ubuntu:19.04 /bin/bash</span><br></pre></td></tr></table></figure><br>其原理是把宿主机上的 <code>/var/lib/lxcfs/proc/meminfo</code> 文件挂载到容器的 <code>/proc/meminfo</code> 位置。</p><p>refer:<br><a href="https://cuisongliu.github.io/2019/03/docker/lxcfs/">https://cuisongliu.github.io/2019/03/docker/lxcfs/</a></p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Namespace 和 Cgroups 使这个特殊的进程看到的是隔离环境，而且使用的资源也被限制。那么这样还有一个点，就是进程看到的文件系统是什么呢？这里没有新的技术，还是最开始提到的Mount Namespace技术，拥有这项技术，可以给容器挂载一个全新、独立的文件系统。</p><p>挂载完成之后使用 <code>chroot</code> 指令, 使得新的挂载点成为进程的 <code>/</code> 路径。一般为了让这个容器的根目录更为真实，一般会给进程容器的根目录下挂载一个完整操作系统的文件系统。比如 Ubuntu19.04 的ISO。<strong>而这个挂载在容器根目录上的、用来给容器进程提供隔离后执行环境的文件系统就是 rootfs（根文件系统）</strong></p><font color="red">这里我再来强调一遍，容器是一个特殊的进程而已！！！rootfs只是操作系统所包含的文件、配置和目录，并不包含内核，内核是宿主机的内核。所以说 rootfs只是操作系统的驱壳，并没有操作系统的灵魂 </font><p>不过正是rootfs的存在，才有了容器作为PaaS的基础，一致性！开发的程序连同操作系统的整个目录环境被打包封装在一个集装箱里。真正的依赖库都放在了这个rootfs的<code>/var/lib/xxx</code> 里。</p><p>还没完，虽然这个时候已经解决了大部分问题，但是每个容器创建的时候都需要一个rootfs未免也太浪费空间了，Docker的解决方法是提出 <code>layer</code> 的概念。用户每制造出来一个镜像就生成一个层。</p><p>Linux操作系统又提供了一种联合文件系统（Union File System）的能力。<br>UFS 提供的能力是将多个目录挂载到同一个目录下，使得多个目录合并。</p><p>假设有两个目录<code>A</code>和<code>B</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│   ├── a</span><br><span class="line">│   └── x</span><br><span class="line">└── B</span><br><span class="line">    ├── b</span><br><span class="line">    └── x</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建目录<code>C</code>,并且将两个目录挂载到一个公共的目录<code>C</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir C</span><br><span class="line">$ mount -t aufs -o dirs&#x3D;.&#x2F;A:.&#x2F;B none .&#x2F;C</span><br><span class="line">$ tree C</span><br><span class="line">C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>以Docker容器为例,这个挂载点就是在 <code>/var/lib/docker/overlay2</code> 下。不出意外，这个下面拥有一个完整的ubuntu操作系统<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2# ll 6f56172222645f34f4454ecdbfd592785245dc7b68511dc49723e0591aba54a8&#x2F;diff&#x2F;</span><br><span class="line">总用量 48</span><br><span class="line">drwxr-xr-x 10 root   root     4096 7月  11 01:04 .&#x2F;</span><br><span class="line">drwx------  3 root   root     4096 7月  11 01:04 ..&#x2F;</span><br><span class="line">drwxr-xr-x  2 root   root    12288 6月  27 08:21 bin&#x2F;</span><br><span class="line">drwxr-xr-x  2 root   root     4096 6月  27 08:21 dev&#x2F;</span><br><span class="line">drwxr-xr-x  3 root   root     4096 6月  27 08:21 etc&#x2F;</span><br><span class="line">drwxr-xr-x  2 nobody nogroup  4096 6月  27 08:21 home&#x2F;</span><br><span class="line">drwx------  2 root   root     4096 6月  27 08:21 root&#x2F;</span><br><span class="line">drwxrwxrwt  2 root   root     4096 6月  27 08:21 tmp&#x2F;</span><br><span class="line">drwxr-xr-x  3 root   root     4096 6月  27 08:21 usr&#x2F;</span><br><span class="line">drwxr-xr-x  4 root   root     4096 6月  27 08:21 var&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>同时也可以看到，对应的操作系统挂载信息里面的overlay信息。可以看到最终多个目录被联合挂载到<code>/var/lib/docker/overlay2/3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1/merged</code> 上，而这个merged会最终呈现一个文件系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;mounts |grep overlay2</span><br><span class="line">overlay &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;merged overlay rw,relatime,lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;N2BLQFHN3PRM3P4BR6LYEALQN5:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FYVKPJJ3TF7THIM4Z4J2OAQTZN:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;GPBK6EICFMAEBZR5IBE6XTWPSO:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FLBZS3ORDOYOD2ECQTRUMHAUBV:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;JAFCRW5O4V3HB7PWVABFY3SLRK,upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;diff,workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;work,xino&#x3D;off 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/docker/aufs_image.png"></p><p>最下面的几层只读。上层的可写。而最上层是可读写。</p><blockquote><p>所以在运行容器的时候，只需要拉取不存在的 image layer。镜像一般完全拉下来的化需要3，4百M，一般的大厂都是采用 p2p 下载镜像，如 <a href="https://developer.aliyun.com/article/244897">阿里的蜻蜓 p2p 下载</a>。</p></blockquote><h1 id="制作Docker镜像"><a href="#制作Docker镜像" class="headerlink" title="制作Docker镜像"></a>制作Docker镜像</h1><p>使用 golang 编写一个web应用。准备一个main.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">        log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q \n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>制作Dockerfile 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.12-alpine</span><br><span class="line"></span><br><span class="line"># Set ENV</span><br><span class="line">ENV GO111MODULE&#x3D;on \</span><br><span class="line">    CGO_ENABLED&#x3D;0 \</span><br><span class="line">    GOOS&#x3D;linux \</span><br><span class="line">    GOARCH&#x3D;amd64</span><br><span class="line"></span><br><span class="line"># Set the Current Working Directory inside the container</span><br><span class="line">WORKDIR $GOPATH&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Copy all file to &#x2F;app</span><br><span class="line">ADD . $GOPATH&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Build the Go app</span><br><span class="line">RUN go build main.go</span><br><span class="line"></span><br><span class="line"># This container exposes port 8000 to the outside world</span><br><span class="line">EXPOSE 8000</span><br><span class="line"></span><br><span class="line"># Run the binary program produced by &#96;.&#x2F;main&#96;</span><br><span class="line">ENTRYPOINT [&quot;.&#x2F;main&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>制作镜像在当前目录执行<code>docker build -t hello .</code><br>run 起来该容器<code>docker run -p 8000:8000 hello</code></p><h2 id="上传到-docker-hub"><a href="#上传到-docker-hub" class="headerlink" title="上传到 docker hub"></a>上传到 docker hub</h2><p>在docker hub 上创建一个 docker 账号&lt;/br&gt;<br>使用 <code>docker login</code> 登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为容器起一个完整的名字。</span></span><br><span class="line">docker tag helloworld your-docker-id/helloworld:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传到docker hub 上</span></span><br><span class="line">docker push your-docker-id/helloworld:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器中新建文件</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 29038er849jsa /bin/sh</span><br><span class="line">touch tmp.file</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新建的内容提交</span></span><br><span class="line">docker commit 29038er849jsa your-docker-id/helloworld:v2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://hijiangtao.github.io/2018/04/17/Docker-in-Action/&quot;&gt;docker&lt;/a&gt; 容器是随着PaaS技术的普及随之诞生的，Docker公司推出了docker并通过“容器镜像”解决了容器打包的根本性难题。而容器本身没有价值，有价值的是“容器编排技术”。Docker项目则通过容器技术解决了应用打包的根本性难题。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://kiosk007.top/categories/docker/"/>
    
    
    <category term="devops" scheme="http://kiosk007.top/tags/devops/"/>
    
    <category term="docker" scheme="http://kiosk007.top/tags/docker/"/>
    
    <category term="k8s" scheme="http://kiosk007.top/tags/k8s/"/>
    
  </entry>
  
</feed>
