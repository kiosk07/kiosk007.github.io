<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kiosk007&#39;s Blog</title>
  
  <subtitle>专注 量变产生质变!</subtitle>
  <link href="http://kiosk007.top/atom.xml" rel="self"/>
  
  <link href="http://kiosk007.top/"/>
  <updated>2021-11-20T08:38:41.000Z</updated>
  <id>http://kiosk007.top/</id>
  
  <author>
    <name>kiosk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>项目管理--编写Golang MakeFile</title>
    <link href="http://kiosk007.top/2021/11/20/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%BC%96%E5%86%99Golang-MakeFile/"/>
    <id>http://kiosk007.top/2021/11/20/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%BC%96%E5%86%99Golang-MakeFile/</id>
    <published>2021-11-20T08:38:41.000Z</published>
    <updated>2021-11-20T08:38:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要先编译，那些文件需要后编译，那些文件需要重建等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，Makefile 可以使得我们的项目工程的编译变得自动化，不需要每次都手动输入一堆源文件和参数。</p><a id="more"></a><blockquote><p>参考：《孔令飞老师的 Go语言开发实战》</p></blockquote><p>以 Linux 下的C语言开发为例来具体说明一下，多文件编译生成一个文件，编译的命令如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o outfile name1.c name2.c ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>outfile 要生成的可执行程序的名字，nameN.c 是源文件的名字。</p><p>下面列举了一些需要我们手动链接的标准库：</p><ul><li>name1.c 用到了数学计算库 math 中的函数，我们得手动添加参数 -Im；</li><li>name4.c 用到了小型数据库 SQLite 中的函数，我们得手动添加参数 -lsqlite3；</li><li>name5.c 使用到了线程，我们需要去手动添加参数 -lpthread。</li></ul><h1 id="Make-语法"><a href="#Make-语法" class="headerlink" title="Make 语法"></a>Make 语法</h1><p>编写高质量 Makefile 的第一步，便是熟练掌握 Makefile 的核心语法。<br>这里可以参考 <a href="https://github.com/seisman/how-to-write-makefile">《跟我一起写Makefile (PDF重制版)》</a>、<a href="http://c.biancheng.net/view/7097.html">Makefile 教程</a></p><p>makefile 完整案例<a href="https://github.com/marmotedu/iam/blob/master/Makefile">IAM Makefile</a></p><p>makefile 的基本写法如下图，由 <code>target</code>,<code>dependencies</code>,<code>command</code>（command前必须是 tab 键） 组成<br><img src="https://img1.kiosk007.top/static/images/makefile/grammar1.png"></p><ul><li><code>target</code>：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；</li><li><code>dependencies</code>：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</li><li><code>command</code>：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li></ul><p>一个最基本的 golang Makefile 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">build: clean vet</span></span><br><span class="line">  @mkdir -p ./Role</span><br><span class="line">  @<span class="keyword">export</span> GOOS=linux &amp;&amp; go build -v .</span><br><span class="line"></span><br><span class="line"><span class="section">vet:</span></span><br><span class="line">  go vet ./...</span><br><span class="line"></span><br><span class="line"><span class="section">fmt:</span></span><br><span class="line">  go fmt ./...</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  rm -rf dashboard</span><br></pre></td></tr></table></figure><blockquote><p>shell 命令行前的 @ 是为了防止回显，否则会将 <code>mkdir -p ./Role</code>输出出来再执行</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ==============================================================================</span></span><br><span class="line"><span class="comment"># Usage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> USAGE_OPTIONS</span><br><span class="line"></span><br><span class="line"><span class="section">Options:</span></span><br><span class="line">  DEBUG        Whether to generate debug symbols. Default is 0.</span><br><span class="line">  BINS         The binaries to build. Default is all of cmd.</span><br><span class="line">               This option is available when using: make </span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"><span class="keyword">export</span> USAGE_OPTIONS</span><br><span class="line"></span><br><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">@<span class="variable">$(MAKE)</span> go.build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## help: Show this help info.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: help</span></span><br><span class="line"><span class="section">help: Makefile</span></span><br><span class="line">@echo -e <span class="string">&quot;\nUsage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...\n\nTargets:&quot;</span></span><br><span class="line">@sed -n &#x27;s/^<span class="comment">##//p&#x27; $&lt; | column -t -s &#x27;:&#x27; | sed -e &#x27;s/^/ /&#x27;</span></span><br><span class="line">@echo <span class="string">&quot;$$USAGE_OPTIONS&quot;</span></span><br></pre></td></tr></table></figure><p>这个进阶的Makefile有以下知识点</p><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>所谓的伪目标可以这样来理解，它并不会创建目标文件，只是想去执行这个目标下面的命令。伪目标的存在可以帮助我们找到命令并执行。</p><p>特殊的标记 “.PHONY” 来显式地指明一个目标是“伪目标”，“.PHONY” 标记的target可以理解成一个无条件执行的动作。<br>这样就可以执行 <code>make help</code> 命令了。</p><p>使用<code>伪目标</code>主要有2个原因：</p><ol><li>避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。</li><li>提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。</li></ol><p>如下命令：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o test</span><br></pre></td></tr></table></figure><p>规则中 rm 命令不是创建文件 clean 的命令，而是执行删除任务，删除当前目录下的所有的 .o 结尾和文件名为 test 的文件。当工作目录下不存在以 clean 命令的文件时，在 shell 中输入 make clean 命令，命令 rm -rf *.o test 总会被执行 ，这也是我们期望的结果。</p><p>如果当前目录下存在文件名为  clean 的文件时情况就会不一样了，当我们在 shell 中执行命令 make clean，由于这个规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令。因此命令 rm 将不会被执行。为了解决这个问题，删除 clean 文件或者是在 Makefile 中将目标 clean 声明为伪目标。将一个目标声明称伪目标的方法是将它作为特殊的目标.PHONY的依赖，比如 <code>.PHONY:clean</code></p><h2 id="自动化变量-Automatic-Variables）"><a href="#自动化变量-Automatic-Variables）" class="headerlink" title="自动化变量 (Automatic Variables）"></a>自动化变量 (Automatic Variables）</h2><p>help 后面跟了一个文件 <code>Makefile</code>, 没错！就是help会将<code>Makefile</code> 当成参数。help 后面里有几个 $$$$、<code>$&lt;</code> 变量</p><p><code>$&lt;</code> 可以引用 Makefile 当成参数。没错，上述的命令展开就是 <code>sed -n &#39;s/^##//p&#39; Makefile | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39;</code>。<br>其实是将整个 <code>Makefile</code> 中的双井号解析成帮助命令。</p><div class="table-container"><table><thead><tr><th style="text-align:left">自动化变量</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">$@</td><td style="text-align:left">表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成.a文件为文档文件，也成为静态的库文件），那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td></tr><tr><td style="text-align:left">$%</td><td style="text-align:left">当目标文件是一个静态库文件时，代表静态库的一个成员名。</td></tr><tr><td style="text-align:left">$&lt;</td><td style="text-align:left">规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td></tr><tr><td style="text-align:left">$?</td><td style="text-align:left">所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td></tr><tr><td style="text-align:left">$^</td><td style="text-align:left">代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件</td></tr><tr><td style="text-align:left">$+</td><td style="text-align:left">类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td></tr></tbody></table></div><p>举个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o test1.o test2.o</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">test.o:test.c test.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">test1.o:test1.c test1.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">test2.o:test2.c test2.h</span></span><br><span class="line">         gcc -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>这个规则模式中用到了 “$@” 、”$&lt;” 和 “$^” 这三个自动化变量，对比之前写的 Makefile 中的命令，我们可以发现</p><ul><li>“$@” 代表的是目标文件test</li><li>“$^”代表的是依赖的文件</li><li>“$&lt;”代表的是依赖文件中的第一个。</li></ul><p>我们在执行 make 的时候，make 会自动识别命令中的自动化变量，并自动实现自动化变量中的值的替换，这个类似于编译C语言文件的时候的预处理的作用。</p><h2 id="内置变量（Implicit-Variables）"><a href="#内置变量（Implicit-Variables）" class="headerlink" title="内置变量（Implicit Variables）"></a>内置变量（Implicit Variables）</h2><p>上面的实例中有这样一个表达式 </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">@<span class="variable">$(MAKE)</span> go.build</span><br></pre></td></tr></table></figure><p>Make命令提供一系列内置变量，（感觉上和gcc/g++的预定义宏差不多）比如，<code>$(CC)</code> 指向当前使用的编译器，<code>$(MAKE)</code> 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册</a>。</p><hr><p>看下面的例子，其是一个 <code>common.mk</code> 提供一些 Makefile 文件调用时的基础变量环境。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SHELL := /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># include the common make file</span></span><br><span class="line">COMMON_SELF_DIR := <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> ROOT_DIR)</span>,undefined)</span><br><span class="line">ROOT_DIR := <span class="variable">$(<span class="built_in">abspath</span> $(<span class="built_in">shell</span> cd <span class="variable">$(COMMON_SELF_DIR)</span>/../.. &amp;&amp; pwd -P)</span>)</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> OUTPUT_DIR)</span>,undefined)</span><br><span class="line">OUTPUT_DIR := <span class="variable">$(ROOT_DIR)</span>/_output</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(OUTPUT_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> TOOLS_DIR)</span>,undefined)</span><br><span class="line">TOOLS_DIR := <span class="variable">$(OUTPUT_DIR)</span>/tools</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(TOOLS_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> TMP_DIR)</span>,undefined)</span><br><span class="line">TMP_DIR := <span class="variable">$(OUTPUT_DIR)</span>/tmp</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(TMP_DIR)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子有以下几个知识点，<code>:=</code>、<code>ifeq</code>、<code>$()</code> 等。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>先说变量，变量对于我们来说是不陌生的，在学习各种编程语言时会经常用到。就拿C语言来说，变量的使用是十分常见的，变量可以用来保存一个值或者是使用变量进行运算操作。</p><p>调用变量的时候可以用 “$(VALUE_LIST)” 或者是 “${VALUE_LIST}” 来替换，这就是变量的引用。实例：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJ=main.o test.o test1.o test2.o</span><br><span class="line"><span class="section">test:<span class="variable">$(OBJ)</span></span></span><br><span class="line">      gcc -o test <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><br><strong>变量的基本赋值</strong><br>知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：</p><ul><li>简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。</li><li>递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。</li><li>条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。</li><li>追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。</li></ul><p>其中的简单赋值和条件赋值比较简单字面意思就可以理解，下面介绍一下另外两种。<br><strong>递归赋值</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=foo</span><br><span class="line">y=<span class="variable">$(x)</span>b</span><br><span class="line">x=new</span><br><span class="line">test：</span><br><span class="line">      @echo <span class="string">&quot;y=&gt;<span class="variable">$(y)</span>&quot;</span></span><br><span class="line">      @echo <span class="string">&quot;x=&gt;<span class="variable">$(x)</span>&quot;</span></span><br><span class="line"><span class="comment">## 执行结果</span></span><br><span class="line"><span class="comment">## y=&gt;newb</span></span><br><span class="line"><span class="comment">## x=&gt;new</span></span><br></pre></td></tr></table></figure><p><strong>追加赋值</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x:=foo</span><br><span class="line">y:=<span class="variable">$(x)</span>b</span><br><span class="line">x+=<span class="variable">$(y)</span></span><br><span class="line">test：</span><br><span class="line">      @echo <span class="string">&quot;y=&gt;<span class="variable">$(y)</span>&quot;</span></span><br><span class="line">      @echo <span class="string">&quot;x=&gt;<span class="variable">$(x)</span>&quot;</span></span><br><span class="line"><span class="comment">## 执行结果</span></span><br><span class="line"><span class="comment">## y=&gt;foob</span></span><br><span class="line"><span class="comment">## x=&gt;foo foob</span></span><br></pre></td></tr></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句只能用于控制 make 实际执行的 Makefile 文件部分，不能控制规则的 shell 命令执行的过程。</p><div class="table-container"><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ifeq</td><td style="text-align:left">判断参数是否不相等，相等为 true，不相等为 false</td></tr><tr><td style="text-align:left">ifneq</td><td style="text-align:left">判断参数是否不相等，不相等为 true，相等为 false</td></tr><tr><td style="text-align:left">ifeq</td><td style="text-align:left">判断是否有值，有值为 true，没有值为 false</td></tr><tr><td style="text-align:left">ifneq</td><td style="text-align:left">判断是否有值，没有值为 true，有值为 false</td></tr></tbody></table></div><h1 id="Makefile-要实现的功能"><a href="#Makefile-要实现的功能" class="headerlink" title="Makefile 要实现的功能"></a>Makefile 要实现的功能</h1><p>对于 Go 项目来说，虽然不同项目集成的功能不一样，但绝大部分项目都需要实现一些通用的功能。接下来，我们就来看看，在一个大型 Go 项目中 Makefile 通常可以实现的功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ make <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...</span><br><span class="line"></span><br><span class="line">Targets:</span><br><span class="line">  <span class="comment"># 代码生成类命令</span></span><br><span class="line">  gen                Generate all necessary files, such as error code files.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 格式化类命令</span></span><br><span class="line">  format             Gofmt (reformat) package sources (exclude vendor dir <span class="keyword">if</span> existed).</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 静态代码检查</span></span><br><span class="line">  lint               Check syntax and styling of go sources.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 测试类命令</span></span><br><span class="line">  <span class="built_in">test</span>               Run unit <span class="built_in">test</span>.</span><br><span class="line">  cover              Run unit <span class="built_in">test</span> and get <span class="built_in">test</span> coverage.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构建类命令</span></span><br><span class="line">  build              Build <span class="built_in">source</span> code <span class="keyword">for</span> host platform.</span><br><span class="line">  build.multiarch    Build <span class="built_in">source</span> code <span class="keyword">for</span> multiple platforms. See option PLATFORMS.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Docker镜像打包类命令</span></span><br><span class="line">  image              Build docker images <span class="keyword">for</span> host arch.</span><br><span class="line">  image.multiarch    Build docker images <span class="keyword">for</span> multiple platforms. See option PLATFORMS.</span><br><span class="line">  push               Build docker images <span class="keyword">for</span> host arch and push images to registry.</span><br><span class="line">  push.multiarch     Build docker images <span class="keyword">for</span> multiple platforms and push images to registry.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 部署类命令</span></span><br><span class="line">  deploy             Deploy updated components to development env.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 清理类命令</span></span><br><span class="line">  clean              Remove all files that are created by building.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 其他命令，不同项目会有区别</span></span><br><span class="line">  release            Release project</span><br><span class="line">  verify-copyright   Verify the boilerplate headers <span class="keyword">for</span> all files.</span><br><span class="line">  ca                 Generate CA files <span class="keyword">for</span> all project components.</span><br><span class="line">  install            Install project system with all its components.</span><br><span class="line">  swagger            Generate swagger document.</span><br><span class="line">  tools              install dependent tools.</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 帮助命令</span></span><br><span class="line">  <span class="built_in">help</span>               Show this <span class="built_in">help</span> info.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项</span></span><br><span class="line">Options:</span><br><span class="line">  DEBUG        Whether to generate debug symbols. Default is 0.</span><br><span class="line">  BINS         The binaries to build. Default is all of cmd.</span><br><span class="line">               This option is available when using: make build/build.multiarch</span><br><span class="line">               Example: make build BINS=<span class="string">&quot;iam-apiserver iam-authz-server&quot;</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>通常而言，Go 项目的 Makefile 应该实现以下功能：<strong>格式化代码</strong>、<strong>静态代码检查</strong>、<strong>单元测试</strong>、<strong>代码构建</strong>、<strong>文件清理</strong>、<strong>帮助</strong>等等。如果通过 docker 部署，还需要有 <strong>docker镜像打包</strong>功能。因为 Go 是跨平台的语言，所以构建和 docker 打包命令，还要能够支持不同的 CPU 架构和平台。为了能够更好地控制 Makefile 命令的行为，还需要支持 Options。</p><p>为了方便查看 Makefile 集成了哪些功能，我们需要支持 help 命令。help 命令最好通过解析 Makefile 文件来输出集成的功能，例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## help: Show this help info.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: help</span></span><br><span class="line"><span class="section">help: Makefile</span></span><br><span class="line">  @echo -e <span class="string">&quot;\nUsage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...\n\nTargets:&quot;</span></span><br><span class="line">  @sed -n &#x27;s/^<span class="comment">##//p&#x27; $&lt; | column -t -s &#x27;:&#x27; | sed -e &#x27;s/^/ /&#x27;</span></span><br><span class="line">  @echo <span class="string">&quot;$$USAGE_OPTIONS&quot;</span></span><br></pre></td></tr></table></figure><h1 id="设计合理的-Makefile-结构"><a href="#设计合理的-Makefile-结构" class="headerlink" title="设计合理的 Makefile 结构"></a>设计合理的 Makefile 结构</h1><p>对于大型项目来说，需要管理的内容很多，所有管理功能都集成在一个 Makefile 中，可能会导致 Makefile 很大，难以阅读和维护，所以建议采用分层的设计方法，根目录下的 Makefile 聚合所有的 Makefile 命令，具体实现则按功能分类，放在另外的 Makefile 中。</p><p><img src="https://img1.kiosk007.top/static/images/makefile/makefile_struct.webp"></p><p>在上面的 Makefile 组织方式中，根目录下的 Makefile 聚合了项目所有的管理功能，这些管理功能通过 Makefile 伪目标的方式实现。同时，还将这些伪目标进行分类，把相同类别的伪目标放在同一个 Makefile 中，这样可以使得 Makefile 更容易维护。对于复杂的命令，则编写成独立的 shell 脚本，并在 Makefile 命令中调用这些 shell 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">├── Makefile</span><br><span class="line">├── scripts</span><br><span class="line">│   ├── gendoc.sh</span><br><span class="line">│   ├── make-rules</span><br><span class="line">│   │   ├── gen.mk</span><br><span class="line">│   │   ├── golang.mk</span><br><span class="line">│   │   ├── image.mk</span><br><span class="line">│   │   └── ...</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure><p>为了跟 Makefile 的层级相匹配，golang.mk 中的所有目标都按go.xxx这种方式命名。通过这种命名方式，我们可以很容易分辨出某个目标完成什么功能，放在什么文件里，这在复杂的 Makefile 中尤其有用。例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/golang.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/image.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/gen.mk</span><br><span class="line"><span class="keyword">include</span> scripts/make-rules/...</span><br><span class="line"></span><br><span class="line"><span class="comment">## build: Build source code for host platform.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> go.build</span><br><span class="line"></span><br><span class="line"><span class="comment">## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build.multiarch</span></span><br><span class="line"><span class="section">build.multiarch:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> go.build.multiarch</span><br><span class="line"></span><br><span class="line"><span class="comment">## image: Build docker images for host arch.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: image</span></span><br><span class="line"><span class="section">image:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> image.build</span><br><span class="line"></span><br><span class="line"><span class="comment">## push: Build docker images for host arch and push images to registry.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: push</span></span><br><span class="line"><span class="section">push:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> image.push</span><br><span class="line"></span><br><span class="line"><span class="comment">## ca: Generate CA files for all iam components.</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: ca</span></span><br><span class="line"><span class="section">ca:</span></span><br><span class="line">  @<span class="variable">$(MAKE)</span> gen.ca</span><br></pre></td></tr></table></figure><h1 id="掌握-Makefile-编写技巧"><a href="#掌握-Makefile-编写技巧" class="headerlink" title="掌握 Makefile 编写技巧"></a>掌握 Makefile 编写技巧</h1><h2 id="技巧-1：善用通配符和自动变量"><a href="#技巧-1：善用通配符和自动变量" class="headerlink" title="技巧 1：善用通配符和自动变量"></a>技巧 1：善用通配符和自动变量</h2><p>Makefile 允许对目标进行类似正则运算的匹配，主要用到的通配符是%。通过使用通配符，可以使不同的目标使用相同的规则，从而使 Makefile 扩展性更强，也更简洁。</p><p>这里，我们来看一个具体的例子，tools.verify.%（位于<a href="https://github.com/marmotedu/iam/blob/master/scripts/make-rules/tools.mk#L17">scripts/make-rules/tools.mk</a>文件中）定义如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TOOLS ?=<span class="variable">$(BLOCKER_TOOLS)</span> <span class="variable">$(CRITICAL_TOOLS)</span> <span class="variable">$(TRIVIAL_TOOLS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: tools.install</span></span><br><span class="line"><span class="section">tools.install: $(addprefix tools.install., <span class="variable">$(TOOLS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: tools.install.%</span></span><br><span class="line"><span class="section">tools.install.%:</span></span><br><span class="line">@echo <span class="string">&quot;===========&gt; Installing <span class="variable">$*</span>&quot;</span></span><br><span class="line">@<span class="variable">$(MAKE)</span> install.<span class="variable">$*</span></span><br><span class="line"></span><br><span class="line"><span class="section">tools.verify.%:</span></span><br><span class="line">@if ! which <span class="variable">$*</span> &amp;&gt;/dev/null; then <span class="variable">$(MAKE)</span> tools.install.<span class="variable">$*</span>; fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>make tools.verify.swagger</code>, <code>make tools.verify.mockgen</code>等均可以使用上面定义的规则，%分别代表了<code>swagger</code>和<code>mockgen</code>。</p><p>如果执行了 <code>make install</code> , 则执行的逻辑是，将执行<code>$(addprefix tools.install., $(TOOLS))</code> 这个命令的意思这时执行 <code>tools.install</code>,进一步拼装了一系列的<code>tools.install.xxxxxx</code> 并执行。</p><p>如果不使用<code>%</code>，则我们需要分别为<code>tools.verify.swagger</code>和<code>tools.verify.mockgen</code>定义规则，很麻烦，后面修改也困难。</p><p>另外，这里也能看出<code>tools.verify.%</code>这种命名方式的好处：tools 说明依赖的定义位于scripts/make-rules/tools.mk Makefile 中；verify说明tools.verify.%伪目标属于 verify 分类，主要用来验证工具是否安装。通过这种命名方式，你可以很容易地知道目标位于哪个 Makefile 文件中，以及想要完成的功能。另外，上面的定义中还用到了自动变量<code>$*</code>，用来指代被匹配的值<code>swagger、mockgen</code>。</p><h2 id="技巧-2：善用函数"><a href="#技巧-2：善用函数" class="headerlink" title="技巧 2：善用函数"></a>技巧 2：善用函数</h2><p>Makefile 自带的函数能够帮助我们实现很多强大的功能。所以，在我们编写 Makefile 的过程中，如果有功能需求，可以优先使用这些函数。我把常用的函数以及它们实现的功能整理在了 <a href="https://github.com/marmotedu/geekbang-go/blob/master/makefile/Makefile%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md">Makefile 常用函数列表</a> 中</p><h2 id="技巧-3：依赖需要用到的工具"><a href="#技巧-3：依赖需要用到的工具" class="headerlink" title="技巧 3：依赖需要用到的工具"></a>技巧 3：依赖需要用到的工具</h2><p>如果 Makefile 某个目标的命令中用到了某个工具，可以将该工具放在目标的依赖中。这样，当执行该目标时，就可以指定检查系统是否安装该工具，如果没有安装则自动安装，从而实现更高程度的自动化。例如，/Makefile 文件中，format 伪目标，定义如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: format</span></span><br><span class="line"><span class="section">format: tools.verify.golines tools.verify.goimports</span></span><br><span class="line">  @echo <span class="string">&quot;===========&gt; Formating codes&quot;</span></span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> gofmt -s -w</span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> goimports -w -local <span class="variable">$(ROOT_PACKAGE)</span></span><br><span class="line">  @<span class="variable">$(FIND)</span> -type f -name &#x27;*.go&#x27; | <span class="variable">$(XARGS)</span> golines -w --max-len=120 --reformat-tags --shorten-comments --ignore-generated .</span><br></pre></td></tr></table></figure><p>可以看到，format 依赖tools.verify.golines tools.verify.goimports。我们再来看下tools.verify.golines的定义：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">tools.verify.%:</span></span><br><span class="line">  @if ! which <span class="variable">$*</span> &amp;&gt;/dev/null; then <span class="variable">$(MAKE)</span> tools.install.<span class="variable">$*</span>; fi</span><br></pre></td></tr></table></figure><p>通过<code>tools.verify.%</code>规则定义，我们可以知道，<code>tools.verify.%</code>会先检查工具是否安装，如果没有安装，就会执行<code>tools.install.$*</code>来安装。如此一来，当我们执行<code>tools.verify.%</code>目标时，如果系统没有安装 golines 命令，就会自动调用go get安装，提高了 Makefile 的自动化程度。</p><h2 id="编写可扩展的-Makefile"><a href="#编写可扩展的-Makefile" class="headerlink" title="编写可扩展的 Makefile"></a>编写可扩展的 Makefile</h2><p>举个例子，执行 <code>make go.build</code> 时能够构建 cmd/ 目录下的所有组件，也就是说，当有新组件添加时， <code>make go.build</code> 仍然能够构建新增的组件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COMMANDS ?= <span class="variable">$(<span class="built_in">filter</span>-out %.md, $(<span class="built_in">wildcard</span> $&#123;ROOT_DIR&#125;/cmd/*)</span>)</span><br><span class="line">BINS ?= <span class="variable">$(<span class="built_in">foreach</span> cmd,$&#123;COMMANDS&#125;,$(<span class="built_in">notdir</span> $&#123;cmd&#125;)</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: go.build</span></span><br><span class="line"><span class="section">go.build: go.build.verify $(addprefix go.build., $(addprefix <span class="variable">$(PLATFORM)</span>., <span class="variable">$(BINS)</span>))</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: go.build.%               </span></span><br><span class="line"></span><br><span class="line"><span class="section">go.build.%:             </span></span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> COMMAND := $(<span class="built_in">word</span> 2,$(<span class="built_in">subst</span> ., ,<span class="variable">$*</span>)</span>))</span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> PLATFORM := $(<span class="built_in">word</span> 1,$(<span class="built_in">subst</span> ., ,<span class="variable">$*</span>)</span>))</span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> OS := $(<span class="built_in">word</span> 1,$(<span class="built_in">subst</span> _, ,<span class="variable">$(PLATFORM)</span>)</span>))           </span><br><span class="line">  <span class="variable">$(<span class="built_in">eval</span> ARCH := $(<span class="built_in">word</span> 2,$(<span class="built_in">subst</span> _, ,<span class="variable">$(PLATFORM)</span>)</span>))                         </span><br><span class="line">  @echo <span class="string">&quot;===========&gt; Building binary <span class="variable">$(COMMAND)</span> <span class="variable">$(VERSION)</span> for <span class="variable">$(OS)</span> <span class="variable">$(ARCH)</span>&quot;</span></span><br><span class="line">  @mkdir -p <span class="variable">$(OUTPUT_DIR)</span>/platforms/<span class="variable">$(OS)</span>/<span class="variable">$(ARCH)</span></span><br><span class="line">  @CGO_ENABLED=0 GOOS=<span class="variable">$(OS)</span> GOARCH=<span class="variable">$(ARCH)</span> <span class="variable">$(GO)</span> build <span class="variable">$(GO_BUILD_FLAGS)</span> -o <span class="variable">$(OUTPUT_DIR)</span>/platforms/<span class="variable">$(OS)</span>/<span class="variable">$(ARCH)</span>/<span class="variable">$(COMMAND)</span><span class="variable">$(GO_OUT_EXT)</span> <span class="variable">$(ROOT_PACKAGE)</span>/cmd/<span class="variable">$(COMMAND)</span></span><br></pre></td></tr></table></figure><p>当执行make go.build 时，会执行 go.build 的依赖 <code>$(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS)))</code> , <code>addprefix</code>函数最终返回字符串 <code>go.build.linux_amd64.iamctl go.build.linux_amd64.iam-authz-server go.build.linux_amd64.iam-apiserver ...</code>，这时候就会执行 <code>go.build.%</code> 伪目标。在 <code>go.build.%</code>伪目标中，通过 <code>eval</code>、<code>word</code>、<code>subst</code> 函数组合，算出了 COMMAND 的值 <code>iamctl/iam-apiserver/iam-authz-server/...</code>，最终通过 <code>$(ROOT_PACKAGE)/cmd/$(COMMAND)</code> 定位到需要构建的组件的 main 函数所在目录。</p><p>通过以下方法可以获取到 cmd 下所有的组件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS ?= $(filter-out %.md, $(wildcard <span class="variable">$&#123;ROOT_DIR&#125;</span>/cmd/*))</span><br><span class="line">BINS ?= $(foreach cmd,<span class="variable">$&#123;COMMANDS&#125;</span>,$(notdir <span class="variable">$&#123;cmd&#125;</span>))</span><br></pre></td></tr></table></figure><p>接着，通过使用通配符和自动变量，自动匹配到go.build.linux_amd64.iam-authz-server 这类伪目标并构建。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要先编译，那些文件需要后编译，那些文件需要重建等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，Makefile 可以使得我们的项目工程的编译变得自动化，不需要每次都手动输入一堆源文件和参数。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Service Mesh 是什么？</title>
    <link href="http://kiosk007.top/2021/09/19/Service-Mesh-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://kiosk007.top/2021/09/19/Service-Mesh-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2021-09-19T03:40:25.000Z</published>
    <updated>2021-09-19T03:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面是摘自维基百科的一段话。</p><blockquote><p>微服务 (Microservices) 是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic) 的 API 集相互通信。</p></blockquote><p>看起来过于抽象，Service Mesh 在我看来，就是如何处理服务于服务之间的关系，如服务之间的相互调用关系，核心服务的熔断等，这不仅不含一个普通的 A 服务对 B 服务的一次 RPC 调用，也涉及RPC调用时具体的超时时间、重试次数等细节。最终目的是让整个服务形成一张网一般。而开发人员只需要注重自己的业务逻辑开发，而服务之间的联系全部交给 Service Mesh。</p><p>想象一下，你的代码不再需要考虑各种超时逻辑、也不需要考虑熔断和集成各种底层网络库。你的代码只有业务本身。</p><a id="more"></a><h1 id="Service-Mesh-的概念"><a href="#Service-Mesh-的概念" class="headerlink" title="Service Mesh 的概念"></a>Service Mesh 的概念</h1><p>微服务的架构特性</p><ol><li>特点一：围绕业务构建团队</li></ol><p>在最开始的时候，可能公司分为 前端RD、后端RD、数据库DBA、运维OPS，整个公司的全部前端服务全部交由前端RD开发，后端代码逻辑全部交由后端RD开发。比如互联网一部负责整个商城系统开发，商城系统服务本身错综复杂，但是大家写的代码都会部署到一起，是个单体服务。</p><p>微服务的诞生打破了这个结构。比如商城系统被拆分成了 售卖组、商品直播组、安全组、售后组等等，每个组自身有后端和前端开发，每个组专注于自身业务。每个组的业务本身也是分离的，互不影响。</p><p>这样的好处是服务彼此独立，独立部署，没有依赖，比如售卖组的业务量大，售卖组的服务可以多部署几份。售后组的服务少部署几份。</p><p><img src="https://img1.kiosk007.top/static/images/service_mesh/feature1.png"></p><ol><li>特点二：去中心化的数据管理</li></ol><p>由于业务部署的独立，数据库也会面临一定的拆分，比如每个业务用到的数据库 database 是不同的库，业务自身使用的是不同的表。</p><p><img src="https://img1.kiosk007.top/static/images/service_mesh/feature2.png"></p><p>为了满足上述的业务服务越拆越细的需求。微服务的概念便出现，随之微服务的几个核心便是<code>服务注册\发现</code>,<code>路由\流量转移</code>,<code>弹性能力、熔断、超时</code>,<code>安全</code>,<code>可链路追踪\监控</code>，而这些核心的实现便是 <strong>Service Mesh</strong></p><p>Service Mesh 发展至今，从最开始的“原始通信时代” 到依托于K8S的“SideCar”模式才发展成了真正的 Service Mesh</p><p><img src="https://img1.kiosk007.top/static/images/service_mesh/history.png"></p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/61901608">什么是 Service Mesh</a></li></ul><h1 id="istlo"><a href="#istlo" class="headerlink" title="istlo"></a>istlo</h1><p>istlo 是什么？</p><blockquote><p>Istio 提供一种简单的方式来为已部署的服务建立网络，该网络具有负载均衡、服务间认证、监控等功能，而不需要对服务的代码做任何改动。</p></blockquote><ul><li>istio 适用于容器或虚拟机环境（特别是 k8s），兼容异构架构。</li><li>istio 使用 sidecar（边车模式）代理服务的网络，不需要对业务代码本身做任何的改动。</li><li>HTTP、gRPC、WebSocket 和 TCP 流量的自动负载均衡。</li><li>istio 通过丰富的路由规则、重试、故障转移和故障注入，可以对流量行为进行细粒度控制；支持访问控制、速率限制和配额。</li><li>istio 对出入集群入口和出口中所有流量的自动度量指标、日志记录和跟踪。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装教程参考官方 (<a href="https://istio.io/latest/zh/docs/setup/getting-started/">https://istio.io/latest/zh/docs/setup/getting-started/</a>), 不过网站似乎国内打不开，下面演示一下 。</p><ul><li><strong>准备 Kubernetes 环境</strong></li></ul><p>kubernetes 环境版本：v1.21.4</p><p>安装方法参考：<a href="https://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/">ubuntu20.04 部署 Kubernetes (k8s)</a></p><ul><li><strong>下载 istio</strong></li></ul><p>下载针对你操作系统的安装文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;istio&#x2F;istio&#x2F;master&#x2F;release&#x2F;downloadIstioCandidate.sh | sh -</span><br></pre></td></tr></table></figure><br>如果想要指定版本、不同处理器体系则可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;istio&#x2F;istio&#x2F;master&#x2F;release&#x2F;downloadIstioCandidate.sh | ISTIO_VERSION&#x3D;1.6.8 TARGET_ARCH&#x3D;x86_64  sh -</span><br></pre></td></tr></table></figure><p>转到istio的目录。例如 istio-1.11.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd istio-1.11.2</span><br></pre></td></tr></table></figure><br>安装目录包含: <code>samples/</code> 目录下的示例应用程序 和 <code>bin/</code> 目录下的 <code>istioctl</code>客户端二进制工具。可将 <code>istioctl</code> 加入到 PATH 中。</p><ul><li><strong>安装 istio</strong></li></ul><p>istio本身提供不同模式的 <code>Configuration Profile</code></p><p><img src="https://img1.kiosk007.top/static/images/service_mesh/configuration.png"></p><p>对于本次安装，我们选择 <code>demo</code> 模式，这个是专门为了展示和学习而准备的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl install --set profile&#x3D;demo -y</span><br><span class="line">✔ Istio core installed                                                                                                                                                          </span><br><span class="line">✔ Istiod installed                                                                                                                                                              </span><br><span class="line">✔ Ingress gateways installed                                                                                                                                                    </span><br><span class="line">✔ Egress gateways installed                                                                                                                                                     </span><br><span class="line">✔ Installation complete                                                                                                                                                         </span><br><span class="line">Thank you for installing Istio 1.11.  Please take a few minutes to tell us about your install&#x2F;upgrade experience!  https:&#x2F;&#x2F;forms.gle&#x2F;kWULBRjUv7hHci7T6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给 namespace 添加标签，指示istio在部署应用时自动注入 envoy sidecar 代理。可以简单的理解为当部署应用清单时，它会帮你改写清单，把具体的sidecar配置给你添加进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label namespace default istio-injection&#x3D;enabled</span><br></pre></td></tr></table></figure><p>查看istio部署的pods</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istio-egressgateway-6cb7bdc7fb-8h2n6    1&#x2F;1     Running   0          6m15s</span><br><span class="line">istio-ingressgateway-694d8d7656-z4ccc   1&#x2F;1     Running   0          6m15s</span><br><span class="line">istiod-6c68579c55-lmp8r                 1&#x2F;1     Running   0          7m</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="部署-bookinfo-应用"><a href="#部署-bookinfo-应用" class="headerlink" title="部署 bookinfo 应用"></a>部署 bookinfo 应用</h1><p>bookinfo 是官方推荐的一个微服务案例。主要包含以下4个微服务，主页productpage服务是由python开发的，主要会调用评论和详细内容两个服务。评论服务有三个版本，reviews 微服务有 3 个版本：</p><blockquote><p>v1 版本不会调用 ratings 服务。<br>v2 版本会调用 ratings 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。<br>v3 版本会调用 ratings 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</p></blockquote><p><img src="https://img1.kiosk007.top/static/images/service_mesh/bookinfo.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples&#x2F;bookinfo&#x2F;platform&#x2F;kube&#x2F;bookinfo.yaml</span><br><span class="line">service&#x2F;details created</span><br><span class="line">serviceaccount&#x2F;bookinfo-details created</span><br><span class="line">deployment.apps&#x2F;details-v1 created</span><br><span class="line">service&#x2F;ratings created</span><br><span class="line">serviceaccount&#x2F;bookinfo-ratings created</span><br><span class="line">deployment.apps&#x2F;ratings-v1 created</span><br><span class="line">service&#x2F;reviews created</span><br><span class="line">serviceaccount&#x2F;bookinfo-reviews created</span><br><span class="line">deployment.apps&#x2F;reviews-v1 created</span><br><span class="line">deployment.apps&#x2F;reviews-v2 created</span><br><span class="line">deployment.apps&#x2F;reviews-v3 created</span><br><span class="line">service&#x2F;productpage created</span><br><span class="line">serviceaccount&#x2F;bookinfo-productpage created</span><br><span class="line">deployment.apps&#x2F;productpage-v1 created</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应用很快会起来，等到应用就绪后，istio 的sidecar 代理将一起被部署。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get service</span><br><span class="line">NAME          TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">details       ClusterIP   10.80.140.94   &lt;none&gt;        9080&#x2F;TCP   61s</span><br><span class="line">kubernetes    ClusterIP   10.80.0.1      &lt;none&gt;        443&#x2F;TCP    24d</span><br><span class="line">productpage   ClusterIP   10.80.6.178    &lt;none&gt;        9080&#x2F;TCP   61s</span><br><span class="line">ratings       ClusterIP   10.80.32.218   &lt;none&gt;        9080&#x2F;TCP   61s</span><br><span class="line">reviews       ClusterIP   10.80.60.33    &lt;none&gt;        9080&#x2F;TCP   61s</span><br></pre></td></tr></table></figure><br>和 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line">NAME                                      READY   STATUS            RESTARTS   AGE</span><br><span class="line">details-v1-79f774bdb9-kl2dg               0/2     PodInitializing   0          2m40s</span><br><span class="line">nfs-client-provisioner-6d9cb7bf7d-wclzl   1/1     Running           38         24d</span><br><span class="line">productpage-v1-6b746f74dc-xt7qh           0/2     PodInitializing   0          2m39s</span><br><span class="line">ratings-v1-b6994bb9-r8pqp                 2/2     Running           0          2m40s</span><br><span class="line">reviews-v1-545db77b95-l6ctg               0/2     PodInitializing   0          2m40s</span><br><span class="line">reviews-v2-7bf8c9648f-72k95               2/2     Running           0          2m40s</span><br><span class="line">reviews-v3-84779c7bbc-zkp5r               0/2     PodInitializing   0          2m40s</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>创建 Ingress</strong></li></ul><p>此时的bookinfo应用已经部署，但是还不能被外界访问，想要访问则需要创建 istio 入站网关 Ingress，他会在网格边缘把一个路径映射到路由。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure><ul><li><strong>确定入站 IP 和 端口</strong></li></ul><p>访问网关有2个变量控制，<span style="color:red">INGRESS_HOST </span> 和 <span style="color:red">INGRESS_PORT</span> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.80.53.173   &lt;pending&gt;     15021:32628/TCP,80:30554/TCP,443:30266/TCP,31400:30402/TCP,15443:30959/TCP   83m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置 <span style="color:red">EXTERNAL-IP</span> 的值之后， 你的环境就有了一个外部的负载均衡，可以用它做入站网关。 但如果 <span style="color:red">EXTERNAL-IP</span> 的值为 <none> (或者一直是 <pending> 状态)， 则你的环境则没有提供可作为入站流量网关的外部负载均衡。 在这个情况下，你还可以用服务（Service）的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#nodeport">节点端口</a> 访问网关 (但是k8s的NodePort设置要求的范围是 30000-32767)。</pending></none></p><p>由于我本地的测试环境没有 Loadblance ，所以就用NodePort方式访问吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].nodePort&#125;&#x27;</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;https&quot;)].nodePort&#125;&#x27;</span>)</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=172.16.101.135</span><br><span class="line">$ <span class="built_in">export</span> GATEWAT_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span></span><br></pre></td></tr></table></figure><p>浏览器访问 <code>http://172.16.101.135:30554/productpage</code> 可以看到这个微服务。</p><ul><li><strong>查看仪表盘</strong></li></ul><p>istio 可以可以添加 kiali 仪表盘、Prometheus、grafana 还有 Jaeger 等。</p><ol><li>安装 并 等待其部署完成<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f samples/addons</span><br><span class="line">kubectl rollout status deployment/kiali -n istio-system</span><br></pre></td></tr></table></figure></li><li>访问 kiali 仪表盘</li></ol><p>kiali 在希腊语中是望远镜的意思，其官方定义是 istio 的可观察性控制台，通过服务拓扑帮助你理解服务网格的结构。通过服务拓扑帮助你理解服务网格的结构，并且具有配置网格的功能。</p><p><img src="https://img1.kiosk007.top/static/images/service_mesh/kiali_funcation.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istioctl dashboard kiali</span><br></pre></td></tr></table></figure><blockquote><p>我因为是在远端虚拟机搭建的k8s集群，所以将 kiali 改为 NodePort 模式</p></blockquote><ol><li>在左侧的导航栏菜单选择 <code>Graph</code>, 然后在Namespace下拉列表选择 default。kiali 仪表盘提供了网络的概览，以及 bookinfo 示例应用的各个服务的关系，它还提供过滤器可视化流量的流动。</li></ol><p><img src="https://img1.kiosk007.top/static/images/service_mesh/kiali.png"></p><h2 id="Virtual-Service-动态路由"><a href="#Virtual-Service-动态路由" class="headerlink" title="Virtual Service 动态路由"></a>Virtual Service 动态路由</h2><p>要路由到一个版本，需要为微服务进行默认模板的设置，在这种情况下，Virtual Service 将所有的流量路由到每一个v1版本的pod上。</p><p><strong>Virtual Service 的作用正是 1. 定义路由规则。 2. 满足描述条件的请求去哪里</strong></p><p>这里涉及到一个满足描述条件，这正是<strong>目标规则 (Destination Rule) 的功能，即 1. 定义子集策略。 2. 描述到达目标的子集怎么处理</strong></p><ol><li>执行以下命令，使所有的 review 流量都打到 review v1 版本上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/destination-rule-all.yaml</span><br><span class="line">$ kubectl apply -f samples/bookinfo/networking/virtual-service-all-v1.yaml</span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/service_mesh/virtualservice.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">productpage</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>这个清单定义了4个 Virtual Service ，可以看到 所有的服务都被打向了 v1 版本。v1 版本是怎么定义出来的呢？在 <code>destination-rule-all.yaml</code> , <code>subsets</code> 中，将不同的labels中定义的版本进行标记，如  <strong>subsets.name.labels.version: v1</strong>, 可以使用 <code>kubectl get destinationrules</code> 查看</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="Gateway-管理进入网格的流量"><a href="#Gateway-管理进入网格的流量" class="headerlink" title="Gateway 管理进入网格的流量"></a>Gateway 管理进入网格的流量</h2><p>网关是运行在网格边缘的负载均衡器，接收外部请求转发到网格内部的服务，配置对外端口与内部服务的对应关系。</p><p><img src="https://img1.kiosk007.top/static/images/service_mesh/gateway.png"></p><p>在之前搭建 bookinfo 时，其实我们已经创建了一个网关，这个网关暴露了bookinfo 这个微服务的对外应用 <code>productpage</code> 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span> <span class="comment"># use istio default controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bookinfo-gateway</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">/productpage</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/static</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">/login</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">/logout</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/api/v1/products</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">          <span class="attr">number:</span> <span class="number">9080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>网关的 VirtualService 有一个 gateways, 正是上面创建 <code>Gateway</code> ，这个服务有5个被暴露出来的 uri，只有匹配的 uri 的流量才被打到 productpage 服务里。</p><h2 id="ServiceEntry-服务入口"><a href="#ServiceEntry-服务入口" class="headerlink" title="ServiceEntry 服务入口"></a>ServiceEntry 服务入口</h2><p>服务入口的作用是添加外部服务到内部网格内，是希望将管理内部服务队外部服务的请求，起到扩展网格的功能。</p><p>一般默认情况下，整个微服务是可以访问外部服务的。所以需要我们先禁止以下微服务访问外部。</p><p> Istio有一个安装选项<code>global.outboundTrafficPolicy.mode</code>用来配置sidecar对外部服务(未在istio内部服务注册中定义的服务)的处理方式。 如果选项值为<span style="color:red">ALLOW_ANY</span>，sidecar将允许调用未知的服务，如果选项值为<span style="color:red">REGISTRY_ONLY</span>，那么Istio代理将会阻止调用任何未在服务网格注册中定义的服务或ServiceEntry的host。</p><p>查看当前的规则则可以使用以下命令，没有任何输出表示默认的 <code>ALLOW_ANY</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get istiooperator installed-state -n istio-system -o jsonpath=<span class="string">&#x27;&#123;.spec.meshConfig.outboundTrafficPolicy.mode&#125;&#x27;</span></span><br></pre></td></tr></table></figure><br>在禁止直接访问之前。安装一个带 <code>curl</code> 命令的pod，访问微服务外的服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/sleep/sleep.yaml</span><br><span class="line">$ kubectl <span class="built_in">exec</span>  sleep-557747455f-svc9k -- curl http://httpbin.org/headers</span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;curl/7.78.0-DEV&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-6147eadc-3c6f1cdb3884436b76fca6f1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-B3-Sampled&quot;</span>: <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-B3-Spanid&quot;</span>: <span class="string">&quot;b0c944c749e6dcd8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-B3-Traceid&quot;</span>: <span class="string">&quot;5822ffcb03b68b61b0c944c749e6dcd8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Envoy-Attempt-Count&quot;</span>: <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Envoy-Peer-Metadata&quot;</span>: <span class="string">&quot;ChkKDkFQUF9DT05UQUlORVJTEgcaBXNsZWVwChoKCkNMVVNURVJfSUQSDBoKS3ViZXJuZXRlcwoZCg1JU1RJT19WRVJTSU9OEggaBjEuMTEuMgrEAQoGTEFCRUxTErkBKrYBCg4KA2FwcBIHGgVzbGVlcAohChFwb2QtdGVtcGxhdGUtaGFzaBIMGgo1NTc3NDc0NTVmCiQKGXNlY3VyaXR5LmlzdGlvLmlvL3Rsc01vZGUSBxoFaXN0aW8KKgofc2VydmljZS5pc3Rpby5pby9jYW5vbmljYWwtbmFtZRIHGgVzbGVlcAovCiNzZXJ2aWNlLmlzdGlvLmlvL2Nhbm9uaWNhbC1yZXZpc2lvbhIIGgZsYXRlc3QKGgoHTUVTSF9JRBIPGg1jbHVzdGVyLmxvY2FsCiAKBE5BTUUSGBoWc2xlZXAtNTU3NzQ3NDU1Zi1zdmM5awoWCglOQU1FU1BBQ0USCRoHZGVmYXVsdApJCgVPV05FUhJAGj5rdWJlcm5ldGVzOi8vYXBpcy9hcHBzL3YxL25hbWVzcGFjZXMvZGVmYXVsdC9kZXBsb3ltZW50cy9zbGVlcAoXChFQTEFURk9STV9NRVRBREFUQRICKgAKGAoNV09SS0xPQURfTkFNRRIHGgVzbGVlcA==&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Envoy-Peer-Metadata-Id&quot;</span>: <span class="string">&quot;sidecar~10.100.1.55~sleep-557747455f-svc9k.default~default.svc.cluster.local&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将 istio改为禁止调用未在网格内注册过的服务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl install --<span class="built_in">set</span> profile=demo -y --<span class="built_in">set</span> meshConfig.outboundTrafficPolicy.mode=REGISTRY_ONLY</span><br><span class="line"></span><br><span class="line">$ kubectl get istiooperator installed-state -n istio-system -o jsonpath=<span class="string">&#x27;&#123;.spec.meshConfig.outboundTrafficPolicy.mode&#125;&#x27;</span></span><br><span class="line">REGISTRY_ONLY</span><br></pre></td></tr></table></figure><br>再访问已经无法访问<br>…</p><p>使用ServiceEntry将一个外部服务注册到服务网格中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f - &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="string">kind: ServiceEntry</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: httpbin-ext</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  hosts:</span></span><br><span class="line"><span class="string">  - httpbin.org</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - number: 80</span></span><br><span class="line"><span class="string">    name: http</span></span><br><span class="line"><span class="string">    protocol: HTTP</span></span><br><span class="line"><span class="string">  resolution: DNS</span></span><br><span class="line"><span class="string">  location: MESH_EXTERNAL</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时便可再访问外部服务。这里的 <code>location: MESH_EXTERNAL</code> 便是指定访问网格外的服务白名单</p><p>参考：<a href="https://blog.frognew.com/2021/07/learning-istio-1.10-11.html">https://blog.frognew.com/2021/07/learning-istio-1.10-11.html</a></p><h2 id="流量转移：灰度发布"><a href="#流量转移：灰度发布" class="headerlink" title="流量转移：灰度发布"></a>流量转移：灰度发布</h2><p>istio 可以实现改写路由的权重，可以完成 灰度发布、蓝绿部署、A/B 测试 等功能。</p><p>其本质还是利用 Virtual Service 进行服务权重的调整，bookinfo 里的 reviews 服务有3个版本，我们即可利用 reviews 服务进行测试。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">50</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><p>其本质是修改路由的权重值。</p><h2 id="Egress-控制出口流量"><a href="#Egress-控制出口流量" class="headerlink" title="Egress 控制出口流量"></a>Egress 控制出口流量</h2><p>查看 egress 网关已安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">grafana-68cc7d6d78-bnwc8                1/1     Running   0          13h</span><br><span class="line">istio-egressgateway-6cb7bdc7fb-8h2n6    1/1     Running   0          17h</span><br><span class="line">istio-ingressgateway-694d8d7656-z4ccc   1/1     Running   0          17h</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看之前的 Service Entry 已配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get se</span><br><span class="line">NAME          HOSTS             LOCATION        RESOLUTION   AGE</span><br><span class="line">httpbin-ext   [<span class="string">&quot;httpbin.org&quot;</span>]   MESH_EXTERNAL   DNS          49m</span><br></pre></td></tr></table></figure><p>配置 Egress 网关、Destination 和 Virtual Service （Destination 和 Virtual Service 配置略）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  name: istio-egressgateway</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    istio: egressgateway</span><br><span class="line">  servers:</span><br><span class="line">  - port:</span><br><span class="line">      number: 80</span><br><span class="line">      name: http</span><br><span class="line">      protocol: HTTP</span><br><span class="line">    hosts:</span><br><span class="line">    - httpbin.org</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详见： <a href="https://cloud.tencent.com/developer/article/1469811">https://cloud.tencent.com/developer/article/1469811</a></p><h2 id="超时重试"><a href="#超时重试" class="headerlink" title="超时重试"></a>超时重试</h2><p>一般一个微服务架构里，最常见的就是服务之间的相互调用。这种调用关系是基于网络的，网络是不可靠的，另外被调用方也有可能因为服务故障导致处理请求慢，调用方对其他服务的调用必然涉及到超时重试，一般来说，业务的服务应该关注业务而不是在这些调用超时、重试之类的细枝末节上，所以微服务的超时重试便由此诞生。</p><p><img src="https://img1.kiosk007.top/static/images/service_mesh/timeout_retry.png"></p><p>演示过程：</p><ul><li>给 ratings 服务添加延迟</li><li>给 reviews 服务添加超时策略</li><li>给 ratings 服务添加重试策略</li></ul><p>先将 review 切换到 v2 版本<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>为 rating 服务添加延迟 2s</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percent:</span> <span class="number">100.0</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">2s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为 review 服务添加超时时间 1s </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">1s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时review 服务将无法响应，页面上可以看到挂掉了。下来验证重试和超时。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">100.0</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">retries:</span></span><br><span class="line">      <span class="attr">attempts:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">1s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>熔断是一种过载保护的手段, 目的是避免服务的级联失败。</p><p>一个熔断器可以有三种状态：关闭、打开和半开，默认情况下处于关闭状态。在关闭状态下，无论请求成功或失败，到达预先设定的故障数量阈值前，都不会触发熔断。而当达到阈值时，熔断器就会打开。当调用处于打开状态的服务时，熔断器将断开请求，这意味着它会直接返回一个错误，而不去执行调用。通过在客户端断开下游请求的方式，可以在生产环境中防止级联故障的发生。在经过事先配置的超时时长后，熔断器进入半开状态，这种状态下故障服务有时间从其中断的行为中恢复。如果请求在这种状态下继续失败，则熔断器将再次打开并继续阻断请求。否则熔断器将关闭，服务将被允许再次处理请求。</p><p><img src="https://img1.kiosk007.top/static/images/service_mesh/circuit_breaking.png"></p><p>设置熔断器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f - &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="string">kind: DestinationRule</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: httpbin</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  host: httpbin</span></span><br><span class="line"><span class="string">  trafficPolicy:</span></span><br><span class="line"><span class="string">    connectionPool:</span></span><br><span class="line"><span class="string">      tcp:</span></span><br><span class="line"><span class="string">        maxConnections: 1</span></span><br><span class="line"><span class="string">      http:</span></span><br><span class="line"><span class="string">        http1MaxPendingRequests: 1</span></span><br><span class="line"><span class="string">        maxRequestsPerConnection: 1</span></span><br><span class="line"><span class="string">    outlierDetection:</span></span><br><span class="line"><span class="string">      consecutiveErrors: 1</span></span><br><span class="line"><span class="string">      interval: 1s</span></span><br><span class="line"><span class="string">      baseEjectionTime: 3m</span></span><br><span class="line"><span class="string">      maxEjectionPercent: 100</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>参考: <a href="https://www.servicemesher.com/blog/istio-circuit-breaking/">https://www.servicemesher.com/blog/istio-circuit-breaking/</a></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>系统的运行状态，除了通过 istio 自带的 <code>prometheus</code>、<code>kiali</code>、<code>grafna</code> 查看相关的日志。但是总是需要看更详细的文本日志输出。</p><p>原始的调用结构是 服务A 直接调用 服务B ，但是现在服务A 的sidecar 调用服务B 的sidecar然后才能调用服务B 。</p><p>那么想要定位问题，就是查看envoy的日志了。 </p><p>首先确保envoy 日志是打开的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> describe configmap istio -n istio-system | grep <span class="string">&quot;accessLogFile&quot;</span></span><br><span class="line">accessLogFile: /dev/stdout</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>envoy 的日志是定制的，在服务的pod里叫做 <code>istio-proxy</code> 这个contianer。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -f productpage-v1-6b746f74dc-xt7qh istio-proxy</span><br><span class="line"></span><br><span class="line">[2021-09-20T14:12:23.277Z] <span class="string">&quot;GET /details/0 HTTP/1.1&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 0 178 24 23 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;768f9804-849c-9aca-b4f0-f85c838304e4&quot;</span> <span class="string">&quot;details:9080&quot;</span> <span class="string">&quot;10.100.1.49:9080&quot;</span> outbound|9080|v1|details.default.svc.cluster.local 10.100.1.51:54256 10.80.140.94:9080 10.100.1.51:46546 - -</span><br><span class="line">[2021-09-20T14:12:23.310Z] <span class="string">&quot;GET /reviews/0 HTTP/1.1&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 0 295 41 41 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;768f9804-849c-9aca-b4f0-f85c838304e4&quot;</span> <span class="string">&quot;reviews:9080&quot;</span> <span class="string">&quot;10.100.0.19:9080&quot;</span> outbound|9080|v1|reviews.default.svc.cluster.local 10.100.1.51:54950 10.80.60.33:9080 10.100.1.51:55736 - -</span><br><span class="line">[2021-09-20T14:12:23.253Z] <span class="string">&quot;GET /productpage HTTP/1.1&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 0 4288 106 105 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;768f9804-849c-9aca-b4f0-f85c838304e4&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:33335 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line">[2021-09-20T14:12:23.411Z] <span class="string">&quot;GET /static/bootstrap/css/bootstrap.min.css HTTP/1.1&quot;</span> 304 - via_upstream - <span class="string">&quot;-&quot;</span> 0 0 32 29 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;8df34a40-a462-99b3-afe3-ea90df5f09d4&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:53397 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line">[2021-09-20T14:12:23.429Z] <span class="string">&quot;GET /static/bootstrap/css/bootstrap-theme.min.css HTTP/1.1&quot;</span> 304 - via_upstream - <span class="string">&quot;-&quot;</span> 0 0 20 19 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;11b436e3-bad2-9608-b389-9eb8f422ca68&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:48115 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line">[2021-09-20T14:12:23.436Z] <span class="string">&quot;GET /static/jquery.min.js HTTP/1.1&quot;</span> 304 - via_upstream - <span class="string">&quot;-&quot;</span> 0 0 18 17 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;105258af-c512-9df4-b8cd-7063eb29ee70&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:50457 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line">[2021-09-20T14:12:23.436Z] <span class="string">&quot;GET /static/bootstrap/js/bootstrap.min.js HTTP/1.1&quot;</span> 304 - via_upstream - <span class="string">&quot;-&quot;</span> 0 0 26 24 <span class="string">&quot;10.100.0.0&quot;</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;</span> <span class="string">&quot;adfefa36-12a2-90a2-b223-11c829cc2133&quot;</span> <span class="string">&quot;172.16.101.135:30554&quot;</span> <span class="string">&quot;10.100.1.51:9080&quot;</span> inbound|9080|| 127.0.0.6:52945 10.100.1.51:9080 10.100.0.0:0 outbound_.9080_._.productpage.default.svc.cluster.local default</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>envoy 日志配置项</p><div class="table-container"><table><thead><tr><th>配置项</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>global.proxy.accessLogFile</td><td style="text-align:right">日志输出文件，空为关闭输出</td></tr><tr><td>global.proxy.accessLogEncoding</td><td style="text-align:right">日志编码格式：JSON、TEXT</td></tr><tr><td>global.proxy.accessLogFormat</td><td style="text-align:right">配置显示在日志中的字段，空为默认格式</td></tr><tr><td>global.proxy.logLevel</td><td style="text-align:right">日志级别，空为 warning</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;下面是摘自维基百科的一段话。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微服务 (Microservices) 是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic) 的 API 集相互通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来过于抽象，Service Mesh 在我看来，就是如何处理服务于服务之间的关系，如服务之间的相互调用关系，核心服务的熔断等，这不仅不含一个普通的 A 服务对 B 服务的一次 RPC 调用，也涉及RPC调用时具体的超时时间、重试次数等细节。最终目的是让整个服务形成一张网一般。而开发人员只需要注重自己的业务逻辑开发，而服务之间的联系全部交给 Service Mesh。&lt;/p&gt;
&lt;p&gt;想象一下，你的代码不再需要考虑各种超时逻辑、也不需要考虑熔断和集成各种底层网络库。你的代码只有业务本身。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx Ingress</title>
    <link href="http://kiosk007.top/2021/09/05/Nginx-Ingress/"/>
    <id>http://kiosk007.top/2021/09/05/Nginx-Ingress/</id>
    <published>2021-09-05T03:37:00.000Z</published>
    <updated>2021-09-05T03:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在K8S的中， Service 暴露给外界的三种方法。其中有一个叫作 LoadBalancer 类型的 Service，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务。</p><p>但是，由于每个 Service 都要有一个负载均衡服务，所以这个做法实际上既浪费成本又高。作为用户，我其实更希望看到 Kubernetes 为我内置一个全局的负载均衡器。然后，通过我访问的 URL，把请求转发给不同的后端 Service。</p><p><strong>这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 Ingress 服务。</strong></p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> <strong>Kubernetes</strong> 内置一个全局的负载均衡器。然后，通过访问 URL，把请求转发给不同的后端 Service。这就是这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 Ingress 服务。所以，Ingress 的功能其实很容易理解：<strong>所谓 Ingress，就是 Service 的“Service”。</strong></p><p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/ingress.png"> </p><h1 id="安装-nginx-ingress"><a href="#安装-nginx-ingress" class="headerlink" title="安装 nginx-ingress"></a>安装 nginx-ingress</h1><p>参考: <a href="https://docs.nginx.com/nginx-ingress-controller/installation/installation-with-manifests/">NGINX Ingress Controller</a></p><ol><li>创建 <code>Nginx Controller</code><ul><li>创建 <code>Namespace</code> 与 <code>账号</code></li><li>创建角色并绑定账号</li><li>创建 default server 的秘钥</li><li>创建存放 <code>nginx.conf</code> 的 <code>Config Map</code></li><li>创建 <code>ingress-class</code></li><li>创建 <code>Nginx Controller Pod</code></li></ul></li><li>暴露 <code>Nginx Controller</code> 服务</li><li>创建 <code>Ingress</code> 规则<ul><li><code>Host</code> 精准与通配符匹配</li><li><code>Path</code> 前缀或精确匹配</li><li><code>Backend</code></li></ul></li></ol><p>第一步：创建 <code>Nginx Controller</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/nginxinc/kubernetes-ingress/</span><br><span class="line">$ <span class="built_in">cd</span> kubernetes-ingress/deployments</span><br><span class="line">$ git checkout v1.12.0</span><br></pre></td></tr></table></figure><p>Namespace 与 账号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f common/ns-and-sa.yaml</span><br><span class="line">$ kubectl apply -f rbac/rbac.yaml</span><br></pre></td></tr></table></figure><p>default server 秘钥证书 与 Config Map</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f common/default-server-secret.yaml</span><br><span class="line">$ kubectl apply -f common/nginx-config.yaml</span><br><span class="line">$ kubectl apply -f common/ingress-class.yaml</span><br></pre></td></tr></table></figure><p>创建 <code>Nginx-Ingress</code> 当一个新的 Ingress 对象由用户创建后，nginx-ingress-controller 就会根据 Ingress 对象里定义的内容，生成一份对应的 Nginx 配置文件（/etc/nginx/nginx.conf），并使用这个配置文件启动一个 Nginx 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deployment/nginx-ingress.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了让用户能够用到这个 Nginx，我们就需要创建一个 Service 来把 Nginx Ingress Controller 管理的 Nginx 服务暴露出去。创建 <code>Node Port</code> , 暴露服务。Kubernetes将在集群的每个节点上随机分配两个端口。可以使用 <strong>任意节点</strong> + <strong>分配的特殊端口</strong> 即可访问服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f service/nodeport.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl get svc -n nginx-ingress</span><br><span class="line">NAME            TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">nginx-ingress   NodePort   10.80.23.67   &lt;none&gt;        80:30595/TCP,443:30920/TCP   4m32s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个 Service 的唯一工作，就是将所有携带 ingress-nginx 标签的 Pod 的 80 和 433 端口暴露出去。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Nginx 官方 ingress 提供了 cafe 、 tea 的例子，参考: <a href="https://github.com/nginxinc/kubernetes-ingress/tree/master/examples/complete-example">https://github.com/nginxinc/kubernetes-ingress/tree/master/examples/complete-example</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IC_IP=172.16.101.135   <span class="comment"># 宿主机ip</span></span><br><span class="line">IC_HTTPS_PORT=30920    <span class="comment"># nodeport</span></span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f cafe.yaml</span><br><span class="line">kubectl create -f cafe-secret.yaml</span><br><span class="line">kubectl create -f cafe-ingress.yaml</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl --resolve cafe.example.com:<span class="variable">$IC_HTTPS_PORT</span>:<span class="variable">$IC_IP</span> https://cafe.example.com:<span class="variable">$IC_HTTPS_PORT</span>/coffee --insecure</span><br><span class="line">Server address: 10.100.1.37:8080</span><br><span class="line">Server name: coffee-6f4b79b975-59d8f</span><br><span class="line">Date: 04/Sep/2021:15:36:01 +0000</span><br><span class="line">URI: /coffee</span><br><span class="line">Request ID: 1873881292193359134a0619136b2780</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>每次文件变化后，执行 <code>kubectl apply -f cafe-ingress.yaml</code>，实际会对Nginx进行一次reload。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">cafe-secret</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/tea</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">tea-svc</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/coffee</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">coffee-svc</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>执行上述命令后，会生成一个 ingress 规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get ingress </span><br><span class="line">NAME           CLASS   HOSTS              ADDRESS   PORTS     AGE</span><br><span class="line">cafe-ingress   nginx   cafe.example.com             80, 443   14h</span><br></pre></td></tr></table></figure><p>而这个ingress 规则实质上是在 <code>ingress controller</code> 的 deployment pod 中的 <code>/etc/nginx/conf.d</code> 中生成一个规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -it -n nginx-ingress nginx-ingress-c7cd9948d-r8hxz -- /bin/bash</span><br><span class="line">nginx@nginx-ingress-c7cd9948d-r8hxz:/$ <span class="built_in">cd</span> /etc/nginx/conf.d/</span><br><span class="line">nginx@nginx-ingress-c7cd9948d-r8hxz:/etc/nginx/conf.d$ ls</span><br><span class="line">default-cafe-ingress.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>nginx.conf</code> 相关配置遵从 configmap 模板配置, 同样更改会reload。<br>详见：<code>https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/</code></p><blockquote><p>k8s 官方的 ingress-nginx 是利用 balance by lua 的方式进行负载均衡。nginx 官方是利用 nginx reload 实现。</p></blockquote><h1 id="ingress-工作原理"><a href="#ingress-工作原理" class="headerlink" title="ingress 工作原理"></a>ingress 工作原理</h1><p>K8S 调度 <code>Nginx Ingress Controller Pod</code>, Go 语言基于Nginx 模板生成的 <code>nginx.conf</code> </p><ul><li>模板语法 <code>import &quot;text/template&quot;</code></li><li>模板位置 Nginx 官方:<ul><li><code>/nginx.ingress.tmpl</code> 和 <code>nginx.tmpl</code></li></ul></li><li>填充模板的数据：<ul><li><code>ConfigMap</code>, <code>Ingress</code>, <code>Service</code> 和  <code>Secrets</code></li></ul></li></ul><p>配置文件改变后，<strong>Nginx 官方的 Ingress (<a href="https://github.com/nginxinc/kubernetes-ingress">https://github.com/nginxinc/kubernetes-ingress</a>) </strong> 的做法是每次 reload。而 <strong>kubernetes 官方的 Ingress </strong>是基于 lua 实现的类似openresty 的 <code>balance by lua</code> 来实现配置重载。</p><p>而配置文件本身是全部存在的 ETCD 中的。ETCD 基于 raft 协议实现高可用的一致性。具体可以参考我之前的文章 <a href="https://kiosk007.top/2020/05/30/go-etcd-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">etcd 的基本入门</a></p><p>Nginx 官方的Ingress 和 K8S 官方的Ingress 性能对比。</p><ul><li>静态部署：即 Nginx 配置文件不变, 可以看到开源的Nginx（蓝线）在压力逐渐增加时，时延变高的最慢。</li></ul><p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/ingress_static_stress.png"></p><ul><li>动态部署: 即 Nginx 配置总是变，如 upstream 变化导致需要配置变化。官方Nginx的性能就拉垮了，压力到90多就时延上升一个台阶，到99.9时时延已经1分钟以上了。</li></ul><p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/ingress_dynamic_stress.png"></p><p>参考：<a href="https://www.nginx.org.cn/course/detail/12">K8S Ingress Controller技术细节探讨</a></p><h2 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h2><p>Ingress Controller 完成了包含 <code>负载均衡/会话保持</code>、<code>协议转换</code>、<code>TLS 卸载、认证</code>、<code>文本压缩</code>、<code>请求认证</code>、<code>限流限速</code>、<code>Waf</code>、<code>全链路跟踪</code>、<code>日志监控</code> 等等功能。</p><h2 id="第三方模块启用"><a href="#第三方模块启用" class="headerlink" title="第三方模块启用"></a><strong>第三方模块启用</strong></h2><p>Nginx 有大量的第三方模块，Ingress 复用 Nginx 时这些大量的第三方模块是用 <code>annotations</code> 的方式加载这些第三方模块。详见 <a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/">K8S官方文档 Annotations</a> 和 <a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-annotations/">Nginx 官方文档</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.org/proxy-connect-timeout:</span> <span class="string">&quot;30s&quot;</span></span><br><span class="line">    <span class="attr">nginx.org/proxy-read-timeout:</span> <span class="string">&quot;20s&quot;</span></span><br><span class="line">    <span class="attr">nginx.org/client-max-body-size:</span> <span class="string">&quot;4m&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># ingressClassName: nginx # use only with k8s version &gt;= 1.18.0</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">cafe-secret</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/tea</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tea-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/coffee</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">coffee-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/ingress_annotations.png"></p><ul><li>opentrace 全链路追踪</li></ul><p>Nginx 本身可以遵从全链路追踪 <code>opentracing</code> 架构规范实现（<a href="https://opentracing.io/）。通过为流行的平台提供一致的，富有表现力的，供应商中立的API，OpenTracing使开发人员可以轻松地通过O（1）配置更改添加（或切换）跟踪实现。OpenTracing还为OSS检测和特定于平台的跟踪帮助程序库提供了通用语言。">https://opentracing.io/）。通过为流行的平台提供一致的，富有表现力的，供应商中立的API，OpenTracing使开发人员可以轻松地通过O（1）配置更改添加（或切换）跟踪实现。OpenTracing还为OSS检测和特定于平台的跟踪帮助程序库提供了通用语言。</a></p><p>比如全链路追踪的 <code>jaeger trace</code>。jaeger 本身搭建比较简单，但是其数据源需要 ingress Nginx 按照 opentracing 规范导入到 jaeger 中最使用 UI 查看。</p><p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/jaeger_trace.png"></p><p><code>nginx ingress</code> 中的nginx 支持如 <code>https://github.com/opentracing-contrib/nginx-opentracing.git</code> 等模块。</p><p>详见: <a href="https://www.nginx.org.cn/article/detail/517">采用 NGINX Ingress Controller for Kubernetes 支持 OpenTracing</a></p><h2 id="nginx-conf-配置加载"><a href="#nginx-conf-配置加载" class="headerlink" title="nginx.conf 配置加载"></a><strong>nginx.conf 配置加载</strong></h2><p>nginx 的 config 配置文件是通过 <code>ConfigMap</code> 搭配 go 语言的 template 模板来更新 <code>nginx.conf</code> 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">nginx-ingress</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">worker-processes:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如下是进入到 <code>nginx ingress controller</code> pod 里看到的内容，<code>ConfigMap</code> 里data中的内容，<code>worker-processes: &quot;2&quot;</code> 会对应到 pod 里的 <code>nginx.tmpl</code> 的 <code>&#123;&#123;.WorkerProcesses&#125;&#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nginx@nginx-ingress-c7cd9948d-r8hxz:/$ ls</span><br><span class="line">bin   dev   docker-entrypoint.sh  home  lib64  mnt     nginx.ingress.tmpl  nginx.transportserver.tmpl  opt   root  sbin  sys  usr</span><br><span class="line">boot  docker-entrypoint.d  etc lib   media  nginx-ingress  nginx.tmpl nginx.virtualserver.tmpl    proc  run srv   tmp  var</span><br><span class="line">nginx@nginx-ingress-c7cd9948d-r8hxz:/$ cat nginx.tmpl </span><br><span class="line"></span><br><span class="line">worker_processes  &#123;&#123;.WorkerProcesses&#125;&#125;;</span><br><span class="line">&#123;&#123;- <span class="keyword">if</span> .WorkerRlimitNofile&#125;&#125;</span><br><span class="line">worker_rlimit_nofile &#123;&#123;.WorkerRlimitNofile&#125;&#125;;&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="keyword">if</span> .WorkerCPUAffinity&#125;&#125;</span><br><span class="line">worker_cpu_affinity &#123;&#123;.WorkerCPUAffinity&#125;&#125;;&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="keyword">if</span> .WorkerShutdownTimeout&#125;&#125;</span><br><span class="line">worker_shutdown_timeout &#123;&#123;.WorkerShutdownTimeout&#125;&#125;;&#123;&#123;end&#125;&#125;</span><br><span class="line">daemon off;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="k8s与Nginx-官方-Ingres-区别"><a href="#k8s与Nginx-官方-Ingres-区别" class="headerlink" title="k8s与Nginx 官方 Ingres 区别"></a>k8s与Nginx 官方 Ingres 区别</h2><p>进程架构</p><ul><li>K8S 官方<ul><li>/usr/bin/dumb-init</li><li>nginx-ingress-controller</li><li>/usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf </li></ul></li><li><p>Nginx 官方</p><ul><li>nginx-ingress</li><li>/usr/sbin/nginx</li></ul></li><li><p><strong>K8S 官方优势</strong></p></li></ul><p>可以看出 K8S 官方是对容器的理解非常深，容器是单进程架构，这并不意味着容器里面只能跑一个进程，而是指容器内只能管理一个进程。K8S 的这一个进程就是 <code>/usr/bin/dumb-init</code> 仿照了操作系统中的 <code>systemd</code> 进程对这个POD容器进行管理。</p><p>而Nginx官方的Ingress 是 <code>nginx-ingress</code> 进程。</p><p>另一个就是K8S官方的负载均衡配置变更是用的 <code>Balance By Lua</code> ，这个在配置频繁变更时性能会很高。</p><ul><li><strong>Nginx 官方优势</strong></li></ul><p>但是 Nginx 官方的 Ingress 明显是对 <code>nginx</code> 的理解更加深刻的。Ingress 默认是不支持正则匹配，Nginx 官方则对此有优化，这个就是 <code>VirtualServer</code>、<code>VirtualServerRoute</code>。</p><p><img src="https://img1.kiosk007.top/static/images/k8s/ingress/virtual_server.png"></p><p>另外，Nginx 官方还提供了 <code>snippets</code> 。支持更高级的匹配模式，但其实也是一种全局的匹配。 具体参考 <a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-snippets/">Advanced Configuration with Snippets</a></p><p>支持添加 302 跳转，支持全局加 Header 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cafe-ingress-with-snippets</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.org/server-snippets:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">          <span class="string">return</span> <span class="number">302</span> <span class="string">/coffee;</span></span><br><span class="line">      &#125;      </span><br><span class="line">    <span class="attr">nginx.org/location-snippets:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">add_header</span> <span class="string">my-test-header</span> <span class="string">test-value;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cafe.example.com</span></span><br><span class="line">  <span class="string">....</span></span><br></pre></td></tr></table></figure><p>另外Nginx官方支持自定义模板。具体参考 <a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/custom-annotations/">Custom Annotations</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在K8S的中， Service 暴露给外界的三种方法。其中有一个叫作 LoadBalancer 类型的 Service，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务。&lt;/p&gt;
&lt;p&gt;但是，由于每个 Service 都要有一个负载均衡服务，所以这个做法实际上既浪费成本又高。作为用户，我其实更希望看到 Kubernetes 为我内置一个全局的负载均衡器。然后，通过我访问的 URL，把请求转发给不同的后端 Service。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 Ingress 服务。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://kiosk007.top/categories/k8s/"/>
    
    
    <category term="nginx" scheme="http://kiosk007.top/tags/nginx/"/>
    
    <category term="k8s" scheme="http://kiosk007.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s 架构拓扑</title>
    <link href="http://kiosk007.top/2021/08/05/k8s%E6%9E%B6%E6%9E%84%E6%8B%93%E6%89%91/"/>
    <id>http://kiosk007.top/2021/08/05/k8s%E6%9E%B6%E6%9E%84%E6%8B%93%E6%89%91/</id>
    <published>2021-08-04T16:05:00.000Z</published>
    <updated>2021-08-04T16:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章将从K8S的架构、存储、网络及服务暴露等几个方面介绍,记录K8S的学习过程。</p><a id="more"></a><p>讨论议题：</p><ul><li>k8s 架构</li><li>k8s 存储架构</li><li>k8s 容器网络</li><li>k8s 服务暴露</li></ul><h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>K8S 集群搭建方式参考, <a href="https://kiosk.io/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/#%E5%AE%89%E8%A3%85-kubernetes">ubuntu20.04 部署 Kubernetes (k8s)</a> </p><blockquote><p>搭建教程当时基于的环境 1.18 ，参考时注意更改到最新的对应版本。</p></blockquote><ul><li>集群主机（vmware 虚拟机）<ul><li>vm-ks0 (master): 172.16.101.135</li><li>vm-ks1 (node1):  172.16.101.136</li></ul></li><li>系统版本: ubuntu 20.04 TLS</li><li>kubernetes版本： v1.22.0</li></ul><p><strong>k8s 初始化 <code>ClusterConfiguration</code> yaml</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config=http://s1.kiosk007.top/static/kubeadm-config.yaml --upload-certs -v 6</span><br></pre></td></tr></table></figure><p><strong>网络插件：flannel</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f http://s1.kiosk007.top/static/kube-flannel.yaml</span><br></pre></td></tr></table></figure><p><strong>去掉master节点的调度taint</strong></p><p>去掉NoSchedule使master节点可以调度pod。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes vm-ks0 node-role.kubernetes.io/master:NoSchedule-</span><br></pre></td></tr></table></figure><br><strong>宿主机安装NFS</strong></p><p>NFS 提供远程存储服务，并提供PV，NFS的安装工作参考 <a href="https://cloud.tencent.com/developer/article/1626660">这里</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt install nfs-kernel-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备磁盘目录</span></span><br><span class="line">mkdir -p /data/nfs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># NFS服务配置文件</span></span><br><span class="line">sudo vim /etc/exports</span><br><span class="line">/home/weijiaxiang/data/nfs *(rw,no_root_squash,sync)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启NFS，并保持NFS启动开机</span></span><br><span class="line">systemctl restart nfs-kernel-server</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-kernel-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有Node节点安装NFS客户端</span></span><br><span class="line">apt install nfs-common rpcbind</span><br><span class="line"></span><br><span class="line"><span class="comment"># Node 节点上查看能否 mount</span></span><br><span class="line">showmount -e 172.16.101.1</span><br></pre></td></tr></table></figure><h1 id="K8S-架构"><a href="#K8S-架构" class="headerlink" title="K8S 架构"></a>K8S 架构</h1><p>议题：</p><ol><li>K8S 架构是什么样的</li></ol><p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_cluster_1.png"></p><ul><li>CNI: 容器网络接口</li><li>CRI：容器运行时接口</li><li>OCI：开放容器标准</li></ul><p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_struct.png"></p><h1 id="容器持久化存储"><a href="#容器持久化存储" class="headerlink" title="容器持久化存储"></a>容器持久化存储</h1><p>议题：</p><ol><li>容器的存储是如何实现的</li><li>k8s集群如何使用存储</li></ol><p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes">Kubernetes 内置了20种持久化存储卷的实现</a></p><h2 id="PV-amp-PVC"><a href="#PV-amp-PVC" class="headerlink" title="PV &amp; PVC"></a>PV &amp; PVC</h2><p><strong>PV (PersistentVolume) 描述的是持久化存储数据卷。</strong>这个 API 对象主要定义的是一个持久化存储在宿主机上的目录，比如一个 NFS 的挂载目录。</p><p><strong>PVC（PersistentVolumeClaim） 描述的是 Pod 所希望使用的持久化存储的属性。</strong>比如，Volume 存储的大小、可读写权限等等。</p><p>一般PV由运维人员创建并提供，PVC是由开发人员所创建，以 PVC 模板的方式成为 StatefulSet 的一部分，然后由 StatefulSet 控制器负责创建带编号的 PVC。<strong>PV 和 PVC 的 storageClassName 字段必须一样，才能使用</strong></p><p>如一个 NFS 的 PV</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nfs-pv001.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pv001</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">pv:</span> <span class="string">nfs-pv001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/nfs/pv001</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.16</span><span class="number">.101</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>声明一个 1 GiB 大小的 PVC</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nfs-pvc001.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pvc001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">pv:</span> <span class="string">nfs-pv001</span></span><br></pre></td></tr></table></figure><p>接下来就可以像 <code>hostPath</code> 等常规类型的 Volume 一样，在自己的 YAML 文件里声明使用。<br>更多例子参考 <a href="http://docs.kubernetes.org.cn/429.html">这里</a></p><p>大多数情况下，持久化 Volume 的实现，往往依赖于一个远程存储服务，比如：远程文件存储（比如，NFS、GlusterFS）、远程块存储（比如，公有云提供的远程磁盘）等等。</p><p>实际生产环境中，一个大规模的 Kubernetes 集群里很可能有成千上万个 PVC，这就意味着运维人员必须得事先创建出成千上万个 PV。更麻烦的是，随着新的 PVC 不断被提交，运维人员就不得不继续添加新的、能满足条件的 PV。 为了自动化的创建PV，提出了一个 <strong>StorageClass</strong> 的概念。</p><p><strong>而 StorageClass 对象的作用，其实就是创建 PV 的模板。</strong><br>具体地说，StorageClass 对象会定义如下两个部分内容：</p><ul><li>第一，PV 的属性。比如，存储类型、Volume 的大小等等。</li><li>第二，创建这种 PV 需要用到的存储插件。比如，Ceph 等等。</li></ul><p>有了这样两个信息之后，Kubernetes 就能够根据用户提交的 PVC，找到一个对应的 StorageClass 了。然后，Kubernetes 就会调用该 StorageClass 声明的存储插件，创建出需要的 PV。</p><p>如开源项目 <a href="https://rook.io/">rook</a>。定义的还是一个名叫 block-service 的 StorageClass。（<a href="https://cloud.tencent.com/developer/article/1470038">Rook &amp; Ceph 简介</a>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ceph.rook.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pool</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">replicapool</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">rook-ceph</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicated:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">3</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">block-service</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">ceph.rook.io/block</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">pool:</span> <span class="string">replicapool</span></span><br><span class="line">  <span class="comment">#The value of &quot;clusterNamespace&quot; MUST be the same as the one in which your rook cluster exist</span></span><br><span class="line">  <span class="attr">clusterNamespace:</span> <span class="string">rook-ceph</span></span><br></pre></td></tr></table></figure><p>作为应用开发者，不必再为难运维人员，上面提到的运维人员创建的PV是运维手工分配的，而 Storage Class 是动态创建的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">claim1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">block-service</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">30Gi</span></span><br></pre></td></tr></table></figure><h2 id="动态-NFS-Provision"><a href="#动态-NFS-Provision" class="headerlink" title="动态 NFS Provision"></a>动态 NFS Provision</h2><ul><li><strong>什么是 NFS-Subdir-External-Provisioner</strong></li></ul><p>存储组件 <code>NFS subdir external provisioner</code> 是一个存储资源自动调配器，它可用将现有的 NFS 服务器通过持久卷声明来支持 Kubernetes 持久卷的动态分配。自动新建的文件夹将被命名为 <code>$&#123;namespace&#125;-$&#123;pvcName&#125;-$&#123;pvName&#125;</code> ，由三个资源名称拼合而成。</p><blockquote><p>此组件是对 nfs-client-provisioner 的扩展，nfs-client-provisioner 已经不提供更新，且 nfs-client-provisioner 的 Github 仓库已经迁移到 <a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">NFS-Subdir-External-Provisioner</a> 的仓库。</p></blockquote><p>部署需要先将这个项目 <code>clone</code> 下来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner</span><br></pre></td></tr></table></figure><p>项目的deployment目录下有我们需要的搭建 yaml 文件。</p><ul><li><strong>创建 ServiceAccount</strong></li></ul><p>现在的 Kubernetes 集群大部分是基于 RBAC 的权限控制，所以我们需要创建一个拥有一定权限的 ServiceAccount 与后面要部署的 NFS Subdir Externa Provisioner 组件绑定。</p><p>执行 kubectl 命令将 RBAC 文件部署到 Kubernetes 集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f rbac.yaml</span><br></pre></td></tr></table></figure><ul><li><strong>部署 NFS-Subdir-External-Provisioner</strong></li></ul><p>设置 <code>NFS-Subdir-External-Provisioner</code> 部署文件。需要对 <code>deployment.yaml</code> 做一些修改。<code>NFS_SERVER</code> 和 <code>NFS_PATH</code> 都需要改成自己的NFS服务器。另外默认镜像地址为 <code>k8s.gcr.io</code>, 我这里找了网上的一个地址 <code>registry.cn-beijing.aliyuncs.com/mydlq/nfs-subdir-external-provisioner:v4.0.0</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deployment.yaml </span><br></pre></td></tr></table></figure><ul><li><strong>创建 NFS SotageClass</strong></li></ul><p>我们在创建 PVC 时经常需要指定 storageClassName 名称，这个参数配置的就是一个 StorageClass 资源名称，PVC 通过指定该参数来选择使用哪个 StorageClass，并与其关联的 Provisioner 组件来动态创建 PV 资源。所以，这里我们需要提前创建一个 Storagelcass 资源。</p><blockquote><p>Provisioner 参数用于声明 NFS 动态卷提供者的名称，该参数值要和上面部署 NFS-Subdir-External-Provisioner 部署文件中指定的 PROVISIONER_NAME 参数保持一致，即设置为 nfs-storage。</p></blockquote><ul><li><strong>测试</strong></li></ul><p>创建一个用于测试的 pvc。并创建一个 pod 使用pvc写文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f test-claim.yaml</span><br><span class="line">$ kubectl apply -f test-pods.yaml</span><br></pre></td></tr></table></figure><p>在宿主机的 nfs 共享目录上发现，已经创建出 <code>SUCCESS</code> 文件。</p><h1 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h1><p>议题：</p><ol><li>同一台主机的容器既然被隔离，是怎样互相通信的</li><li>为什么跨主机的容器可以互相通信</li><li>容器间的网络通信和主机间的网络通信性能相差</li><li>k8s的CNI网络实现</li><li>K8S网络方案L2和L3的区别</li><li>网络隔离方案</li></ol><p>实验环境，起 2个 pod</p><p>flannel 网络通信方式</p><div class="table-container"><table><thead><tr><th>通信方式</th><th style="text-align:center">概念</th><th style="text-align:center">方式</th></tr></thead><tbody><tr><td>主机内通信</td><td style="text-align:center">1台机器内部的</td><td style="text-align:center">veth pair</td></tr><tr><td>L2 主机间通信</td><td style="text-align:center">2台主机连在同一台交换机的场景</td><td style="text-align:center">hostgw</td></tr><tr><td>L3 主机间通信</td><td style="text-align:center">2台主机没有连在同一台交换机的场景。</td><td style="text-align:center">内核态：vxlan  用户态：udp (性能差)</td></tr></tbody></table></div><h2 id="主机内POD通信-（cni0-与-veth-pair）"><a href="#主机内POD通信-（cni0-与-veth-pair）" class="headerlink" title="主机内POD通信 （cni0 与 veth pair）"></a>主机内POD通信 （cni0 与 veth pair）</h2><ul><li>node: <code>vm-ks1</code>：<code>172.16.101.136/16</code><ul><li>pod0: <code>web-0</code> : <code>10.100.1.39  eth0@if6  0a:ff:9f:1b:5c:02</code></li><li>pod1: <code>web-1</code> : <code>10.100.1.40  eth0@if7  16:60:24:3d:0f:84</code></li></ul></li></ul><p>宿主机 vm-ks1 上的网卡, 除了 flannel和cni0 网卡外，还有一堆veth开头的网卡，每创建一个容器或pod都会在宿主机上生成一个 veth pair，这个veth pair可以理解为容器和宿主机之间拉了一条网线。可参考<a href="https://www.cnblogs.com/bakari/p/10613710.html">这篇文章</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@vm-ks1:~# ip link show</span><br><span class="line">root@vm-ks1:~# ip link show | egrep &quot;veth&quot; | awk -F&quot;:&quot; &#39;&#123;print $1&quot;:&quot;$2&#125;&#39;</span><br><span class="line">6: veth50ce0fb7@if3</span><br><span class="line">7: veth51f9d367@if3</span><br><span class="line">8: veth8b0a5941@if3</span><br><span class="line">9: veth940d7fa4@if3</span><br><span class="line">10: veth12a5546b@if3</span><br><span class="line">11: veth1b7e020f@if3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_cni0_1.png"></p><p>同一主机内的pod之间的互相通信流量会经过 <code>cni0</code>，可以看到 pod0 的Mac地址<code>0a:ff:9f:1b:5c:02</code> 可以直接访问 pod1 的Mac地址 <code>16:60:24:3d:0f:84</code><br>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@vm-ks1:~<span class="comment"># tcpdump -i cni0 port 80 -XXe -v</span></span><br><span class="line">tcpdump: listening on cni0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">23:42:29.370870 0a:ff:9f:1b:5c:02 (oui Unknown) &gt; 16:60:24:3d:0f:84 (oui Unknown), ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 64, id 16685, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.100.1.39.52402 &gt; 10.100.1.40.http: Flags [S], cksum 0x1745 (incorrect -&gt; 0x9d01), seq 2993213598, win 64860, options [mss 1410,sackOK,TS val 2243936499 ecr 0,nop,wscale 7], length 0</span><br><span class="line">0x0000:  1660 243d 0f84 0aff 9f1b 5c02 0800 4500  .`$=......\...E.</span><br><span class="line">0x0010:  003c 412d 4000 4006 e278 0a64 0127 0a64  .&lt;A-@.@..x.d.<span class="string">&#x27;.d</span></span><br><span class="line"><span class="string">0x0020:  0128 ccb2 0050 b268 d09e 0000 0000 a002  .(...P.h........</span></span><br><span class="line"><span class="string">0x0030:  fd5c 1745 0000 0204 0582 0402 080a 85bf  .\.E............</span></span><br><span class="line"><span class="string">0x0040:  c0f3 0000 0000 0103 0307                 ..........</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>从宿主机的 <code>arp</code> 命令可知 <code>cni0</code> 上的路由表是既有 <code>pod0</code> 的mac地址+ip地址，也有<code>pod1</code>的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@vm-ks1:~<span class="comment"># arp -v</span></span><br><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">10.100.0.0               ether   da:e9:f6:2d:73:b5   CM                    flannel.1</span><br><span class="line">10.100.1.41              ether   5e:82:a8:f9:ab:92   C                     cni0</span><br><span class="line">10.100.1.40              ether   16:60:24:3d:0f:84   C                     cni0</span><br><span class="line">10.100.1.42              ether   ae:85:38:14:2e:3f   C                     cni0</span><br><span class="line">10.100.1.44              ether   56:0c:75:ed:ca:cb   C                     cni0</span><br><span class="line">_gateway                 ether   00:50:56:e3:07:3f   C                     ens33</span><br><span class="line">172.16.101.1             ether   00:50:56:c0:00:08   C                     ens33</span><br><span class="line">vm-ks0                   ether   00:0c:29:ee:ae:5f   C                     ens33</span><br><span class="line">10.100.1.39              ether   0a:ff:9f:1b:5c:02   C                     cni0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="k8s-跨主机ip通信"><a href="#k8s-跨主机ip通信" class="headerlink" title="k8s 跨主机ip通信"></a>k8s 跨主机ip通信</h2><p>跨主机间通信分2种，hostgw: eht0  vxlan: flannel0。我们在初始化k8s 集群时使用的是 flannel的网络cni插件。<a href="https://github.com/coreos/flannel">flannel</a>通过给每台宿主机分配一个子网的方式为容器提供虚拟网络，它基于Linux TUN/TAP，使用UDP封装IP包来创建overlay网络，并借助etcd维护网络的分配情况。</p><blockquote><p>udp：使用用户态udp封装，默认使用8285端口。由于是在用户态封装和解包，性能上有较大的损失<br>vxlan：vxlan封装，需要配置VNI，Port（默认8472）和GBP<br>host-gw：直接路由的方式，将容器网络的路由信息直接更新到主机的路由表中，仅适用于二层直接可达的网络</p></blockquote><ul><li><p>node: <code>vm-ks1</code>：<code>172.16.101.136/16</code></p><ul><li>pod0: <code>web-0</code> : <code>10.100.1.39  eth0@if6  0a:ff:9f:1b:5c:02</code></li><li>flannel.1: <code>10.100.0.0  da:e9:f6:2d:73:b5</code></li></ul></li><li><p>node: <code>vm-ks0</code>: <code>172.16.101.135/16</code></p><ul><li>pod2: <code>web-2</code> : <code>10.100.0.22  eth0@if8  66:14:4c:b9:74:13</code></li><li>flannel.1: <code>10.100.1.0  fe:ca:1a:3e:42:41</code></li></ul></li></ul><p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_flannel.png"></p><p>vm-ks0 的 <code>flannel</code> 设备收到“原始 IP 包”后，就要想办法把“原始 IP 包”加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 flannel” 设备。vm-ks0 和 vm-ks1 上的 flannel 设备组成了一个虚拟的2层网络，即：通过二层数据帧进行通信。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@vm-ks0:~<span class="comment"># ifconfig flannel.1</span></span><br><span class="line">flannel.1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        inet 10.100.0.0  netmask 255.255.255.255  broadcast 10.100.0.0</span><br><span class="line">        inet6 fe80::d8e9:f6ff:fe2d:73b5  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether da:e9:f6:2d:73:b5  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 4387  bytes 777102 (777.1 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8578  bytes 1684583 (1.6 MB)</span><br><span class="line">        TX errors 19  dropped 49 overruns 0  carrier 19  collisions 0</span><br><span class="line">        </span><br><span class="line">root@vm-ks0:~<span class="comment"># ip neigh show dev flannel.1</span></span><br><span class="line">10.100.1.0 lladdr fe:ca:1a:3e:42:41 PERMANENT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在vm-ks0上执行 <code>ip neigh show dev flannel.1</code><br>这条记录的意思非常明确，即：IP 地址 10.100.1.0，对应的 MAC 地址是 fe:ca:1a:3e:42:41。</p><p>一个 flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对应的宿主机地址是什么。</p><p>也就是说，这个 UDP 包该发给哪台宿主机呢？</p><p>在这种场景下，flannel.1 设备实际上要扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而在 Linux 内核里面，“网桥”设备进行转发的依据，来自于一个叫作 FDB（Forwarding Database）的转发数据库。</p><p>这个 flannel.1“网桥”对应的 FDB 信息，也是 flanneld 进程负责维护的。它的内容可以通过 bridge fdb 命令查看到，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm-ks0:~<span class="comment"># bridge fdb show flannel.1 | grep fe:ca:1a:3e:42:41</span></span><br><span class="line">fe:ca:1a:3e:42:41 dev flannel.1 dst 172.16.101.136 self permanent</span><br></pre></td></tr></table></figure><p>这下整个转发过程就清楚了，参考下图的封装过程。</p><p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_vxlan_packet.webp"></p><p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_vxlan.png"></p><p>从上面的 wireshark 抓包可以看到，跨主机访问的报文是UDP的VXLAN协议，使用 8472 端口。<br>VXLAN 上的二层Mac地址分别是两台node节点的flannel网卡的Mac地址。<br>再向上就如同pod0 和 pod2 直接通信的效果了。</p><p>3 层主机之间的通信UDP模式已经废弃。<br>我们在进行系统级编程的时候，有一个非常重要的优化原则，就是要减少用户态到内核态的切换次数，并且把核心的处理逻辑都放在内核态进行。这也是为什么，Flannel 后来支持的VXLAN 模式，逐渐成为了主流的容器网络方案的原因。</p><h2 id="CNI-插件的部署和实现"><a href="#CNI-插件的部署和实现" class="headerlink" title="CNI 插件的部署和实现"></a>CNI 插件的部署和实现</h2><p>我们在部署 Kubernetes 的时候，有一个步骤是安装 kubernetes-cni 包，它的目的就是在宿主机上安装 <strong>CNI 插件所需的基础可执行文件</strong>。</p><p>在安装完成后，你可以在宿主机的 /opt/cni/bin 目录下看到它们，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@vm-ks0:~<span class="comment"># ls -al /opt/cni/bin/</span></span><br><span class="line">total 70504</span><br><span class="line">drwxrwxr-x 2 root root     4096 Aug 15 10:07 .</span><br><span class="line">drwxr-xr-x 3 root root     4096 Aug 15 10:07 ..</span><br><span class="line">-rwxr-xr-x 1 root root  4159518 May 14  2020 bandwidth</span><br><span class="line">-rwxr-xr-x 1 root root  4671647 May 14  2020 bridge</span><br><span class="line">-rwxr-xr-x 1 root root 12124326 May 14  2020 dhcp</span><br><span class="line">-rwxr-xr-x 1 root root  5945760 May 14  2020 firewall</span><br><span class="line">-rwxr-xr-x 1 root root  3069556 May 14  2020 flannel</span><br><span class="line">-rwxr-xr-x 1 root root  4174394 May 14  2020 host-device</span><br><span class="line">-rwxr-xr-x 1 root root  3614480 May 14  2020 host-local</span><br><span class="line">-rwxr-xr-x 1 root root  4314598 May 14  2020 ipvlan</span><br><span class="line">-rwxr-xr-x 1 root root  3209463 May 14  2020 loopback</span><br><span class="line">-rwxr-xr-x 1 root root  4389622 May 14  2020 macvlan</span><br><span class="line">-rwxr-xr-x 1 root root  3939867 May 14  2020 portmap</span><br><span class="line">-rwxr-xr-x 1 root root  4590277 May 14  2020 ptp</span><br><span class="line">-rwxr-xr-x 1 root root  3392826 May 14  2020 sbr</span><br><span class="line">-rwxr-xr-x 1 root root  2885430 May 14  2020 static</span><br><span class="line">-rwxr-xr-x 1 root root  3356587 May 14  2020 tuning</span><br><span class="line">-rwxr-xr-x 1 root root  4314446 May 14  2020 vlan</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些 CNI 的基础可执行文件，按照功能可以分为三类:</p><ul><li><strong>第一类，叫作 Main 插件，它是用来创建具体网络设备的二进制文件</strong>。比如，bridge（网桥设备）、ipvlan、loopback（lo 设备）、macvlan、ptp（Veth Pair 设备），以及 vlan。我在前面提到过的 Flannel、Weave 等项目，都属于“网桥”类型的 CNI 插件。所以在具体的实现中，它们往往会调用 bridge 这个二进制文件。</li><li><strong>第二类，叫作 IPAM（IP Address Management）插件</strong>，它是负责分配 IP 地址的二进制文件。比如，dhcp，这个文件会向 DHCP 服务器发起请求；host-local，则会使用预先配置的 IP 地址段来进行分配。</li><li><strong>第三类，是由 CNI 社区维护的内置 CNI 插件</strong>。比如：flannel，就是专门为 Flannel 项目提供的 CNI 插件；tuning，是一个通过 sysctl 调整网络设备参数的二进制文件；portmap，是一个通过 iptables 配置端口映射的二进制文件；bandwidth，是一个使用 Token Bucket Filter (TBF) 来进行限流的二进制文件。</li></ul><p><strong>首先，实现这个网络方案本身</strong>。这一部分需要编写的，其实就是 flanneld 进程里的主要逻辑。比如，创建和配置 flannel.1 设备、配置宿主机路由、配置 ARP 和 FDB 表里的信息等等。</p><p><strong>然后，实现该网络方案对应的 CNI 插件</strong>。这一部分主要需要做的，就是配置 Infra 容器里面的网络栈，并把它连接在 CNI 网桥上。</p><p>其启动和配置原理如下,首先，CNI bridge 插件会在宿主机上检查 CNI 网桥是否存在。如果没有的话，那就创建它。这相当于在宿主机上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在宿主机上</span></span><br><span class="line">$ ip link add cni0 <span class="built_in">type</span> bridge</span><br><span class="line">$ ip link <span class="built_in">set</span> cni0 up</span><br></pre></td></tr></table></figure><p>接下来，CNI bridge 插件会通过 Infra 容器的 Network Namespace 文件，进入到这个 Network Namespace 里面，然后创建一对 Veth Pair 设备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一对Veth Pair设备。其中一个叫作eth0，另一个叫作vethb4963f3</span></span><br><span class="line">$ ip link add eth0 <span class="built_in">type</span> veth peer name vethb4963f3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动eth0设备</span></span><br><span class="line">$ ip link <span class="built_in">set</span> eth0 up </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将Veth Pair设备的另一端（也就是vethb4963f3设备）放到宿主机（也就是Host Namespace）里</span></span><br><span class="line">$ ip link <span class="built_in">set</span> vethb4963f3 netns <span class="variable">$HOST_NS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Host Namespace，启动宿主机上的vethb4963f3设备</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$HOST_NS</span> ip link <span class="built_in">set</span> vethb4963f3 up </span><br></pre></td></tr></table></figure><p>这样，vethb4963f3 就出现在了宿主机上，而且这个 Veth Pair 设备的另一端，就是容器里面的 eth0。(在宿主机上操作也可以，原理都一样)</p><p>接下来，CNI bridge 插件就可以把 vethb4963f3 设备连接在 CNI 网桥上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在宿主机上</span></span><br><span class="line">$ ip link <span class="built_in">set</span> vethb4963f3 master cni0</span><br></pre></td></tr></table></figure><p>所有容器都可以直接使用 IP 地址与其他容器通信，而无需使用 NAT。</p><p>容器自己“看到”的自己的 IP 地址，和别人（宿主机或者容器）看到的地址是完全一样的。</p><h2 id="三层网络方案"><a href="#三层网络方案" class="headerlink" title="三层网络方案"></a>三层网络方案</h2><p>除了网桥类型的 Flannel 插件，还有一种纯三层（Pure Layer 3）网络方案，典型例子包括 Flannel 的 host-gw 模式和 Calico 项目。</p><p>当你设置 Flannel 使用 host-gw 模式之后，flanneld 会在宿主机上创建这样一条规则，以 vm-ks0 为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ip route</span><br><span class="line">...</span><br><span class="line">10.100.1.0/24 via 172.16.101.136 dev eth0</span><br></pre></td></tr></table></figure><p>这条路由规则的含义是：目的 IP 地址属于 10.100.1.0/24 网段的 IP 包，应该经过本机的 eth0 设备发出去（即：dev eth0）；并且，它下一跳地址（next-hop）是 172.16.101.136（即：via 172.16.101.136）。</p><p><strong>host-gw 模式的工作原理，其实就是将每个 Flannel 子网（Flannel Subnet，比如：10.100.1.0/24）的“下一跳”，设置成了该子网对应的宿主机的 IP 地址。</strong></p><p>也就是说，这台“主机”（Host）会充当这条容器通信路径里的“网关”（Gateway）。这也正是“host-gw”的含义。<strong>所以说，Flannel host-gw 模式必须要求集群宿主机之间是二层连通的。</strong></p><p><strong>不同于 Flannel 通过 Etcd 和宿主机上的 flanneld 来维护路由信息的做法，Calico 项目使用了一个BGP(Border Gateway Protocol，即：边界网关协议) 来自动地在整个集群中分发路由信息。</strong></p><p><img src="https://img1.kiosk007.top/static/images/k8s/structure/k8s_network_l3_bgp.webp"></p><p>比如上述，有2个自治系统（Autonomous System，简称为 AS）：AS 1 和 AS 2。在正常情况下，自治系统之间不会有任何“来往”。</p><p>比如，AS 1 里面的主机 10.10.0.2，要访问 AS 2 里面的主机 172.17.0.3 的话。它发出的 IP 包，就会先到达自治系统 AS 1 上的路由器 Router 1。</p><p>而在此时，Router 1 的路由表里，有这样一条规则，即：目的地址是 172.17.0.2 包，应该经过 Router 1 的 C 接口，发往网关 Router 2（即：自治系统 AS 2 上的路由器）。至此Router 2 就会把数据包交付到真正的目的主机上。</p><p>我们就把它形象地称为：<strong>边界网关</strong>。它跟普通路由器的不同之处在于，它的路由表里拥有其他自治系统里的主机路由信息。</p><p>而 BGP 的这个能力，正好可以取代 Flannel 维护主机上路由表的功能。而且，BGP 这种原生就是为大规模网络环境而实现的协议，其可靠性和可扩展性，远非 Flannel 自己的方案可比。</p><ul><li><strong>三层网络和二层隧道的区别</strong><ul><li>三层和隧道的异同：<br>相同之处是都实现了跨主机容器的三层互通，而且都是通过对目的 MAC 地址的操作来实现的；不同之处是三层通过配置下一条主机的路由规则来实现互通，隧道则是通过通过在 IP 包外再封装一层 MAC 包头来实现。</li></ul></li></ul><blockquote><ul><li>三层的优点：少了封包和解包的过程，性能肯定是更高的。</li><li>三层的缺点：需要自己想办法维护路由规则。</li><li>隧道的优点：简单，原因是大部分工作都是由 Linux 内核的模块实现了，应用层面工作量较少。</li><li>隧道的缺点：主要的问题就是性能低。</li></ul></blockquote><p>根据实际的测试，host-gw 的性能损失大约在 10% 左右，而其他所有基于 VXLAN“隧道”机制的网络方案，性能损失都在 20%~30% 左右。</p><h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h2><p>在 Kubernetes 里，网络隔离能力的定义，是依靠一种专门的 API 对象来描述的，即：NetworkPolicy。</p><p><strong>Kubernetes 里的 Pod 默认都是“允许所有”（Accept All）的</strong>，即：Pod 可以接收来自任何发送方的请求；或者，向任何接收方发送请求。而如果你要对这个情况作出限制，就必须通过 NetworkPolicy 对象来指定。</p><p>如下例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">        <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">project:</span> <span class="string">myproject</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5978</span></span><br></pre></td></tr></table></figure><p>这个 NetworkPolicy 对象，指定的隔离规则如下所示：</p><ol><li>该隔离规则只对 default Namespace 下的，携带了 role=db 标签的 Pod 有效。限制的请求类型包括 ingress（流入）和 egress（流出）。</li><li>Kubernetes 会拒绝任何访问被隔离 Pod 的请求，除非这个请求来自于以下“白名单”里的对象，并且访问的是被隔离 Pod 的 6379 端口。这些“白名单”对象包括：<br>a. default Namespace 里的，携带了 role=fronted 标签的 Pod；<br>b. 携带了 project=myproject 标签的 Namespace 里的任何 Pod；<br>c. 任何源地址属于 172.17.0.0/16 网段，且不属于 172.17.1.0/24 网段的请求。</li><li>Kubernetes 会拒绝被隔离 Pod 对外发起任何请求，除非请求的目的地址属于 10.0.0.0/24 网段，并且访问的是该网段地址的 5978 端口。</li></ol><p>在 Kubernetes 生态里，目前已经实现了 NetworkPolicy 的网络插件包括 Calico、Weave 和 kube-router 等多个项目，但是并不包括 Flannel 项目。</p><p>所以说，如果想要在使用 Flannel 的同时还使用 NetworkPolicy 的话，你就需要再额外安装一个网络插件，比如 Calico 项目，来负责执行 NetworkPolicy。<a href="https://docs.projectcalico.org/v3.2/getting-started/kubernetes/installation/flannel">安装方式</a></p><h1 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h1><p>我们知道 deployment 是由一堆 pod 组成的。在我们要访问pod 上的服务时有2个问题需要解决。</p><ol><li>pod 的ip是不固定的，随着调度一直在变</li><li>pod之间需要一种负载均衡的访问</li></ol><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>一个最典型的 <code>service</code> 定义如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>可以看到这个名为 <code>nginx</code> 的service，后面挂载了3个pod。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe svc nginx</span><br><span class="line">Name:              nginx</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Family Policy:  SingleStack</span><br><span class="line">IP Families:       IPv4</span><br><span class="line">IP:                10.96.60.101</span><br><span class="line">IPs:               10.96.60.101</span><br><span class="line">Port:              default  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.100.1.39:80,10.100.1.40:80,10.100.1.43:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问时可以随机负载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-0</span><br><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-1</span><br><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-1</span><br><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-2</span><br><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># curl 10.96.60.101/hello</span></span><br><span class="line">hi, web-0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上，Service 是由 kube-proxy 组件，加上 iptables 来共同实现的。</p><p>对于我们前面创建的名叫 <code>nginx</code> 的 Service 来说，一旦它被提交给 Kubernetes，那么 kube-proxy 就可以通过 Service 的 Informer 感知到这样一个 Service 对象的添加。而作为对这个事件的响应，它就会在宿主机上创建这样一条 iptables 规则（你可以通过 iptables-save 看到它），如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm-ks0:~/k8s/svc<span class="comment"># iptables-save | grep &quot;10.96.60.101&quot;</span></span><br><span class="line">-A KUBE-SERVICES -d 10.96.60.101/32 -p tcp -m comment --comment <span class="string">&quot;default/nginx:default cluster IP&quot;</span> -m tcp --dport 80 -j KUBE-SVC-5JWVWZBQU2R3YJF2</span><br><span class="line">-A KUBE-SVC-5JWVWZBQU2R3YJF2 ! -s 10.100.0.0/16 -d 10.96.60.101/32 -p tcp -m comment --comment <span class="string">&quot;default/nginx:default cluster IP&quot;</span> -m tcp --dport 80 -j KUBE-MARK-MASQ</span><br></pre></td></tr></table></figure><p>这条 iptables 规则的含义是：凡是目的地址是 10.96.60.101、目的端口是 80 的 IP 包，都应该跳转到另外一条名叫 KUBE-SVC-5JWVWZBQU2R3YJF2 的 iptables 链进行处理。</p><p>那如何做到随机访问，实际上是利用了iptable规则里的random组件里的 <code>--probability</code> 实现的，有33%的概率访问到 <code>web-0</code>, 如果没命中的话，有50%的概率访问到 <code>web-1</code>, 如果还没有命中的话，则必访问到 <code>web-3</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SVC-5JWVWZBQU2R3YJF2 -m comment --comment <span class="string">&quot;default/nginx:default&quot;</span> -m statistic --mode random --probability 0.33333333349 -j KUBE-SEP-WZ2C5AZQZKHYZFZC</span><br><span class="line">-A KUBE-SVC-5JWVWZBQU2R3YJF2 -m comment --comment <span class="string">&quot;default/nginx:default&quot;</span> -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-VQLGMKAWCVHQEJD4</span><br><span class="line">-A KUBE-SVC-5JWVWZBQU2R3YJF2 -m comment --comment <span class="string">&quot;default/nginx:default&quot;</span> -j KUBE-SEP-W6K7OWILI2KV46KH</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不难想到，当你的宿主机上有大量 Pod 的时候，成百上千条 iptables 规则不断地被刷新，会大量占用该宿主机的 CPU 资源，甚至会让宿主机“卡”在这个过程中。所以说，<strong>一直以来，基于 iptables 的 Service 实现，都是制约 Kubernetes 项目承载更多量级的 Pod 的主要障碍。</strong></p><p>而 IPVS 模式的 Service，就是解决这个问题的一个行之有效的方法。IPVS 模式的工作原理，其实跟 iptables 模式类似。当我们创建了前面的 Service 之后，kube-proxy 首先会在宿主机上创建一个虚拟网卡（叫作：kube-ipvs0），并为它分配 Service VIP 作为 IP 地址，</p><p class="div-border green">所以，在大规模集群里，建议 kube-proxy 设置–proxy-mode=ipvs 来开启这个功能。它为 Kubernetes 集群规模带来的提升，还是非常巨大的。</p><ul><li><strong>DNS 服务发现</strong></li></ul><p>在 Kubernetes 中，Service 和 Pod 都会被分配对应的 DNS A 记录（从域名解析 IP 的记录）。</p><p>对于 ClusterIP 模式的 Service 来说（比如我们上面的例子），它的 A 记录的格式是：..svc.cluster.local。当你访问这条 A 记录的时候，它解析到的就是该 Service 的 VIP 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@web-1:&#x2F;# dig nginx.default.svc.cluster.local +short</span><br><span class="line">10.96.60.101</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在 Kubernetes 里，/etc/hosts 文件是单独挂载的，这也是为什么 kubelet 能够对 hostname 进行修改并且 Pod 重建后依然有效的原因。这跟 Docker 的 Init 层是一个原理。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章将从K8S的架构、存储、网络及服务暴露等几个方面介绍,记录K8S的学习过程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s 部署 HTTP3  Nginx </title>
    <link href="http://kiosk007.top/2021/08/04/k8s-%E9%83%A8%E7%BD%B2-Nginx-%E9%9B%86%E7%BE%A4/"/>
    <id>http://kiosk007.top/2021/08/04/k8s-%E9%83%A8%E7%BD%B2-Nginx-%E9%9B%86%E7%BE%A4/</id>
    <published>2021-08-04T14:56:00.000Z</published>
    <updated>2021-08-04T14:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前的文章中介绍了如何编译<a href="https://kiosk007.top/2021/07/31/%E5%B0%9D%E8%AF%95-Nginx-%E4%B8%8A%E4%BD%BF%E7%94%A8HTTP3/">支持HTTP3的Nginx</a> 为了一键将H3 Nginx上云，一劳永逸，本文会记录一下容器化Nginx的过程。</p><a id="more"></a><h1 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h1><p>Docker Image 的制作两种方法，支持 HTTP3 的 Nginx 在上面的文章中已经阐述(不过需要加上 <code>nginx-upstream-dynamic-servers</code> 这个模块，后面会用到)，镜像的制作是将编译好的二进制文件打包放进 Docker 镜像当中，并保证其可运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法 1：docker commit #保存 container 的当前状态到 image 后，然后生成对应的 image</span><br><span class="line">方法 2：docker build #使用 Dockerfile 文件自动化制作 image</span><br></pre></td></tr></table></figure><h2 id="方法一-docker-commit"><a href="#方法一-docker-commit" class="headerlink" title="方法一: docker commit"></a>方法一: docker commit</h2><p>获取 ubuntu 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu:latest &#x2F;bin&#x2F;bash</span><br><span class="line"># 进入到容器后，创建 nginx 家目录</span><br><span class="line">mkdir nginx</span><br></pre></td></tr></table></figure><p>Nginx 的编译产物会全部放进 ${NGINX_QUIC_PATH}/objs 目录下。所以创建镜像需要将这里面的必要文件copy进镜像中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  nginx-quic ls objs </span><br><span class="line">addon  autoconf.err  Makefile  nginx  nginx.8  ngx_auto_config.h  ngx_auto_headers.h  ngx_modules.c  ngx_modules.o  src</span><br><span class="line"></span><br><span class="line">➜  docker cp ./obj/nginx 9d129eb7c4a6:/nginx/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为Nginx依赖 Lua 动态库所以还需要将 luajit 等动态库拷贝进镜像中。并指明相关的动态库加载地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  docker cp /usr/<span class="built_in">local</span>/include/luajit-2.0/ 9d129eb7c4a6:/usr/<span class="built_in">local</span>/include</span><br><span class="line">➜  docker cp /usr/<span class="built_in">local</span>/lib/libluajit-5.1.a 9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib</span><br><span class="line">➜  docker cp /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2.0.5 9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib</span><br><span class="line"></span><br><span class="line">➜  docker cp /usr/<span class="built_in">local</span>/lib/libpcre.so.1.2.12 9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib/</span><br><span class="line">➜  docker cp /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1  9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib/</span><br><span class="line">➜  docker cp /usr/lib/x86_64-linux-gnu/libprofiler.so.0.4.18 9d129eb7c4a6:/usr/<span class="built_in">local</span>/lib/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到容器中，创建软连</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib</span><br><span class="line">ln -sv libluajit-5.1.so.2.0.5 libluajit-5.1.so</span><br><span class="line">ln -sv libluajit-5.1.so.2.0.5 libluajit-5.1.so.2</span><br><span class="line"></span><br><span class="line">ln -sv libpcre.so.1.2.12 libpcre.so</span><br><span class="line">ln -sv libpcre.so.1.2.12 libpcre.so.1</span><br><span class="line"></span><br><span class="line">ln -sv libprofiler.so.0.4.18 libprofiler.so</span><br><span class="line">ln -sv libprofiler.so.0.4.18 libprofiler.so.0</span><br><span class="line"></span><br><span class="line">ln -sv libunwind.so.8.0.1 libunwind.so</span><br><span class="line">ln -sv libunwind.so.8.0.1 libunwind.so.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器内的 ~/.bashrc 生成环境变量</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LUAJIT_LIB=/usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">export</span> LUAJIT_INC=/usr/<span class="built_in">local</span>/include/luajit-2.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 exit 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>根据容器当前状态做一个 image 镜像</p><blockquote><p>-m :提交时的说明文字； -a :提交的镜像作者；</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  docker commit -m <span class="string">&quot;nginx http3 quic&quot;</span> -a <span class="string">&quot;kiosk007&quot;</span> 158c3352b0da weijiaxiang007/nginx-http3:v0.1</span><br><span class="line">sha256:322e9c9b5fa886294ca478440ccfe972fcef2416f1d99b3eb9a20552454246fa</span><br><span class="line"></span><br><span class="line">➜  docker images</span><br><span class="line">REPOSITORY                                                    TAG       IMAGE ID       CREATED              SIZE</span><br><span class="line">http3_nginx                                                   v0.1      47f04055cd4e   About a minute ago   201MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法二：DockerFile"><a href="#方法二：DockerFile" class="headerlink" title="方法二：DockerFile"></a>方法二：DockerFile</h2><p>使用 docker build 创建镜像时，需要使用 Dockerfile 文件自动化制作 image 镜像<br>Dockerfile 有点像源码编译时./configure 后产生的 Makefile</p><ul><li>创建工作目录 和 DockerFile 文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  mkdir nginx-http3</span><br><span class="line">➜  <span class="built_in">cd</span> nginx-http3</span><br><span class="line">➜  touch Dockerfile</span><br></pre></td></tr></table></figure><p>将 Nginx-http3 的编译产物和依赖动态库 copy 至该目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  cp -rf /usr/<span class="built_in">local</span>/include/luajit-2.0 .</span><br><span class="line">➜  cp -rf /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2.0.5 .</span><br><span class="line">➜  cp -rf /usr/<span class="built_in">local</span>/lib/libluajit-5.1.a .       </span><br><span class="line">➜  cp -rf /usr/<span class="built_in">local</span>/lib/libpcre.so.1.2.12 .</span><br><span class="line">➜  cp -rf /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1 .</span><br><span class="line">➜  cp -rf /usr/lib/x86_64-linux-gnu/libprofiler.so.0.4.18 .</span><br><span class="line">➜  cp -rf ~/Project/Nginx/nginx-quic/objs/nginx .</span><br><span class="line">➜  cp -rf ~/Project/Nginx/nginx-quic/conf/nginx.conf .</span><br><span class="line">➜  cp -rf ~/Project/Nginx/nginx-quic/conf/mime.types . </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>编写DockerFile</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This dockerfile uses the ubuntu image</span></span><br><span class="line"><span class="comment"># VERSION 2 - EDITION 1</span></span><br><span class="line"><span class="comment"># Author: kiosk007</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FROM 基于哪个镜像</span></span><br><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># MAINTAINER 镜像创建者</span></span><br><span class="line">MAINTAINER kiosk007</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">ENV LUAJIT_LIB=/usr/<span class="built_in">local</span>/lib LUAJIT_INC=/usr/<span class="built_in">local</span>/include/luajit-2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY 文件至容器中</span></span><br><span class="line">COPY luajit-2.0 /usr/<span class="built_in">local</span>/include/luajit-2.0</span><br><span class="line">COPY lib* /usr/<span class="built_in">local</span>/lib/</span><br><span class="line">COPY nginx /sbin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN </span></span><br><span class="line">RUN ln -sv /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2.0.5 /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2.0.5 /usr/<span class="built_in">local</span>/lib/libluajit-5.1.so.2 &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libpcre.so.1.2.12 /usr/<span class="built_in">local</span>/lib/libpcre.so &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libpcre.so.1.2.12 /usr/<span class="built_in">local</span>/lib/libpcre.so.1 &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libprofiler.so.0.4.18 /usr/<span class="built_in">local</span>/lib/libprofiler.so &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libprofiler.so.0.4.18 /usr/<span class="built_in">local</span>/lib/libprofiler.so.0 &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libunwind.so.8.0.1 /usr/<span class="built_in">local</span>/lib/libunwind.so &amp;&amp; \</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/lib/libunwind.so.8.0.1 /usr/<span class="built_in">local</span>/lib/libunwind.so.8 &amp;&amp; mkdir -p /nginx/logs &amp;&amp; mkdir -p /nginx/conf &amp;&amp; ldconfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># EXPOSE 暴露端口</span></span><br><span class="line">EXPOSE 80/tcp 443/tcp 443/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置挂载路径 /nginx</span></span><br><span class="line">VOLUME /nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD</span></span><br><span class="line">CMD [<span class="string">&quot;/sbin/nginx&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="string">&quot;/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p class="div-border grey">Dockerfile 的指令每执行一次都会在 docker 上新建一层，所以特别是 RUN 指令尽量通过 && 连在一起</p><p>关于Docker CMD 和 ENTRYPOINT ，可参考<a href="https://www.jb51.net/article/136264.htm">这篇文章</a>, Dockerfile 语法参考 <a href="https://www.runoob.com/docker/docker-dockerfile.html">菜鸟</a>，<br>关于为什么 CMD 要写成 <code>daemon off</code> 参考 <a href="https://z.itpub.net/article/detail/45E0117B462C4053A0FA82AC0FBED1FB">Docker，为什么你容器刚启动就停了？</a></p><ul><li>构建镜像文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker build -t kiosk007&#x2F;nginx-quic:v0.2 .</span><br></pre></td></tr></table></figure><p>—tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签.</p><p>镜像打包好后，通过 <code>docker images</code> 命令可以看到当前的镜像id</p><ul><li>运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name http3_nginx -v ~&#x2F;Project&#x2F;Nginx&#x2F;nginx-quic:&#x2F;nginx -p 8080:80 -p 8443:443&#x2F;udp -p 8443:443&#x2F;tcp -d 35edbb5f8be1</span><br></pre></td></tr></table></figure><blockquote><p>-p 8443:443 映射端口<br>-d 守护进程运行<br>-name http3_nginx 指定容器的名称<br>-v xxxx:/nginx 将宿主机的Nginx工作目录映射进容器中的工作目录 </p></blockquote><p>OK, 既然容器已经都起来了，那么访问一下吧，我本地的nginx conf 已经配置了 <code>quic.kiosk007.top 的 quic 配置</code>，使用 quic 客户端访问一下吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http_client -H quic.kiosk007.top:8443 -p /ping   </span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">server: nginx/1.21.1</span><br><span class="line">date: Sat, 07 Aug 2021 08:57:50 GMT</span><br><span class="line">content-type: text/html</span><br><span class="line">content-length: 4</span><br><span class="line">strict-transport-security: max-age=63072000; includeSubDomains; preload</span><br><span class="line">alt-svc: h3-27=<span class="string">&quot;:8443&quot;</span>; h3-28=<span class="string">&quot;:8443&quot;</span>; h3-29=<span class="string">&quot;:8443&quot;</span>; ma=86400; quic=<span class="string">&quot;:8443&quot;</span></span><br><span class="line"></span><br><span class="line">pong%                                                  </span><br></pre></td></tr></table></figure><h2 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h2><p>登录到 <code>https://hub.docker.com/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker login</span><br></pre></td></tr></table></figure><p>上传到 docker hub<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker push weijiaxiang007/nginx-http3:v0.1</span><br></pre></td></tr></table></figure><br>在 docker hub 官网上可以找到自己上传上去的镜像。</p><p><img src="https://img1.kiosk007.top/static/images/docker/docker_hub.png"></p><p>大家如果想要获取我制作的 http3-nginx 镜像，可直接拉取<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push weijiaxiang007/nginx-http3:latest</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container prune  # 删除所有停止的容器</span><br><span class="line">docker image prune -a   # 删除没有用到的镜像</span><br></pre></td></tr></table></figure><h1 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h1><h2 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h2><p>Minikube是由Kubernetes社区维护的单机版的Kubernetes集群。并支持Kubernetes的大部分功能，从基础的容器编排管理，到高级特性如负载均衡、Ingress，权限控制等。</p><p>安装 minikube ，可参考官方文档 <a href="https://minikube.sigs.k8s.io/docs/start/">minikube start</a>, 另外还需要安装 kubectl 另外做一些配置（如关掉 swap ），具体可参考我之前的<a href="https://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/#%E5%AE%89%E8%A3%85k8s-master">文章</a> 。</p><p>minikube 中安装 cni 是有版本依赖，老旧版本没有 —cni 选项，新版本可以支持<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  minikube version</span><br><span class="line">minikube version: v1.22.0</span><br><span class="line">commit: a03fbcf166e6f74ef224d4a63be4277d017bb62e</span><br></pre></td></tr></table></figure><br>cni 插件安装：</p><p>flannel 服务在安装运行过程中依赖二进制文件 /opt/cni/bin/portmap ，没有会报错</p><p>安装 cni 后会在对应目录生成二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo apt install kubernetes-cni -y</span><br></pre></td></tr></table></figure><p>启动 minikube 集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  minikube start --cni=flannel</span><br></pre></td></tr></table></figure><p>安装完成后, 查看状态 <code>minikube status</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  minikube status</span><br><span class="line">minikube</span><br><span class="line"><span class="built_in">type</span>: Control Plane</span><br><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line">apiserver: Running</span><br><span class="line">kubeconfig: Configured</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用minikube</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -o wide <span class="comment">## 可以查看到有了一个单节点的集群，IP地址</span></span><br><span class="line">kubectl get pods -o wide  <span class="comment">## 可以看到创建的pods，当然现在是空的</span></span><br><span class="line">kubectl cluster-info      <span class="comment">## 查看集群Master信息</span></span><br><span class="line">kubectl get all --namespace=kube-system<span class="comment">## 查看部署组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##现在我们ssh到我们的master节点</span></span><br><span class="line">ssh -i ~/.minikube/machines/minikube/id_rsa docker@$(minikube ip)</span><br><span class="line"><span class="comment">## 也可以直接执行 minikube ssh</span></span><br></pre></td></tr></table></figure><ul><li>minikube 网络控制台</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure><p>dashboard 是 kubernetes 的一个web UI，提供了友好的图形化界面，和对集群交互的基本操作功能。</p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><strong>议题</strong></p><ol><li>K8S集群中为什么需要负载均衡器</li><li>在K8S集群的边缘节点运行Nginx</li><li>Nginx如何发现K8S中的服务</li><li>K8S中的Ingress</li></ol><p><strong>基础概念介绍：</strong></p><ul><li><strong>K8S Deployments 介绍</strong></li></ul><p>为了实现在Kubernetes集群上部署容器化应用程序。需要创建一个Kubernetes Deployment，Deployment负责创建和更新应用。</p><p>典型的应用场景包括：</p><blockquote><p>a. 定义Deployment来创建Pod和ReplicaSet<br>b. 滚动升级和回滚应用<br>c. 扩容和缩容<br>d. 暂停和继续Deployment</p></blockquote><p>参考：<a href="https://www.kubernetes.org.cn/deployment">https://www.kubernetes.org.cn/deployment</a></p><ul><li><strong>K8S Service 介绍</strong></li></ul><p>Kubernetes Service 定义了这样一种抽象：一个 Pod 的逻辑分组，也就是为一组Pod提供统一的访问方式。通常 Pod 通过 Label Selector 实现的与 Service 绑定。</p><p>一个 Service 在 Kubernetes 中是一个 REST 对象，和 Pod 类似。 像所有的 REST 对象一样， Service 定义可以基于 POST 方式，请求 apiserver 创建新的实例。 例如，假定有一组 Pod，它们对外暴露了 9376 端口，同时还被打上 “app=MyApp” 标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: MyApp</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br></pre></td></tr></table></figure><p>参考: <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a></p><h2 id="如何获取K8S集群中的服务"><a href="#如何获取K8S集群中的服务" class="headerlink" title="如何获取K8S集群中的服务?"></a>如何获取K8S集群中的服务?</h2><p>一般来说暴露服务的三种方式</p><ul><li><p><strong><span class="inline-tag blue">NodePort</span></strong>: 将服务的类型设置成NodePort-每个集群节点都会在节点上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。该服务仅在内部集群 IP 和端口上才可访间， 但也可通过所有节点上的专用端口访问。<strong>缺点是端口一般是奇怪的端口且端口肯定面临不够用的境地</strong></p></li><li><p><strong><span class="inline-tag blue">LoadBalane</span></strong>: 将服务的类型设置成LoadBalance, NodePort类型的一 种扩展，这使得服务可以通过一个专用的负载均衡器来访问， 这是由Kubernetes中正在运行的云基础设施提供的。 负载均衡器将流量重定向到跨所有节点的节点端口。客户端通过负载均衡器的 IP 连接到服务。<strong>缺点是只是云厂商才能玩得起的（他们有路由器、有SDN）</strong></p></li><li><p><strong><span class="inline-tag blue">Ingress</span></strong>: 创建一个Ingress资源， 这是一个完全不同的机制， 通过一个IP地址公开多个服务，就是一个网关入口。通过域名即可访问。<strong>推荐！！</strong></p></li></ul><blockquote><p>虽然推荐 Ingress 的形式，但是也会先以 Headless Service 的方式搭建一个Nginx集群。</p></blockquote><p><strong>为何获取K8S中的服务是比较困难的？</strong></p><ul><li>每一个pod都有一个由网络层提供的私有地址，在K8S集群中的任一节点上可以可达。K8S集群外部不能直接访问。</li><li>一组相同功能的pod构成service，K8S赋予每个Service一个cluster IP地址。Service可以从cluster IP地址访问。</li><li>Cluster IP地址只在K8S集群内有效，不能从外部直接访问。</li></ul><p><strong>外部应用如何才能访问K8S中的service?</strong></p><ul><li>K8S集群中要有一个或者多个public IP边缘节点</li><li>外部要访问K8S集群内的Service必须通过边缘节点的public IP地址进行访问</li><li>有public IP地址的边缘节点需要部署如Nginx，HAProxy等反向代理将请求转发给K8S中的service</li></ul><p>参考上图也就是边缘节点（Node）需要部署一台Nginx，Nginx有一个 public ip，用来访问k8s中的 service。那么Nginx的部署方式就有了2种。一种是部署在 K8S 集群内，一种是部署在K8S集群外。</p><p><img src="https://img1.kiosk007.top/static/images/k8s/k8s_nginx_deploy.png"></p><p>2种方案有各自的优缺点。</p><ol><li><p>Nginx 部署在K8S 外需要在Nginx的配置文件中指定nameserver；另外Nginx本身需要自己手动维护。</p></li><li><p>Nginx 部署在K8S 内则在Nginx的配置文件中不用指定nameserver，nameserver已由K8S配置好；K8S管理Nginx的启停；Nginx监听端口要映射到host的端口上或者使用host网络(hostNetwork:true)。</p></li></ol><blockquote><p>所以还是推荐使用部署在K8S内的方式。</p></blockquote><p> <strong>通过NodePort发现服务</strong></p><p>在k8s上可以给Service设置成NodePort类型，这样的话可以让Kubernetes在其所有节点上开放一个端口给外部访问（所有节点上都使用相同的端口号）， 并将传入的连接转发给作为Service服务对象的pod。这样我们的pod就可以被外部请求访问到。至于服务都在哪些节点上，就需要动态更新Nginx的配置文件了（ngx_dynamic_upstream）</p><p><img src="https://img1.kiosk007.top/static/images/k8s/service_nodeport_1.png"></p><p>Nginx 配置如下<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> my_services &#123;</span><br><span class="line">  <span class="attribute">zone</span> my_zone <span class="number">1m</span>;   <span class="comment"># my_zone 提供有service pod 的节点的 node ip</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">location</span> / &#123;  </span><br><span class="line">    proxy_passhttp://my_services;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不过问题还是因为端口有限，暴露的服务也是有限的。</p><p><strong>通过Headless service发现服务(推荐）</strong></p><p>Service 是 Kubernetes 项目中用来将一组 Pod 暴露给外界访问的一种机制，如果不是 VIP 的方式访问，那么即是以 DNS 的方式访问，DNS访问又分两种，第一种，DNS的解析是VIP，那后面的访问形式和上述无异，另一种是DNS解析到POD上。</p><p>这就是 <strong>Headless Service</strong>，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。</p><p>这样的话Nginx需支持upstream动态后端服务器地址注册(nginx-upstream-dynamic-servers）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> my_services&#123;</span><br><span class="line">   <span class="attribute">server</span> my_services:<span class="number">8080</span> resolve;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">location</span> / &#123;</span><br><span class="line">      proxy_passhttp://my_services;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在K8S中发布hello 服务配置nginx:</span></span><br></pre></td></tr></table></figure><p>Nginx 可以部署在一个有外网ip（集群外部可访问ip）上。具体可以给Nginx的编排配置上加 <code>Label Selector</code></p><p>当然，我们当前是Minikube单机模式，如果是正式的K8S环境，可以执行以下命令加标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectllabel node node3 node-type=edge</span><br></pre></td></tr></table></figure><blockquote><p>参考 <a href="https://www.cnblogs.com/wzs5800/p/13534942.html">deployment 模板</a></p></blockquote><h2 id="配置-minikube"><a href="#配置-minikube" class="headerlink" title="配置 minikube"></a>配置 minikube</h2><p>minikube 和 标准的 k8s 还是有很多不一样。这里有很多坑其实我还没有踩明白。</p><p>搭建访问tunnel ip<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  minikube tunnel</span><br><span class="line"></span><br><span class="line">Status:</span><br><span class="line">machine: minikube</span><br><span class="line">pid: 1158570</span><br><span class="line">route: 10.96.0.0/12 -&gt; 192.168.49.2</span><br><span class="line">minikube: Running</span><br><span class="line">services: []</span><br><span class="line">    errors: </span><br><span class="line">minikube: no errors</span><br><span class="line">router: no errors</span><br><span class="line">loadbalancer emulator: no errors</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>挂载宿主机目录</p><p class="div-border red">minikube 需要额外执行这一步，才能将宿主机的目录挂载到Pod中的容器中 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube mount /home/weijiaxiang/Project/Nginx/nginx:/host</span><br></pre></td></tr></table></figure><h2 id="配置-k8s"><a href="#配置-k8s" class="headerlink" title="配置 k8s"></a>配置 k8s</h2><p>可参考： <a href="https://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/">ubuntu20.04 部署 Kubernetes (k8s)</a></p><h2 id="Nginx-depolyment"><a href="#Nginx-depolyment" class="headerlink" title="Nginx depolyment"></a>Nginx depolyment</h2><p>新建文件: <code>nginx_http3-deployment.yaml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-http3-deployment</span><br><span class="line">  namespace: default    #必填，Pod所属的命名空间</span><br><span class="line">  labels:               #自定义标签</span><br><span class="line">    app: nginx        #自定义标签名字&lt;key: value&gt;</span><br><span class="line">  annotations:          #自定义注释列表</span><br><span class="line">    imageregistry: &quot;https:&#x2F;&#x2F;hub.docker.com&#x2F;&quot;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-http3  # 必填，通过此标签匹配对应pod</span><br><span class="line">  replicas: 1           # 副本集个数</span><br><span class="line">  template:             # 必填，应用容器模版定义</span><br><span class="line">    metadata:</span><br><span class="line">      labels:           # 必填，遇上面matchLabels的标签相同</span><br><span class="line">        app: nginx-http3</span><br><span class="line">    spec:</span><br><span class="line">      hostIPC: true  </span><br><span class="line">      hostNetwork: true   # 使用主机网络</span><br><span class="line">      #Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Never表示不再重启该Pod</span><br><span class="line">      restartPolicy: Always   </span><br><span class="line">      shareProcessNamespace: true  # Pod 里的容器共享 PID Namespace</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: weijiaxiang007&#x2F;nginx-http3:v0.2</span><br><span class="line">        imagePullPolicy: IfNotPresent   # [Always | Never | IfNotPresent] 获取镜像的策略 Alawys表示下载镜像;IfnotPresent表示优先使用本地镜像，否则下载镜像;Nerver表示仅使用本地镜像</span><br><span class="line">        workingDir: &quot;&#x2F;nginx&#x2F;&quot;            # 选填，容器的工作目录</span><br><span class="line">        volumeMounts:                   # 挂载到容器内部的存储卷配置</span><br><span class="line">        - mountPath: &quot;&#x2F;nginx&#x2F;&quot;</span><br><span class="line">          name: nginx-vol               # 引用pod定义的共享存储卷的名称</span><br><span class="line">        livenessProbe:                  # 对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket</span><br><span class="line">          httpGet:       </span><br><span class="line">            path: &#x2F;_check_domain_health      </span><br><span class="line">            port: 80</span><br><span class="line">            scheme: HTTP       </span><br><span class="line">          initialDelaySeconds: 30       # 容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">          periodSeconds: 1200             # 对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">          timeoutSeconds: 1            # 对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 50m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 500Mi</span><br><span class="line">        env:</span><br><span class="line">          - name: NGINX_VERSION</span><br><span class="line">            value: &quot;1.21.0&quot;</span><br><span class="line">          - name: RUN_DEV</span><br><span class="line">            value: &quot;boe&quot;</span><br><span class="line">      - name: shell</span><br><span class="line">        image: ubuntu    </span><br><span class="line">        stdin: true    </span><br><span class="line">        tty: true</span><br><span class="line">        workingDir: &quot;&#x2F;nginx&#x2F;&quot;            # 选填，容器的工作目录</span><br><span class="line">        command: [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;sleep 100000000&quot;]</span><br><span class="line">        volumeMounts:                   # 挂载到容器内部的存储卷配置</span><br><span class="line">          - mountPath: &quot;&#x2F;nginx&#x2F;&quot;</span><br><span class="line">            name: nginx-vol               # 引用pod定义的共享存储卷的名称</span><br><span class="line">        lifecycle:      </span><br><span class="line">          postStart:        </span><br><span class="line">            exec:          </span><br><span class="line">              command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo Nginx HTTP3 Server Start from the postStart handler &gt; &#x2F;usr&#x2F;share&#x2F;message&quot;]      </span><br><span class="line">          preStop:        </span><br><span class="line">            exec:          </span><br><span class="line">              command: [&quot;&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]</span><br><span class="line">      volumes:                # 在该pod上定义共享存储卷列表</span><br><span class="line">      - name: nginx-vol       # 共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;host</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建 deployment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx_http3-deployment.yaml</span><br></pre></td></tr></table></figure><br>查看 deployment 状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-http3-deployment-7cf4c654b5-6km4p   2/2     Running   0          31m</span><br><span class="line">➜  ~ kubectl get deployment</span><br><span class="line">NAME                     READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-http3-deployment   1/1     1            1           32m</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  curl https:&#x2F;&#x2F;webtransport.kiosk007.top:443&#x2F;ping --resolve webtransport.kiosk007.top:443:192.168.49.2</span><br><span class="line">pong</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的文章中介绍了如何编译&lt;a href=&quot;https://kiosk007.top/2021/07/31/%E5%B0%9D%E8%AF%95-Nginx-%E4%B8%8A%E4%BD%BF%E7%94%A8HTTP3/&quot;&gt;支持HTTP3的Nginx&lt;/a&gt; 为了一键将H3 Nginx上云，一劳永逸，本文会记录一下容器化Nginx的过程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>尝试 Nginx 上使用HTTP3</title>
    <link href="http://kiosk007.top/2021/07/31/%E5%B0%9D%E8%AF%95-Nginx-%E4%B8%8A%E4%BD%BF%E7%94%A8HTTP3/"/>
    <id>http://kiosk007.top/2021/07/31/%E5%B0%9D%E8%AF%95-Nginx-%E4%B8%8A%E4%BD%BF%E7%94%A8HTTP3/</id>
    <published>2021-07-31T13:41:00.000Z</published>
    <updated>2021-07-31T13:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前的文章介绍了<a href="https://kiosk007.top/2021/07/24/QUIC-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">QUIC发生了什么</a>, QUIC 已经演变成了一个“传输层”协议。其上可以运行 HTTP 协议。</p><a id="more"></a><p>在去年6月，Nginx的官方博客发表了<a href="https://www.nginx.com/blog/introducing-technology-preview-nginx-support-for-quic-http-3/">一篇对 HTTP3 技术的支持概览</a>。Nginx 官方宣布了 <code>http_v3_module</code> 的最初版本。但这只是一个技术概览，并不建议就应用到生产环境上。关于HTTP3的支持目前还没有正式合入主线分支。是在 <a href="https://hg.nginx.org/nginx-quic?_ga=2.233412253.2051667104.1627697657-1009067521.1605942879">https://hg.nginx.org/nginx-quic</a> 这个专门的分支上。</p><p>今年7月，Nginx又发了<a href="https://www.nginx.com/blog/our-roadmap-quic-http-3-support-nginx/">一篇博客</a>，明确表示，Nginx QUIC 将于今年年底正式合入Nginx 主分支。</p><p>另外 QUIC+HTTP/3 的Nginx官方实现是和 CloudFlare 的 <a href="https://blog.cloudflare.com/experiment-with-http-3-using-nginx-and-quiche/">quiche project</a> 并不是一个。</p><h1 id="Nginx-QUIC-支持"><a href="#Nginx-QUIC-支持" class="headerlink" title="Nginx QUIC 支持"></a>Nginx QUIC 支持</h1><p>本文是21年7月，这个时候QUIC的第一个正式版本 RFC9000 已经正式面世2个月了，Nginx当然也对其进行了良好的支持。</p><p>当然这些都是实验性的。更多可参考 <a href="https://quic.nginx.org/readme.html">https://quic.nginx.org/readme.html</a></p><p>由于Nginx当前对QUIC的支持仍尚处于实验阶段。仍存在一些QUIC特性的不支持。 (1.21.x)</p><p>比如以下功能在Nginx-QUIC的当前版本中尚不支持。</p><ol><li>QUIC 的显示拥塞通知（ECN)</li><li>结构化日志</li><li>HTTP/3 trailers</li></ol><p>不过QUIC的<a href="https://hg.nginx.org/nginx-quic?_ga=2.221821851.2051667104.1627697657-1009067521.1605942879">相关提交</a>也是在不断的完善当中</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装环境</p><ul><li>操作系统：Ubuntu 20.04.1 LTS</li><li>内核版本：5.4.0-77-generic</li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>我们必须安装mercurial，mercurial 是一个免费的分布式源代码管理工具。Nginx 的源码正是用 mercurial 管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mercurial</span><br></pre></td></tr></table></figure><p>从 <a href="https://hg.nginx.org/nginx-quic">https://hg.nginx.org/nginx-quic</a>. 下载nginx的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line">hg <span class="built_in">clone</span> -b quic https://hg.nginx.org/nginx-quic</span><br></pre></td></tr></table></figure><h3 id="安装-BoringSSL"><a href="#安装-BoringSSL" class="headerlink" title="安装 BoringSSL"></a>安装 BoringSSL</h3><p>QUIC 默认使用的是Boring SSL 来作为QUIC的 SSL 模块。它是来自Google的OpenSSL的分支，添加了quic支持。</p><p>但首先，必须安装这些依赖项来编译BoringSSL。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install golang</span><br><span class="line">sudo apt-get install libunwind-dev</span><br></pre></td></tr></table></figure><p>拉取 Boring SSL 的代码。注意这个仓库很大，有250M 左右。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/google/boringssl</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> boringssl/</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ../</span><br><span class="line">make -j 16</span><br></pre></td></tr></table></figure><h2 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h2><h3 id="Pagespeed"><a href="#Pagespeed" class="headerlink" title="Pagespeed"></a>Pagespeed</h3><p>ngx_pagespeed 是Google 推出的一个 Nginx 的扩展模块，可以加速网站，减少页面加载时间，自动将一些提升web性能的实践应用到网页和相关的资源（CSS、JS和图片）上，无需修改内容和流程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir module</span><br><span class="line"><span class="built_in">cd</span> module</span><br><span class="line">wget https://github.com/apache/incubator-pagespeed-ngx/archive/v1.13.35.2-stable.zip</span><br><span class="line">unzip v1.13.35.2-stable.zip</span><br><span class="line">mv incubator-pagespeed-ngx-1.13.35.2-stable ngx_pagespeed</span><br></pre></td></tr></table></figure><p>然后在ngx_pagespeed文件夹中，我们必须添加pagespeed的库PSOL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ngx_pagespeed</span><br><span class="line">sudo wget https://dl.google.com/dl/page-speed/psol/1.13.35.2-x64.tar.gz</span><br><span class="line">sudo tar -xzvf 1.13.35.2-x64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="Brotli"><a href="#Brotli" class="headerlink" title="Brotli"></a>Brotli</h3><p>Brotli是一种全新的数据格式，可以提供比Zopfli高20-26%的压缩比。据谷歌研究，Brotli压缩速度同zlib的Deflate实现大致相同，而在Canterbury语料库上的压缩密度比LZMA和bzip2略大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd module</span><br><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;ngx_brotli</span><br></pre></td></tr></table></figure><h3 id="gperftool"><a href="#gperftool" class="headerlink" title="gperftool"></a>gperftool</h3><p>gperftools是Google开源的一款非常使用的性能分析工具集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y google-perftools libgoogle-perftools-dev libgoogle-perftools4</span><br></pre></td></tr></table></figure><h3 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h3><p>ngx_lua是Nginx的一个模块，将Lua嵌入到Nginx中，从而可以使用Lua来编写脚本，这样就可以使用Lua编写应用脚本，部署到Nginx中运行，即Nginx变成了一个Web容器；这样开发人员就可以使用Lua语言开发高性能Web应用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module.git</span><br></pre></td></tr></table></figure><p>目前lua-nginx-module的最新release版本是v0.10.19，使用该版本在测试过程中遇到报错如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nginx: [alert] failed to load the <span class="string">&#x27;resty.core&#x27;</span> module (https://github.com/openresty/lua-resty-core); ensure you are using an OpenResty release from https://openresty.org/en/download.html (reason: module <span class="string">&#x27;resty.core&#x27;</span> not found:</span><br><span class="line">no field package.preload[<span class="string">&#x27;resty.core&#x27;</span>]</span><br><span class="line">no file <span class="string">&#x27;./resty/core.lua&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;/usr/local/share/luajit-2.1.0-beta3/resty/core.lua&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;/usr/local/share/lua/5.1/resty/core.lua&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;/usr/local/share/lua/5.1/resty/core/init.lua&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;./resty/core.so&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;/usr/local/lib/lua/5.1/resty/core.so&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;/usr/local/lib/lua/5.1/loadall.so&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;./resty.so&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;/usr/local/lib/lua/5.1/resty.so&#x27;</span></span><br><span class="line">no file <span class="string">&#x27;/usr/local/lib/lua/5.1/loadall.so&#x27;</span>) <span class="keyword">in</span> /usr/<span class="built_in">local</span>/src/nginx/conf/nginx.conf:117</span><br></pre></td></tr></table></figure><p>在下面的链接中找到了答案，使用v0.10.14版本即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/openresty/lua-resty-core/issues/248</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编写编译脚本"><a href="#编写编译脚本" class="headerlink" title="编写编译脚本"></a>编写编译脚本</h2><p>以下的编译脚本包含了很多其他Nginx模块，实际安装时可以按需安装。创建一个 <code>build.sh</code><br> 脚本文件。填写以下内容。（模块可按需添加）</p><p class="div-border green">Lua 模块安装可参考<a src="https://www.cnblogs.com/52fhy/p/10164553.html">该文</a> ，因为我之前安装过，所以很多依赖没有在本文中体现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># set -x</span><br><span class="line"># set -e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.&#x2F;auto&#x2F;configure \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_cache_purge \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_devel_kit \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_brotli \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;nginx-rtmp-module \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_devel_kit \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;echo-nginx-module \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;headers-more-nginx-module \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;lua-nginx-module \</span><br><span class="line">--add-module&#x3D;.&#x2F;modules&#x2F;ngx_pagespeed \</span><br><span class="line">--with-ld-opt&#x3D;-Wl,-rpath,&#x2F;usr&#x2F;local&#x2F;luajit&#x2F;lib \</span><br><span class="line">--with-cc-opt&#x3D;&quot;-I..&#x2F;boringssl&#x2F;include&quot; --with-ld-opt&#x3D;&quot;-L..&#x2F;boringssl&#x2F;build&#x2F;ssl -L..&#x2F;boringssl&#x2F;build&#x2F;crypto&quot; \</span><br><span class="line">--with-file-aio \</span><br><span class="line">--with-http_flv_module \</span><br><span class="line">--with-http_gunzip_module \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_v2_module \</span><br><span class="line">--with-http_realip_module \</span><br><span class="line">--with-http_addition_module \</span><br><span class="line">--without-mail_pop3_module \</span><br><span class="line">--without-mail_imap_module \</span><br><span class="line">--without-mail_smtp_module \</span><br><span class="line">--with-http_sub_module \</span><br><span class="line">--with-http_auth_request_module \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-google_perftools_module \</span><br><span class="line">--with-http_secure_link_module \</span><br><span class="line">--with-http_mp4_module \</span><br><span class="line">--with-stream \</span><br><span class="line">--with-http_v3_module</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash build.sh</span><br><span class="line">make -j 16</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译产物在 objs 目录中，将 nginx 二进制可执行文件copy到指定 <code>/usr/local/sbin</code> 下。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>提供基础的配置文件如下。配置文件可按实际情况进行调整。需要使用<code>add_header alt svc</code>来确保web浏览器知道服务器支持http/3。</p><ul><li>由于HTTP/3需要使用udp协议端口，请注意开放对应的防火墙</li><li>http2监听的是443的tcp端口，而http3监听的是udp端口</li><li>nginx中添加了$http3和$quic变量，可以添加到日志中，这样就可以看到是否使用了HTTP/3来进行访问了</li><li>如果有多个server_name，在不指定IP的情况下，只需要在任意一个配置了listen 443 http3 quic reuseport;那么其他所有server_name都会开启HTTP3，并且不需要再添加该配置否则会报错（不知道后续会不会把报错去掉），如果需要部分server_name开启HTTP/3，请指定监听IP。</li></ul><p>http3增加了<code>http3_max_table_capacity</code>、<code>http3_max_blocked_streams</code>、<code>http3_max_concurrent_pushes</code>、 <code>http3_push</code>、<code>http3_push_preload</code>这六个变量来控制http3的性能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 443 http3 quic reuseport;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    server_name kiosk007.top;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该选项用于开启address validation，但是会和0-RTT冲突</span></span><br><span class="line">    <span class="comment"># quic_retry on;</span></span><br><span class="line">    ssl_early_data on;</span><br><span class="line"></span><br><span class="line">    http3_max_field_size 5000;</span><br><span class="line">    http3_max_table_capacity 50;</span><br><span class="line">    http3_max_blocked_streams 30;</span><br><span class="line">    http3_max_concurrent_pushes 30;</span><br><span class="line">    http3_push 10;</span><br><span class="line">    http3_push_preload on;</span><br><span class="line"></span><br><span class="line">    add_header Alt-Svc <span class="string">&#x27;h3=&quot;:8443&quot;; ma=86400&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/kiosk007.top/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/kiosk007.top/privkey.pem;</span><br><span class="line">    include /etc/letsencrypt/options-ssl-nginx.conf;</span><br><span class="line">    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    location /ping &#123;</span><br><span class="line">            default_type text/html;</span><br><span class="line">            <span class="built_in">return</span> 200 <span class="string">&quot;pong&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="div-border red"> 本地测试的时候不要开 quic_retry on; (路径验证) 。否则连不上 </p><p>目前的主流浏览器Firefox和Chrome都支持了HTTP/3协议。</p><ul><li>Chrome</li></ul><p>nginx 的官网提示说Chrome需要83+版本才支持HTTP/3，实测在部分网站（如google.com）确实可以使用HTTP/3的某些草案版本，但是Chrome目前来说默认还是不支持h3-27协议，我们需要手动开启。对于Linux系统而言，我们使用命令行+指定参数的方式开启h3-27的支持：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;google-chrome-stable --enable-quic --quic-version&#x3D;h3-27 --origin-to-force-quic-on&#x3D;webtransport.kiosk007.top:443</span><br></pre></td></tr></table></figure></p><p>还可以如下网站去验证测试。</p><ul><li><a href="https://www.http3check.net/">https://www.http3check.net/</a></li><li><a href="https://gf.dev/http3-test">https://gf.dev/http3-test</a></li></ul><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_http3_check.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前的文章介绍了&lt;a href=&quot;https://kiosk007.top/2021/07/24/QUIC-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/&quot;&gt;QUIC发生了什么&lt;/a&gt;, QUIC 已经演变成了一个“传输层”协议。其上可以运行 HTTP 协议。&lt;/p&gt;</summary>
    
    
    
    <category term="QUIC" scheme="http://kiosk007.top/categories/QUIC/"/>
    
    
    <category term="network" scheme="http://kiosk007.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>QUIC 发生了什么</title>
    <link href="http://kiosk007.top/2021/07/24/QUIC-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://kiosk007.top/2021/07/24/QUIC-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2021-07-24T08:02:00.000Z</published>
    <updated>2021-07-24T08:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从 HTTP/1.1（1999 年发布）到 HTTP/2 发布（2015 年发布）之间的发展差距很大，随着 2019 年 HTTP/3 的发布，HTTP/3 即将成为互联网上超文本传输协议的下一代协议，HTTP/3 是Google QUIC协议的演变。它与传统的 HTTP 有很大的不同。QUIC 是一种新的可靠传输协议，可以被视为一种下一代TCP。</p><a id="more"></a><p>QUIC 连接通过 UDP 端口和 IP 地址建立的，一旦建立，该连接就通过其“连接 ID”相关联（每个连接都拥有一组连接标识符或连接 ID，每个连接标识符都可用于识别连接）。</p><p>QUIC 提供 0-RTT 和 1-RTT 连接设置，所以建立新连接时，会比传统的 TCP + TLS 的组合要快许多。</p><h1 id="HTTP-的演变"><a href="#HTTP-的演变" class="headerlink" title="HTTP 的演变"></a>HTTP 的演变</h1><p>超文本传输协议 (HTTP) 是运行在 TCP/IP 之上的应用层协议，<br>HTTP 有 4 个稳定版本——HTTP/0.9、HTTP/1.0、HTTP/1.1 和 HTTP/2。在 2021年七月，市面上已经有 三分之二的浏览器支持了 HTTP/3 。</p><p>同年5月底，IETF：QUIC Version 1 (<a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-version-negotiation">RFC 9000</a>) 作为标准化版本现已发布，QUIC部署将从使用临时草案版本转向新创建的Version 1。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/http_protocol_versions.png"></p><h1 id="QUIC-从哪来"><a href="#QUIC-从哪来" class="headerlink" title="QUIC 从哪来"></a>QUIC 从哪来</h1><p>IETF 并不是从头开始研究 QUIC。2012 年，<a href="https://blog.chromium.org/2013/06/experimenting-with-quic.html">谷歌设计了自己的 QUIC 版本</a>， 随后 Chrome 浏览器及其Google的大部分服务相继支持QUIC，包括 Youtube 和 Google 搜索。</p><p>IETF QUIC 与 早期的 gQUIC 相比也已经有了比较大的变化，这里不妨列举几个。</p><ul><li>加密协商：谷歌 QUIC 是定制加密握手，而 IETF 是采用了 TLS1.3</li><li>分离：IETF QUIC 的层级是分明的，其上可以承载的应用层协议不止 HTTP 协议</li><li>头部压缩：gQUIC 沿用了HTTP2的 HPack，而IETF QUIC 使用的是QPACK。</li></ul><h1 id="QUIC-的版本"><a href="#QUIC-的版本" class="headerlink" title="QUIC 的版本"></a>QUIC 的版本</h1><p>目前有<a href="https://github.com/quicwg/base-drafts/wiki/Implementations">15种实验型QUIC</a>。【RFC9000 确定后，所有的QUIC版本会趋于统一】。但是这些实验性QUIC互操性比较差，因为各家的QUIC的实现标准不统一，对具体的一些功能实现存在diff。</p><p class="div-border yellow"> 数据截取于 2021.07</p><h2> <a href="https://github.com/aiortc/aioquic" aria-hidden="true" class="header-anchor">aioquic</a></h2><p>使用Python和asyncio的QUIC实现</p><blockquote><ul><li>Language: Python </li><li>Version: draft-29 through version 1(RCF 9000)</li><li>Handshake: TLS 1.3</li><li>Protocol IDs: <code>0xff00001d</code>, <code>0xff00001e</code>, <code>0xff00001f</code>, <code>0xff000020</code>, <code>0x1</code></li></ul></blockquote><h2> <a href="https://github.com/litespeedtech/lsquic" aria-hidden="true" class="header-anchor">Chromium</a></h2><p>Chromium的QUIC实现（chrome85.0.4171.0及更高版本支持draft-29）</p><blockquote><ul><li><strong>Languages</strong>: C, C++</li><li><strong>Versions</strong>: Q043, Q046, Q050, T050, T051, draft-27, draft-29.</li><li><strong>Handshakes</strong>: QUIC Crypto, TLS</li><li><strong>Protocol IDs</strong>: <code>Q043</code>, <code>Q046</code>, <code>Q050</code>, <code>T050</code>, <code>T051</code>, <code>0xff00001b</code>, <code>0xff00001d</code></li><li><strong>ALPNs</strong>: h3-Q043, h3-Q046, h3-Q050, h3-T050, h3-T051, h3-27, h3-29</li><li>Google将实现命名为“quiche”，但它与Cloudflare的Rust实现完全无关。</li></ul></blockquote><h2> <a href="https://github.com/litespeedtech/lsquic" aria-hidden="true" class="header-anchor">lsquic</a></h2><p>LiteSpeed QUIC和HTTP/3库。适用于Linux、FreeBSD、MacOS、Android和Windows。</p><blockquote><ul><li><strong>Language</strong>: C</li><li><strong>Version</strong>: v1, Draft-34, Draft-29, Draft-27, Q043, Q046, and Q050.</li><li><strong>Roles</strong>: Client, Server, Library</li><li><strong>Handshake</strong>: QUIC Crypto, RFC 8446</li><li><strong>Protocol</strong> IDs: <code>0x00000001</code>, <code>0xFF000022</code>, <code>0xFF00001D</code>, <code>0xFF00001B</code></li></ul></blockquote><p>当前互联网上的<a href="https://quic.netray.io/stats.html">QUIC流量</a>，draft-29 和 Version 1 版本 的量级在逐渐上升。国内的一些大厂也在使用QUIC来作为当前主要的流量接入，比如微信的视频号就使用 gQUIC 43 、快手也宣布了线上的<a href="https://www.infoq.cn/article/41HJkeZM7hEgIYlJRFK0">千万级QUIC计划</a>。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_version.png"></p><p>相信今年的 RFC9000 推出 QUICv1 版本后，QUIC的互操性能得到更广泛的运用。当前各大版本实现的<a href="https://interop.seemann.io/">QUIC互操性</a>能得到进一步的提升。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_interop.png"></p><h1 id="QUIC-实验"><a href="#QUIC-实验" class="headerlink" title="QUIC 实验"></a>QUIC 实验</h1><p>当前的QUIC 版本很多，支持的比较完整的是 Chromium 和 lsquic 。</p><p>下面将以 <a href="https://github.com/litespeedtech/lsquic">lsquic</a> 为例，实际剖析一下QUIC。</p><p>目前支持的QUIC版本有v1、Internet draft-27 和 draft-29, 包括老一些的Google QUIC 版本 <code>Q043</code> 、<code>Q046</code> 和 <code>Q050</code> 。</p><p>相关文档: <a href="https://lsquic.readthedocs.io/en/latest/">https://lsquic.readthedocs.io/en/latest/</a></p><p>要构建LSQUIC，需要CMake、zlib和BoringSSL。</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><ul><li>Building BoringSSL</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国内可用 git clone https://github.com/google/boringssl.git</span></span><br><span class="line">git <span class="built_in">clone</span> https://boringssl.googlesource.com/boringssl</span><br><span class="line"><span class="built_in">cd</span> boringssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到特殊版本</span></span><br><span class="line">git checkout a2278d4d2cabe73f6663e3299ea7808edfa306b9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 </span></span><br><span class="line">cmake . &amp;&amp;  make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录当前位置</span></span><br><span class="line">BORINGSSL=<span class="variable">$PWD</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Building LSQUIC Library</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：测试程序由 libevent 驱动，测试程序需要先装 libevent-dev</span></span><br><span class="line">sudo apt-get install libevent-dev</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/litespeedtech/lsquic.git</span><br><span class="line"><span class="built_in">cd</span> lsquic</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Statically:</span></span><br><span class="line"><span class="comment"># $BORINGSSL is the top-level BoringSSL directory from the previous step</span></span><br><span class="line">cmake -DBORINGSSL_DIR=<span class="variable">$BORINGSSL</span> .</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># As a dynamic library:</span></span><br><span class="line">cmake -DLSQUIC_SHARED_LIB=1 -DBORINGSSL_DIR=<span class="variable">$BORINGSSL</span> .</span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>demo</li></ul><p>quic 的 demo 在 $lsquic_pwd/bin 目录下, 我们实验用就用 <code>http_client</code> 吧。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>先看看 <code>http_client</code> 支持的几个命令行参数.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">./http_client -<span class="built_in">help</span> </span><br><span class="line">Usage: http_client [opts]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">   -p PATH     Path to request.  May be specified more than once.  If no</span><br><span class="line">                 path is specified, the connection is closed as soon as</span><br><span class="line">                 handshake succeeds.</span><br><span class="line">   -n CONNS    Number of concurrent connections.  Defaults to 1.</span><br><span class="line">   -r NREQS    Total number of requests to send.  Defaults to 1.</span><br><span class="line">   -R MAXREQS  Maximum number of requests per single connection.  Some</span><br><span class="line">                 connections will have fewer requests than this.</span><br><span class="line">   -w CONCUR   Number of concurrent requests per single connection.</span><br><span class="line">                 Defaults to 1.</span><br><span class="line">   -M METHOD   Method.  Defaults to GET.</span><br><span class="line">   -P PAYLOAD  Name of the file that contains payload to be used <span class="keyword">in</span> the</span><br><span class="line">                 request.  This adds two more headers to the request:</span><br><span class="line">                 content-type: application/octet-stream and</span><br><span class="line">                 content-length</span><br><span class="line">   -K          Discard server response</span><br><span class="line">   -I          Abort on incomplete reponse from server</span><br><span class="line">   -4          Prefer IPv4 when resolving hostname</span><br><span class="line">   -6          Prefer IPv6 when resolving hostname</span><br><span class="line">   -C DIR      Certificate store.  If specified, server certificate will</span><br><span class="line">                 be verified.</span><br><span class="line">   -a          Display server certificate chain after successful handshake.</span><br><span class="line">   -b N_BYTES  Send RESET_STREAM frame after the client has <span class="built_in">read</span> n bytes.</span><br><span class="line">   -t          Print stats to stdout.</span><br><span class="line">   -T FILE     Print stats to FILE.  If FILE is -, <span class="built_in">print</span> stats to stdout.</span><br><span class="line">   -q FILE     QIF mode: issue requests from the QIF file and validate</span><br><span class="line">                 server responses.</span><br><span class="line">   -e TOKEN    Hexadecimal string representing resume token.</span><br><span class="line">   -3 MAX      Close stream after reading at most MAX bytes.  The actual</span><br><span class="line">                 number of bytes <span class="built_in">read</span> is randominzed.</span><br><span class="line">   -9 SPEC     Priority specification.  May be specified several <span class="built_in">times</span>.</span><br><span class="line">                 SPEC takes the form stream_id:nread:UI, <span class="built_in">where</span> U is</span><br><span class="line">                 urgency and I is incremental.  Matched \d+:\d+:[0-7][01]</span><br><span class="line">   -7 DIR      Save fetched resources into this directory.</span><br><span class="line">   -Q ALPN     Use hq ALPN.  Specify, <span class="keyword">for</span> example, <span class="string">&quot;h3-29&quot;</span>.</span><br><span class="line">   -0 FILE     Provide session resumption file (reading or writing)</span><br><span class="line">   -s SVCPORT  Service port.  Takes on the form of host:port, host,</span><br><span class="line">                 or port.  If host is not an IPv4 or IPv6 address, it is</span><br><span class="line">                 resolved.  If host is not <span class="built_in">set</span>, the value of SNI is</span><br><span class="line">                 used (see the -H flag).  If port is not <span class="built_in">set</span>, the default</span><br><span class="line">                 is 443.</span><br><span class="line">                 Examples:</span><br><span class="line">                     127.0.0.1:12345</span><br><span class="line">                     ::1:443</span><br><span class="line">                     example.com</span><br><span class="line">                     example.com:8443</span><br><span class="line">                     8443</span><br><span class="line">                 If no -s option is given, 0.0.0.0:12345 address</span><br><span class="line">                 is used.</span><br><span class="line">   -D          Do not <span class="built_in">set</span> <span class="string">&#x27;do not fragment&#x27;</span> flag on outgoing UDP packets</span><br><span class="line">   -z BYTES    Maximum size of outgoing UDP packets (client only).</span><br><span class="line">                 Overrides -o base_plpmtu.</span><br><span class="line">   -L LEVEL    Log level <span class="keyword">for</span> all modules.  Possible values are `debug<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                 `info&#x27;</span>, `notice<span class="string">&#x27;, `warn&#x27;</span>, `error<span class="string">&#x27;, `alert&#x27;</span>, `emerg<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                 and `crit&#x27;</span>.</span><br><span class="line">   -l LEVELS   Log levels <span class="keyword">for</span> modules, e.g.</span><br><span class="line">                 -l event=info,engine=debug</span><br><span class="line">               Can be specified more than once.</span><br><span class="line">   -m MAX      Maximum number of outgoing packet buffers that can be</span><br><span class="line">                 assigned at any one time.  By default, there is no max.</span><br><span class="line">   -y style    Timestamp style used <span class="keyword">in</span> <span class="built_in">log</span> messages.  The following styles</span><br><span class="line">                 are supported:</span><br><span class="line">                   0   No timestamp</span><br><span class="line">                   1   Millisecond time (this is the default).</span><br><span class="line">                         Example: 11:04:05.196</span><br><span class="line">                   2   Full date and millisecond time.</span><br><span class="line">                         Example: 2017-03-21 13:43:46.671</span><br><span class="line">                   3   Chrome-like timestamp: date/time.microseconds.</span><br><span class="line">                         Example: 1223/104613.946956</span><br><span class="line">                   4   Microsecond time.</span><br><span class="line">                         Example: 11:04:05.196308</span><br><span class="line">                   5   Full date and microsecond time.</span><br><span class="line">                         Example: 2017-03-21 13:43:46.671345</span><br><span class="line">   -S opt=val  Socket options.  Supported options:</span><br><span class="line">                   sndbuf=12345    <span class="comment"># Sets SO_SNDBUF</span></span><br><span class="line">                   rcvbuf=12345    <span class="comment"># Sets SO_RCVBUF</span></span><br><span class="line">   -W          Use stock PMI (malloc &amp; free)</span><br><span class="line">   -g          Use sendmmsg() to send packets.</span><br><span class="line">   -j          Use recvmmsg() to receive packets.</span><br><span class="line">   -H host     Value of `host<span class="string">&#x27; HTTP header.  This is also used as SNI</span></span><br><span class="line"><span class="string">                 in Client Hello.  This option is used to override the</span></span><br><span class="line"><span class="string">                 `host&#x27;</span> part of the address specified using -s flag.</span><br><span class="line">   -G dir      SSL keys will be logged to files <span class="keyword">in</span> this directory.</span><br><span class="line">   -k          Connect UDP socket.  Only meant to be used with clients</span><br><span class="line">                 to pick up ICMP errors.</span><br><span class="line">   -i USECS    Clock granularity <span class="keyword">in</span> microseconds.  Defaults to 1000.</span><br><span class="line">   -h          Print this <span class="built_in">help</span> screen and <span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="QUIC-发生了什么"><a href="#QUIC-发生了什么" class="headerlink" title="QUIC 发生了什么"></a>QUIC 发生了什么</h1><p>lsquic 提供了测试网站 <code>www.litespeedtech.com</code>，我们用下面的命令行工具访问这个网站, 并使用Wireshark 抓包和 <a href="https://zhuanlan.zhihu.com/p/151858528">qlog 去解析QUIC</a>，探索一些QUIC究竟发生了什么。</p><p class="div-border green">Wireshark （3.4.2）已经支持了解析 IETF QUIC，加载秘钥的方法参考 <a href="https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/">Wireshark Tutorial: Decrypting HTTPS Traffic</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不指定版本。默认是使用 Version 1 版本 </span></span><br><span class="line">$ http_client -H www.litespeedtech.com:443 -p /  -G . -o version=h3-29</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当前目录下会生成一个 sslkeylog <code>F9CE5E3D598B8D80.keys</code>，wireshark 导入，注意<a href="https://github.com/quicwg/base-drafts/wiki/Tools#wireshark">Wireshark 要装最新版本（当前是 3.4.2）</a>。</p><blockquote><p>注意： Wireshark 本身无法解密 GQUIC 数据包，即使已配置NSS Keylogging。</p></blockquote><p class="div-border green">更多QUIC debug or 可视化工具参考: https://github.com/quicwg/base-drafts/wiki/Tools </p><p>抓包内容如下：<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_capture_handshake.png"></p><p><strong>这里再介绍一下HTTP3的分层结构。</strong></p><p>一个 HTTP3 包会按照以下方式分层。实时上 QUIC 已经完全可以理解为一个传输层协议了，QUIC的实现也是和HTTP协议分离的，正如 RFC 9000 所描述的。“<a href="https://www.rfc-editor.org/rfc/rfc9000.html#section-1-2">QUIC 是一种面向连接的协议，它在客户端和服务器之间创建有状态的交互。</a>”</p><p class="div-border blue"> <a href="https://github.com/lucas-clemente/quic-go/blob/master/example/echo/echo.go">  quic-go 的 echo 示例 </a> 也在其示例代码中提供了QUIC层的demo `session.OpenStreamSync(context.Background())` </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UDP Header</span><br><span class="line">Packet Header     -----</span><br><span class="line">QUIC Frame Header    --  TLS1.3</span><br><span class="line">HTTP3 Frame Header   --   </span><br><span class="line">HTTP Message      -----</span><br></pre></td></tr></table></figure><h2 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h2><p>Packet Header实现了可靠的连接。当UDP报文丢失后，通过Packet Header中的Packet Number实现报文重传。连接也是通过其中的Connection ID字段定义的</p><p>这里会有两种 Header 类型，<strong>Long Header</strong> 和 <strong>Short Header</strong>。Long Header 用于初始化交换 直到 可以1RTT可以被激动和版本协商完成。Short Header 用于承载数据。</p><ul><li><strong>Long Header</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|S|Typ|  Next   |              Magic <span class="string">&quot;uic&quot;</span>/<span class="string">&quot;UIC&quot;</span>                |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                         Connection ID                         +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            Version                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Packet Number                         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       [Header Extensions]                   ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Payload                           ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>建立连接时，连接是由服务器通过Source Connection ID字段分配的，这样，后续传输时，双方只需要固定住Destination Connection ID，就可以在客户端IP地址、端口变化后，绕过UDP四元组（与TCP四元组相同），实现连接迁移功能。如下图，后续的DCID和SCID都会统一为 <code>752566b9c5e2b77a</code></p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_connection_id.png"></p><ul><li><strong>Short Header</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|S|K|                Packet Number (30)                         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                         Connection ID                         +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>Packet Number是每个报文独一无二的序号，基于它可以实现丢失报文的精准重发。</p><p>参考: <a href="https://gist.github.com/martinthomson/744d04cbcec9be554f2f8e7bae2715b8">martinthomson/quic_header.md</a></p><h2 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h2><p>在Packet Header之上的QUIC Frame Header, QUIC中的流为应用程序提供了轻量级的有序字节流抽象。流可以是单向的或双向的，而且Stream之间可以实现真正的并发。</p><p>所有的帧被包含在单独的QUIC Packet 中，且没有帧可以跨越QUIC Packet 边界。一个Packet报文中可以存放多个QUIC Frame，当然所有Frame的长度之和不能大于PMTUD（Path Maximum Transmission Unit Discovery，这是大于1200字节的值）, 一个QUIC Frame 也不允许跨Packet。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_frame1.png"></p><p>每一个QUIC Frame 都有明确的帧类型。</p><p>参考： <a href="https://quic.readthedocs.io/zh/latest/Frame%20Types%20and%20Formats.html">帧类型和格式</a></p><p class="div-border red"> 上述文档比较老，很多数据有变动，下面是结合 <a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-frames-and-frame-types"> RFC9000 </a> 的版本 </p><p>当前定义的<strong>普通帧类型</strong>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+-----------------------------+------------+</span><br><span class="line">| Type-field value      |     Control Frame-type      |    Spec    |</span><br><span class="line">+-----------------------+-----------------------------+------------+</span><br><span class="line">| 00000000B (0x00)      |  PADDING                    |     NP     |</span><br><span class="line">| 00000001B (0x01)      |  PING                       |            |</span><br><span class="line">| 00000010B (0x02-0x03) |  ACK                        |     NC     |</span><br><span class="line">| 00000100B (0x04)      |  RESET_STREAM               |            |</span><br><span class="line">| 00000101B (0x05)      |  STOP_SENDING               |            |</span><br><span class="line">| 00000110B (0x06)      |  CRYPTO                     |            |</span><br><span class="line">| 00000111B (0x07)      |  NEW_TOKEN                  |            |</span><br><span class="line">| 00001000B (0x08-0x0F) |  STREAM                     |     F      |</span><br><span class="line">| 00010000B (0x10)      |  MAX_DATA                   |            |</span><br><span class="line">| 00010001B (0x11)      |  MAX_STREAM_DATA            |            |</span><br><span class="line">| 00001100B (0x12-0x13) |  MAX_STREAMS                |            |</span><br><span class="line">| 00001110B (0x14)      |  DATA_BLOCKED               |            |</span><br><span class="line">| 00001111B (0x15)      |  STREAM_DATA_BLOCKED        |            |</span><br><span class="line">| 00010000B (0x16-0x17) |  STREAMS_BLOCKED            |            |</span><br><span class="line">| 00010010B (0x18)      |  NEW_CONNECTION_ID      |     P      |</span><br><span class="line">| 00010011B (0x19)      |  RETIRE_CONNECTION_ID       |            |</span><br><span class="line">| 00010100B (0x1a)      |  PATH_CHALLENGE             |     P      |</span><br><span class="line">| 00010101B (0x1b)      |  PATH_RESPONSE              |     P      |</span><br><span class="line">| 00010110B (0x1c-0x1d) |  CONNECTION_CLOSE           |     N      |</span><br><span class="line">| 00011000B (0x1e)      |  HANDSHAKE_DONE             |            |</span><br><span class="line">+-----------------------+-----------------------------+------------+</span><br></pre></td></tr></table></figure><blockquote><p>第三列 SPEC 规定了该帧的一些特殊用法<br>N : 该类帧不会被ACK<br>C : 出于拥塞控制目的,该类型帧不会被计入飞行中的字节数<br>P : 该类型帧的数据包可用于在连接迁移期间探测新的网络路径<br>F : 该类型帧用于流控</p></blockquote><ul><li><strong>PADDING 帧</strong>：PADDING帧使用0x00字节填充一个包。当遇到该帧时，包的剩余部分需要被填充字节。 该帧包含0x00字节并扩展至QUIC包的末端。</li><li><strong>PING 帧</strong>：PING帧用来验证对端是否仍然存活。PING帧不包含载荷。 PING帧的接收方只需要应答（ACK）包含该帧的包。 PING帧应该被用于当一条流被打开时，保持连接存活。 默认是30s</li><li><strong>ACK 帧</strong>: 发送ACK帧以通知对端已经接收了哪些分组，以及接收方仍然认为丢失了哪些分组（可能需要重新发送丢失分组的内容）。<ul><li>如果帧类型为0x02：普通的ACK应答作用</li><li>如果帧类型为0x03：则ACK帧还包含在此点之前在连接上接收到的具有相关ECN标记的QUIC数据包的累积计数。如果发送的数据包启用了ECN，则应使用ECN部分中的信息来管理拥塞状态</li></ul></li><li><strong>RST_STREAM 帧</strong>：RST_STREAM帧允许异常终止一条流。当这个帧是流的创建者发出的，表示创建者希望取消这条流。 当接收端发送这个帧，表示有错误或者当前接收端不希望接收这个流，因此这个流应该被关闭。</li><li><strong>STOP_SENDING 帧</strong>：请求对等方停止流上的传输.</li><li><strong>CRYPTO 帧</strong>：用于传输加密握手消息，加密帧在功能上与STREAM帧相同,但是不受流控。加密帧上传输 TLS 握手细信息。</li><li><strong>NEW_TOKEN 帧</strong>：为客户端提供一个令牌，以便用于之后的链接0-RTT。</li><li><strong>STREAM 帧</strong> : STREAM帧同时被用于隐式地创建流和在流上发送数据。STREAM帧中的类型字段的格式为0B00001xxx（或0x08到0x0f的一组值）,帧类型的三个低阶位确定帧中存在的字段。流可以是单向的，也可以是双向的，对于连接上的所有流都是唯一的。流低2位可标识是客户端还是服务端发起的单向流或双向流。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BitsStream Type</span><br><span class="line">0x00Client-Initiated, Bidirectional</span><br><span class="line">0x01Server-Initiated, Bidirectional</span><br><span class="line">0x02Client-Initiated, Unidirectional</span><br><span class="line">0x03Server-Initiated, Unidirectional</span><br></pre></td></tr></table></figure></li><li><strong>MAX_DATA 帧</strong>：用于流控,用于通知对端整个连接上可发送的最大数据量。</li><li><strong>MAX_STREAM_DATA 帧</strong>：用于流控，用于通知对端流上可发送的最大数据量。</li><li><strong>MAX_STREAMS 帧</strong>：通知对等端允许打开的给定类型的流的最大数。<ul><li>0x12 的MAX_STREAM适用于双向流</li><li>0x13 的MAX_STREAM适用于单向流</li></ul></li><li><strong>DATA_BLOCKED 帧</strong>：BLOCKED帧用于向远端指明本端点已经准备好发送数据了（且有数据要发送）， 但是当前被流量控制阻塞了。这是一个纯粹的信息帧，它对于调试极其有用。 BLOCKED帧的接收者应该简单的丢弃它（可能在打印了一条有帮助的log消息之后）</li><li><strong>STREAM_DATA_BLOCKED 帧</strong>：当发送方希望发送数据但由于流级流控制而无法发送数据时，发送方应发送 STREAM_DATA_BLOCKED。</li><li><strong>STREAMS_BLOCKED 帧</strong>：当发送方希望打开流，但由于其对等方设置的最大流限制而无法打开流时，发送方应发送STREAMS_BLOCKED,<ul><li>0x16 的STREAMS_BLOCKED适用于双向流</li><li>0x17 的STREAMS_BLOCKED适用于单向流</li></ul></li><li><strong>NEW_CONNECTION_ID 帧</strong>：发送一个新的 NEW_CONNECTION_ID 帧, 为其对端提供可用于在迁移连接时中断可链接性的替代连接ID</li><li><strong>RETIRE_CONNECTION_ID 帧</strong>: 一端发送 RETIRE_CONNECTION_ID 表示不再使用对端发送的CONNECTION ID ，包含握手时确定的 连接id，后续可以发送新的 CONNECTION ID 再。</li><li><strong>PATH_CHALLENGE 帧</strong>：来检查对等方的可达性，并在连接迁移期间进行路径验证</li><li><strong>PATH_RESPONSE 帧</strong>: PATH_CHALLENGE 的响应帧</li><li><strong>CONNECTION_CLOSE 帧</strong>：CONNECTION_CLOSE帧用来通知连接将被关闭。如果流仍然有数据在发送，那么在连接关闭时， 这些流将被隐式关闭。</li><li><strong>HANDSHAKE_DONE 帧</strong>：向客户端发送握手确认信号。</li></ul><h2 id="HTTP3-Frame-Header"><a href="#HTTP3-Frame-Header" class="headerlink" title="HTTP3 Frame Header"></a>HTTP3 Frame Header</h2><p>QUIC 的 STREAM 帧是实际承载流量的帧。自然也是 <a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html#name-reserved-frame-types">HTTP3 协议</a>的承载。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_stream_frame.png"> </p><p>Stream Frame头部的3个字段，完成了多路复用、有序字节流以及报文段层面的二进制分隔功能</p><ul><li><strong>Stream ID</strong> 标识了一个有序字节流。当HTTP Body非常大，需要跨越多个Packet时，只要在每个Stream Frame中含有同样的Stream ID，就可以传输任意长度的消息。多个并发传输的HTTP消息，通过不同的Stream ID加以区别</li><li>消息序列化后的“有序”特性，是通过Offset字段完成的，它类似于TCP协议中的Sequence序号，用于实现Stream内多个Frame间的累计确认功能；</li><li>Length指明了Frame数据的长度。</li></ul><p>HTTP3 的Frame 继承了 HTTP2 的Frame 设计。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Frame         Control StreamRequest StreamPush Stream</span><br><span class="line">DATA          No                Yes               Yes</span><br><span class="line">HEADERS       No                Yes               Yes</span><br><span class="line">CANCEL_PUSH   Yes               No                No</span><br><span class="line">SETTINGS      Yes              (1)                No</span><br><span class="line">PUSH_PROMISE  No                Yes               No</span><br><span class="line">GOAWAY        Yes               No                No</span><br><span class="line">MAX_PUSH_ID   Yes               No                No</span><br><span class="line">Reserved      Yes               Yes               Yes</span><br></pre></td></tr></table></figure><p>QUIC Stream Frame定义了有序字节流，且多个Stream间的传输没有时序性要求，这样，HTTP消息基于QUIC Stream就实现了真正的多路复用，队头阻塞问题自然就被解决掉了。</p><p><strong>HTTP Header头部的编码方式，它需要面对另一种队头阻塞问题</strong></p><p>与HTTP2中的HPACK编码方式相似，HTTP3中的QPACK也采用了静态表、动态表及Huffman编码：</p><p>在HTTP2中，共有61个静态表项,而在QPACK中，则上升为98个静态表项, 比如 qpack 的golang 实现中的 <code>staticTableEntries</code> 所示。可以从<a href="https://github.com/marten-seemann/qpack/blob/master/static_table.go">这里</a>找到 HTTP3 的完整静态表</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/qpack.png"></p><p>相较于HTTP3的静态表，和HTTP2协议其实并没有特别大的变化。但动态表编解码方式差距很大。</p><p>所谓动态表，就是将未包含在静态表中的Header项，在其首次出现时加入动态表，这样后续传输时仅用1个数字表示，大大提升了编码效率。因此，动态表是天然具备时序性的，如果首次出现的请求出现了丢包，后续请求解码HPACK头部时，一定会被阻塞！</p><p>事实上，QPACK将动态表的编码、解码独立在单向Stream中传输，仅当单向Stream中的动态表编码成功后，接收端才能解码双向Stream上HTTP消息里的动态表索引。</p><p>因此，当Stream ID是0、4、8、12时，这就是客户端发起的双向Stream（HTTP3不支持服务器发起双向Stream），它用于传输HTTP请求与响应。单向Stream有很多用途，所以它在数据前又多出一个Stream Type字段：</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_stream_type.png"></p><p>Stream Type有以下取值：</p><ul><li>0x00：控制Stream，传递各类Stream控制消息；</li><li>0x01：服务器推送消息；</li><li>0x02：用于编码QPACK动态表，比如面对不属于静态表的HTTP请求头部，客户端可以通过这个Stream发送动态表编码；</li><li>0x03：用于通知编码端QPACK动态表的更新结果。</li></ul><p>由于HTTP3的STREAM之间是乱序传输的，因此，若先发送的编码Stream后到达，双向Stream中的QPACK头部就无法解码，此时传输HTTP消息的双向Stream就会进入Block阻塞状态（两端可以通过控制帧定义阻塞Stream的处理方式）。</p><p>QPack 在编解码原理上和 HPack 没有本质区别。从 <a href="https://github.com/marten-seemann/qpack">QPACK</a> 的代码中可以看出，其内部完全是套了一层 HAPCK 的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteField encodes f into a single Write to e&#x27;s underlying Writer.</span></span><br><span class="line"><span class="comment">// This function may also produce bytes for the Header Block Prefix</span></span><br><span class="line"><span class="comment">// if necessary. If produced, it is done before encoding f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encoder)</span> <span class="title">WriteField</span><span class="params">(f HeaderField)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// write the Header Block Prefix</span></span><br><span class="line"><span class="keyword">if</span> !e.wrotePrefix &#123;</span><br><span class="line">e.buf = appendVarInt(e.buf, <span class="number">8</span>, <span class="number">0</span>)</span><br><span class="line">e.buf = appendVarInt(e.buf, <span class="number">7</span>, <span class="number">0</span>)</span><br><span class="line">e.wrotePrefix = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idxAndVals, nameFound := encoderMap[f.Name]</span><br><span class="line"><span class="keyword">if</span> nameFound &#123;</span><br><span class="line"><span class="keyword">if</span> idxAndVals.values == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(f.Value) == <span class="number">0</span> &#123;</span><br><span class="line">e.writeIndexedField(idxAndVals.idx)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">e.writeLiteralFieldWithNameReference(&amp;f, idxAndVals.idx)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">valIdx, valueFound := idxAndVals.values[f.Value]</span><br><span class="line"><span class="keyword">if</span> valueFound &#123;</span><br><span class="line">e.writeIndexedField(valIdx)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">e.writeLiteralFieldWithNameReference(&amp;f, idxAndVals.idx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">e.writeLiteralFieldWithoutNameReference(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e.w.Write(e.buf)</span><br><span class="line">e.buf = e.buf[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="QUIC-Feature"><a href="#QUIC-Feature" class="headerlink" title="QUIC Feature"></a>QUIC Feature</h1><h2 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0 RTT"></a>0 RTT</h2><p>使用 0-RTT 取决于客户端和服务器使用从先前连接协商的协议参数。为了启用 0-RTT, 客户端将服务器传输参数与它在连接上收到的 session tickets 一起存储, 另外还存储应用程序或加密握手所需的信息。</p><p>和握手相关的报头都是长报头(<code>Long Packet</code>) 。分别是 <strong><code>Initial (0x00)</code></strong>、<strong><code>0-RTT    (0x01)</code></strong>、<strong><code>Handshake (0x02)</code></strong>、<strong><code>Retry (0x03)</code></strong>。</p><ul><li><code>CRYPTO</code> 帧可以在不同的数据包编号空间（packet number spaces）中发送。CRYPTO 帧使用偏移量（offsets）来确保加密握手数据的有序传递的在每个包编号空间（packet number spaces）都是从零开始。</li></ul><p><strong>握手流程示例</strong></p><ol><li>QUIC 在握手前会先进行地址验证（Address Validation），确保请求包里面的源地址不是伪造的。</li><li>一旦地址验证交换完成，就可以使用加密握手来获取加密密钥。加密握手通过初始（Initial）和握手（Handshake）包进行传输。</li><li>下图展示了 1-RTT 握手的示例。每行显示一个 QUIC 包（packet），首先显示包类型（type）和包编号（number），然后是帧（frames）。例如，第一个包是 Initial 类型，包编号为 0，并且包含一个携带 ClientHello（缩写：CH） 的 CRYPTO 帧。</li><li>多个 QUIC 数据包（即便是不同的类型）也可以合并成一个单独的 UDP 数据报（datagram）。因此，下图所示的 1-RTT 握手可以由 4 个UDP数据报（datagrams）组成。如果受协议固有的限制（如拥塞控制（congestion control）和反放大（anti-amplification））也可以使用更多的数据报。</li></ol><ul><li>1 - RTT</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[0]</span><br><span class="line">                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]</span><br><span class="line">                                 &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;]</span><br><span class="line"></span><br><span class="line">Initial[1]: ACK[0]</span><br><span class="line">Handshake[0]: CRYPTO[FIN], ACK[0]</span><br><span class="line">1-RTT[0]: STREAM[0, &quot;...&quot;], ACK[0] -&gt;</span><br><span class="line"></span><br><span class="line">                                          Handshake[1]: ACK[0]</span><br><span class="line">         &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, &quot;...&quot;], ACK[0]</span><br></pre></td></tr></table></figure><ul><li>0 - RTT</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH]</span><br><span class="line">0-RTT[0]: STREAM[0, &quot;...&quot;] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[0]</span><br><span class="line">                                  Handshake[0] CRYPTO[EE, FIN]</span><br><span class="line">                          &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;] ACK[0]</span><br><span class="line"></span><br><span class="line">Initial[1]: ACK[0]</span><br><span class="line">Handshake[0]: CRYPTO[FIN], ACK[0]</span><br><span class="line">1-RTT[1]: STREAM[0, &quot;...&quot;] ACK[0] -&gt;</span><br><span class="line"></span><br><span class="line">                                          Handshake[1]: ACK[0]</span><br><span class="line">         &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, &quot;...&quot;], ACK[1]</span><br></pre></td></tr></table></figure><p>如下是取自于 qvis的 1-RTT 握手请求。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/qvis_quictools_info.png"></p><h2 id="地址验证（Address-Validation）"><a href="#地址验证（Address-Validation）" class="headerlink" title="地址验证（Address Validation）"></a>地址验证（Address Validation）</h2><p>地址验证主要是用于确保端点（endpoint）不能被用于流量放大攻击（traffic amplification attack）。攻击者如果伪造数据包的源地址为受害者的地址，发送大量的数据包给服务端，如果服务端没有进行地址验证，直接响应大量数据包给源地址（受害者），就会被攻击者利用、进行流量放大攻击。</p><p>QUIC 针对放大攻击的主要防御措施是验证端点（endpoint）是否能够在其声明的传输地址接收数据包。地址验证在<strong>连接建立（connection establishment）期间</strong>和 <strong>连接迁移（connection migration）期间</strong>进行。</p><ul><li>连接建立时，为了验证客户端的地址是否是攻击者伪造的，服务端会生成一个令牌（token）并通过重试包（Retry packet）响应给客户端。客户端需要在后续的初始包（Initial packet）带上这个令牌，以便服务端进行地址验证。</li><li>服务端可以在当前连接中通过 NEW_TOKEN 帧预先发布令牌，以便客户端在后续的新连接使用，这是 QUIC 实现 0-RTT 很重要的一个功能。</li><li>当我们的网络路径变化时（比如从蜂窝网络切换到 WIFI），QUIC 提供了连接迁移（connection migration）的功能来避免连接中断。QUIC 通过路径验证（Path Validation）验证网络新地址的可达性（reachability），防止在连接迁移中的地址是攻击者伪造的。</li></ul><p><strong>使用重试数据包（Retry Packets）验证地址</strong></p><p>在接收到客户端的初始数据包（Initial packet）后，服务端可以通过发送包含令牌（token）的重试数据包（Retry packet）来请求地址验证。客户端在接收到这个重试数据包（Retry packet）的令牌（token）之后，必须在该连接中后续所有初始数据包（Initial packet）中附上该令牌（token）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line"></span><br><span class="line">Initial[0]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                                &lt;- Retry+Token</span><br><span class="line"></span><br><span class="line">Initial+Token[1]: CRYPTO[CH] -&gt;</span><br><span class="line"></span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[1]</span><br><span class="line">                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]</span><br><span class="line">                                 &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;]</span><br></pre></td></tr></table></figure><p><strong>后续的连接使用 NEW_TOKEN 帧的令牌（token）</strong></p><p>服务端可以在一次连接中向客户端提供地址验证令牌（token），该令牌可用于后续的连接。这对于 0-RTT 尤其重要，后续的新连接可以直接使用该令牌进行地址验证，而无需额外的 1-RTT。</p><p>服务端使用 NEW_TOKEN 帧向客户端提供地址验证令牌，该令牌可用于验证后续的连接。在后续的连接中，客户端在初始数据包（Initial packets）中包含该令牌，以提供地址验证。</p><p>重试数据包（Retry packet）中提供的令牌只能立即使用，不能用于后续连接的地址验证。而 NEW_TOKEN 帧生成的令牌可以在一个时间范围内使用，这个令牌应该有一个过期时间，可以是显式的过期时间，也可以是可用于动态计算过期时间的时间戳（timestamp）。服务端可以存储过期时间，也可以在令牌中以加密的形式包含它。</p><p>参考： <a href="https://zhuanlan.zhihu.com/p/290694322">跟坚哥学QUIC系列：地址验证（Address Validation)</a></p><h2 id="链接迁移"><a href="#链接迁移" class="headerlink" title="链接迁移"></a>链接迁移</h2><p>QUIC 使用连接ID（而不是 ip + port）来确保数据包的路由一致性。如果用户的 IP 发生变化时，比如从移动蜂窝 4G 网络切换到 WiFi，IP 地址会改变。而使用一个唯一的连接ID 可以确保用户的 IP 变化时业务请求依然能够被继续处理，不用重新建连，可以继续使用当前连接ID 路由数据包，因此 QUIC 可以通过这个特性支持连接迁移</p><p>QUIC 的数据包（packets）长报头（long header）包含两个连接ID：目标连接ID（Destination Connection ID）由数据包的接收者选择并用于提供一致的路由，源连接ID（Source Connection ID）用于对端（peer）响应时使用的目标连接ID（Destination Connection ID）。</p><p>在握手过程中，带有长报头的包用于建立两端（both endpoints）使用的连接ID。在处理第一个初始数据包（Initial packet）之后，每个端点使用其接收到的源连接ID（Source Connection ID）字段的值设置为后续数据包中的目标连接ID（Destination Connection ID）字段。</p><p>当客户端发送了一个初始包（Initial packet），而该客户端之前没有从服务端接收过初始数据包（Initial packet）或重试包（Retry packet），则客户端将用一个不可预测的值（长度至少为8字节）填充到目标连接ID字段。在从服务端接收到数据包之前，客户端必须对该连接中的所有数据包使用相同的目标连接ID值。</p><p>当第一次从服务端接收到初始（Initial）或重试（Retry）数据包时，客户端使用服务端提供的源连接ID作为后续数据包（包括任何 0-RTT 数据包）的目标连接ID。这意味着在建立连接的过程中，客户端可能需要两次更改它的目标连接ID字段：一次用于响应重试（Retry），一次用于响应来自服务端的初始数据包（Initial）。一旦客户端从服务端接收到有效的初始数据包，客户端必须丢弃它后续接收到的具有不同源连接ID的数据包。</p><p>服务端必须根据第一个接收到的初始数据包（Initial packet）的源连接ID，设置为用于发送数据包的目标连接ID。后续只有当接收到 NEW_CONNECTION_ID 帧时，才允许对目标连接ID进行更改。如果后续初始数据包包含不同的源连接ID，则必须将其丢弃。这样可以避免由于无状态（stateless）处理具有不同源连接ID的多个初始数据包而导致的不可预测结果。</p><p>参考文章： </p><ul><li><a href="https://www.ietf.org/blog/whats-happening-quic/">What’s Happening with QUIC</a></li><li><a href="https://blogs.keysight.com/blogs/tech/nwvs.entry.html/2021/07/16/road_to_quic-DGa5.html">Road To QUIC</a></li><li><a href="https://www.nginx.org.cn/article/detail/422">深入剖析HTTP3协议</a></li><li><a href="https://zhuanlan.zhihu.com/p/290694322">跟坚哥学QUIC系列：地址验证（Address Validation)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 HTTP/1.1（1999 年发布）到 HTTP/2 发布（2015 年发布）之间的发展差距很大，随着 2019 年 HTTP/3 的发布，HTTP/3 即将成为互联网上超文本传输协议的下一代协议，HTTP/3 是Google QUIC协议的演变。它与传统的 HTTP 有很大的不同。QUIC 是一种新的可靠传输协议，可以被视为一种下一代TCP。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="QUIC" scheme="http://kiosk007.top/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark解析器Lua脚本</title>
    <link href="http://kiosk007.top/2021/07/10/Wireshark%E8%A7%A3%E6%9E%90%E5%99%A8Lua%E8%84%9A%E6%9C%AC/"/>
    <id>http://kiosk007.top/2021/07/10/Wireshark%E8%A7%A3%E6%9E%90%E5%99%A8Lua%E8%84%9A%E6%9C%AC/</id>
    <published>2021-07-10T07:15:00.000Z</published>
    <updated>2021-07-10T07:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Wireshark集成了Lua解释器，以支持Lua脚本（自己编译的话根据编译配置决定是否支持Lua）。</p><p>启动wireshark，依次点击“Help”，”About Wireshark“菜单，在打开的对话框中的”Wireshark”标签页上观察版本信息，如果如下图一样显示With Lua，说明此版本支持Lua插件。</p><p>然后打开wireshark主目录下的init.lua文件，确保disable_lua的值为false，即开启了lua：</p><a id="more"></a><p><img src="https://img1.kiosk007.top/static/images/wireshark/R-C.jpeg" style="height:400px"></p><p>因实际工作中需要对一种非官方的自研协议进行解析，每次可能需要对传输的内容进行对比，为了方便需要利用wireshark工具进行分析。恰好，Wireshark 可以利用其暴露的 <a href="https://wiki.wireshark.org/Lua">Lua API</a> 对抓包数据进行分析。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>Lua是一种轻量级的脚本语言，解释执行，不需要编译器之类的。基本语法可参考 <a href="https://www.w3cschool.cn/lua/lua-tutorial.html">Lua W3CSchool</a></p><p>Wireshark内置了对Lua脚本的支持，可以直接编写Lua脚本，无需配置额外的环境。使用起来方便。<br> <a href="https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html">Wireshark Developer’s Guide</a>里的第10章和第11章都是关于Lua支持的文档。</p><p>使用Lua编写Wireshark协议解析插件，有几个比较重要的概念:</p><ul><li><code>Dissector</code>: 中文直译是解剖器，就是用来解析包的类，为了解析一个新协议，我们需要编写的也是一个Dissector。</li><li><code>DissectorTable</code>: 解析器表是Wireshark中解析器的组织形式，是某一种协议的子解析器的一个列表，其作用是把所有的解析器组织成一种树状结构，便于Wireshark在解析包的时候自动选择对应的解析器。例如TCP协议的子解析器 http, smtp, sip等都被加在了”tcp.port”这个解析器表中，可以根据抓到的包的不同的tcp端口号，自动选择对应的解析器。</li></ul><p>Wireshark是用C编写的，Wireshark的剖析器通常也是用C编写的。然而，Wireshark有一个Lua实现，这使得不熟悉C的人很容易编写剖析器。对于那些不熟悉Lua的人来说，它是一种非常轻量级的编程语言，旨在作为脚本语言在应用程序中实现，以扩展其功能。</p><h2 id="Wireshark-支持"><a href="#Wireshark-支持" class="headerlink" title="Wireshark 支持"></a>Wireshark 支持</h2><p>Wireshark 天然对 Lua 有良好的支持性，且Lua在Wireshark中可以做的事情也有很多，详见<a href="https://wiki.wireshark.org/Lua/Examples">Wireshark Lua Example</a></p><p>网上的教程是点击 Help –&gt; About Wireshark –&gt; Folders，查找 Wireshark 的lua脚本存放目录。</p><p>但是实际上我找到的敌方有些不同，不过亲测有效。该目录下有一个 <code>init.lua</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux </span></span><br><span class="line">/usr/share/wireshark</span><br><span class="line"><span class="comment"># Mac</span></span><br><span class="line">/Applications/Wireshark.app/Contents/Resources/share/wireshark</span><br></pre></td></tr></table></figure><br>将<code>init.lua</code> 文件末加上， <code>dofile(DATA_DIR..&quot;your_lua_script&quot;)</code></p><p><img src="https://img1.kiosk007.top/static/images/wireshark/init_lua.png"></p><p>当 Wireshark 启动时，该脚本将处于激活状态。当脚本修改后，必须重启 Wireshark， 或者按 <code>Ctrl+Shift+L</code> （Mac 下<code>Shift+Command+L</code>） 重载 Lua 脚本。</p><h1 id="Lua-API"><a href="#Lua-API" class="headerlink" title="Lua API"></a>Lua API</h1><p>在 Lua API 之前先看一个Lua 解析脚本的示例。参考 <a href="https://zhuanlan.zhihu.com/p/114669991">自己动手编写Wireshark Lua插件解析自定义协议</a></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">--协议名称为DT，在Packet Details窗格显示为Nselab.Zachary DT</span></span><br><span class="line">    <span class="keyword">local</span> p_DT = Proto(<span class="string">&quot;DT&quot;</span>,<span class="string">&quot;Nselab.Zachary DT&quot;</span>)</span><br><span class="line">    <span class="comment">--协议的各个字段</span></span><br><span class="line">    <span class="keyword">local</span> f_identifier = ProtoField.uint8(<span class="string">&quot;DT.identifier&quot;</span>,<span class="string">&quot;Identifier&quot;</span>, base.HEX)</span><br><span class="line">    <span class="comment">--这里的base是显示的时候的进制，详细可参考https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html#lua_class_ProtoField</span></span><br><span class="line">    <span class="keyword">local</span> f_speed = ProtoField.uint8(<span class="string">&quot;DT.speed&quot;</span>, <span class="string">&quot;Speed&quot;</span>, base.HEX)</span><br><span class="line"></span><br><span class="line">    <span class="comment">--这里把DT协议的全部字段都加到p_DT这个变量的fields字段里</span></span><br><span class="line">    p_DT.fields = &#123;f_identifier, f_speed&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--这里是获取data这个解析器</span></span><br><span class="line">    <span class="keyword">local</span> data_dis = Dissector.get(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">DT_dissector</span><span class="params">(buf,pkt,root)</span></span></span><br><span class="line">        <span class="keyword">local</span> buf_len = buf:<span class="built_in">len</span>();</span><br><span class="line">        <span class="comment">--先检查报文长度，太短的不是我的协议</span></span><br><span class="line">        <span class="keyword">if</span> buf_len &lt; <span class="number">16</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">--验证一下identifier这个字段是不是0x12,如果不是的话，认为不是我要解析的packet</span></span><br><span class="line">        <span class="keyword">local</span> v_identifier = buf(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (v_identifier:uint() ~= <span class="number">0x12</span>)</span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">--取出其他字段的值</span></span><br><span class="line">        <span class="keyword">local</span> v_speed = buf(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">--现在知道是我的协议了，放心大胆添加Packet Details</span></span><br><span class="line">        <span class="keyword">local</span> t = root:add(p_DT,buf)</span><br><span class="line">        <span class="comment">--在Packet List窗格的Protocol列可以展示出协议的名称</span></span><br><span class="line">        pkt.cols.protocol = <span class="string">&quot;DT&quot;</span></span><br><span class="line">        <span class="comment">--这里是把对应的字段的值填写正确，只有t:add过的才会显示在Packet Details信息里. 所以在之前定义fields的时候要把所有可能出现的都写上，但是实际解析的时候，如果某些字段没出现，就不要在这里add</span></span><br><span class="line">        t:add(f_identifier,v_identifier)</span><br><span class="line">        t:add(f_speed,v_speed)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">--这段代码是目的Packet符合条件时，被Wireshark自动调用的，是p_DT的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">p_DT.dissector</span><span class="params">(buf,pkt,root)</span></span> </span><br><span class="line">        <span class="keyword">if</span> DT_dissector(buf,pkt,root) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">--valid DT diagram</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">--data这个dissector几乎是必不可少的；当发现不是我的协议时，就应该调用data</span></span><br><span class="line">            data_dis:call(buf,pkt,root)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">local</span> udp_encap_table = DissectorTable.get(<span class="string">&quot;udp.port&quot;</span>)</span><br><span class="line">    <span class="comment">--因为我们的DT协议的接受端口肯定是50002，所以这里只需要添加到&quot;udp.port&quot;这个DissectorTable里，并且指定值为50002即可。</span></span><br><span class="line">    udp_encap_table:add(<span class="number">50002</span>, p_DT)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如上图就是一个标准的协议解析流程。下面我们做一个详细的流程梳理。</p><h2 id="1-Proto"><a href="#1-Proto" class="headerlink" title="1. Proto"></a>1. Proto</h2><p>官方文档：<a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html#lua_class_Proto">11.6.5. Proto</a>:</p><p>表示一个新的Protocol，在Wireshark中Protocol对象有很多用处，解析器是其中主要的一个。主要接口有：</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>proto:__call(name, desc)</td><td style="text-align:right">创建Proto对象。name和desc分别是对象的名称和描述，前者可用于过滤器等</td></tr><tr><td>Proto.new(name, desc)</td><td style="text-align:right">创建一个Proto对象</td></tr><tr><td>proto:register_heuristic(listname, func)</td><td style="text-align:right">创建一个启发式解析器（<a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/30/creating-port-independent-wireshark-dissectors-in-lua.html">启发式解析器</a>）</td></tr><tr><td>proto.dissector</td><td style="text-align:right">解析函数，3个参数tvb,pinfo,tree，分别是报文内容，报文信息和解析树结构</td></tr><tr><td>proto.prefs</td><td style="text-align:right">解析器的首选项</td></tr><tr><td>proto.init</td><td style="text-align:right">初始化</td></tr><tr><td>proto.name</td><td style="text-align:right">该解析器的名字</td></tr><tr><td>proto.description</td><td style="text-align:right">该解析器的描述</td></tr><tr><td>proto.fields</td><td style="text-align:right">该解析器的内容（返回 ProtoFeild 表）</td></tr><tr><td>proto.experts</td><td style="text-align:right">该解析器的专家信息</td></tr></tbody></table></div><p>举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> NAME = <span class="string">&quot;bvc_srt&quot;</span></span><br><span class="line"><span class="keyword">local</span> bvc_srt = Proto(NAME, <span class="string">&quot;BVC_SRT Protocol&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 bvc_srt 协议首选项</span></span><br><span class="line">srt_dev.prefs[<span class="string">&quot;srt_udp_port&quot;</span>] = Pref.uint(<span class="string">&quot;SRT UDP Port&quot;</span>, <span class="number">1935</span>, <span class="string">&quot;SRT UDP Port&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注册解析器, 将 bvc_srt 自定义协议挂载到 udp 1935 端口上 </span></span><br><span class="line">DissectorTable.get(<span class="string">&quot;udp.port&quot;</span>):add(<span class="number">1935</span>, bvc_srt)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 也可以直接调用下面函数，每个数据包都会用该 bvc_srt 去解析</span></span><br><span class="line"><span class="comment">-- register_postdissector(bvc_srt)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="2-ProtoField"><a href="#2-ProtoField" class="headerlink" title="2.ProtoField"></a>2.ProtoField</h2><p>表示协议字段，一般用于解析字段后往解析树上添加节点。根据字段类型不同，其接口可以分为两大类。</p><p>这些接口都会返回一个新的字段对象。方括号内是可选字段，花括号内是可替换的类型字段。</p><p>字段可以是 uin8\uin16\uin64\string\char 等等</p><p>如下所示：<br><code>ProtoField.uint8(abbr, [name], [base], [valuestring], [mask], [desc])</code></p><ul><li>abbr: 协议字段缩写，比如 <code>bvc_srt.time_stamp</code>、<code>http.port</code></li><li>name: 字段的实际名字，比如 <code>Time Stamp</code>、<code>HTTP Port</code></li><li>base: 展示的形式，比如时间戳、端口号 是一个int64的十进制数字就可以填 <code>base.DEC</code>,再或者魔术值是一个 16进制数，可以填 <code>base.HEX</code> , 或者是HTTP的Header是字符串，可以填 <code>base.STRING</code></li><li>valuestring: 与值对应的文本表，比如TCP的Flag有 9 位，每一位的对应关系就在这里体现。</li><li>mask: 掩码，与valuestring配合，主要解决的是TCP Flag 的那种情况。</li><li>desc: 描述</li></ul><p>举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fields.peer_ipaddr = ProtoField.ipv4(<span class="string">&quot;bvc_srt.peer_ipaddr&quot;</span>, <span class="string">&quot;Peer IP address&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加到树的时候要注意</span></span><br><span class="line"><span class="comment">-- 如果是网络序，要使用add_le，而不是add</span></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/proto_field.png"><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> flag_select = &#123;[<span class="number">0</span>]=<span class="string">&quot;[Not Set]&quot;</span>,[<span class="number">1</span>]=<span class="string">&quot;[Set]&quot;</span>&#125;</span><br><span class="line">fields.tcp_flag_reserved = ProtoField.uint16(<span class="string">&quot;tcp.flag.reserved&quot;</span>, <span class="string">&quot;Reserved&quot;</span>, base.HEX, flag_select, <span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- TCP Flag 需要 3 字节，这样处理解析器即可, 0b00010000000 做掩码。</span></span><br><span class="line">data_flag_info_tree:add(fields.tcp_flag_reserved, tvb(offset, <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/proto_field_tcp.png"></p><h2 id="3-TVB"><a href="#3-TVB" class="headerlink" title="3.TVB"></a>3.TVB</h2><p>TVB 是 <code>proto.dissector(tvb, pinfo, treeitem)</code> 的第一个参数，我们将在 <code>proto.dissector</code> 函数里做我们的协议解析。</p><p><a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Tvb.html#lua_class_Tvb">Tvb（Testy Virtual Buffer）</a>表示报文缓存，也就是实际的报文数据，可以通过下面介绍的TvbRange从报文数据中解出信息。主要接口有：</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>tvb:__tostring()</td><td style="text-align:right">将报文数据转化为字符串，可用于调试</td></tr><tr><td>tvb:reported_len()</td><td style="text-align:right">get tvb的(not captured)长度</td></tr><tr><td>tvb:len()</td><td style="text-align:right">get tvb的(captured)长度</td></tr><tr><td>tvb:reported_length_remaining()</td><td style="text-align:right">获取当前tvb的剩余长度，如果偏移值大于报文长度，则返回-1</td></tr><tr><td>tvb:offset()</td><td style="text-align:right">返回原始偏移</td></tr><tr><td>tvb:raw()</td><td style="text-align:right">获取tvb中二进制字节的Lua字符串</td></tr></tbody></table></div><p>用法举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- tvb(offset, 4)表示从offset开始之后的4个字节</span></span><br><span class="line">subtree:add_le(fields.peer_ipaddr, tvb(offset, <span class="number">4</span>))</span><br></pre></td></tr></table></figure></p><h2 id="4-TvbRange"><a href="#4-TvbRange" class="headerlink" title="4.TvbRange"></a>4.TvbRange</h2><p>表示Tvb的可用范围，常用来从Tvb中解出信息。主要接口有</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>tvb:range([offset], [length])</td><td style="text-align:right">从tvb创建TvbRange，可选参数分别是偏移和长度，默认值分别是0和总长度</td></tr><tr><td>tvbrange:{type}()</td><td style="text-align:right">将tvbrange所表示范围内的数据转换成type类型的值，type包括但不限于：uint,uint64,int,int64,float,ipv4,ether,nstime,string,ustring,bytes,bitfield等，其中某些类型的方法可以带一些参数</td></tr></tbody></table></div><p>很少在实际使用中用到，大多数会取整个 tvb 进行运算位移。</p><h2 id="5-ByteArray"><a href="#5-ByteArray" class="headerlink" title="5. ByteArray"></a>5. ByteArray</h2><p>字节数组，可与Tvb互相转换。另外字符串也可以换成 <a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Tvb.html#lua_class_ByteArray">ByteArray</a> ，进而换成 Tvb。</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>ByteArray.new([hexbytes], [separator])</td><td style="text-align:right">创建一个新 ByteArray 对象</td></tr><tr><td>bytearray:__concat(first, second)</td><td style="text-align:right">连接两个 ByteArray</td></tr><tr><td>bytearray:append(appended)</td><td style="text-align:right">将 ByteArray 追加到此 ByteArray</td></tr><tr><td>bytearray:len()</td><td style="text-align:right">获取 ByteArray 的长度</td></tr><tr><td>bytearray:subset(offset, length)</td><td style="text-align:right">获取 ByteArray 的一段，作为新的 ByteArray</td></tr><tr><td>bytearray:base64_decode()</td><td style="text-align:right">获取 Base64 解码的 ByteArray</td></tr><tr><td>bytearray:__tostring()</td><td style="text-align:right">获取包含 ByteArray 中的字节的 Lua 字符串，以便可以在显示过滤器中使用它 (例如 “01FE456789AB”)</td></tr><tr><td>bytearray:tvb(name)</td><td style="text-align:right">ByteArray 转Tvb</td></tr><tr><td>bytearray:raw([offset], [length])</td><td style="text-align:right">获取 ByteArray 中的二进制字节的 Lua 字符串</td></tr></tbody></table></div><p>用法举例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proto_foo.dissector</span><span class="params">(buf, pinfo, tree)</span></span></span><br><span class="line">            <span class="comment">-- Create a new tab named &quot;My Tvb&quot; and add some data to it</span></span><br><span class="line">            <span class="keyword">local</span> b = ByteArray.new(<span class="string">&quot;11223344&quot;</span>)</span><br><span class="line">            <span class="keyword">local</span> tvb = ByteArray.tvb(b, <span class="string">&quot;My Tvb&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- Create a tree item that, when clicked, automatically shows the tab we just created</span></span><br><span class="line">            tree:add( tvb(<span class="number">1</span>,<span class="number">2</span>), <span class="string">&quot;Foo&quot;</span> )</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="6-Pinfo"><a href="#6-Pinfo" class="headerlink" title="6. Pinfo"></a>6. Pinfo</h2><p>报文信息(packet information)。主要接口有：</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>pinfo.len pinfo.caplen</td><td style="text-align:right">get报文长度</td></tr><tr><td>pinfo.abs_ts</td><td style="text-align:right">get报文捕获时间</td></tr><tr><td>pinfo.number</td><td style="text-align:right">get报文编号</td></tr><tr><td>pinfo.src pinfo.dst</td><td style="text-align:right">get/set报文的源地址、目的地址</td></tr><tr><td>pinfo.columns pinfo.cols</td><td style="text-align:right">get报文列表列（界面）</td></tr></tbody></table></div><p>用法举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改协议名称（效果见下图）</span></span><br><span class="line">pinfo.cols.protocol = bvc_srt.name</span><br><span class="line"><span class="comment">-- 为报文的信息尾部添加字符串（效果见下图）</span></span><br><span class="line">pinfo.cols.info:append(<span class="string">&quot; [ACK]&quot;</span>)</span><br><span class="line"><span class="comment">-- 还有一种便是直接覆盖</span></span><br><span class="line">pinfo.cols.info = <span class="string">&quot;[ACK]&quot;</span></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_pinfo.png"></p><h2 id="7-TreeItem"><a href="#7-TreeItem" class="headerlink" title="7. TreeItem"></a>7. TreeItem</h2><p>表示报文解析树中的一个树节点。主要接口有：</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>treeitem:add([protofield], [tvbrange], [value], [label])</td><td style="text-align:right">向当前树节点添加一个子节点</td></tr><tr><td>treeitem:set_text(text)</td><td style="text-align:right">设置当前树节点的文本</td></tr><tr><td>treeitem:prepend_text(text)</td><td style="text-align:right">在当前树节点文本的前面加上text</td></tr><tr><td>treeitem:append_text(text)</td><td style="text-align:right">在当前树节点文本的后面加上text</td></tr></tbody></table></div><p>还有注意一下网络字节序的问题，如果是网络字节序需要用add_le添加节点~<br>添加节点举例<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtree:add(fields.dst_sock, tvb(offset, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><br>实现协议里面添加子树例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子树其实也是一个节点，因此也需要在fields里面添加字段</span></span><br><span class="line">fields.pack_type_tree = ProtoField.uint32(NAME .. <span class="string">&quot;.pack_type_tree&quot;</span>, <span class="string">&quot;Packet Type&quot;</span>, base.HEX)</span><br><span class="line"><span class="comment">-- 创建子树</span></span><br><span class="line">pack_type_tree = subtree:add(fields.pack_type_tree, tvb(offset, <span class="number">4</span>))</span><br><span class="line">pack_type_tree:add(fields.msg_type, tvb(offset, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_treeitem.png"></p><h2 id="8-Fields"><a href="#8-Fields" class="headerlink" title="8. Fields"></a>8. Fields</h2><p>获得Wireshark已有协议字段。</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Field.new(fieldname)</td><td style="text-align:right">获得一个字段</td></tr><tr><td>all_field_infos()</td><td style="text-align:right">获取当前packet的 field 信息</td></tr></tbody></table></div><p>wireshark 本身已有大量的字段，比如我们想要获取 http2 的data 帧的内容，即可用 <code>http2.data.data</code> 获取。具体的fields 可以通过以下方式获得。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = Field.list()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, name <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_fields.png" style="height:400px"></p><p>可以为tap定义一个回调函数packet，每当有http协议的报文时wireshark将调用这个函数，参数tvb是报文的二进制缓冲区。在该函数中调用Field变量可以取得分析好的字段，如果不存在返回nil。</p><p>我们要截获的http协议包就包括这几层协议Frame,IP,TCP,HTTP,data-text-lines（这个是http内容）,这些上层协议的字段你都可以通过Field字段取得。<br>下面这一个截获框架，你可以使用tshark -X lua_script:tap.lua来执行这个例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tap = Listener.new(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> http = Field.new(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> host = Field.new(<span class="string">&quot;http.host&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> location = Field.new(<span class="string">&quot;http.location&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dst_ip = Field.new(<span class="string">&quot;ip.dst&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> src_ip = Field.new(<span class="string">&quot;ip.src&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dst_port = Field.new(<span class="string">&quot;tcp.dstport&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> src_port = Field.new(<span class="string">&quot;tcp.srcport&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> text = Field.new(<span class="string">&quot;data-text-lines&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.packet</span><span class="params">(pinfo,tvb,tapinfo)</span></span></span><br><span class="line">    <span class="comment">--获取对应的字段</span></span><br><span class="line">    <span class="keyword">local</span> dst = dst_ip()</span><br><span class="line">    <span class="keyword">local</span> src = src_ip()</span><br><span class="line">    <span class="keyword">local</span> h = host()</span><br><span class="line">    <span class="keyword">local</span> dstp = dst_port()</span><br><span class="line">    <span class="keyword">local</span> srcp = src_port()</span><br><span class="line">    <span class="comment">--这里可以对截获的数据做存储打印等处理</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">tostring</span>(dst))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;host : &quot;</span>..<span class="built_in">tostring</span>(h))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.draw</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;draw called&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.reset</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;reset called&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也可以调用 <code>all_field_infos</code> 获取当前 packet 中的信息，比如说以下这个 <code>MQTT Over Websocket</code> 的例子。</p><p><a href="https://cloud.tencent.com/developer/article/1093536">https://cloud.tencent.com/developer/article/1093536</a></p><h1 id="创建-Lua-解析器"><a href="#创建-Lua-解析器" class="headerlink" title="创建 Lua 解析器"></a>创建 Lua 解析器</h1><p>以下会的内容是搜集网上的一些优秀的介绍关于如何使用。</p><h2 id="MongoDB-dissector"><a href="#MongoDB-dissector" class="headerlink" title="MongoDB dissector"></a>MongoDB dissector</h2><p>以下的5篇文章是我从全网找到的最详尽的 lua 自定义协议解析脚本的教程。<br>从Lua基础到协议解析的全过程进行了阐述，从TCP Data 中解析 MongoDB 协议。</p><p>原文地址：</p><ul><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/04/creating-a-wireshark-dissector-in-lua-1.html">Creating a Wireshark dissector in Lua - part 1 (the basics)</a></li><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/06/creating-a-wireshark-dissector-in-lua-2.html">Creating a Wireshark dissector in Lua - part 2 (debugging and a more advanced dissector)</a></li><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/08/creating-a-wireshark-dissector-in-lua-3.html">Creating a Wireshark dissector in Lua - part 3 (parsing the payload)</a></li><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/16/creating-a-wireshark-dissector-in-lua-4.html">Creating a Wireshark dissector in Lua - part 4 (separate subtrees)</a></li><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/18/creating-a-wireshark-dissector-in-lua-5.html">Creating a Wireshark dissector in Lua - part 5 (modularization)</a></li></ul><p>Other</p><ul><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/30/creating-port-independent-wireshark-dissectors-in-lua.html">Creating port-independent (heuristic) Wireshark dissectors in Lua</a></li></ul><h2 id="SRT协议的Wireshark解析器编写"><a href="#SRT协议的Wireshark解析器编写" class="headerlink" title="SRT协议的Wireshark解析器编写"></a>SRT协议的Wireshark解析器编写</h2><p>该文章也详细介绍了如何使用wireshark解析一个自定义协议，本文的内容也有一些参考了本文章。 github 上的 <code>srt-dev.lua</code> 也是 比较全的例子。</p><p>原文地址：</p><ul><li><a href="https://blog.csdn.net/Boring_Wednesday/article/details/99695507">SRT协议的Wireshark解析器编写</a></li></ul><p>wireshark 解析脚本示例：</p><ul><li><a href="https://github.com/Haivision/srt/blob/master/scripts/srt-dev.lua">https://github.com/Haivision/srt/blob/master/scripts/srt-dev.lua</a></li></ul><h2 id="解析Websocket上的MQTT协议"><a href="#解析Websocket上的MQTT协议" class="headerlink" title="解析Websocket上的MQTT协议"></a>解析Websocket上的MQTT协议</h2><p>这篇文章被我单独列出的一个重要原因是，这个文章列举了如何实现，在已有协议之上的 payload 接着解析协议。比如本例中的在 websocket 的payload 之上解析 MQTT 协议。</p><p>原文地址:</p><ul><li><a href="https://cloud.tencent.com/developer/article/1093536">Lua编写wireshark插件初探——解析Websocket上的MQTT协议</a></li></ul><p>github 地址：</p><ul><li><a href="https://github.com/a3135134/Wireshark-Plugin-MQTToverWebSocket/blob/master/mqttoverwebsocket.lua">https://github.com/a3135134/Wireshark-Plugin-MQTToverWebSocket/blob/master/mqttoverwebsocket.lua</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wireshark集成了Lua解释器，以支持Lua脚本（自己编译的话根据编译配置决定是否支持Lua）。&lt;/p&gt;
&lt;p&gt;启动wireshark，依次点击“Help”，”About Wireshark“菜单，在打开的对话框中的”Wireshark”标签页上观察版本信息，如果如下图一样显示With Lua，说明此版本支持Lua插件。&lt;/p&gt;
&lt;p&gt;然后打开wireshark主目录下的init.lua文件，确保disable_lua的值为false，即开启了lua：&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="wireshark" scheme="http://kiosk007.top/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/2 特性概览</title>
    <link href="http://kiosk007.top/2021/06/07/HTTP-2-%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88/"/>
    <id>http://kiosk007.top/2021/06/07/HTTP-2-%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88/</id>
    <published>2021-06-07T03:19:00.000Z</published>
    <updated>2021-06-07T03:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HTTP的第一个文档版本于1991年发布，名称为HTTP0.9，后来导致1996年正式引入并认可HTTP1.0。HTTP1.1于1997年问世，此后几乎没有迭代改进。2015年2月，互联网工程任务组（IETF）HTTP工作组修订了HTTP，并以HTTP / 2的形式开发了应用协议的第二个主要版本。</p><blockquote><p>参考 kinsta.com 上 <a href="https://kinsta.com/learn/what-is-http2/">what-is-http2</a> 这篇文章。<br><a href="https://httpwg.org/specs/rfc7540.html">HTTP RFC 7540</a></p></blockquote><a id="more"></a><hr><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http-timeline.png"></p><h1 id="为什么要H2"><a href="#为什么要H2" class="headerlink" title="为什么要H2"></a>为什么要H2</h1><p>要解答这个问题，首先就需要知道HTTP1.x 出了什么问题。HTTP协议自1991年诞生依赖，很少有过大修大改。在H2之前最新版本的HTTP1.1已经为网络世界服务了15多年。随着互联网的发展速度越发的迅速，大量的消息充斥，而我们又对信息加载速度的一再苛刻要求。急需改变当前状况。</p><h2 id="HTTP1-1-PipeLine"><a href="#HTTP1-1-PipeLine" class="headerlink" title="HTTP1.1 PipeLine"></a>HTTP1.1 PipeLine</h2><p>HTTP1.1被限制为每个TCP连接仅处理一个未完成的请求，从而迫使浏览器使用多个TCP连接来同时处理多个请求。</p><p>但是，并行使用太多TCP连接会导致TCP拥塞，从而导致网络资源的不公平垄断。Web浏览器在使用多个连接来处理请求可能造成网络请求的大幅度占用，因此降低了其他用户的网络性能。</p><p>为了解决这个问题。互联网行业自然被迫采用诸如域分片，串联，数据内联和拼写之类的做法来破解这些约束。<br><img src="/images/network/HTTP2/http-requests.png"></p><h2 id="HTTP1-1-Bigger-Header"><a href="#HTTP1-1-Bigger-Header" class="headerlink" title="HTTP1.1 Bigger Header"></a>HTTP1.1 Bigger Header</h2><p>在HTTP1.x 中，可以用“Content-Encoding” 指定Body的编码方式，比如用 gzip 压缩来节约带宽资源，但是Header是一直没有考虑到的，Header中其实也存在大量的固定头部字段，多达上百上前字节，一些大型站点，功能复杂的，每次通信需要带上 “User Agent”、”Cookie”、”Accept” 或者一些自定义字段，这些字段都是重复的，非常浪费。”长尾效应”导致大量的带宽消耗在极度冗余的字段上。</p><h1 id="H2-特性"><a href="#H2-特性" class="headerlink" title="H2 特性"></a>H2 特性</h1><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p><img src="/images/network/HTTP2/http2-streams.png" style="height:450px"></p><p>“流”是在HTTP/2连接中客户端和服务器之间交换的独立的双向帧传输队列。流有几个重要特征：</p><ul><li>单个HTTP/2连接可以包含多个并发打开的流，其中任一端点从多个流交错发送多个Frame数据帧</li><li>流可以单方向的从客户端或者服务端建立</li><li>流可以被任意一方关闭</li><li>在流之上发送数据帧的顺序是必须的，一条流之上的Header帧在DATA帧之前。必须按照顺序</li><li>每一条流都一个流ID，流ID由发起方携带</li><li>客户端发起的流是单数递增，服务端发起的流是双数递增。</li></ul><blockquote><p>more: <a href="https://httpwg.org/specs/rfc7540.html#StreamsLayer">https://httpwg.org/specs/rfc7540.html#StreamsLayer</a></p></blockquote><p>在 HTTP2 的golang实现中可以看到<code>Framer</code>这个结构体，这个结构体规定了帧的读取和发送。在创建新的 <code>ClientConn</code> 时，会对一个<code>ClientConn</code> 通过调用 <code>cc.fr = NewFramer(cc.bw, cc.br)</code> 创建一个 <code>Framer</code> ,并且将整个 <code>net.Conn</code> 当做了 <code>io.Reader</code> 和 <code>io.Writer</code> 参数传给了 <code>Framer</code> 。<br>在<code>Framer</code>内部，会维护一个 <code>wbuf</code> 的字节队列，新写入的 Frame  会源源不断的写入到队列中。每写入的Frame的所携带的 <strong>Stream ID</strong> 并不一样。但是相同 <strong>Stream ID</strong> 会严格保持顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Framer reads and writes Frames.</span></span><br><span class="line"><span class="keyword">type</span> Framer <span class="keyword">struct</span> &#123;</span><br><span class="line">    r    io.Reader</span><br><span class="line">    w    io.Writer</span><br><span class="line">wbuf []<span class="keyword">byte</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">newClientConn</span><span class="params">(c net.Conn, singleUse <span class="keyword">bool</span>)</span> <span class="params">(*ClientConn, error)</span></span> &#123;</span><br><span class="line">cc := &amp;ClientConn&#123;</span><br><span class="line">t:                     t,</span><br><span class="line">tconn:                 c,</span><br><span class="line">readerDone:            <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">nextStreamID:          <span class="number">1</span>,</span><br><span class="line">maxFrameSize:          <span class="number">16</span> &lt;&lt; <span class="number">10</span>,           <span class="comment">// spec default</span></span><br><span class="line">initialWindowSize:     <span class="number">65535</span>,              <span class="comment">// spec default</span></span><br><span class="line">maxConcurrentStreams:  <span class="number">1000</span>,               <span class="comment">// &quot;infinite&quot;, per spec. 1000 seems good enough.</span></span><br><span class="line">peerMaxHeaderListSize: <span class="number">0xffffffffffffffff</span>, <span class="comment">// &quot;infinite&quot;, per spec. Use 2^64-1 instead.</span></span><br><span class="line">streams:               <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint32</span>]*clientStream),</span><br><span class="line">singleUse:             singleUse,</span><br><span class="line">wantSettingsAck:       <span class="literal">true</span>,</span><br><span class="line">pings:                 <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">8</span>]<span class="keyword">byte</span>]<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> d := t.idleConnTimeout(); d != <span class="number">0</span> &#123;</span><br><span class="line">cc.idleTimeout = d</span><br><span class="line">cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> VerboseLogs &#123;</span><br><span class="line">t.vlogf(<span class="string">&quot;http2: Transport creating client conn %p to %v&quot;</span>, cc, c.RemoteAddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cc.cond = sync.NewCond(&amp;cc.mu)</span><br><span class="line">cc.flow.add(<span class="keyword">int32</span>(initialWindowSize))</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> adjust this writer size to account for frame size +</span></span><br><span class="line"><span class="comment">// MTU + crypto/tls record padding.</span></span><br><span class="line">cc.bw = bufio.NewWriter(stickyErrWriter&#123;c, &amp;cc.werr&#125;)</span><br><span class="line">cc.br = bufio.NewReader(c)</span><br><span class="line">cc.fr = NewFramer(cc.bw, cc.br)</span><br><span class="line">cc.fr.ReadMetaHeaders = hpack.NewDecoder(initialHeaderTableSize, <span class="literal">nil</span>)</span><br><span class="line">cc.fr.MaxHeaderListSize = t.maxHeaderListSize()</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> SetMaxDynamicTableSize, SetMaxDynamicTableSizeLimit on</span></span><br><span class="line"><span class="comment">// henc in response to SETTINGS frames?</span></span><br><span class="line">cc.henc = hpack.NewEncoder(&amp;cc.hbuf)</span><br><span class="line">        <span class="keyword">if</span> t.AllowHTTP &#123;</span><br><span class="line">cc.nextStreamID = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cs, ok := c.(connectionStater); ok &#123;</span><br><span class="line">state := cs.ConnectionState()</span><br><span class="line">cc.tlsState = &amp;state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initialSettings := []Setting&#123;</span><br><span class="line">&#123;ID: SettingEnablePush, Val: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;ID: SettingInitialWindowSize, Val: transportDefaultStreamFlow&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max := t.maxHeaderListSize(); max != <span class="number">0</span> &#123;</span><br><span class="line">initialSettings = <span class="built_in">append</span>(initialSettings, Setting&#123;ID: SettingMaxHeaderListSize, Val: max&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cc.bw.Write(clientPreface)</span><br><span class="line">cc.fr.WriteSettings(initialSettings...)</span><br><span class="line">cc.fr.WriteWindowUpdate(<span class="number">0</span>, transportDefaultConnFlow)</span><br><span class="line">cc.inflow.add(transportDefaultConnFlow + initialWindowSize)</span><br><span class="line">cc.bw.Flush()</span><br><span class="line"><span class="keyword">if</span> cc.werr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, cc.werr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> cc.readLoop()</span><br><span class="line"><span class="keyword">return</span> cc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到。63 行的 <code>cc.bw</code> 可以任意写入非Frame的字符串，如果需要写入 <code>Frame</code> 的话，会通过 64 行的<code>cc.fr.WriteXXXX</code> 写入。如下面的 <code>Setting 帧的写入</code> 。HTTP2 发送一个帧的实现就是将该帧结构完完整整的塞入 wbuf 中, 由 <code>startWrite</code> 写入wbuf, 再由<code>endWrite</code> 函数将wbuf 写入 <code>io.Writer</code>中，刚才在 <code>NewFramer(cc.bw, cc.br)</code> 函数中已经看到了，<code>io.Writer</code> 就是 net.Conn, 也就是这个 Frame 被发出去了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteSettings writes a SETTINGS frame with zero or more settings</span></span><br><span class="line"><span class="comment">// specified and the ACK bit not set.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It will perform exactly one Write to the underlying Writer.</span></span><br><span class="line"><span class="comment">// It is the caller&#x27;s responsibility to not call other Write methods concurrently.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Framer)</span> <span class="title">WriteSettings</span><span class="params">(settings ...Setting)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f.startWrite(FrameSettings, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> settings &#123;</span><br><span class="line">f.writeUint16(<span class="keyword">uint16</span>(s.ID))</span><br><span class="line">f.writeUint32(s.Val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f.endWrite()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Framer)</span> <span class="title">startWrite</span><span class="params">(ftype FrameType, flags Flags, streamID <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// Write the FrameHeader.</span></span><br><span class="line">f.wbuf = <span class="built_in">append</span>(f.wbuf[:<span class="number">0</span>],</span><br><span class="line"><span class="number">0</span>, <span class="comment">// 3 bytes of length, filled in in endWrite</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="keyword">byte</span>(ftype),</span><br><span class="line"><span class="keyword">byte</span>(flags),</span><br><span class="line"><span class="keyword">byte</span>(streamID&gt;&gt;<span class="number">24</span>),</span><br><span class="line"><span class="keyword">byte</span>(streamID&gt;&gt;<span class="number">16</span>),</span><br><span class="line"><span class="keyword">byte</span>(streamID&gt;&gt;<span class="number">8</span>),</span><br><span class="line"><span class="keyword">byte</span>(streamID))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Framer)</span> <span class="title">endWrite</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Now that we know the final size, fill in the FrameHeader in</span></span><br><span class="line"><span class="comment">// the space previously reserved for it. Abuse append.</span></span><br><span class="line">length := <span class="built_in">len</span>(f.wbuf) - frameHeaderLen</span><br><span class="line"><span class="keyword">if</span> length &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrFrameTooLarge</span><br><span class="line">&#125;</span><br><span class="line">_ = <span class="built_in">append</span>(f.wbuf[:<span class="number">0</span>],</span><br><span class="line"><span class="keyword">byte</span>(length&gt;&gt;<span class="number">16</span>),</span><br><span class="line"><span class="keyword">byte</span>(length&gt;&gt;<span class="number">8</span>),</span><br><span class="line"><span class="keyword">byte</span>(length))</span><br><span class="line"><span class="keyword">if</span> f.logWrites &#123;</span><br><span class="line">f.logWrite()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n, err := f.w.Write(f.wbuf)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; n != <span class="built_in">len</span>(f.wbuf) &#123;</span><br><span class="line">err = io.ErrShortWrite</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么由此就得知了流的组成，和流多路复用的原理。以及流之间的帧是有顺序的。<strong>（这个例子足够简单，以至于没有实现流优先级的概念，也没有流控之类的概念，后面我们再介绍）</strong><br>但是我们帧可以任意交织在一起。实现一套逻辑层面的流的概念。</p><p>更多帧格式参见：<a href="https://httpwg.org/specs/rfc7540.html#FrameTypes">https://httpwg.org/specs/rfc7540.html#FrameTypes</a></p><h2 id="HPACK"><a href="#HPACK" class="headerlink" title="HPACK"></a>HPACK</h2><p><img src="/images/network/HTTP2/http2-hpack-compression.png" style="height:130px"></p><p>在 HTTP1.1 中，每一个请求都携带着沉重的 header，包含 cookie 、trace-link、<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server-Timing">server-timing</a>、X-FF 信息。</p><p>在网站提供丰富媒体内容的情况下，客户端发送多个几乎相同的HTTP头部，会导致延迟和有限的网络资源的不必要消耗。HTTP2 正是针对这点进行了优化，</p><p>HPACK 正是HTTP2 减少HTTP请求header的秘诀，HPACK 由 <a href="https://httpwg.org/specs/rfc7541.html">RFC7541</a> 规定。</p><p>而HPACK 的压缩方式分 3 种</p><ul><li>静态字典</li><li>动态字典</li><li>压缩算法：Huffman 压缩 （最高压缩比 8:5）</li></ul><h3 id="静态字典"><a href="#静态字典" class="headerlink" title="静态字典"></a>静态字典</h3><p><a href="https://httpwg.org/specs/rfc7541.html#static.table.definition">https://httpwg.org/specs/rfc7541.html#static.table.definition</a></p><p>静态字典由 <code>index</code>、<code>header name</code>、<code>header value</code> 组成，比如字符2就可以直接代表 <code>:method : GET</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IndexHeader NameHeader Value</span><br><span class="line">1:authority</span><br><span class="line">2:methodGET</span><br><span class="line">3:methodPOST</span><br><span class="line">4:path&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/hpack.jpeg"></p><p>可以在静态表字典里查到的会直接引用，无法查到的会进行 <code>Huffman</code> 编码。</p><p>静态表一共有61项，动态表采用先入先出的淘汰策略，大小由 <code>SETTINGS_HEADER_TABLE_SIZE</code> 控制。</p><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack-table.png"></p><h3 id="Huffman-编码原理"><a href="#Huffman-编码原理" class="headerlink" title="Huffman 编码原理"></a>Huffman 编码原理</h3><p>出现概率较大的字符串用较短的数字编码，出现概率较小的字符串用比较长的数字编码。</p><p>huffman 编码分两种，一种是<strong>静态 huffman</strong>，一种是<strong>动态huffman</strong>，静态huffman编码是对当前已有的字符的一个出现概率的统计。<code>0</code>、<code>1</code>、<code>.</code>、<code>a</code>、<code>c</code>、<code>e</code> 等字符串出现概率较高，所以就用较短的字符做映射从而统计生成了一套<a href="https://httpwg.org/specs/rfc7541.html#huffman.code">静态 huffmane 编码表</a>。早先的 spdy 使用的动态huffman编码，但是容易被攻击，所以HTTP2使用的都是静态 huffman 编码，</p><ul><li>Huffman 树的构造过程</li></ul><ol><li>计算各字母的出现概率</li><li>将出现概率较小的两个字母相加构成子树，左小右大</li><li>重复步骤二完成树的构建</li><li>给树的左链接编码0.右链接编码1</li><li>每个字母的编码即从根节点至叶节点的串联和</li></ol><p><a href="https://www.geeksforgeeks.org/huffman-decoding/">huffman 树编码(Huffman Decoding)</a></p><p><strong>举例</strong></p><p>有一串字符</p><p>A 出现 25 次 、 B 出现 15 次、C 出现 14 次、 D 出现 20 次、 E 出现 17 次、F 出现9 次</p><p>按照左小右大的规则。 F 与 C 组成一组, 加起来是 23 ，以此类推。</p><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/huffman_tree.png"></p><p>从 Golang 的 hpack 实现中可以调取 http2/hpack 来做header编解码。核心代码只有2部分，<code>NewEncoder</code> 创建一个编码<code>Encoder</code>对象。通过 <code>WriteFeild</code> 来实现header内容的写入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewEncoder returns a new Encoder which performs HPACK encoding. An</span></span><br><span class="line"><span class="comment">// encoded data is written to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> *<span class="title">Encoder</span></span> &#123;</span><br><span class="line">e := &amp;Encoder&#123;</span><br><span class="line">minSize:         uint32Max,</span><br><span class="line">maxSizeLimit:    initialHeaderTableSize,</span><br><span class="line">tableSizeUpdate: <span class="literal">false</span>,</span><br><span class="line">w:               w,</span><br><span class="line">&#125;</span><br><span class="line">e.dynTab.table.init()</span><br><span class="line">e.dynTab.setMaxSize(initialHeaderTableSize)</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteField encodes f into a single Write to e&#x27;s underlying Writer.</span></span><br><span class="line"><span class="comment">// This function may also produce bytes for &quot;Header Table Size Update&quot;</span></span><br><span class="line"><span class="comment">// if necessary. If produced, it is done before encoding f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encoder)</span> <span class="title">WriteField</span><span class="params">(f HeaderField)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">e.buf = e.buf[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e.tableSizeUpdate &#123;</span><br><span class="line">e.tableSizeUpdate = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> e.minSize &lt; e.dynTab.maxSize &#123;</span><br><span class="line">e.buf = appendTableSize(e.buf, e.minSize)</span><br><span class="line">&#125;</span><br><span class="line">e.minSize = uint32Max</span><br><span class="line">e.buf = appendTableSize(e.buf, e.dynTab.maxSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx, nameValueMatch := e.searchTable(f)</span><br><span class="line"><span class="keyword">if</span> nameValueMatch &#123;</span><br><span class="line">e.buf = appendIndexed(e.buf, idx)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">indexing := e.shouldIndex(f)</span><br><span class="line"><span class="keyword">if</span> indexing &#123;</span><br><span class="line">e.dynTab.add(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> idx == <span class="number">0</span> &#123;</span><br><span class="line">e.buf = appendNewName(e.buf, f, indexing)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">e.buf = appendIndexedName(e.buf, f, idx, indexing)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n, err := e.w.Write(e.buf)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; n != <span class="built_in">len</span>(e.buf) &#123;</span><br><span class="line">err = io.ErrShortWrite</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>代码第21行，更新增大动态表size，这个不用关心，只有SETTING帧协商时才会变大，正常是走不到21行的这个if语句。</li><li>代码第30行，在hpack表（静态表+动态表）中搜索，如果能搜到（name+value）则在第32行将索引写入buffer中，否则在第34行判断一下是否可以索引，可以索引的话就加入到动态表，如果 idx 为0（name和value都没有查到）则对整个header kv进行索引，如果有idx，证明只是value没有被索引，只对value 索引即可</li></ul><p>下面以 <code>appendNewName(dst []byte, f HeaderField, indexing bool)</code> 为例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// appendNewName appends f, as encoded in one of &quot;Literal Header field</span></span><br><span class="line"><span class="comment">// - New Name&quot; representation variants, to dst and returns the</span></span><br><span class="line"><span class="comment">// extended buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f.Sensitive is true, &quot;Never Indexed&quot; representation is used. If</span></span><br><span class="line"><span class="comment">// f.Sensitive is false and indexing is true, &quot;Incremental Indexing&quot;</span></span><br><span class="line"><span class="comment">// representation is used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendNewName</span><span class="params">(dst []<span class="keyword">byte</span>, f HeaderField, indexing <span class="keyword">bool</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">dst = <span class="built_in">append</span>(dst, encodeTypeByte(indexing, f.Sensitive))</span><br><span class="line">dst = appendHpackString(dst, f.Name)</span><br><span class="line"><span class="keyword">return</span> appendHpackString(dst, f.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第9行代码，表示加一个前缀，表示该字段是否可以被索引，sensitive如果为true的话表示不能被索引，比如一些每次请求绝对会变化的value，如<code>server-timing</code>就不能被索引。</li><li>第10行代码，将Header Name 进行动态表索引。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// appendHpackString appends s, as encoded in &quot;String Literal&quot;</span></span><br><span class="line"><span class="comment">// representation, to dst and returns the extended buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// s will be encoded in Huffman codes only when it produces strictly</span></span><br><span class="line"><span class="comment">// shorter byte string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendHpackString</span><span class="params">(dst []<span class="keyword">byte</span>, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">huffmanLength := HuffmanEncodeLength(s)</span><br><span class="line"><span class="keyword">if</span> huffmanLength &lt; <span class="keyword">uint64</span>(<span class="built_in">len</span>(s)) &#123;</span><br><span class="line">first := <span class="built_in">len</span>(dst)</span><br><span class="line">dst = appendVarInt(dst, <span class="number">7</span>, huffmanLength)</span><br><span class="line">dst = AppendHuffmanString(dst, s)</span><br><span class="line">dst[first] |= <span class="number">0x80</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dst = appendVarInt(dst, <span class="number">7</span>, <span class="keyword">uint64</span>(<span class="built_in">len</span>(s)))</span><br><span class="line">dst = <span class="built_in">append</span>(dst, s...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第7行代码获取huffman编码后的长度， string 的每一位被编码后的长度之和会由<code>HuffmanEncodeLength</code>提供，如果Huffman编码后有字节节省才会真正编码。负责直接将原数据直接加入到 dst buffer 中。</li><li>第8行证明了Huffman 编码更有优势。在buffer开始或等于 0x80 表示 Huffman编码。并由 <code>AppendHuffmanString(dst, s)</code> 真正开始Huffman编码。由于是静态Huffman编码，所以接下来要做的事情就是查表了。</li></ul><blockquote><p>实际上可供编码的只有7位，最高位置1表示是huffman 编码。<br>例如：method: GET 在静态表中为 2，则最终编码为 1000 0010 hex 表示为82</p></blockquote><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack1.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">名字和值都在索引表中</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack2.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">名字在索引表中，值进行编码</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack3.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">名字和值都不在索引表中，2个都进行huffman编码</div></center><p>HPACK 压缩比检测：<br><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-hpack.png"></p><blockquote><p>空间节省了 71.44% , 访问的次数越多，节约的空间越多，访问一次只会发挥 静态表和huffman 算法的作用。</p></blockquote><h2 id="流优先级-amp-amp-流控"><a href="#流优先级-amp-amp-流控" class="headerlink" title="流优先级 &amp;&amp; 流控"></a>流优先级 &amp;&amp; 流控</h2><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-weight.png" style="height:140px"></p><p>这里就先说流控吧。</p><p>HTTP2 一般 Connection 和 Stream 的初始 flow-control window 大小都是 65535 bytes （如果一切顺利不丢包的情况下，RTT为 100ms，则每秒最多能发送65535*(1000/100)的数据，大约就是600KB/s）。通过发送 SETTINGS Frame，携带 <a href="http://httpwg.org/specs/rfc7540.html#SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE</a> ，修改初始窗口大小。如果当前窗口已存在，会做delta 更新，这个值即为新的 stream flow-control window 初始大小。</p><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control0.png"></p><p>通过对官方代码按照 RFC 实现的http2库分析：</p><p>首先服务端视角，入向流量每收到一个 <code>DataFrame</code> 都会在自身链接级别和流级别更新当前的 <strong>flow-control</strong>，而每创建一个新stream时，其入向 <strong>sc.inflow</strong> 是继承当前连接级别的 <strong>flow-control</strong> 。<strong>即所有 stream 级别的窗口之和等于 Connection 级别的窗口。</strong></p><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control1.png"></p><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control2.png"></p><p>整个发送过程会遵从流控限制，如果窗口 &gt; 0 但是 窗口 &lt; 客户端要发送的数据，客户端要发送的数据会被分成2部分，其中流控内的数据会被发送</p><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control3.png"></p><p>在一次实际的上传过程中，观察到如下的一次上传的 netlog。服务端的窗口经常因为耗尽而等待，等待时长约 70ms + ，与akamai 的 ping 延迟基本也在 30-60ms 。每次窗口恢复和挤牙膏一样非常缓慢。<br><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-flow-control4.png"></p><h2 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h2><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-push.png" style="height:150px"></p><p><a href="https://httpwg.org/specs/rfc7540.html#PUSH_PROMISE">Push Promise</a> 是HTTP2 与 HTTP1.1 最大的一个区别，它是指在客户端在发起一个请求时，服务端在返回该请求响应之前，返回一个 PushPromise 表示有资源要推送，并且会再新开一个偶数流，推送内容，在客户端发起请求之前让客户端拿到数据。如下是 push promise 的服务端实现。</p><p><img src="https://img1.kiosk007.top/static/images/network/HTTP2/http2-serverpush.png" style="height:400px"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushHandler</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> path, handler := <span class="keyword">range</span> pushResources &#123;</span><br><span class="line"><span class="keyword">if</span> r.URL.Path == path &#123;</span><br><span class="line">handler.ServeHTTP(w, r)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cacheBust := time.Now().UnixNano()</span><br><span class="line"><span class="keyword">if</span> pusher, ok := w.(http.Pusher); ok &#123;</span><br><span class="line"><span class="keyword">for</span> path := <span class="keyword">range</span> pushResources &#123;</span><br><span class="line">url := fmt.Sprintf(<span class="string">&quot;%s?%d&quot;</span>, path, cacheBust)</span><br><span class="line"><span class="keyword">if</span> err := pusher.Push(url, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Failed to push %v: %v&quot;</span>, path, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// fake network latency + parsing time</span></span><br><span class="line"><span class="keyword">if</span> err := PushTmpl.Execute(w, <span class="keyword">struct</span> &#123;</span><br><span class="line">CacheBust   <span class="keyword">int64</span></span><br><span class="line">HTTPSHost   <span class="keyword">string</span></span><br><span class="line">HTTP1Prefix <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">CacheBust:   cacheBust,</span><br><span class="line">HTTPSHost:   HttpsHost(),</span><br><span class="line">HTTP1Prefix: Http1Prefix(),</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Executing server push template: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接前言"><a href="#连接前言" class="headerlink" title="连接前言"></a>连接前言</h2><p>TLS 握手成功之后，客户端需要发送一个”连接前言”（connection preface），用来确认HTTP/2的连接。Magic被称为H2不可知的魔法。而PRISM，其实就是在暗讽2013年斯诺登事件爆出的“棱镜计划”。</p><p>参考：<a href="https://blog.jgc.org/2015/11/the-secret-message-hidden-in-every.html">https://blog.jgc.org/2015/11/the-secret-message-hidden-in-every.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Magic: PRI * HTTP&#x2F;2.0\r\n\r\nSM\r\n\r\n</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li>[0]: <a href="https://kinsta.com/learn/what-is-http2/">https://kinsta.com/learn/what-is-http2/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTTP的第一个文档版本于1991年发布，名称为HTTP0.9，后来导致1996年正式引入并认可HTTP1.0。HTTP1.1于1997年问世，此后几乎没有迭代改进。2015年2月，互联网工程任务组（IETF）HTTP工作组修订了HTTP，并以HTTP / 2的形式开发了应用协议的第二个主要版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考 kinsta.com 上 &lt;a href=&quot;https://kinsta.com/learn/what-is-http2/&quot;&gt;what-is-http2&lt;/a&gt; 这篇文章。&lt;br&gt;&lt;a href=&quot;https://httpwg.org/specs/rfc7540.html&quot;&gt;HTTP RFC 7540&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何减少TTFB以提升WordPress加载性能</title>
    <link href="http://kiosk007.top/2021/06/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91TTFB%E4%BB%A5%E6%8F%90%E9%AB%98%E7%BD%91%E9%A1%B5%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4/"/>
    <id>http://kiosk007.top/2021/06/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91TTFB%E4%BB%A5%E6%8F%90%E9%AB%98%E7%BD%91%E9%A1%B5%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4/</id>
    <published>2021-06-05T03:19:00.000Z</published>
    <updated>2021-06-05T03:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当谈论到你的 <a href="What Is WordPress? Explained for Beginners">WordPress Site</a> 加载性能时，大多数我们都是在关注前端的性能优化来提升页面加载速度。然而我们有时候应该从服务端视角来看待这个问题。今天我们来讨论一下 <strong>TTFB (time to first byte)</strong> 是怎么影响你的网站加载速度，另外我们如何去降低他。TTFB是一个经常会被忽略的重要性能因素，但是我们在网站性能优化是必须考虑进来。</p><p><img src="http://img1.kiosk007.top/static/images/network/performance/ttfb.png" style="height:300px"></p><p>— 译 <a href="https://kinsta.com/blog/ttfb/">How to Reduce TTFB to Improve WordPress Page Load Times</a></p><a id="more"></a><ul><li><a href>什么是TTFB?</a></li><li><a href>TTFB 重要吗？</a></li><li><a href>如何测量TTFB？</a></li><li><a href>4种方法来减少Wordpress站点的TTFB</a></li></ul><h1 id="什么是TTFB？"><a href="#什么是TTFB？" class="headerlink" title="什么是TTFB？"></a>什么是TTFB？</h1><p>TTFB 表示”首字节时间”, 简单的说，表示从浏览器收到服务端的第一个字节所需要的时间。TTFB时间越长、那么页面加载显示的时间就越长。一个常见的误解是，这个时间主要是DNS查找时间计算的。然而，真正的 <a href="https://en.wikipedia.org/wiki/Time_To_First_Byte">TTFB</a> 其实包含整个网络期间的时延。并且以下三个步骤之和才是总的TTFB。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/waiting-ttfb.jpg" style="height:300px"></p><h2 id="1-请求服务"><a href="#1-请求服务" class="headerlink" title="1. 请求服务"></a>1. 请求服务</h2><p>当有用户访问你的网站时。发生的第一件事是客户端（浏览器）会先发送一个HTTP请求。在此步骤中，可能有多种因素导致延迟、<strong>缓慢的DNS</strong> 查找时间可能会增加请求的时间。如果服务器在地理上很远，这可能会导致数据传输距离的延迟。此外，如果您有复杂的防火墙规则，这可能会增加路由时间。并且不要忘记客户端的互联网速度。</p><h2 id="2-服务端处理耗时"><a href="#2-服务端处理耗时" class="headerlink" title="2. 服务端处理耗时"></a>2. 服务端处理耗时</h2><p>发送请求后，服务器现在必须处理它并生成响应。这可能会引入许多不同的延迟，例如<strong>缓慢的数据库调用</strong>、过多的第三方脚本、<strong>未缓存</strong>第一个响应、糟糕的代码或 WordPress 主题以及低效的服务器资源，例如<strong>磁盘 I/O</strong> 或<strong>内存</strong>。</p><h2 id="3-响应"><a href="#3-响应" class="headerlink" title="3. 响应"></a>3. 响应</h2><p>服务器处理完请求后，必须将其发送回客户端（或者更确切地说是发送回第一个字节）。这受到服务器和客户端网络速度的影响。如果客户端的 Wi-Fi 热点速度较慢，这将反映在 TTFB 中。</p><h1 id="TTFB-重要吗？"><a href="#TTFB-重要吗？" class="headerlink" title="TTFB 重要吗？"></a>TTFB 重要吗？</h1><p>重要的是要了解 TTFB（到第一个字节的时间）与网站速度不同。这实际上是对响应能力的衡量。网络上有很多关于 TTFB 是否重要的​​讨论。有人说它毫无意义（<a href="https://blog.cloudflare.com/ttfb-time-to-first-byte-considered-meaningles/">Cloudflare</a>、<a href>LittleBizzy</a>），而另一些人说它很重要（<a href="https://plus.google.com/+IlyaGrigorik/posts/GTWYbYWP6xP">Ilya Grigorik</a>，Google 的 Web 性能工程师）。双方都提出了一些关于为什么或为什么不重要的有效观点，以及关于它如何实际计算的一些问题。</p><p>Moz 甚至对<a href="https://moz.com/blog/improving-search-rank-by-optimizing-your-time-to-first-byte">搜索排名与第一个字节的时间之间的相关性</a>进行了深入研究。 但是，很难知道搜索排名是否是和TTFB相关的 。或者 TTFB 较低的网站是否也只是总体上更快。</p><p>然而，与其花时间讨论是否重要，我们宁愿专注于可以做的优化来改进这个指标。在我们具有更大 TTFB 的测试站点中，只需加载并感觉更慢。</p><p>通常，<strong>低于 100 毫秒的TTFB 都很棒</strong>。<a href="https://kinsta.com/blog/google-pagespeed-insights/">Google PageSpeed Insights</a> 建议服务器响应时间小于 200 毫秒。如果您在 300-500 毫秒范围内，这是非常标准的。如果超过 600 毫秒，您的服务或者链路可能有问题，或者可能是时候升级到更好的 Web 服务了。或者按照我们下面有关如何减少 TTFB 的建议进行操作。SSL/TLS 协商也可能是一个点。</p><h1 id="如何测量TTFB"><a href="#如何测量TTFB" class="headerlink" title="如何测量TTFB"></a>如何测量TTFB</h1><p>可以通过多种不同的方式来测试你站点的 TTFB。下面将探索一些。但请记住，每种工具都会给出略有不同的结果，因此重要的是只使用一种工具并坚持使用它作为基线。</p><h2 id="使用-Google-Chrome-DevTools-测量-TTFB"><a href="#使用-Google-Chrome-DevTools-测量-TTFB" class="headerlink" title="使用 Google Chrome DevTools 测量 TTFB"></a>使用 Google Chrome DevTools 测量 TTFB</h2><p>可以通过启动DevTools在 Google Chrome 中测量 TTFB 。但请记住，如果您在计算机上测试 TTFB 会受到网络延迟和 Internet 连接的影响。因此，使用从数据中心进行测试的第 3 方工具（如下所示）可能更有效。</p><ul><li>从 Chrome 菜单中选择更多工具 &gt; 开发者工具。</li><li>右键单击页面元素并选择检查</li><li>使用键盘快捷键Ctrl+ Shift+ I(Windows) 或Cmd+ Opt+ I(Mac)</li><li>您可以启动网络窗口并查看站点的性能。</li></ul><p><img src="https://img1.kiosk007.top/static/images/network/performance/google-chrome-devtools-ttfb.jpg" style="height:300px"></p><h2 id="使用-Geekflare-的工具测量-TTFB"><a href="#使用-Geekflare-的工具测量-TTFB" class="headerlink" title="使用 Geekflare 的工具测量 TTFB"></a>使用 Geekflare 的工具测量 TTFB</h2><p>Geekflare 拥有一系列很棒的免费工具，您可以使用它们来测试和排除网站上的问题。<a href="https://gf.dev/ttfb-test">Geekflare</a> 的 TTFB 工具简单、快速，可让您查看从全球三个位置获取第一个字节的时间有多快（低）</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/geekflare.png" style="height:300px"></p><h2 id="使用-WebPageTest-测量-TTFB"><a href="#使用-WebPageTest-测量-TTFB" class="headerlink" title="使用 WebPageTest 测量 TTFB"></a>使用 WebPageTest 测量 TTFB</h2><p>您还可以使用 <a href="https://www.webpagetest.org/">WebPageTest</a> 测量您的 TTFB 。根据他们的术语表，目标时间是 DNS、套接字和 SSL 协商所需的时间 + 100 毫秒。超出目标每100ms扣除一个字母等级。正如您在下面的测试中所见，该站点的 TTFB 为 0.256 秒或 256 毫秒。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/webpagetest-ttfb.jpg" style="height:300px"></p><h2 id="用-Pingdom-测量-TTFB"><a href="#用-Pingdom-测量-TTFB" class="headerlink" title="用 Pingdom 测量 TTFB"></a>用 Pingdom 测量 TTFB</h2><p>Chrome 和 WebPageTest 将其称为 TTFB。但是，如果您使用Pingdom，它实际上被称为“等待”时间。请务必查看我们关于如何使用 Pingdom的深入指南。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/wait-time-pingdom.jpg" style="height:300px"></p><h2 id="使用-GTmetrix-测量-TTFB"><a href="#使用-GTmetrix-测量-TTFB" class="headerlink" title="使用 GTmetrix 测量 TTFB"></a>使用 GTmetrix 测量 TTFB</h2><p>在 GTmetrix 中，就像 Pingdom 一样，TTFB 被称为等待时间。请务必查看我们关于如何使用 <a href="https://kinsta.com/blog/gtmetrix-speed-test/">GTmetrix的深入指南</a> 。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/gtmetrix-waiting.png" style="height:300px"></p><h2 id="使用-KeyCDN-的工具测量-TTFB"><a href="#使用-KeyCDN-的工具测量-TTFB" class="headerlink" title="使用 KeyCDN 的工具测量 TTFB"></a>使用 KeyCDN 的工具测量 TTFB</h2><p>KeyCDN 有一个很棒的 <a href="https://tools.keycdn.com/performance">网络性能测试工具</a> ，您可以在其中同时从 14 个不同的位置测量您的 TTFB。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/keycdn-ttfb-test.jpg" style="height:300px"></p><p>还有一些其他各种工具可以测量 TTFB，例如<a href="https://performance.sucuri.net/">Sucuri Performance Tool</a>和<a href="http://www.bytecheck.com/">ByteCheck</a>。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/google-analytics-ttfb.jpg" style="height:300px"></p><h1 id="减少-WordPress-网站上-TTFB-的-4-种方法"><a href="#减少-WordPress-网站上-TTFB-的-4-种方法" class="headerlink" title="减少 WordPress 网站上 TTFB 的 4 种方法"></a>减少 WordPress 网站上 TTFB 的 4 种方法</h1><blockquote><p>现在让我们深入探讨如何减少 WordPress 网站上的 TTFB。</p></blockquote><h2 id="1-使用快速的-WordPress-主机"><a href="#1-使用快速的-WordPress-主机" class="headerlink" title="1. 使用快速的 WordPress 主机"></a>1. 使用快速的 WordPress 主机</h2><p>减少 TTFB 的第一种方法是确保您使用的是快速的 WordPress 主机。我们比较了第三方云服务器的 TTFB（位于亚利桑那州凤凰城）和 Kinsta 的 TTFB（位于爱荷华州康瑟尔布拉夫斯）。我们使用了完全相同的设置，运行默认的 27 主题。Kinsta 现在拥有所有 25 个可用的Google Cloud Platform 节点，因此战略性地将您的 WordPress 站点放置在离访问者更近的位置非常重要。</p><p>切换到更快的主机可以将您网站的 TTFB 减少多达 200%。</p><p>Kinsta 还在 所有托管计划中使用了 Google Cloud Platform 的高级网络。许多其他托管服务提供商使用 Google Cloud 的标准层网络，这会导致速度变慢。</p><p>在所有地区，平均 TTFB 为 520 毫秒。在美国和加拿大，平均 TTFB 为 240 毫秒。</p><p>因此，仅通过使用更快的主机，可以显著降低 TTFB </p><h2 id="2-CDN-or-DSA"><a href="#2-CDN-or-DSA" class="headerlink" title="2. CDN or DSA"></a>2. CDN or DSA</h2><p>另一种减少 TTFB 的简单方法是利用 <strong><a href="https://kinsta.com/blog/wordpress-cdn/">内容交付网络</a></strong> (CDN)。如果您的网站为该国不同地区或全球的访问者提供服务，这会大大降低您的 TTFB。正如我们在上面看到的，位置非常重要。我们进行了一个小测试，以显示 KeyCDN 作为我们的 CDN 提供商的不同之处。每个测试运行 5 次并取平均值。</p><ul><li>没有 CDN 的 TTFB</li></ul><p>我们首先在禁用 CDN 的情况下运行测试，我们的总加载时间为 1.45 秒，资产的平均 TTFB 约为 136 毫秒。</p><ul><li>带 CDN 的 TTFB<br>我们的总加载时间下降到 788 毫秒，我们的平均 TTFB 现在是 37 毫秒！CDN 可以带来多大的不同</li></ul><p>注意：如果您使用 Cloudflare，您的TTFB可能略高。这很可能是由于运行完全代理服务的额外开销和复杂性。Cloudflare 具有某些 CDN 提供商没有的其他防火墙和其他功能。</p><h2 id="3-WordPress-缓存"><a href="#3-WordPress-缓存" class="headerlink" title="3. WordPress 缓存"></a>3. WordPress 缓存</h2><p>减少 TTFB 的第三种方法，也可能是最简单的方法之一，就是在 WordPress 网站上使用缓存。许多人只认为缓存可以帮助减少加载时间，但实际上，它也有助于减少 TTFB，因为它有助于减少服务器处理时间。</p><h2 id="4-使用高级-DNS-提供商"><a href="#4-使用高级-DNS-提供商" class="headerlink" title="4. 使用高级 DNS 提供商"></a>4. 使用高级 DNS 提供商</h2><p>DNS 也在 TTFB 中发挥作用。很难准确计算它受到的影响有多大，但您仍然可以看到总体 DNS 查找时间，并看到那里有越来越快的提供商。</p><p><a href="http://www.solvedns.com/dnsspeedtest/">SolveDNS 速度测试工具</a> 可以帮我们测试DNS解析速度。 大的云厂商，如 AWS 会比一些免费的DNS提供商的质量要好很多。</p><p>更多内容可以查看 [Why Premium DNS is No Longer Optional][<a href="https://kinsta.com/blog/premium-dns/">https://kinsta.com/blog/premium-dns/</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当谈论到你的 &lt;a href=&quot;What Is WordPress? Explained for Beginners&quot;&gt;WordPress Site&lt;/a&gt; 加载性能时，大多数我们都是在关注前端的性能优化来提升页面加载速度。然而我们有时候应该从服务端视角来看待这个问题。今天我们来讨论一下 &lt;strong&gt;TTFB (time to first byte)&lt;/strong&gt; 是怎么影响你的网站加载速度，另外我们如何去降低他。TTFB是一个经常会被忽略的重要性能因素，但是我们在网站性能优化是必须考虑进来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.kiosk007.top/static/images/network/performance/ttfb.png&quot; style=&quot;height:300px&quot;&gt;&lt;/p&gt;
&lt;p&gt;— 译 &lt;a href=&quot;https://kinsta.com/blog/ttfb/&quot;&gt;How to Reduce TTFB to Improve WordPress Page Load Times&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
  </entry>
  
  <entry>
    <title>curl 命令小结</title>
    <link href="http://kiosk007.top/2021/05/29/curl-%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>http://kiosk007.top/2021/05/29/curl-%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</id>
    <published>2021-05-29T07:22:00.000Z</published>
    <updated>2021-05-29T07:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>curl 命令是我日常工作中最常用的命令之一，所以很有必要总结一下curl命令的一些用法。如统计耗时、以指定的ip访问某个域名。添加携带某些Header等。curl命令绝对是日常debug之神。</p><p><img src="https://img1.kiosk007.top/static/images/network/curl/curl-command.png" style="height:200px"></p><a id="more"></a><ul><li>curl 官网：<a href="https://curl.se">https://curl.se</a></li><li>curl 支持：<br>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP. curl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, HTTP/2, HTTP/3, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, SCRAM-SHA, NTLM, Negotiate and Kerberos), file transfer resume, proxy tunneling and more.</li></ul><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><ul><li>指定解析：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://github.com --resolve github.com:443:13.229.188.59 -v -o /dev/null</span><br></pre></td></tr></table></figure><ul><li>POST请求携带json数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X POST -d <span class="string">&#x27;&#123;&quot;abc&quot;:123,&quot;bcd&quot;:&quot;nihao&quot;&#125;&#x27;</span> URL</span><br></pre></td></tr></table></figure><ul><li>修改请求头</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;host: www.baidu.com&quot;</span> https://127.0.0.1</span><br></pre></td></tr></table></figure><ul><li>限速</li></ul><p>限制curl使用的最大带宽；如果未指定单位，默认单位为“bytes/秒”，你也可以指定单位为“K”、“M”、“G”等单位，如：“—limit-rate 1m”为限制最大使用带宽为“1m字节/秒”；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://www.baidu.com --limit-rate 10k</span><br></pre></td></tr></table></figure></p><ul><li>下载</li></ul><p>显示进度条(option：-#)或不显示进度条(option：-s)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="comment"># -O https://img1.kiosk007.top/static/images/network/curl/curl-command.png</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p>curl 命令提供了 -w 参数，这个参数在 manpage 是这样解释的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-w, --write-out &lt;format&gt;</span><br><span class="line">              Make curl display information on stdout after a completed transfer. The format is a string that may contain plain text mixed with any number of variables. The</span><br><span class="line">              format can be specified as a literal <span class="string">&quot;string&quot;</span>, or you can have curl <span class="built_in">read</span> the format from a file with <span class="string">&quot;@filename&quot;</span> and to tell curl  to  <span class="built_in">read</span>  the  format  from</span><br><span class="line">              stdin you write <span class="string">&quot;@-&quot;</span>.</span><br><span class="line"></span><br><span class="line">              The  variables  present <span class="keyword">in</span> the output format will be substituted by the value or text that curl thinks fit, as described below. All variables are specified as</span><br><span class="line">              %&#123;variable_name&#125; and to output a normal % you just write them as %%. You can output a newline by using \n, a carriage <span class="built_in">return</span> with \r and a tab space with \t.</span><br><span class="line"></span><br><span class="line">              The output will be written to standard output, but this can be switched to standard error by using %&#123;stderr&#125;.</span><br><span class="line"></span><br><span class="line">              NOTE: The %-symbol is a special symbol <span class="keyword">in</span> the win32-environment, <span class="built_in">where</span> all occurrences of % must be doubled when using this option.</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>它能够按照指定的格式打印某些信息，里面可以使用某些特定的变量，而且支持 \n、\t和 \r 转义字符。提供的变量很多，比如 status<em>code、local_port、size_download 等等，这篇文章我们只关注和请求时间有关的变量（以 time</em> 开头的变量）。</p><p>具体支持的变量如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">% content_type   The Content-Type of the requested document, <span class="keyword">if</span> there was any.</span><br><span class="line"></span><br><span class="line">% filename_effective   The ultimate filename that curl writes out to. This is only meaningful <span class="keyword">if</span> curl is told to write to a file with the  -O,  --remote-name  or  -o, --output option. It<span class="string">&#x27;s most useful in combination with the -J, --remote-header-name option. (Added in 7.26.0)&#x27;</span></span><br><span class="line"></span><br><span class="line">% ftp_entry_path The initial path curl ended up <span class="keyword">in</span> when logging on to the remote FTP server. (Added <span class="keyword">in</span> 7.15.4)</span><br><span class="line"></span><br><span class="line">% http_code      The  numerical  response  code  that was found <span class="keyword">in</span> the last retrieved HTTP(S) or FTP(s) transfer. In 7.18.2 the <span class="built_in">alias</span> response_code was added to show the same info.</span><br><span class="line"></span><br><span class="line">% http_connect   The numerical code that was found <span class="keyword">in</span> the last response (from a proxy) to a curl CONNECT request. (Added <span class="keyword">in</span> 7.12.4)</span><br><span class="line"></span><br><span class="line">% http_version   The http version that was effectively used. (Added <span class="keyword">in</span> 7.50.0)</span><br><span class="line"></span><br><span class="line">% local_ip       The IP address of the <span class="built_in">local</span> end of the most recently <span class="keyword">done</span> connection - can be either IPv4 or IPv6 (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% local_port     The <span class="built_in">local</span> port number of the most recently <span class="keyword">done</span> connection (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% num_connects   Number of new connects made <span class="keyword">in</span> the recent transfer. (Added <span class="keyword">in</span> 7.12.3)</span><br><span class="line"></span><br><span class="line">% num_redirects  Number of redirects that were followed <span class="keyword">in</span> the request. (Added <span class="keyword">in</span> 7.12.3)</span><br><span class="line"></span><br><span class="line">% proxy_ssl_verify_result   The result of the HTTPS proxy<span class="string">&#x27;s SSL peer certificate verification that was requested. 0  means  the  verification  was  successful.  (Added  in 7.52.0)&#x27;</span></span><br><span class="line"></span><br><span class="line">% redirect_url   When an HTTP request was made without -L, --location to follow redirects (or when --max-redir is met), this variable will show the actual URL a redirect would have gone to. (Added <span class="keyword">in</span> 7.18.2)</span><br><span class="line"></span><br><span class="line">% remote_ip      The remote IP address of the most recently <span class="keyword">done</span> connection - can be either IPv4 or IPv6 (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% remote_port    The remote port number of the most recently <span class="keyword">done</span> connection (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>先往文本文件 curl-format.txt 写入下面的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat curl-format.txt</span><br><span class="line">time_namelookup:  %&#123;time_namelookup&#125;\n</span><br><span class="line">time_connect:  %&#123;time_connect&#125;\n</span><br><span class="line">time_appconnect:  %&#123;time_appconnect&#125;\n</span><br><span class="line">time_pretransfer:  %&#123;time_pretransfer&#125;\n</span><br><span class="line">time_redirect:  %&#123;time_redirect&#125;\n</span><br><span class="line">time_starttransfer:  %&#123;time_starttransfer&#125;\n</span><br><span class="line">----------\n</span><br><span class="line">time_total:  %&#123;time_total&#125;\n</span><br><span class="line">http_code:  %&#123;http_code&#125;\n</span><br><span class="line">----------\n</span><br><span class="line">local_ip:  %&#123;local_ip&#125;\n</span><br><span class="line">size_download:  %&#123;size_download&#125;\n</span><br><span class="line">size_header:  %&#123;size_header&#125;\n</span><br><span class="line">size_request:  %&#123;size_request&#125;\n</span><br><span class="line">size_upload:  %&#123;size_upload&#125;\n</span><br><span class="line">speed_download:  %&#123;speed_download&#125;\n</span><br><span class="line">speed_upload:  %&#123;speed_upload&#125;\n</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ul><li>ime_namelookup：DNS 域名解析的时候，就是把 <a href="https://zhihu.com">https://zhihu.com</a> 转换成 ip 地址的过程</li><li>time_connect：TCP 连接建立的时间，就是三次握手的时间</li><li>time_appconnect：SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间</li><li>time_redirect：从开始到最后一个请求事务的时间</li><li>time_pretransfer：从请求开始到响应开始传输的时间</li><li>time_starttransfer：从请求开始到第一个字节将要传输的时间</li><li>time_total：这次请求花费的全部时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">% curl -w<span class="string">&quot;@curl-format.txt&quot;</span> -o /dev/null -s -L https://kiosk007.top/   </span><br><span class="line">time_namelookup:  0.011032</span><br><span class="line">time_connect:  0.103585</span><br><span class="line">time_appconnect:  0.235695</span><br><span class="line">time_pretransfer:  0.235911</span><br><span class="line">time_redirect:  0.000000</span><br><span class="line">time_starttransfer:  0.375289</span><br><span class="line">----------</span><br><span class="line">time_total:  0.657439</span><br><span class="line">http_code:  200</span><br><span class="line">----------</span><br><span class="line">local_ip:  192.168.0.112</span><br><span class="line">size_download:  18180</span><br><span class="line">size_header:  661</span><br><span class="line">size_request:  74</span><br><span class="line">size_upload:  0</span><br><span class="line">speed_download:  27671.000</span><br><span class="line">speed_upload:  0.000</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="HTTP3-新特性"><a href="#HTTP3-新特性" class="headerlink" title="HTTP3 新特性"></a>HTTP3 新特性</h1><p><a href="https://curl.se/docs/http3.html">https://curl.se/docs/http3.html</a></p><p>curl 可以基于 <a href="https://github.com/cloudflare/quiche">quiche</a> 实现HTTP3 的能力，当前H3的草案还没有完全定稿，所以curl 的quic不一定能够访问成功所有的QUIC服务端实现。</p><p>通过以下方式编译支持H3特性的curl</p><p>Build quiche and BoringSSL:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% git <span class="built_in">clone</span> --recursive https://github.com/cloudflare/quiche</span><br><span class="line">% <span class="built_in">cd</span> quiche</span><br><span class="line">% cargo build --release --features ffi,pkg-config-meta,qlog</span><br><span class="line">% mkdir deps/boringssl/src/lib</span><br><span class="line">% ln -vnf $(find target/release -name libcrypto.a -o -name libssl.a) deps/boringssl/src/lib/</span><br></pre></td></tr></table></figure><br>Build curl:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">cd</span> ..</span><br><span class="line">% git <span class="built_in">clone</span> https://github.com/curl/curl</span><br><span class="line">% <span class="built_in">cd</span> curl</span><br><span class="line">% ./buildconf</span><br><span class="line">% ./configure LDFLAGS=<span class="string">&quot;-Wl,-rpath,<span class="variable">$PWD</span>/../quiche/target/release&quot;</span> --with-openssl=<span class="variable">$PWD</span>/../quiche/deps/boringssl/src --with-quiche=<span class="variable">$PWD</span>/../quiche/target/release</span><br><span class="line">% make</span><br></pre></td></tr></table></figure><br>Use HTTP/3 directly:</p><p><code>curl --http3 https://nghttp2.org:4433/</code><br>Upgrade via Alt-Svc:</p><p><code>curl --alt-svc altsvc.cache https://quic.aiortc.org/</code></p><p>See this list of <a href="https://bagder.github.io/HTTP3-test/">public HTTP/3 servers</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;curl 命令是我日常工作中最常用的命令之一，所以很有必要总结一下curl命令的一些用法。如统计耗时、以指定的ip访问某个域名。添加携带某些Header等。curl命令绝对是日常debug之神。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img1.kiosk007.top/static/images/network/curl/curl-command.png&quot; style=&quot;height:200px&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="ops" scheme="http://kiosk007.top/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>Go 测试框架 stretchr/testify</title>
    <link href="http://kiosk007.top/2021/04/29/Go-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-stretchr-testify/"/>
    <id>http://kiosk007.top/2021/04/29/Go-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-stretchr-testify/</id>
    <published>2021-04-29T14:43:40.000Z</published>
    <updated>2021-04-29T14:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>golang的测试框架stretchr/testify 简单的API去检验你的GoLang代码按照你的意愿运行。</p><p>项目地址： <code>https://github.com/stretchr/testify</code></p><a id="more"></a><p><strong>特性：</strong></p><ul><li>易用的断言接口 (<a href="https://github.com/stretchr/testify#assert-package">Easy assertions</a>)</li><li>接口模拟 (<a href="https://github.com/stretchr/testify#mock-package">Mocking</a>)</li><li>测试套件接口与性能 (<a href="https://github.com/stretchr/testify#suite-package">Testing suite interfaces and functions</a>)</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用 <code>go get</code> 安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/stretchr/testify</span><br></pre></td></tr></table></figure><br>安装后获得以下包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">github.com/stretchr/testify/assert</span><br><span class="line">github.com/stretchr/testify/require</span><br><span class="line">github.com/stretchr/testify/mock</span><br><span class="line">github.com/stretchr/testify/suite</span><br><span class="line">github.com/stretchr/testify/http (deprecated</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>assert package</li><li>require package</li><li>mock package</li><li>suite package</li></ul><p><strong>这里面最常用的是前两个 package，他们的唯一差别就是require的函数会直接导致case结束，而assert虽然也标记为case失败，但case不会退出，而是继续往下执行</strong></p><h2 id="assert-package"><a href="#assert-package" class="headerlink" title="assert package"></a>assert package</h2><p><code>assert</code> 包提供了一些有用的方法，允许您在Go中编写更好的测试代码。</p><ul><li>友好输出，更详细的问题描述</li><li>代码可读性强</li><li>可以选择用消息注释断言</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCase1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Bob&quot;</span></span><br><span class="line">age := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">assert.Equal(t, <span class="string">&quot;Bob&quot;</span>, name)</span><br><span class="line">assert.Equal(t, <span class="number">20</span>, age,<span class="string">&quot;年龄不相等&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestCase1</span><br><span class="line">    TestCase1: abc_test.go:18: </span><br><span class="line">        Error Trace:abc_test.go:18</span><br><span class="line">        Error:      Not equal: </span><br><span class="line">                    expected: 20</span><br><span class="line">                    actual  : 10</span><br><span class="line">        Test:       TestCase1</span><br><span class="line">        Messages:   年龄不相等</span><br><span class="line">--- FAIL: TestCase1 (0.00s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Expected :20</span><br><span class="line">Actual   :10</span><br><span class="line">&lt;Click to see difference&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FAIL</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="require-package"><a href="#require-package" class="headerlink" title="require package"></a>require package</h2><p><code>require</code>包提供与assert包相同的全局函数，但它们不会返回布尔结果，而是终止当前测试。</p><h2 id="mock-package"><a href="#mock-package" class="headerlink" title="mock package"></a>mock package</h2><p><code>mock</code>包提供了一种机制，可以方便地编写mock对象，在编写测试代码时可以用它代替真实对象。</p><p>如下一个示例测试函数，它测试依赖外部对象<code>testObj</code>的一段代码，可以设置期望（证明）并断言它们确实发生了。</p><p>例如，一个是消息服务或电子邮件服务，无论何时被调用，都会向客户端发送电子邮件。如果我们正在积极地开发我们的代码库，可能每天会运行数百次测试，但我们不希望每天向客户发送数百封电子邮件或消息，因为那样他们可能会不高兴。</p><blockquote><p>那么，我们要如何使用 testify 包来模拟呢？</p></blockquote><p>让我们来看一下如何将 <code>mocks</code> 应用到一个相当简单的例子中。在这个例子中，我们有一个系统会尝试向客户收取产品或服务的费用。当 <code>ChargeCustomer()</code> 被调用时，它将随后调用 <code>Message Service</code>，向客户发送 SMS 文本消息来通知他们已经被收取的金额。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MessageService 通知客户被收取的费用</span></span><br><span class="line"><span class="keyword">type</span> MessageService <span class="keyword">interface</span> &#123;</span><br><span class="line">SendChargeNotification(<span class="keyword">int</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SMSService 是 MessageService 的实现</span></span><br><span class="line"><span class="keyword">type</span> SMSService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyService 使用 MessageService 来通知客户</span></span><br><span class="line"><span class="keyword">type</span> MyService <span class="keyword">struct</span> &#123;</span><br><span class="line">messageService MessageService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SendChargeNotification 通过 SMS 来告知客户他们被收取费用</span></span><br><span class="line"><span class="comment">// 这就是我们将要模拟的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sms SMSService)</span> <span class="title">SendChargeNotification</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Sending Production Charge Notification&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChargeCustomer 向客户收取费用</span></span><br><span class="line"><span class="comment">// 在真实系统中，我们会模拟这个</span></span><br><span class="line"><span class="comment">// 但是在这里，我想在每次运行时都赚点钱</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a MyService)</span> <span class="title">ChargeCustomer</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">a.messageService.SendChargeNotification(value)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Charging Customer For the value of %d\n&quot;</span>, value)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 &quot;Production&quot; 例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">smsService := SMSService&#123;&#125;</span><br><span class="line">myService := MyService&#123;smsService&#125;</span><br><span class="line">myService.ChargeCustomer(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们如何进行测试以确保我们不会让客户疯掉？好吧，我们通过创建一个新的 struct 称之为 <code>smsServiceMock</code> ，用来模拟我们的 <code>SMSService</code>，并且将 <code>mock.Mock</code> 添加到它的字段列表中。</p><p>然后我们将改写 <code>SendChargeNotification</code> 方法，这样它就不会向我们的客户发送通知并返回 nil 错误。</p><p>最后，我们创建 <code>TestChargeCustomer</code> 测试函数，接着实例化一个新的类型实例 <code>smsServiceMock</code> 并指定 <code>SendChargeNotification</code>在被调用时应该做什么。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smsServiceMock</span></span><br><span class="line"><span class="keyword">type</span> smsServiceMock <span class="keyword">struct</span> &#123;</span><br><span class="line">mock.Mock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们模拟的 smsService 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m smsServiceMock)</span> <span class="title">SendChargeNotification</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Mocked charge notification function&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Value passed in: %d\n&quot;</span>, value)</span><br><span class="line"><span class="comment">// 这将记录方法被调用以及被调用时传进来的参数值</span></span><br><span class="line">args := m.Called(value)</span><br><span class="line"><span class="comment">// 它将返回任何我需要返回的</span></span><br><span class="line"><span class="comment">// 这种情况下模拟一个 SMS Service Notification 被发送出去</span></span><br><span class="line">args.Bool(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestChargeCustomer 是个奇迹发生的地方</span></span><br><span class="line"><span class="comment">// 在这里我们将创建 SMSService mock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChargeCustomer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> smsService smsServiceMock</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后我们将定义当 100 传递给 SendChargeNotification 时，需要返回什么</span></span><br><span class="line"><span class="comment">// 在这里，我们希望它在成功发送通知后返回 true</span></span><br><span class="line">smsService.On(<span class="string">&quot;SendChargeNotification&quot;</span>, <span class="number">100</span>).Return(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，我们要定义要测试的服务</span></span><br><span class="line">myService := MyService&#123;smsService&#125;</span><br><span class="line"><span class="comment">// 然后调用方法</span></span><br><span class="line">myService.ChargeCustomer(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，我们验证 myService.ChargeCustomer 调用了我们模拟的 SendChargeNotification 方法</span></span><br><span class="line">smsService.AssertExpectations(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当我们运行 <code>go test ./... -v</code>时，我们应该看到以下输出：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test ./... -v</span><br><span class="line">=== RUN   TestChargeCustomer</span><br><span class="line">Mocked charge notification function</span><br><span class="line">Value passed in: <span class="number">100</span></span><br><span class="line">Charging Customer For the value of <span class="number">100</span></span><br><span class="line">--- PASS: TestChargeCustomer (<span class="number">0.00</span>s)</span><br><span class="line">    main_test.<span class="keyword">go</span>:<span class="number">33</span>: PASS:      SendChargeNotification(<span class="keyword">int</span>)</span><br><span class="line">PASS</span><br><span class="line">ok      _/Users/elliot/Documents/Projects/tutorials/golang/<span class="keyword">go</span>-testify-tutorial  <span class="number">0.012</span>s</span><br></pre></td></tr></table></figure><p>这证明我们的 myService.ChargeCustomer() 方法按照我们所期望的方式在运行！</p><p>我们现在已经能够使用模拟的方法来全面测试更复杂的项目。值得注意的是，此技术可用于各种不同的系统，例如模拟数据库查询或者是如何与其他 API 交互。总的来说，模拟是非常强大的手段</p><h2 id="suite-package"><a href="#suite-package" class="headerlink" title="suite package"></a>suite package</h2><p>这个包不太常用</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;golang的测试框架stretchr/testify 简单的API去检验你的GoLang代码按照你的意愿运行。&lt;/p&gt;
&lt;p&gt;项目地址： &lt;code&gt;https://github.com/stretchr/testify&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建我的ELK 7.12</title>
    <link href="http://kiosk007.top/2021/03/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84ELK-7-2/"/>
    <id>http://kiosk007.top/2021/03/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84ELK-7-2/</id>
    <published>2021-03-27T05:52:18.000Z</published>
    <updated>2021-03-27T05:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。</p><p>“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。</p><p>引用官网的一句话：</p><blockquote><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="https://img1.kiosk007.top/static/images/elk/elk.png" style="height:500px"></p><p><strong>ElasticSearch 的目录结构</strong></p><div class="table-container"><table><thead><tr><th>目录</th><th style="text-align:right">配置文件</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>bin</td><td style="text-align:right"></td><td style="text-align:center">脚本文件，包括启动elasticsearch，安装插件，运行统计数据等 </td></tr><tr><td>config</td><td style="text-align:right">elasticsearch.yml</td><td style="text-align:center">集群配置文件，user，role based 相关配置</td></tr><tr><td>JDK</td><td style="text-align:right"></td><td style="text-align:center">java 运行环境</td></tr><tr><td>data</td><td style="text-align:right">path.data</td><td style="text-align:center">数据文件</td></tr><tr><td>lib</td><td style="text-align:right"></td><td style="text-align:center">java 类库</td></tr><tr><td>logs</td><td style="text-align:right">path.log</td><td style="text-align:center">日志文件</td></tr><tr><td>modules</td><td style="text-align:right"></td><td style="text-align:center">包含所有ES模块</td></tr><tr><td>plugins</td><td style="text-align:right"></td><td style="text-align:center">包含所有已经安装的插件</td></tr></tbody></table></div><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><p>官方文档 Set up Elasticsearch 有各个 OS 的安装指导，页面 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/install-elasticsearch.html">Installing Elasticsearch</a> 中提供了多种安装包对应的指导链接！</p><p>本文选择绿色安装包的的方式（tar.gz）安装。</p><ul><li>安装环境： ubuntu 20.04</li><li>下载链接： <a href="https://mirrors.huaweicloud.com/elasticsearch/">华为镜像站</a> 速度能快一点</li></ul><p>说明：ElasticSearch使用java语言开发，所以默认需要安装并配置JDK，设置 JAVA_HOME, 但是从 7.0 开始，ElasticSearch 内置了Java环境，无需再安装。另外ES启动不能使用root用户</p><p>内核参数修改（32C + 128G参考）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改文件描述符数量</span></span><br><span class="line">grep <span class="string">&quot;* - nofile 512000&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span>  <span class="string">&quot;* - nofile 512000&quot;</span>  &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改最大打开进程数数量</span></span><br><span class="line">grep <span class="string">&quot;work - nproc unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;elasticsearch - nproc unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"><span class="comment">#配合es mem lock，centos6无须添加</span></span><br><span class="line">grep <span class="string">&quot;* soft memlock unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;* soft memlock unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#配合es mem lock，centos6无须添加</span></span><br><span class="line">grep <span class="string">&quot;* hard memlock unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;* hard memlock unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改系统文件描述符</span></span><br><span class="line">grep <span class="string">&quot;fs.file-max = 1024000&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;fs.file-max = 1024000&quot;</span>  &gt;&gt; /etc/sysctl.conf </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改程序最大管理的vm</span></span><br><span class="line">grep <span class="string">&quot;vm.max_map_count = 262144&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.max_map_count = 262144&quot;</span>  &gt;&gt;  /etc/sysctl.conf  </span><br><span class="line"></span><br><span class="line">grep  <span class="string">&quot;vm.min_free_kbytes = 2097152&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.min_free_kbytes = 2097152&quot;</span>  &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">grep  <span class="string">&quot;vm.zone_reclaim_mode = 0&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.zone_reclaim_mode = 0&quot;</span>  &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">swapoff -a   <span class="comment">#关闭虚拟内存</span></span><br></pre></td></tr></table></figure><h2 id="1-安装-elasticsearch"><a href="#1-安装-elasticsearch" class="headerlink" title="1. 安装 elasticsearch"></a>1. 安装 elasticsearch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xf elasticsearch-7.12.0-linux-x86_64.tar.gz -C ~</span><br><span class="line"><span class="built_in">cd</span> ~/elasticsearch-7.12.0</span><br><span class="line">./bin/elasticsearch  <span class="comment"># 启动</span></span><br></pre></td></tr></table></figure><p>启动成功后访问本地的 9200 端口，可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:9200</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;k8s-master&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;sEn3TgEVSnW4kHpIAU1-5Q&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : <span class="string">&quot;7.12.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_type&quot;</span> : <span class="string">&quot;tar&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_hash&quot;</span> : <span class="string">&quot;78722783c38caa25a70982b5b042074cde5d3b3a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_date&quot;</span> : <span class="string">&quot;2021-03-18T06:17:15.410153305Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;lucene_version&quot;</span> : <span class="string">&quot;8.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;6.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p class="div-border red">如果有安装的错误，参考：</p><ul><li><strong>seccomp unavailable 错误</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：elasticsearch.yml 配置</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure></li><li><strong>max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：修改 &#x2F;etc&#x2F;security&#x2F;limits.conf，配置：</span><br><span class="line">hard nofile 80000</span><br><span class="line">soft nofile 80000</span><br></pre></td></tr></table></figure></li><li><strong>max virtual memory areas vm.max_map_count [65530] is too low</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：修改 &#x2F;etc&#x2F;sysctl.conf，添加 ：</span><br><span class="line">vm.max_map_count &#x3D; 262144</span><br><span class="line">然后 sysctl -p 生效</span><br></pre></td></tr></table></figure><blockquote><p>安装插件方式：./bin/elasticsearch-plugin install analysis-icu</p></blockquote></li></ul><p><strong>ES 相关配置</strong></p><ul><li>官网关于配置的内容主要有两处：<ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html">Configuring Elasticsearch</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">Important Elasticsearch configuration</a></li></ul></li><li>Elasticsearch 主要有三个配置文件：<ul><li><code>elasticsearch.yml</code>：ES的配置文件 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">more</a></li><li><code>jvm.options</code>: ES JVM 参数 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/jvm-options.html#jvm-options">more</a></li><li><code>log4j2.properties</code>: ES log 配置 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/logging.html#logging">more</a></li></ul></li></ul><p>默认情况，ES 告诉 JVM 使用一个最小和最大都为 4GB 的堆。但是到了生产环境，这个配置就比较重要了，确保 ES 有足够堆空间可用。</p><blockquote><p>但是我的XPS 16G内存。不改堆内存大小的只能起一个实例，再起其他实例，旧的实例总显示 Killed。<br>修复方式，更改 <code>./config/jvm.options</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g </span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>运行多个Elasticsearch 实例</strong></p><p>每个实例的配置文件需要不同，这里降低复杂度，不修改配置文件，而是直接用命令行的形式启动一个集群。</p><ul><li>启动实例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动实例1</span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -Enode.name=node0 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">false</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9200 -E transport.tcp.port=9300 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-E cluster.initial_master_nodes=<span class="string">&quot;node0&quot;</span> -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动实例2 </span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -E node.name=node1 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">true</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E path.data=./data/data_node1 -E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9201 -E transport.tcp.port=9301 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动实例3 </span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -E node.name=node2 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">true</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E path.data=./data/data_node2 -E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9202 -E transport.tcp.port=9302 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-d</span><br></pre></td></tr></table></figure><blockquote><ul><li>9300端口： ES节点之间通讯使用</li><li>9200端口： ES节点 和 外部 通讯使用</li><li><code>discovery.seed_hosts</code>: 发现设置。有两种重要的发现和集群形成配置，以便集群中的节点能够彼此发现并且选择一个主节点.其中 <code>discovery.seed_hosts</code> 是组件集群时比较重要的配置，用于启动当前节点时，发现其他节点的初始列表。<br>当一个已经加入过集群的节点重启时，如果他无法与之前集群中的节点通信，很可能就会报这个错误 master not discovered or elected yet, an election requires at least 2 nodes with ids from。必须至少配置 [discovery.seed_hosts，discovery.seed_providers，cluster.initial_master_nodes] 中的一个。</li><li><code>cluster.initial_master_nodes</code>: 初始的候选 master 节点列表。初始主节点应通过其 node.name 标识，默认为其主机名。确保 cluster.initial_master_nodes 中的值与 node.name 完全匹配。<p class="div-border red">`cluster.initial_master_nodes` 该配置项并不是需要每个节点设置保持一致，设置需谨慎，如果其中的主节点关闭了，可能会导致其他主节点也会关闭。因为一旦节点初始启动时设置了这个参数，它下次启动时还是会尝试和当初指定的主节点链接，当链接失败时，自己也会关闭！因此，为了保证可用性，预备做主节点的节点不用每个上面都配置该配置项！保证有的主节点上就不设置该配置项，这样当有主节点故障时，还有可用的主节点不会一定要去寻找初始节点中的主节点！</p></li><li>详细资料参考：<ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-discovery-bootstrap-cluster.html">Bootstrapping a cluster</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-settings.html">Discovery and cluster formation settings</a></li></ul></li></ul><p>在新版 7.x 的 ES 中，对 ES 的集群发现系统做了调整，不再有 discovery.zen.minimum_master_nodes 这个控制集群脑裂的配置，转而由集群自主控制，并且新版在启动一个新的集群的时候需要有cluster.initial_master_nodes 初始化集群主节点列表。如果一个集群一旦形成，你不该再设置该配置项，应该移除它。该配置项仅仅是集群第一次创建时设置的！集群形成之后，这个配置也会被忽略的！</p><ul><li><code>discovery.seed_hosts</code>: 提供群集中符合master节点资格的地址列表</li></ul></blockquote><p>node0 节点仅仅是一个 master 节点，它不是一个数据节点。</p><p>先启动 node0 节点，因为它设置了初始主节点的列表。这时候就可以使用 <code>http://&lt;host IP&gt;:9200/</code> 看到结果了。然后逐一启动 node1 和 node2。通过访问 <code>http://127.0.0.1:9200/_cat/nodes</code> 查看集群是否 OK。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:9200/_cat/nodes</span><br><span class="line">127.0.0.1 42 49 58 4.45 2.09 1.37 lmr        * node0</span><br><span class="line">127.0.0.1 42 49 54 4.45 2.09 1.37 cdfhlmrstw - node1</span><br><span class="line">127.0.0.1 42 49 45 4.45 2.09 1.37 cdfhlmrstw - node2</span><br></pre></td></tr></table></figure></p><h2 id="2-安装-Kibana"><a href="#2-安装-Kibana" class="headerlink" title="2. 安装 Kibana"></a>2. 安装 Kibana</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xf kibana-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kibana-7.12.0-linux-x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>启动kibana</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将kibana改成中文</span></span><br><span class="line">vim config/kibana.yml</span><br><span class="line">     i18n.locale: <span class="string">&quot;zh-CN&quot;</span>   <span class="comment">## 最后一行</span></span><br><span class="line">./bin/kibana</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问本地的5601端口<br>查看样例。点击右下角的 <code>try out sample data</code> ，可以导入kibana的测试数据。分别是电商网站报表、航空数据、日志<br><img src="https://img1.kiosk007.top/static/images/elk/kinana_home.png"><br>这里分 <a href="https://www.elastic.co/cn/enterprise-search?elektra=home&amp;storm=river1">Enterprise Search(企业搜索)</a>、<a href="https://www.elastic.co/guide/en/observability/7.9/observability-introduction.html">Observability(监控)</a>、<a href="https://www.elastic.co/guide/en/security/7.9/es-overview.html">Security(安全)</a></p><ul><li>Enterprise Search(企业搜索)：可建立强大的搜索体验，当然是付费滴。</li><li>Observability(监控)：日志、APM、站点SLA监控、指标打点。（支持Nginx、MySQL、Redis等日志）</li><li>Security(安全): 安全相关的解决方案</li></ul><p>另外还开以打开 <code>http://127.0.0.1:5601/app/dev_tools#/console</code> 控制台，这个是直接对接 ES 的。可在这里直接使用查询语句。</p><h2 id="3-安装-Logstash"><a href="#3-安装-Logstash" class="headerlink" title="3. 安装 Logstash"></a>3. 安装 Logstash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-安装-cerebro"><a href="#4-安装-cerebro" class="headerlink" title="4. 安装 cerebro"></a>4. 安装 cerebro</h2><p>cerebro是专业化项目管理系统，提供一个协作工作环境和项目管理软件，用于处理复杂的视觉材料。它<br>专为 CGI 和动画工作室、广告公司、电视公司和建筑设计公司而开发。也可以说它是一款Elasticsearch监控工具。</p><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/lmenezes/cerebro/releases/download/v0.9.3/cerebro-0.9.3.tgz</span><br><span class="line">tar -xf cerebro-0.9.3.tgz </span><br><span class="line"><span class="built_in">cd</span> cerebro-0.9.3 </span><br><span class="line">./bin/cerebro   <span class="comment"># 启动</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>cerebro 需要 java 才能运行，没有java环境的化，可以执行 <code>sudo apt install openjdk-11-jdk</code> 。 Java 11 是 Java 的一个长期支持版本（LTS）。它同时也是 Ubuntu 20.04的默认 Java 开发和运行环境。</p></blockquote><p>访问 <code>http://127.0.0.1:9000</code> 浏览器打开。</p><p><img src="https://img1.kiosk007.top/static/images/elk/cerebro.png "></p><p>点击左上方 node，可查看节点情况。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>下载测试样本 movielens<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://files.grouplens.org/datasets/movielens/ml-20m.zip</span><br><span class="line">unzip ml-20m.zip</span><br></pre></td></tr></table></figure><br>开始配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">&quot;/home/work/logs/ml-20m/movies.csv&quot;</span></span><br><span class="line">    start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">    sincedb_path =&gt; <span class="string">&quot;/dev/null&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  csv &#123;</span><br><span class="line">    separator =&gt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    columns =&gt; [<span class="string">&quot;id&quot;</span>,<span class="string">&quot;content&quot;</span>,<span class="string">&quot;genre&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123; <span class="string">&quot;genre&quot;</span> =&gt; <span class="string">&quot;|&quot;</span> &#125;</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;path&quot;</span>, <span class="string">&quot;host&quot;</span>,<span class="string">&quot;@timestamp&quot;</span>,<span class="string">&quot;message&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line"></span><br><span class="line">    split =&gt; [<span class="string">&quot;content&quot;</span>, <span class="string">&quot;(&quot;</span>]</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;title&quot;</span> =&gt; <span class="string">&quot;%&#123;[content][0]&#125;&quot;</span>&#125;</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;year&quot;</span> =&gt; <span class="string">&quot;%&#123;[content][1]&#125;&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    convert =&gt; &#123;</span><br><span class="line">      <span class="string">&quot;year&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    strip =&gt; [<span class="string">&quot;title&quot;</span>]</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;path&quot;</span>, <span class="string">&quot;host&quot;</span>,<span class="string">&quot;@timestamp&quot;</span>,<span class="string">&quot;message&quot;</span>,<span class="string">&quot;content&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch &#123;</span><br><span class="line">     hosts =&gt; <span class="string">&quot;http://localhost:9200&quot;</span></span><br><span class="line">     index =&gt; <span class="string">&quot;movies&quot;</span></span><br><span class="line">     document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>导入测试数据到ES中<br><code>logstash -f log.conf</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。&lt;/p&gt;
&lt;p&gt;“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。&lt;/p&gt;
&lt;p&gt;引用官网的一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Worker Pool in Golang</title>
    <link href="http://kiosk007.top/2021/03/21/Worker-Pool-in-Golang/"/>
    <id>http://kiosk007.top/2021/03/21/Worker-Pool-in-Golang/</id>
    <published>2021-03-21T07:41:37.000Z</published>
    <updated>2021-03-21T07:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。但是，如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响</p><a id="more"></a><h1 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h1><p>Pool 的出现，可以避免反复的创建一些对象，比如 TCP链接、数据库链接等等，这些对象创建都比较耗时，如果将创建好的对象放入到池子中，需要的时候取，不需要的时候归还池子，将是一个非常不错的实现方式。</p><p>通过创建一个 Worker Pool 来减少 goroutine 的使用。比如，我们实现一个 TCP 服务器，如果每一个连接都要由一个独立的 goroutine 去处理的话，在大量连接的情况下，就会创建大量的 goroutine，这个时候，我们就可以创建一个固定数量的 goroutine（Worker），由这一组 Worker 去处理连接，比如 fasthttp 中的<a href="https://github.com/valyala/fasthttp/blob/9f11af296864153ee45341d3f2fe0f5178fd6210/workerpool.go#L16">Worker Pool</a>。</p><ul><li><p>著名的TCP连接池实现：fatih 开发的 <a href="https://github.com/fatih/pool">fatih/pool</a>, 虽然已经归档，但是这是由于这个项目已经足够稳定。</p></li><li><p>数据库连接池实现：database/sql 可以参考这篇分析 <a href="https://blog.csdn.net/qq_39384184/article/details/103954821">Golang 侧数据库连接池原理和参数调优</a>，同样使用方式直接参考 <a href="https://www.jianshu.com/p/2d58243fae22">这篇文章</a></p></li></ul><p><strong>一句话总结：保存和复用临时对象，减少内存分配，降低 GC 压力。</strong></p><p>举例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int32</span></span><br><span class="line">Remark [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf, _ = json.Marshal(Student&#123;Name: <span class="string">&quot;Geektutu&quot;</span>, Age: <span class="number">25</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarsh</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := &amp;Student&#123;&#125;</span><br><span class="line">json.Unmarshal(buf, stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>json 的反序列化在文本解析和网络通信过程中非常常见，当程序并发度非常高的情况下，短时间内需要创建大量的临时对象。而这些对象是都是分配在堆上的，会给 GC 造成很大压力，严重影响程序的性能。</p><p><strong>声明对象池</strong></p><p>只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> studentPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(Student) </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Get &amp;&amp; Put </strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu := studentPool.Get().(*Student)</span><br><span class="line">json.Unmarshal(buf, stu)</span><br><span class="line">studentPool.Put(stu)</span><br></pre></td></tr></table></figure></p><ul><li>Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。</li><li>Put() 则是在对象使用完毕后，返回对象池。</li></ul><h1 id="gammazero-workerpool"><a href="#gammazero-workerpool" class="headerlink" title="gammazero/workerpool"></a>gammazero/workerpool</h1><p><a href="https://pkg.go.dev/github.com/gammazero/workerpool">gammazero/workerpool</a> gammazero/workerpool 可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</p><p>下面做一些介绍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gammazero/workerpool&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wp := workerpool.New(<span class="number">2</span>)</span><br><span class="line">requests := []<span class="keyword">string</span>&#123;<span class="string">&quot;alpha&quot;</span>, <span class="string">&quot;beta&quot;</span>, <span class="string">&quot;gamma&quot;</span>, <span class="string">&quot;delta&quot;</span>, <span class="string">&quot;epsilon&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> requests &#123;</span><br><span class="line">r := r</span><br><span class="line">wp.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Handling request:&quot;</span>, r)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wp.StopWait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用提示</strong></li></ul><p>排队的任务数没有上限，只有系统资源的限制。如果入站任务的数量太多，以至于无法排队等待处理那么解决方案就超出了workerpool的处理范围，应该通过在多个系统上分配负载来解决</p><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h2 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h2><p>用户通过 <code>Submit(task func())</code> 方法提交一个 task 到 task 队列中。<br>task 函数默认没有返回值，如果想要有返回值，可以用管道将task 的返回值传到管道中。</p><p>提交的 task 会立即开启一个可用的worker或者新创建一个worker。如果没有可用的worker或者worker数已经达到最大，task会被放入到 task 等待队列中。当worker空闲时会从task 等待队列中取出task。</p><p>一个Worker长时间闲置时可以删除并释放资源。</p><p>这个函数非常简单，就是将收到的待执行任务放入到 task等待队列中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">Submit</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> task != <span class="literal">nil</span> &#123;</span><br><span class="line">p.taskQueue &lt;- task</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有一个变种, 支持同步等待结果<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">SubmitWait</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> task == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">doneChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">p.taskQueue &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">task()</span><br><span class="line"><span class="built_in">close</span>(doneChan)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-doneChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="New"><a href="#New" class="headerlink" title="New"></a>New</h2><p><code>New()</code> 函数创建了一个 worker goroutines pool 。 Max 指定了最大的worker数量，也就是最大并发的执行数，当没有新到来的 task 时，worker会逐渐减少至0.这里注意 taskQueue 是一个只有1个buffer的缓冲，task等待队列是 <code>waitingQueue()</code> 。dispatch 里实现派发任务的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxWorkers <span class="keyword">int</span>)</span> *<span class="title">WorkerPool</span></span> &#123;</span><br><span class="line"><span class="comment">// There must be at least one worker.</span></span><br><span class="line"><span class="keyword">if</span> maxWorkers &lt; <span class="number">1</span> &#123;</span><br><span class="line">maxWorkers = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool := &amp;WorkerPool&#123;</span><br><span class="line">maxWorkers:  maxWorkers,</span><br><span class="line">taskQueue:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>, 1),</span></span><br><span class="line">workerQueue: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>),</span></span><br><span class="line">stopSignal:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">stoppedChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the task dispatcher.</span></span><br><span class="line"><span class="keyword">go</span> pool.dispatch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch 任务派发</strong> 通过设置 idleTimer ，超过这个时间还没有task，就会杀掉一个worker。这个函数刚开始判断等待队列是否为 0，如果不为0，说明任务已经积压，需要将新的task传到等待队列中 ，<code>processWaitingQueue</code>函数内将 task 传给 waitQueue，并在workerQueue有buffer时将任务传给 worker Queue。</p><p>如果 waitQueue 不存在（长度为0），说明还不存在任务排队情况，会将task传给 workerQueue（如果workerQueue能把task塞进去的话），如果塞不进去<br>就创建一个新worker，要么worker刚好又不够了（达到最大worker数量），任务扔进 waitQueue。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispatch sends the next queued task to an available worker.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(p.stoppedChan)</span><br><span class="line">timeout := time.NewTimer(idleTimeout)</span><br><span class="line"><span class="keyword">var</span> workerCount <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> idle <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.waitingQueue.Len() != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !p.processWaitingQueue() &#123;</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.taskQueue:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Got a task to do.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.workerQueue &lt;- task:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Create a new worker, if not at max.</span></span><br><span class="line"><span class="keyword">if</span> workerCount &lt; p.maxWorkers &#123;</span><br><span class="line"><span class="keyword">go</span> startWorker(task, p.workerQueue)</span><br><span class="line">workerCount++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Enqueue task to be executed by next available worker.</span></span><br><span class="line">p.waitingQueue.PushBack(task)</span><br><span class="line">atomic.StoreInt32(&amp;p.waiting, <span class="keyword">int32</span>(p.waitingQueue.Len()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">idle = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line"><span class="comment">// Timed out waiting for work to arrive.  Kill a ready worker if</span></span><br><span class="line"><span class="comment">// pool has been idle for a whole timeout.</span></span><br><span class="line"><span class="keyword">if</span> idle &amp;&amp; workerCount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.killIdleWorker() &#123;</span><br><span class="line">workerCount--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">idle = <span class="literal">true</span></span><br><span class="line">timeout.Reset(idleTimeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If instructed to wait, then run tasks that are already queued.</span></span><br><span class="line"><span class="keyword">if</span> p.wait &#123;</span><br><span class="line">p.runQueuedTasks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop all remaining workers as they become ready.</span></span><br><span class="line"><span class="keyword">for</span> workerCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">p.workerQueue &lt;- <span class="literal">nil</span></span><br><span class="line">workerCount--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>waitingQueue</code> 的目的是讲一个新的task放入到等待 task 队列。或者等待工人队列中有可用的工人时将 task 等待队列中取出 task 交给 worker 队列。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">processWaitingQueue</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.taskQueue:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">p.waitingQueue.PushBack(task)</span><br><span class="line"><span class="keyword">case</span> p.workerQueue &lt;- p.waitingQueue.Front().(<span class="function"><span class="keyword">func</span><span class="params">()</span>):</span></span><br><span class="line"><span class="comment">// A worker was ready, so gave task to worker.</span></span><br><span class="line">p.waitingQueue.PopFront()</span><br><span class="line">&#125;</span><br><span class="line">atomic.StoreInt32(&amp;p.waiting, <span class="keyword">int32</span>(p.waitingQueue.Len()))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。但是，如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP/3</title>
    <link href="http://kiosk007.top/2021/02/21/HTTP3/"/>
    <id>http://kiosk007.top/2021/02/21/HTTP3/</id>
    <published>2021-02-21T03:08:54.000Z</published>
    <updated>2021-02-21T03:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不得不说国外的很多文章写的都十分优秀，将技术的历史背景和细节都讲得十分出色。下面是转自 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> ，这里有很多对外国优秀文章的翻译。关于<strong>HTTP/3</strong>相关的知识。下面做一些简短的记录。</p><a id="more"></a><blockquote><ul><li>原文地址：HTTP/3: From root to tip</li><li>原文作者：Lucas Pardue</li><li>译文出自：掘金翻译计划</li><li>译者：Starrier</li></ul></blockquote><h1 id="HTTP-3-起源"><a href="#HTTP-3-起源" class="headerlink" title="HTTP/3 起源"></a>HTTP/3 起源</h1><p>HTTP/3 是 QUIC 传输层的 HTTP 应用程序映射。该名称在最近（2018 年 10 月底）草案的第 17 个版本中被正式提出（<a href="https://tools.ietf.org/html/draft-ietf-quic-http-17">draft-ietf-quic-http-17</a>），在 11 月举行的 IETF 103 会议中进行了讨论并形成了初步的共识。HTTP/3 以前被称为 QUIC（以前被称为 HTTP/2）。在此之前，我们已经有了 gQUIC，而在更早之前，我们还有 SPDY。事实是，HTTP/3 只是一种适用于 IETF QUIC 的新 HTTP 语法 —— 基于 UDP 的多路复用和安全传输。</p><p>这篇文章将讲述 HTTP/3 的发展历史。详细发展图见 <a href="https://blog.cloudflare.com/content/images/2019/01/web_timeline_large1.svg">Cloudflare Secure Web Timeline</a></p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/gquic-stack.png" style="height:400px"></p><p>HTTP/3 分层模型（蛋糕模型）</p><h2 id="HTTP-演进"><a href="#HTTP-演进" class="headerlink" title="HTTP 演进"></a>HTTP 演进</h2><p>在我们关注 HTTP 之前，值得回忆的是两个共享 QUIC 的名称。就像我们之前解释得那样，gQUIC 通常是指 Google QUIC（协议起源），QUIC 通常用于表示与 gQUIC 不同的 IETF 标准（正在开发的版本）。</p><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP/1"></a><strong>HTTP/1</strong></h3><p>HTTP/1.1 是非常成功的协议，时间线显示 1999 年以后 IETF 并不活跃。然而，事实是，多年的积极使用，为 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 研究潜在问题提供了实战经验，但这也导致了一些交互操作的问题。此外，RFC（像 2817 和 2818）还对该协议进行了扩展。2007 年决定启动一项改进 HTTP 协议规范的新活动 —— HTTPbis（”bis” 源自拉丁语，意为“二”、“两次”或“重复”），它还采用了新的工作组形式。最初的<a href="https://tools.ietf.org/wg/httpbis/charters?item=charter-httpbis-2007-10-23.txt">章程</a>详细描述了尝试解决的问题。</p><p>简而言之，HTTPbis 决定重构 RFC 2616。它将纳入勘误修订，合并在此期间发布的其他规范的一些内容。文件将被分为几个部分，这导致 2017 年 12 月发布了 6 个 I-D：</p><ol><li>draft-ietf-httpbis-p1-messaging</li><li>draft-ietf-httpbis-p2-semantics</li><li>draft-ietf-httpbis-p4-conditional</li><li>draft-ietf-httpbis-p5-range</li><li>draft-ietf-httpbis-p6-cache</li><li>draft-ietf-httpbis-p7-auth</li></ol><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/http1_refactor.png" style="height:400px"></p><p>图表显示了这项工作是如何在长达 7 年的草案过程中取得进展的，在最终被标准化之前，已经发布了 27 份草案。2014 年 6 月，发布了 RFC 723x 系列（x 范围在 0-5）。HTTPbis 工作组的主席以 “<a href="https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead">RFC2616 is Dead</a>“ 来庆祝这一成果。如果它不够清楚，这些新文档就会弃用旧的 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>。</p><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a><strong>SPDY</strong></h3><p>尽管 IETF 的 RFC 723x 系列的工作繁忙，但是技术的进步并未停止。人们继续加强、扩展和测试因特网上的 HTTP。而 Google 已率先开始尝试名为 SPDY（发音同 Speedy）的技术。该协议宣称可以提高 Web 浏览性能，一个使用 HTTP 原则的用例。2009 年底，SPDY v1 发布，2010 年 SPDY v2 紧随其后。</p><p>Google 对 SPDY 实验表明，改变 HTTP 语法是有希望的，维持现有 HTTP 语义是有意义的。比如，保留 URL 的使用格式 —— <code>https://</code>，可以避免许多可能影响采用的问题。看到一些积极的结果后，IETF 决定考虑 HTTP/2.0。2012 年 3 月 IETF 83 期间举行的 HTTPbis 会议的 slides显示了请求、目标和成功标准。它还明确指出 “HTTP/2.0 与 HTTP/1.x 连线格式不兼容”。</p><h3 id="gQUIC-横空出世"><a href="#gQUIC-横空出世" class="headerlink" title="gQUIC 横空出世"></a><strong>gQUIC 横空出世</strong></h3><p>2012 - 2015 之间，Google 继续进行试验，他们发布了 SPDY v3 和 v3.1。他们还开始研究 gQUIC(当时的发音类似于 quick），在 2012 年年初，发布了初始的公共规范。gQUIC 的早期版本使用 SPDY v3 形式的 HTTP 语法。这个选择是有意义的，因为 HTTP/2 尚未完成。SPDY 二进制语法被打包到可以用 UDP 数据报发送数据的 QUIC 包中。</p><p>gQUIC 使用巧妙的设计来实现性能优化。其中一个是破坏应用程序与传输层之间清晰的分层。这也意味着 gQUIC 只支持 HTTP。因此，gQUIC 最后被称为 “QUIC”。它是 HTTP 下一个候选版本的同义词。QUIC 从过去的几年到现在，一直在持续更新，QUIC 也被人们理解为是初始 HTTP 的变体。不幸的是，这正是我们在讨论协议时，经常出现混乱的原因。</p><p>gQUIC 继续在实验中摸索，最后选择了更接近 HTTP/2 的语法。也正因为如此，它才被称为 “HTTP/2 over QUIC”。但因为技术上的限制，所有存在一些非常微妙的差别。一个示例是，HTTP 头是如何序列化并交换的。这是一个细微的差别，但实际上，这意味着 HTTP/2 式 gQUIC 与 IETF’s HTTP/2 并不兼容。</p><p class="div-border yellow">17年-20年市面上大多商用的QUIC均是gQuic，客户端一般为cronet（chromium的网络库），服务端接入层的Nginx一般经过chromium 的封装 </p><p>最后，同样重要的是，我们总是需要考虑互联网协议的安全方面。gQUIC 选择不使用 TLS 来提供安全性。转而使用 Google 开发的另一种称为 QUIC Crypto 的方法。其中一个有趣的方面是有一种加速安全握手的新方法。以前与服务器建立了安全会话的客户端可以重用信息来进行“零延迟往返握手”或 0-RTT 握手。0-RTT 后来被纳入 TLS 1.3。</p><h3 id="什么是HTTP-3"><a href="#什么是HTTP-3" class="headerlink" title="什么是HTTP/3"></a>什么是HTTP/3</h3><p>当然，现在可以说什么是HTTP/3 了，gQUIC 并非与众不同。在2015 年 6 月的 draft-tsvwg-quic-protocol-00 中，写有 “QUIC：基于 UDP 的安全可靠的 HTTP/2 传输” 已经提交。请记住我之前提过的，几乎都是 HTTP/2 的语法。</p><p>Google <a href="https://groups.google.com/a/chromium.org/forum/#!topic/proto-quic/otGKB4ytAyc">宣布</a>将在布拉格举行一次 Bar BoF IETF 93 会议。如有疑问，请参阅 <a href="https://tools.ietf.org/html/rfc6771">RFC 6771</a>。提示：BoF 是物以类聚（Birds of a Feather）的缩写。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_adoption.png" style="height:400px"></p><p>总之，与 IETF 的合作结果是 QUIC 在传输层提供了许多优势，而且它应该与 HTTP 分离。应该重新引入层与层之间清楚的隔离。此外，还有返回基于 TLS 握手的优先级</p><p>大约是一年后，在 2016 年，一组新的 I-D 集合被提交：</p><ul><li><a href="https://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-00">draft-hamilton-quic-transport-protocol-00</a></li><li><a href="https://tools.ietf.org/html/draft-thomson-quic-tls-00">draft-thomson-quic-tls-00</a></li><li><a href="https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00">draft-iyengar-quic-loss-recovery-00</a></li><li><a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a></li></ul><p>这里是关于 HTTP 和 QUIC 的另一个困惑的来源。<a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a> 题为 “HTTP/2 使用 QUIC 传输协议的语义”，对于自己的描述是 “HTTP/2 式 QUIC 的另一种语义映射”。但这个解释并不正确。HTTP/2 在维护语义的同时，改变了语法。而且，我很早之前就说过了，”HTTP/2 式 gQUIC” 从未对语法进行确切的描述，记住这个概念。</p><p>2016 年在柏林举行 IETF 96 会议决定了有数百人参加了这次会议。会议结束时，达成了一致的共识：<strong>QUIC 将被 IETF 采用并标准化。</strong></p><p class="div-border green">之后的QUIC必将全面IETF化</p><p>将 HTTP 映射到 QUIC 的第一个 IETF QUIC I-D —— <a href="https://tools.ietf.org/html/draft-ietf-quic-http-00">draft-ietf-quic-http-00</a>，采用了 Ronseal 方法来简化命名 —— “HTTP over QUIC”。不幸的是，它并没有达到预期效果，整个内容中都残留有 HTTP/2 术语的实例。Mike Bishop —— I-D 的新编辑，发现并修复了 HTTP/2 的错误名称。在 01 草案中，将描述修改为 “a mapping of HTTP semantics over QUIC”。</p><p>随着时间和版本的推进，”HTTP/2” 的使用逐渐减少，实例部分仅仅是对 <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> 部分的引用。从 2018 年 10 月开始向前回退两年的时间开始计算，I-D 如今已经是第 16 版本。虽然 HTTP over QUIC 与 HTTP/2 有相似内容，但始终是独立的（非向后兼容的 HTTP 语法）。然而，对那些不密切关注 IETF 发展的人来说（人数众多），他们并不能从名称中发现一些细微的差异。标准化的重点之一是帮助通信和互操作性。但像命名这样的简单事件，才是导致社区相对混乱的主要原因。<br>回顾 2012 年的内容，”HTTP/2.0 意味着 wire 格式与 HTTP/1.x 格式不兼容”。IETF 遵循现有线索。IETF 103 是经过深思熟虑才最终达成一致的，即：”HTTP over QUIC” 命名为 HTTP/3。互联网正在促使世界变得更加美好，我们可以继续进行更加重要的的探讨。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>概况来说就是：HTTP/3 只是一种适用于 IETF QUIC 的新 HTTP 语法 —— 一种基于 UDP 多路复用的安全传输层。仍有许多有趣的领域需要深入探索。</p><blockquote><p>参考文章</p><ul><li>：<a href="https://juejin.cn/post/6914561963393548295#heading-11">揭秘QUIC的性能与安全</a></li><li>：<a href="https://juejin.cn/post/6908522467107536903#heading-3">Google、Facebook等均开始支持的HTTP3到底是个什么鬼？</a></li></ul></blockquote><h1 id="QUIC的实现"><a href="#QUIC的实现" class="headerlink" title="QUIC的实现"></a>QUIC的实现</h1><h2 id="QUIC-握手"><a href="#QUIC-握手" class="headerlink" title="QUIC 握手"></a>QUIC 握手</h2><p>在2016年11月国际互联网工程任务组(IETF)召开的第一次QUIC工作组会议，受到了业界的广泛关注。这也意味着QUIC开始了它的标准化过程，成为新一代传输层协议，形成了最新的iQUIC。<strong>IETF在QUIC的加密协议上就放弃了google的加密协议使用了标准的TLS1.3。</strong></p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_struct.png"></p><p><strong>QUIC 握手</strong></p><p>QUIC 连接的建立整体流程大致为：QUIC在握手过程中使用Diffie-Hellman算法协商初始密钥，初始密钥依赖于服务器存储的一组配置参数，该参数会周期性的更新。初始密钥协商成功后，服务器会提供一个临时随机数，双方根据这个数再生成会话密钥。客户端和服务器会使用新生的的密钥进行数据加解密。</p><p>以上过程主要分为两个步骤：<span class="inline-tag grey">初始握手（Initial handshake）</span>、<span class="inline-tag grey">最终 与重复 握手（Final (and repeat) handshake）</span> ，分别介绍下这两个过程。</p><h3 id="初始握手（Initial-handshake）"><a href="#初始握手（Initial-handshake）" class="headerlink" title="初始握手（Initial handshake）"></a>初始握手（Initial handshake）</h3><p>在连接开始建立时，客户端会向服务端发送一个打招呼信息，（inchoate client hello (CHLO)），因为是初次建立，所以，服务端会返回一个拒绝消息（REJ），表明握手未建立或者密钥已过期。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake1.jpeg"></p><p>但是，这个拒绝消息中还会包含更多的信息（配置参数），主要有：</p><ol><li>Server Config：一个服务器配置，包括服务器端的Diffie-Hellman算法的长期公钥（long term Diffie-Hellman public value）</li><li>Certificate Chain：用来对服务器进行认证的信任链</li><li>Signature of the Server Config：将Server Config使用信任链的叶子证书的public key加密后的签名</li><li>Source-Address Token：一个经过身份验证的加密块，包含客户端公开可见的IP地址和服务器的时间戳。</li></ol><p>在客户端接收到拒绝消息（REJ）之后，客户端会进行数据解析，签名验证等操作，之后会将必要的配置缓存下来。<br>同时，在接收到REJ之后，客户端会为这次连接随机产生一对自己的短期密钥（ephemeral Diffie-Hellman private value） 和 短期公钥（ephemeral Diffie-Hellman public value）。</p><p>之后，客户端会将自己刚刚产生的短期公钥打包一个Complete CHLO的消息包中，发送给服务端。这个请求的目的是将自己的短期密钥传输给服务端，方便做前向保密。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake2.jpeg"></p><p>在发送了Complete CHLO消息给到服务器之后，为了减少RTT，客户端并不会等到服务器的响应，而是立刻会进行数据传输。</p><p>为了保证数据的安全性，客户端会自己的短期密钥和服务器返回的长期公钥进行运算，得到一个初始密钥（initial keys）。接下来他接收到客户端使用初始密钥加密的数据之后，就可以使用这个初识密钥进行解密了，并且可以将自己的响应再通过这个初始密钥进行加密后返回给客户端。</p><h3 id="最终（与重复）握手"><a href="#最终（与重复）握手" class="headerlink" title="最终（与重复）握手"></a>最终（与重复）握手</h3><p>那么，之后的数据传输就可以使用初始密钥（initial keys）加密了吗？<br>其实并不完全是，因为初始密钥毕竟是基于服务器的长期公钥产生的，而在公钥失效前，几乎多有的连接使用的都是同一把公钥，所以，这其实存在着一定的危险性。<br>所以，为了达到前向保密 (Forward Secrecy) 的安全性，客户端和服务端需要使用彼此的短期公钥和自己的短期密钥来进行运算。</p><p>那么现在问题是，客户端的短期密钥已经发送给服务端，而服务端只把自己的长期密钥给了客户端，并没有给到自己的短期密钥。<br>所以，服务端在收到Complete CHLO之后，会给到服务器一个server hello(SHLO)消息，这个消息会使用初始密钥（initial keys）进行加密。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake4.jpeg"></p><p>这个CHLO消息包中，会包含一个服务端重新生成的短期公钥。<br>这样客户端和服务端就都有了对方的短期公钥（ephemeral Diffie-Hellman public value）。<br>这样，客户端和服务端都可以基于自己的短期密钥和对方的短期公钥做运算，产生一个仅限于本次连接使用的前向保密密钥 (Forward-Secure Key)，后续的请求发送，都基于这个密钥进行加解密就可以了。<br>这样，双方就完成了最终的密钥交换、连接的握手并且建立了QUIC连接。<br>当下一次要重新创建连接的时候，客户端会从缓存中取出自己之前缓存下来的服务器的长期公钥，并重新创建一个短期密钥，重新生成一个初识密钥，再使用这个初始密钥对想要传输的数据进行加密，向服务器发送一个Complete CHLO 请求即可。这样就达到了0 RTT的数据传输。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake5.jpeg"></p><p>所以，如果是有缓存的长期公钥，那么数据传输就会直接进行，准备时间是0 RTT</p><p><strong>以上，通过使用Diffie-Hellman算法协商密钥，并且对加密和握手过程进行合并，大大减小连接过程的RTT ，使得基于QUIC的连接建立可以少到1 RTT甚至0 RTT。</strong></p><p>下面是建立握手的完整过程</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake6.jpeg"></p><p><strong>小结</strong>：</p><p>QUIC的通讯过程在初次没有建立过连接时使用1-RTT的握手机制，同时保证连接的建立和达到安全的保障。以下是QUIC的1-RTT的握手过程：</p><ol><li>Server端会持有0-RTT公私钥对，并且生成SCFG（服务端的配置信息对象），把公钥放入SCFG中；</li><li>客户端初次请求时，需要向服务端获取0-RTT公钥，这个需要消耗一个RTT，这也QUIC的1-RTT的所在；</li><li>客户端在收到0-RTT公钥以后会缓存起来，同时生成自己的临时公私钥对，经过前面的一个RTT后客户端把自己的临时私钥与服务端发过来的0-RTT的公钥根据DH算法生成一个加密密钥K1，同时使用K1加密数据同时附送自己的临时公钥一起发送服务端，此时已有用户数据发送；</li><li>在服务端收到用户使用K1加密的用户数据和客户端发来的临时公钥以后，会做如下几件事：<ul><li>使用0-RTT私钥与客户端发来的临时公钥通过DH算法生成K1解密用户数据并递交到应用；</li><li>生成服务端临时公私钥对，使用临时公私钥对的私钥，与客户端发来的客户端临时公钥，生成K2加密服务端要传输的数据</li><li>把服务端的临时公钥和使用K2加密的应用数据发送到客户端</li></ul></li><li>客户端收到服务端发送的服务端临时公钥和使用K2加密的应用数据后会再次使用DH算法把服务端的临时公钥和客户端原来的临时私钥重新生成K2解密数据，并且从此以后使用K2进行数据层的加解密</li></ol><ul><li><strong>1RTT握手</strong></li></ul><p>0-RTT是QUIC一个很关键的属性，能够在连接的第一个数据报文就可以携带用户数据。但是我们也可以看到如果客户端和服务端从来没有通讯过，那么是不存在0-RTT的，需要一个完成的RTT之后才能承载用户数据。<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_1rtt.png" style="height:400px"></p><ul><li><strong>0RTT握手</strong></li></ul><p>这个流程是gQUIC的流程，iQUIC由于使用的是TLS1.3，握手阶段报文的细节会有些不一样，例如首个请求的是证书、PSK等信息。在0-RTT阶段使用的是session复用的ticket方式。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_0rtt.png" style="height:400px"></p><p class="div-border yellow">gQUIC使用的是gQUIC Crypto，并不是TLS1.3</p><ul><li><strong>安全考虑</strong></li></ul><p>UDP的安全性存在的几个关键的地方，源地址欺骗攻击，UDP放大攻击等。在QUIC中有设计了源地址TOKEN（STK）验证的安全机制来解决源地址的欺骗攻击，在通讯过程中服务器要求确认客户端的源地址TOKEN，这个源地址TOKEN根据数据包的源地址和服务器的时间戳等因子生成STK，随后和响应数据包一起发送到客户端，而在后续的数据传输过程中客户端需要透传这个STK到服务端，从而服务端可以进行校验。当服务端发现连接对应的源地址发送变化时会主动发送RETRY报文进行服务端主动源地址验证。客户端也可以主动发起源地址验证信息。源地址验证可以保护两类攻击问题，源地址欺骗攻击和UDP放大攻击。</p><ol><li><p>连接建立时，为了验证客户端的地址是否是攻击者伪造的，服务端会生成一个令牌（token）并通过重试包（Retry packet）响应给客户端。客户端需要在后续的初始包（Initial packet）带上这个令牌，以便服务端进行地址验证。</p></li><li><p>服务端可以在当前连接中通过 NEW_TOKEN 帧预先发布令牌，以便客户端在后续的新连接使用，这是 QUIC 实现 0-RTT 很重要的一个功能。</p></li><li><p>当我们的网络路径变化时（比如从蜂窝网络切换到 WIFI），QUIC 提供了连接迁移（connection migration）的功能来避免连接中断。QUIC 通过路径验证（Path Validation）验证网络新地址的可达性（reachability），防止在连接迁移中的地址是攻击者伪造的。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;不得不说国外的很多文章写的都十分优秀，将技术的历史背景和细节都讲得十分出色。下面是转自 &lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt; ，这里有很多对外国优秀文章的翻译。关于&lt;strong&gt;HTTP/3&lt;/strong&gt;相关的知识。下面做一些简短的记录。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GoLang 编程模式 -- 基本概念</title>
    <link href="http://kiosk007.top/2021/01/30/GoLang-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://kiosk007.top/2021/01/30/GoLang-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-30T03:12:07.000Z</published>
    <updated>2021-01-30T03:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为了巩固一下 Go 的基础，主要涉及 Slice、Interface、函数式编程等。</p><a id="more"></a><p>也是读了<a href="https://coolshell.cn/" style>左耳朵耗子</a> 叔的 <a href="https://coolshell.cn/articles/21128.html">Go编程模式</a> 的系列文章发现有的细节确实之前也有遗漏，刚好也趁机复习巩固一下。</p><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">//指向存放数据的数组指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span>            <span class="comment">//长度有多大</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span>            <span class="comment">//容量有多大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Slicce标头的<strong>array</strong>字段是底层真正指向数组的指针。</p><p><img src="https://i0.wp.com/golangbyexample.com/wp-content/uploads/2020/05/slice.jpg?w=391&amp;ssl=1" alt></p><p>Golang 的切片是子集。切片可以是数组、列表或字符串的子集。可以从一个字符串中提取多个片段，每个片段作为一个新变量。</p><h3 id="与数组的不同："><a href="#与数组的不同：" class="headerlink" title="与数组的不同："></a><strong>与数组的不同</strong>：</h3><p>数组在声明为一定大小后，不能调整大小，而切片可以调整大小。切片是引用类型，而数组是值类型。</p><h3 id="在Golang中创建切片"><a href="#在Golang中创建切片" class="headerlink" title="在Golang中创建切片"></a><strong>在Golang中创建切片</strong></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> stringSlice = []<span class="keyword">string</span>&#123;<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;slice&quot;</span>&#125;</span><br><span class="line">fmt.Println(stringSlice)  <span class="comment">// prints [This is a string slice]</span></span><br><span class="line"><span class="comment">// res:  [This is a string slice]</span></span><br><span class="line"></span><br><span class="line">myset := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* take slice */</span></span><br><span class="line">s1 := myset[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">// res:  [0 1 2 3]</span></span><br><span class="line"></span><br><span class="line">mystring := <span class="string">&quot;Go programming&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* take slice */</span></span><br><span class="line">s2 := mystring[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s2)</span><br><span class="line"><span class="comment">// res:  Go</span></span><br><span class="line"></span><br><span class="line">numbers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;numbers=%v\n&quot;</span>, numbers)</span><br><span class="line">fmt.Printf(<span class="string">&quot;length=%d\n&quot;</span>, <span class="built_in">len</span>(numbers))</span><br><span class="line">fmt.Printf(<span class="string">&quot;capacity=%d\n&quot;</span>, <span class="built_in">cap</span>(numbers))</span><br><span class="line"><span class="comment">// res:</span></span><br><span class="line"><span class="comment">//numbers=[0 0 0]</span></span><br><span class="line"><span class="comment">//length=3</span></span><br><span class="line"><span class="comment">//capacity=5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片引用"><a href="#切片引用" class="headerlink" title="切片引用"></a><strong>切片引用</strong></h3><p>切片是引用类型，那么就意味着数组指针的问题——数据会发生共享！下面我们来看看 Slice 的一些操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">foo[<span class="number">3</span>] = <span class="number">42</span></span><br><span class="line">foo[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">bar  := foo[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">bar[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 foo</span></span><br><span class="line"><span class="comment">// 打印 bar</span></span><br></pre></td></tr></table></figure><ol><li>首先，创建一个 foo 的 Slice，其中的长度和容量都是 5；</li><li>然后，开始对 foo 所指向的数组中的索引为 3 和 4 的元素进行赋值；</li><li>最后，对 foo 做切片后赋值给 bar，再修改 bar[1]。</li></ol><p>最终的foo和bar的结果是什么呢? 是不是和想象的不太一样，这是因为切片操作的底层数组是同一个数组。foo 和 bar 的内存是共享的，所以，foo 和 bar 对数组内容的修改都会影响到对方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(foo)  &#x2F;&#x2F; res: [0 0 99 42 100]</span><br><span class="line">fmt.Println(bar)  &#x2F;&#x2F; res: [0 99 42]</span><br></pre></td></tr></table></figure></p><p>再来看一个 <code>append</code> 的例子。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">16</span>]</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印a</span></span><br><span class="line"><span class="comment">// 打印b</span></span><br></pre></td></tr></table></figure><br>在这段代码中，把 <code>a[1:16]</code> 的切片赋给 b ，此时，a 和 b 的内存空间是共享的，然后，对 a 做了一个 append()的操作，这个操作会让 a 重新分配内存，这就会导致 a 和 b 不再共享，如下图所示：<br><img src="https://static001.geekbang.org/resource/image/9a/13/9a29d71d309616f6092f6bea23f30013.png" style="max-width: 70%;border-radius: 6px"></p><p>这时 a 和 b 的值是多少？append()操作让 a 的容量变成了 64，而长度是 33。这里你需要重点注意一下，<strong>append()这个函数在 cap 不够用的时候，就会重新分配内存以扩大容量，如果够用，就不会重新分配内存了！</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(a)  &#x2F;&#x2F; res: [0 0 42 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]</span><br><span class="line">fmt.Println(b)  &#x2F;&#x2F; res: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>那既然这样相同的例子我们再来一遍，如果让a不要重新分配内存(比如初始化a的时候使用<code>a := make([]int, 33))</code>，那么b的结果就会变成 <code>[0 42 0 0 0 0 0 0 0 0 0 0 0 0 0]</code> <strong>注意</strong>：这时的b会因为<code>a[2]</code> 的变化而变化。</p><p>同样的例子如下，只要没有发生<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path := []<span class="keyword">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">sepIndex := bytes.IndexByte(path,<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dir1 := path[:sepIndex]</span><br><span class="line">dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir1),<span class="built_in">cap</span>(dir1)) <span class="comment">// prints: len: 4 cap: 14</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir2),<span class="built_in">cap</span>(dir2)) <span class="comment">// prints: len: 9 cap: 14</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">dir1 = <span class="built_in">append</span>(dir1,<span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; uffixBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子中，dir1 和 dir2 共享内存，虽然 dir1 有一个 append() 操作，但是因为 cap 足够，于是数据扩展到了dir2 的空间。下面是相关的图示（注意上图中 dir1 和 dir2 结构体中的 cap 和 len 的变化）：</p><p><img src="https://static001.geekbang.org/resource/image/17/aa/1727ca49dfe2e6a73627a52a899535aa.png" style="max-width: 70%;border-radius: 6px"></p><p>这里的 <code>dir1:=path[:sepIndex]</code> 没有触发重新分配内存，如果想要强行重新分配内存的话可以使用<code>dir1 := path[:sepIndex:sepIndex]</code> 最后一个参数叫“Limited Capacity”，于是，后续的 append() 操作会导致重新分配内存。</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface 接口是一个抽象概念，它支持Go中的<strong>多态</strong>。该接口的变量可以保存实现该类型的值。类型断言用于获取底层的具体值。接口也是给Go语言带来了无限扩展空间。其中 <code>io.Reader</code> 接口就是一个典型的例子，<strong>io.Reader</strong> 表示读取设备数据流的能力，可以从<a href="https://golang.cafe/blog/golang-reader-example.html">网络、文件、字符串</a>等等。先简单介绍下 <code>io.Reader</code> 接口 ，后面会介绍如何使用接口式编程的方式封装 Reader 。</p><h3 id="接口式编程"><a href="#接口式编程" class="headerlink" title="接口式编程"></a>接口式编程</h3><p><a href="https://golang.org/pkg/io/#Reader">io.Reader</a> interface 可以表示从实体中读取字节流。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即只要实现了 <code>Read(buf []byte) (n int, err error)</code> 方法便就是 <code>io.Reader</code> 接口。Read最多将 <code>len(buf)</code> 字节读入buf并返回读取的字节, 直到读到 <code>io.EOF</code> 时返回。标准库中实现了很多Reader的实现。并且很多应用程序都接受 <code>Reader</code> 作为输入。</p><ul><li><strong>直接从字节流中读取</strong></li></ul><p>这里分为 <code>Read</code>、 <code>io.ReadFull</code>、 <code>ioutil.ReadAll</code> 三种方法。每种方法都有一些区别。</p><ol><li>直接使用 Read 方法</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r := strings.NewReader(<span class="string">&quot;abcde&quot;</span>)</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(buf)</span><br><span class="line">fmt.Println(n, err, buf[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个字节流 <code>r</code>, 在循环从r中读取出数据。循环会执行3次，第一次读取4个字节，第二次读取1个字节，第三次读到 <code>io.EOF</code> 返回跳出循环。注意，Read方法读取时会清空 <code>buf</code> 里的数据，所以这里需要每次读完打印一下。再次读时，<code>buf</code> 里的数据会被重新覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 &lt;nil&gt; [97 98 99 100]</span><br><span class="line">1 &lt;nil&gt; [101]</span><br><span class="line">0 EOF []</span><br></pre></td></tr></table></figure><p>另外还可以使用 <code>io.ReadFull</code> 或者 <code>ioutil.ReadAll</code> 取读取字节流,<code>io.ReadFull</code>用法和<code>Read</code>差不多，<code>ioutil.ReadAll</code>不需要设置buf可直接返回buf。更多可参考：<a href="https://yourbasic.org/golang/io-reader-interface-explained/">How to use the io.Reader interface</a></p><ul><li><strong>利用接口特性</strong></li></ul><p>下面的代码是一个实时统计标准输入字符个数的代码。用户每次按下回车都可以看到当前输入的字符以及历史上已经输入的字符的个数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountNumber</span><span class="params">(input <span class="keyword">chan</span> []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> input &#123;</span><br><span class="line">count += <span class="built_in">len</span>(data)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> bytes := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>)</span><br><span class="line"> fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line"> <span class="keyword">go</span> CountNumber(bytes)</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，但是似乎和我们要讲到的接口式编程没什么关系。下面我们用接口封装一下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCountReader</span><span class="params">()</span> *<span class="title">CountReader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CountReader&#123;</span><br><span class="line">bytes: <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>),</span><br><span class="line">data:  <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountReader <span class="keyword">struct</span> &#123;     <span class="comment">// 声明CountReader对象</span></span><br><span class="line">bytes    <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line">data     []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123; <span class="comment">// 实现Read方法</span></span><br><span class="line">ok := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> ok &amp;&amp; <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line">h.data, ok = &lt;-h.bytes   <span class="comment">// 将bytes里的数据全部传给 data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok || <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, io.EOF    <span class="comment">// 可能读到了结尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l := <span class="built_in">copy</span>(p, h.data)</span><br><span class="line">h.data = h.data[l:]</span><br><span class="line"><span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := bufio.NewReader(h)</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">n,err := b.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">count += <span class="built_in">len</span>(buf[:n])</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明了一个结构体 <code>CountReader</code>, 再实现了一个 <code>Read()</code> 方法调用，我们知道实现了<code>Read()</code>即可以成为 <code>io.Reader</code> 接口的实现。也就是说 <code>CountReader</code> 就是一个 <code>io.Reader</code> ，那么 <code>io.Reader</code> 可以使用的方法，也可以给 <code>CountReader</code> 使用。这时就可以使用 <code>bufio</code> 这个库了。使用 <code>bufio.NewReader</code> 的函数对输入数据进行读取和计算。</p><p class="div-border yellow"><code>bufio.NewReader()</code> 方法提供一个缓存buf, 默认缓存4k buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line">Counter := NewCountReader()</span><br><span class="line"><span class="keyword">go</span> Counter.run()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">Counter.bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来通过上述代码即可完成相同的操作，这只是一个简单的例子，如果换成文件io、网络io就会有非常可观的收益。带来业务性能的提升。</p><h1 id="Functional-Option"><a href="#Functional-Option" class="headerlink" title="Functional Option"></a>Functional Option</h1><p>Functional Options 这个编程模式是一个函数式编程的应用案例，编程技巧也很好，是目前 Go 语言中最流行的一种编程模式。</p><p>假设实际编程中需要针对业务对象设置很多属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr     <span class="keyword">string</span></span><br><span class="line">    Port     <span class="keyword">int</span></span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    MaxConns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 Server 对象中，我们可以看到：</p><ul><li>要设置侦听的 IP 地址 Addr 和端口号 Port。（必填）</li><li>协议、超时时间、最大链接数、TLS选项等属性需要配置。（非必填）</li></ul><p>那么如何让调用方实现这个必填参数和非必填参数呢？一个方法是将非必填参数设成 <code>...interface&#123;&#125;</code> 但这样肯定不好，因为不同的参数类型都不一样。另一种方式就是将 必填参数和非必填参数分开了。</p><p>如非必填参数搞成一个结构体</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    Maxconns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必填参数和这个 <code>Config</code> 直接传给初始化函数，如果没有要填的参数可以将 <code>Config</code> 设为 <code>nil</code> 。</p><p>这样一来 <code>Server</code> 结构体便成了这样, 初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Conf *Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, conf *Config)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using the default configuratrion</span></span><br><span class="line">srv1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="literal">nil</span>) </span><br><span class="line"></span><br><span class="line">conf := ServerConfig&#123;Protocol:<span class="string">&quot;tcp&quot;</span>, Timeout: <span class="number">60</span>*time.Duration&#125;</span><br><span class="line">srv2, _ := NewServer(<span class="string">&quot;locahost&quot;</span>, <span class="number">9000</span>, &amp;conf)</span><br></pre></td></tr></table></figure><p>这样便已经是大多数人的作法了。但是不是没有修改空间，下面介绍一下 Functional Option 方式。</p><h2 id="初始化-Server-示例"><a href="#初始化-Server-示例" class="headerlink" title="初始化 Server 示例"></a><strong>初始化 Server 示例</strong></h2><p>首先我们定义一个 <code>Option</code> 类型:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span></span></span><br></pre></td></tr></table></figure><p>用函数式方式定义一组函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Protocol = p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Timeout = timeout</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxConns</span><span class="params">(maxconns <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.MaxConns = maxconns</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TLS</span><span class="params">(tls *tls.Config)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.TLS = tls</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这组代码的含义是传入一个参数，返回一个函数，函数会将 <code>Server</code> 结构的对应参数值进行设置。例如，当我们调用其中的一个函数 MaxConns(30) 时，其返回值是一个 func(s* Server) { s.MaxConns = 30 } 的函数。</p><p>这下，我们可以定义一个 <code>NewServer</code> 函数，其中有一个可变参数 <code>option</code> ,用一个循环来设置 Server 的属性。不仅提供了默认值，还提供将默认值改成可修改选项进行修改。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...<span class="keyword">func</span>(*Server)</span>) <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  srv := Server&#123;</span><br><span class="line">    Addr:     addr,</span><br><span class="line">    Port:     port,</span><br><span class="line">    Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">    Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">    MaxConns: <span class="number">1000</span>,</span><br><span class="line">    TLS:      <span class="literal">nil</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">    option(&amp;srv)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，我们在创建 Server 对象的时候，就可以像下面这样：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">1024</span>)</span><br><span class="line">s2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">2048</span>, Protocol(<span class="string">&quot;udp&quot;</span>))</span><br><span class="line">s3, _ := NewServer(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8080</span>, Timeout(<span class="number">300</span>*time.Second), MaxConns(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p>这下对 Server 的封装就像搭积木一样简单容易并且可视化很好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为了巩固一下 Go 的基础，主要涉及 Slice、Interface、函数式编程等。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>探索 Webtransport</title>
    <link href="http://kiosk007.top/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/"/>
    <id>http://kiosk007.top/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/</id>
    <published>2021-01-23T02:33:00.000Z</published>
    <updated>2021-01-23T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://wicg.github.io/web-transport/">WebTransport</a> 是一个新一代的浏览器API，提供客户端-服务端之间的双向低延迟交互，并在顶部使用常见 API 来实现其下的可插拔协议（<font style="color:#FF7F50">尤其是基于<a style="color:#FF7F50" href=" https://www.chromium.org/quic">QUIC</a></font>）。该 API 与 WebSocket 相似，也是客户端和服务器的双向连接，但允许进一步减少客户端和服务器之间的网络通信延迟，并且还支持多个流、单向流、乱序和不可靠传输。基于QUIC的Webtransport (Quictransport)即支持通过 datagram API 发送不可靠的数据，也支持通过 stream API 实现可靠数据传输。</p><p>使用场景包括使用不可靠且乱序的消息向服务器重复发送低延迟的游戏状态、从服务器到客户端的媒体片段的低延迟传输以及大多数逻辑在服务器上运行的云场景。</p><p>WebTransport 提案详细介绍：<font style="color:#FF7F50"> <a href="https://wicg.github.io/web-transport/">https://wicg.github.io/web-transport/</a> </font></p><p><strong>重点</strong></p><ol><li>Webtransport 支持不可靠传输，通过轻量级、低延迟的UDP协议传输。</li><li>Webtransport 可基于 QUIC 实现 Client-Server 可靠的流式传输。</li><li>可支持多条流的相互独立 + QUIC 多路复用\非队头阻塞特性 完美代替当前的 Websocket。Webtransport 提供了一些当前websocket规范不可能提供的功能。可消除当前多个数据包之间的队头阻塞。</li></ol><p><strong>标准规范</strong></p><ol><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-overview-01"> WebTransport overview </a> : Webtransport 的概述及对传输层的要求。</li><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-quic"> WebTransport over QUIC</a> : 定义了基于QUIC的 Webtransport</li><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-http3-02"> WebTransport over HTTP/3 </a>: 定义了基于HTTP/3的 Webtransport （实际上 HTTP/3 也是基于QUIC的）</li></ol><p>当前 Chrome 团队只实现了基于 QUIC 的 Webtransport 。然而目前也仅仅是实验性的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transport = <span class="keyword">new</span> QuicTransport(<span class="string">&#x27;quic-transport://localhost:4433/path&#x27;</span>);</span><br></pre></td></tr></table></figure><br>Webtransport draft 标明是支持TCP的， 但显然目前大家都在UDP上了投入了大量精力，也主要是以UDP去实现的。</p><p><img src="https://img1.kiosk007.top/static/images/network/WebTransport/common_transport_requirements.png"></p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>当前的Webtransport 必须基于 QUIC draft-29 或更高版本。客户端主要以 chrome 浏览器为主，版本必须 &gt;= 85 。服务端我们将基于 <a href="github.com/lucas-clemente/quic-go" style="color:#FF7F50"> github.com/lucas-clemente/quic-go </a>  go library 。因为是本地测试，我们还需要签发一个自签名证书。</p><h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>因为当前Webtransport的底层实现是基于 QUIC or HTTP/3 ，所以我们必须要实现自签名证书，确保通信过程的安全性。这里我们使用的是 <code>openssl</code> </p><p>首先需要确保你的 <code>openssl</code> 安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ <span class="built_in">which</span> openssl</span><br><span class="line">/usr/bin/openssl</span><br><span class="line">➜ openssl version</span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>创建证书和私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl req -newkey rsa:2048 -nodes -keyout certificate.key \</span><br><span class="line">-x509 -out certificate.pem -subj <span class="string">&#x27;/CN=Test Certificate&#x27;</span> \</span><br><span class="line">-addext <span class="string">&quot;subjectAltName = DNS:localhost&quot;</span></span><br></pre></td></tr></table></figure><p>计算证书的指纹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl x509 -pubkey -noout -<span class="keyword">in</span> certificate.pem |</span><br><span class="line">openssl rsa -pubin -outform der |</span><br><span class="line">openssl dgst -sha256 -binary | base64</span><br><span class="line"><span class="comment">#      The result should be a base64-encoded blob that looks like this:</span></span><br><span class="line"><span class="comment">#          &quot;Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=&quot;</span></span><br></pre></td></tr></table></figure><p>向chrome传入参数指明允许使用自签证书的服务端地址+端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--origin-to-force-quic-on=localhost:4433</span><br></pre></td></tr></table></figure><p>使用如下参数以信任证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ignore-certificate-errors-spki-list=Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=</span><br></pre></td></tr></table></figure><br>更多可以参考： <a href="https://www.chromium.org/developers/how-tos/run-chromium-with-flags">docs on how to run Chrome/Chromium with custom flags.</a></p><p>最后打开 <a style="color:#FF7F50" href="https://googlechrome.github.io/samples/webtransport/client.html">https://googlechrome.github.io/samples/webtransport/client.html</a></p><p><img src="https://img1.kiosk007.top/static/images/network/WebTransport/webtransport_client.png" style="height:550px"></p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>我们使用 github.com/lucas-clemente/quic-go 来实现QUIC。</p><p>Run 方法来实现接受客户端的连接请求。quic.ListenAddr 创建一个监听器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   listener, err := quic.ListenAddr(s.config.ListenAddr, s.generateTLSConfig(), s.generateQUICConfig())</span><br><span class="line">   utils.Logging.Info().Err(err)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;WebTransport Engine v0.1 Start ...&quot;</span>)</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;Listening for %s connections on %s&quot;</span>,<span class="string">&quot;udp&quot;</span>, s.config.ListenAddr)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      session, err := listener.Accept(context.Background())</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      utils.Logging.Info().Msgf(<span class="string">&quot;session accepted: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _ = session.CloseWithError(<span class="number">0</span>, <span class="string">&quot;bye&quot;</span>)</span><br><span class="line">            utils.Logging.Info().Msgf(<span class="string">&quot;close session: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line">         &#125;()</span><br><span class="line">         s.handleSession(session)</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端需要在 ALPN 中携带 alpnQuicTransport = “wq-vvv-01” 服务端读取后就会针对开始Webtransport 传输。<br><img src="https://img1.kiosk007.top/static/images/network/WebTransport/wq-vvv-01_alpn.png" style="height:550px"></p><p>代码参见：<a href="https://github.com/weijiaxiang007/webtransport/" style="color:#FF7F50"> https://github.com/weijiaxiang007/webtransport/ </a></p><h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p><font style="color:#6495ED">QUIC使用流ID的最低两位指示流标识以下信息</font></p><ol><li>单向 or 双向流</li><li>由客户端 or 服务端发起。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+----------------------------------+</span><br><span class="line">| Bits | Stream Type                      |</span><br><span class="line">+======+==================================+</span><br><span class="line">| 0x0  | Client-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x1  | Server-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x2  | Client-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x3  | Server-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br></pre></td></tr></table></figure><ul><li>对于每一个双向流，流的发起方和流的接收方均可以在一条双向流上传输数据。</li><li>对于每一条单向流，只能是流的发起方向流的接收方发送数据。接收方可以在一条新的单向流上回复数据。</li><li>对于数据报格式的数据，由于 quic-go 底层不支持，这里不再赘述。不过已经有相关的提交去支持 <a href="https://github.com/lucas-clemente/quic-go/pull/2162" style="color:#FF7F50"> https://github.com/lucas-clemente/quic-go/pull/2162 </a></li></ul><p>更多信息参见：<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1" style="color:#FF7F50">https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1</a></p><p><font style="color:#6495ED">客户端请求</font><br>客户端请求一般 按照 Key — Value 的方式携带请求的资源标识。如下是请求的 Origin 和 Path。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientIndicationKey <span class="keyword">int16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   clientIndicationKeyOrigin clientIndicationKey = <span class="number">0</span></span><br><span class="line">   clientIndicationKeyPath                       = <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Key (16)            |          Length (16)          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Value (*)                         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>这里只实现了双向流，可以看到双向流建立之前会先建立一个单向流用于认证信息。之后的数据会在双向流上传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">handleSession</span><span class="params">(sess quic.Session)</span></span> &#123;</span><br><span class="line">stream, err := sess.AcceptUniStream(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utils.Logging.Info().Msgf(<span class="string">&quot;unidirectional stream accepted, id: %d&quot;</span>, stream.StreamID())</span><br><span class="line">indication, err := receiveClientIndication(stream)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utils.Logging.Info().Msgf(<span class="string">&quot;client indication: %+v&quot;</span>, indication)</span><br><span class="line"><span class="keyword">if</span> err := s.validateClientIndication(indication); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = s.communicate(sess)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="QUIC" scheme="http://kiosk007.top/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>Go Reflect </title>
    <link href="http://kiosk007.top/2021/01/18/Go-Reflect/"/>
    <id>http://kiosk007.top/2021/01/18/Go-Reflect/</id>
    <published>2021-01-18T15:57:00.000Z</published>
    <updated>2021-01-18T15:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言标准库 <a href="https://golang.org/pkg/reflect/">reflect</a> 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。</p><a id="more"></a><h1 id="类型和接口-Types-and-interfaces"><a href="#类型和接口-Types-and-interfaces" class="headerlink" title="类型和接口 (Types and interfaces)"></a>类型和接口 (Types and interfaces)</h1><p>因为反射是建立在类型之上的，所以想要了解反射必须先知道Go 语言中所有的变量都有一个静态类型。例如 <code>int</code>、<code>[]byte</code>、<code>float32</code>、<code>*MyType</code>等等。<br>如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure><br>接口是一种特殊的类型，它表示固定的方法集。接口变量可以存储任何具体（非接口）值,只要该值实现接口的方法。最经典的例子便是 io.Reader \ io.Writer 。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有人说Go的接口是动态类型的，但这是误导。它们是静态类型。一个特殊的例子是空接口，即 <code>interface&#123;&#125;</code>。</p><p>在这个例子中。<font style="color:#00008B">os.OpenFile</font> 的返回参数tty的类型是 <code>*os.File</code>，由于 <code>*os.File</code> 实现了 <font style="color:#00008B">Read()</font> 方法，所以该类型可以被赋于类型 io.Reader (io.Reader是一个interface)。尽管 <code> *os.File</code> 实现了很多方法，但是变量r仅有一个方法Read。但内部的值仍包含有关该值的所有类型信息。这就是为什么我们可以做 <code>w=r.(io.Writer)</code> 的原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>) <span class="comment">// tty *os.File</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> &#125;</span><br><span class="line">r = tty</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer    </span><br><span class="line">w = r.(io.Writer)  <span class="comment">// 由于r实际内部是有Write方法的，所以r可以被断言成 io.Writer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;12345&quot;</span>));err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">_ = tty.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以继续执行下面的操作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br><span class="line">fmt.Println(reflect.TypeOf(empty))</span><br></pre></td></tr></table></figure></p><h2 id="反射基本用法"><a href="#反射基本用法" class="headerlink" title="反射基本用法"></a>反射基本用法</h2><h3 id="从接口值到反射对象"><a href="#从接口值到反射对象" class="headerlink" title="从接口值到反射对象"></a><font style="color:#483D8B"><strong>从接口值到反射对象</strong></font></h3><p>ValueOf用来获取输入参数接口中的数据的值。如果是空接口则返回 invalid 。<br>TypeOf用来动态获取输入参数接口中的值的类型，如果空接口则返回nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>,reflect.TypeOf(num))     <span class="comment">// type:  float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>,reflect.ValueOf(num))   <span class="comment">// value:  1.2345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以判断类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(v)</span><br><span class="line"><span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line">fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;   <span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从反射对象到接口值"><a href="#从反射对象到接口值" class="headerlink" title="从反射对象到接口值"></a><font style="color:#483D8B"><strong>从反射对象到接口值</strong></font></h3><p>go 提供了反射和反射的逆，可以通过 <code>.(type)</code> 断言的方式将一个Interface()转成他真正的类型。如果断言的类型不匹配，会发生panic。</p><p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说 明</th></tr></thead><tbody><tr><td>Interface() interface{}</td><td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td>Int() int64</td><td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td>Uint() uint64</td><td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td>Float() float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td>Bool() bool</td><td>将值以 bool 类型返回</td></tr><tr><td>Bytes() []bytes</td><td>将值以字节数组 []bytes 类型返回</td></tr><tr><td>String() string</td><td>将值以字符串类型返回</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi <span class="keyword">float64</span></span><br><span class="line">pi = <span class="number">3.1415926</span></span><br><span class="line">v := reflect.ValueOf(pi)</span><br><span class="line">y := v.Interface().(<span class="keyword">float64</span>) <span class="comment">// y will have type float64.</span></span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></table></figure><h3 id="要修改反射对象，该值必须可设置"><a href="#要修改反射对象，该值必须可设置" class="headerlink" title="要修改反射对象，该值必须可设置"></a><font style="color:#483D8B"><strong>要修改反射对象，该值必须可设置</strong></font></h3><p>如果运行下面的代码将会 <font style="color:#8B0000"> panic </font> ，这时因为 v 是不可设置的。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>备  注</th></tr></thead><tbody><tr><td>Elem() Value</td><td>取值指向的元素值，类似于语言层*操作</td></tr><tr><td>Addr() Value</td><td>对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机</td></tr><tr><td>CanAddr() bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet() bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>通过 <code>CanSet()</code> 即可判断，<code>CanSet()</code> 报告 v 的值是否可以改变。值只能在可寻址的情况下更改，并且不能通过使用未导出的结构字段获取。如果 CanSet 返回 false ，则调用 Set 或任何类型特定的 setter （例如 SetBool ，SetInt ）将会发生panic。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><br>v 不可寻址，因为 v 只是 x 的拷贝，即便把 x 换成 &amp;x,还是不可寻址，因为 <code>reflect.ValueOf(&amp;x)</code> 也仅仅是 x 指针的拷贝。实际上，所有通过 <code>reflect.ValueOf(x)</code> 返回的 reflect.Value 都是不可取地址的。但是通过调用 <code>reflect.ValueOf(&amp;x).Elem()</code>，来获取任意变量x对应的可取地址的 Value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span></span><br><span class="line">x = <span class="number">3.1415</span></span><br><span class="line">pv := reflect.ValueOf(&amp;x)</span><br><span class="line">pv = pv.Elem()</span><br><span class="line">pv.SetFloat(<span class="number">7.1</span>) </span><br><span class="line"></span><br><span class="line">fmt.Println(x)   <span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure><h2 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h2><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) StructField</td><td>根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生panic</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量。当类型不是结构体或索引超界时发生panic</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生 panic</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时发生 panic</td></tr><tr><td>FieldByNameFunc( match func(string) bool) (StructField,bool)</td><td>根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生panic</td></tr></tbody></table></div><h3 id="普通结构体"><a href="#普通结构体" class="headerlink" title="普通结构体"></a>普通结构体</h3><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>假设有以下 <code>User struct</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int</span></span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Work    Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">Id           <span class="keyword">int</span></span><br><span class="line">Occupation   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;My Id :%d ,My Name :%s ,My Occupation :%s&quot;</span>,u.Id,u.Name,u.Work.Occupation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFuncHasArgs</span><span class="params">(foo <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;This is number %d \n&quot;</span>, foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来演示的是如何通过反射区打印结构体中的所有对象、打印结构体中的所有字段、调用方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">Work: Worker&#123;</span><br><span class="line">Id: <span class="number">1</span>,</span><br><span class="line">Occupation: <span class="string">&quot;farmer&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(user)</span><br><span class="line">fmt.Println(<span class="string">&quot;get type is: &quot;</span>,getType.Name())  <span class="comment">// get type is:  User</span></span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line">fmt.Println(<span class="string">&quot;get all Fields is &quot;</span>, getValue) <span class="comment">// get all Fields is  &#123;1 Kiosk &#123;1 farmer&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字段进行遍历 获取方法的字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumField();i++ &#123;</span><br><span class="line">field := getType.Field(i)</span><br><span class="line">value := getValue.Field(i).Interface()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: %v = %v \n&quot;</span>,field.Name,field.Type,value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Id: int = 1</span></span><br><span class="line"><span class="comment">Name: string = Kiosk</span></span><br><span class="line"><span class="comment">Work: main.Worker = &#123;1 farmer&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumMethod();i++ &#123;</span><br><span class="line">m := getType.Method(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s : %v\n&quot;</span>,m.Name,m.Type)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ReflectCallFunc : func(main.User)</span></span><br><span class="line"><span class="comment">   ReflectCallFuncHasArgs : func(main.User, int)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="comment">// 有参数调用</span></span><br><span class="line">methodValue := getValue.MethodByName(<span class="string">&quot;ReflectCallFuncHasArgs&quot;</span>)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(<span class="number">2</span>)&#125;</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is number 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数调用</span></span><br><span class="line">methodValue = getValue.MethodByName(<span class="string">&quot;ReflectCallFunc&quot;</span>)</span><br><span class="line">args = <span class="built_in">make</span>([]reflect.Value,<span class="number">0</span>)</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">My Id :1 ,My Name :Kiosk ,My Occupation :farmer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带tag的struct"><a href="#带tag的struct" class="headerlink" title="带tag的struct"></a>带tag的struct</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int</span> <span class="string">`json:&quot;id&quot;   bson:&quot;id&quot;`</span></span><br><span class="line">Name    <span class="keyword">string</span><span class="string">`json:&quot;name&quot; bson:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(user)</span><br><span class="line">fmt.Printf(<span class="string">&quot;get type is: %v \n&quot;</span>,getType.String())  <span class="comment">// get type is:  main.User</span></span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line">fmt.Println(getValue) <span class="comment">// &#123;1 Kiosk&#125;</span></span><br><span class="line"></span><br><span class="line">name := getValue.FieldByName(getType.Field(<span class="number">1</span>).Name).String()</span><br><span class="line">fmt.Printf(<span class="string">&quot;name is %s \n&quot;</span>, name)  <span class="comment">// name is Kiosk</span></span><br><span class="line"></span><br><span class="line">tag := getType.Field(<span class="number">0</span>).Tag</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %v  tag: &#x27;%v&#x27;\n&quot;</span>, getType.Field(<span class="number">0</span>).Name, tag) <span class="comment">// name: Id  tag: &#x27;json:&quot;id&quot;   bson:&quot;id&quot;&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;tag is %s, %s \n&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), tag.Get(<span class="string">&quot;bson&quot;</span>)) <span class="comment">//  tag is id, id </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断反射值的有效性和空"><a href="#判断反射值的有效性和空" class="headerlink" title="判断反射值的有效性和空"></a>判断反射值的有效性和空</h2><p>IsNil()和IsValid() — 判断反射值的空和有效性</p><p>反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。</p><div class="table-container"><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>IsNil() bool</td><td>返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的v== nil操作</td></tr><tr><td>IsValid() bool</td><td>判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*int的空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;var a *int:&quot;</span>, reflect.ValueOf(a).IsNil())  </span><br><span class="line">    <span class="comment">// var a *int: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//nil值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;nil:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid()) </span><br><span class="line">    <span class="comment">// nil: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*int类型的空指针</span></span><br><span class="line">fmt.Println(<span class="string">&quot;(*int)(nil):&quot;</span>, reflect.ValueOf((*<span class="keyword">int</span>)(<span class="literal">nil</span>)).Elem().IsValid()) </span><br><span class="line">    <span class="comment">// (*int)(nil): false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个结构体</span></span><br><span class="line">s := <span class="keyword">struct</span> &#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从结构体中查找一个不存在的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(s).FieldByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的结构体成员: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从结构体中查找一个不存在的方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的方法:&quot;</span>, reflect.ValueOf(s).MethodByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的方法: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个map</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的键:&quot;</span>, reflect.ValueOf(m).MapIndex(reflect.ValueOf(<span class="number">3</span>)).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的键: false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 语言标准库 &lt;a href=&quot;https://golang.org/pkg/reflect/&quot;&gt;reflect&lt;/a&gt; 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。&lt;/p&gt;</summary>
    
    
    
    <category term="programming" scheme="http://kiosk007.top/categories/programming/"/>
    
    
    <category term="Go" scheme="http://kiosk007.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>TLS详解（三）</title>
    <link href="http://kiosk007.top/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://kiosk007.top/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-01-16T08:48:00.000Z</published>
    <updated>2021-01-16T08:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。</p><a id="more"></a><ul><li><a href="https://www.kiosk007.top/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/">TLS 详解一</a></li><li><a href="https://www.kiosk007.top/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/">TLS 详解二</a></li></ul><h1 id="TLS1-3-Feature"><a href="#TLS1-3-Feature" class="headerlink" title="TLS1.3 Feature"></a>TLS1.3 Feature</h1><ul><li><font color="#7B68EE">Speed Benefits of TLS 1.3</font></li></ul><p>TLS1.3 可以使用1RTT建立握手，比1.2版本能节约一个网络来回。</p><p><img style="height:300px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-performance.png"></p><ul><li><font color="#7B68EE">Improved Security With TLS 1.3</font></li></ul><p>TLS1.3 移除了RC4、DES、MD5 等诸多脆弱不安全的算法，目前仅保持了支持AEAD的ECDH类等算法。</p><ul><li><font color="#7B68EE"> 1.3 Browser Support</font></li></ul><p>从 Chrome65 开始，Google公司就可以支持 <a href="http://www.chromium.org/Home/tls13">draft version of TLS 1.3 </a> , 2018年10月的 Chrome70 就完全支持了TLS1.3。同样Firefox63也在同年10月支持了TLS1.3。Microsoft Edge version 76 及 Safari 12.1 on macOS 10.14.4. 也都支持了TLS1.3 。</p><h1 id="The-TLS-handshake"><a href="#The-TLS-handshake" class="headerlink" title="The TLS handshake"></a>The TLS handshake</h1><p>总体握手流程如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">handshake</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c := hs.c</span><br><span class="line"></span><br><span class="line"><span class="comment">// For an overview of the TLS 1.3 handshake, see RFC 8446, Section 2.</span></span><br><span class="line"><span class="keyword">if</span> err := hs.processClientHello(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.checkForResumption(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.pickCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">c.buffering = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerParameters(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="comment">// Note that at this point we could start sending application data without</span></span><br><span class="line"><span class="comment">// waiting for the client&#x27;s second flight, but the application might not</span></span><br><span class="line"><span class="comment">// expect the lack of replay protection of the ClientHello parameters.</span></span><br><span class="line"><span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err  &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.readClientCertificate(); err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> err  &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.readClientFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"></span><br><span class="line">atomic.StoreUint32(&amp;c.handshakeStatus, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/network/TLSDetailAnalysis/tls-1.3.png"></p><h2 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a><font style="color:#4682B4">Client Hello</font></h2><p>由于TLS1.2已经在互联网上存在了10年。网络中大量的网络中间设备都十分老旧，这些网络设备会识别中间的TLS握手头部，所以TLS1.3的出现如果引入了未知的TLS Version 必然会存在大量的握手失败，为了解决这一点，TLS1.3 的握手头部默认是TLS1.2。</p><p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-clienthello.png"></p><p>如果客户端支持TLS1.3 则在 <strong><font style="color:#483D8B">Client Hello</font></strong> 发出时在Extensions中携带 supported_versions 并标明客户端是支持TLS1.3的，同样为了1RTT快速握手，会将客户端Key_share 发送给服务端。Key_Share是客户端提前生成好的公钥信息。其密钥派生过程依赖于密码套件的 HKDF Extract 和 HKDF Expand 函数以及 Hash函数。</p><p>在密钥交换之前，客户端和服务端使用HKDF生成密钥。（它取代了基于HMAC的伪随机密钥生成函数PRF。</p><p>下面用代码过一遍客户端的Client Hello流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> params ecdheParameters</span><br><span class="line"><span class="keyword">if</span> hello.supportedVersions[<span class="number">0</span>] == VersionTLS13 &#123;</span><br><span class="line">hello.cipherSuites = <span class="built_in">append</span>(hello.cipherSuites, defaultCipherSuitesTLS13()...)</span><br><span class="line"></span><br><span class="line">curveID := config.curvePreferences()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> _, ok := curveForCurveID(curveID); curveID != X25519 &amp;&amp; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;tls: CurvePreferences includes unsupported curve&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">params, err = generateECDHEParameters(config.rand(), curveID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">hello.keyShares = []keyShare&#123;&#123;group: curveID, data: params.PublicKey()&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，如果客户端是支持  <font style="color:#483D8B">VersionTLS13</font>, 则在创建 <font style="color:#483D8B"> Client Hello </font> 时,添加TLS1.3支持的秘钥套件，并使用 x25519 曲线和随机数生成 <font style="color:#483D8B"> PublickKey </font>放入 <font style="color:#483D8B"> Client Hello Extension</font> 中的 <font style="color:#483D8B"> KeyShares </font> 中。</p><h2 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a><font style="color:#4682B4">Server Hello</font></h2><p>服务端的TLS Version仍为TLS1.2（实际上后续的TLS版本均为1.2），如果服务端支持TLS1.3，则会在  <font style="color:#483D8B">supported_versions</font> 中的携带TLS1.3，这样后续的会话便均在TLS1.3下通信。</p><p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-serverhello.png"></p><p>服务端会在<font style="color:#483D8B"> Server Hello </font> 中的 <font style="color:#483D8B"> key_share </font> 中携带公钥信息。</p><p>下面是完整的握手过程，BTW <font style="color:red">虽然0RTT是各大博客都吹嘘的TLS1.3亮点，但是0RTT 当前大多数的官方库都还没有实现（Nginx似乎是支持了）</font> ，比如看这里<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hs.clientHello.earlyData &#123;</span><br><span class="line"><span class="comment">// See RFC 8446, Section 4.2.10 for the complicated behavior required</span></span><br><span class="line"><span class="comment">// here. The scenario is that a different server at our address offered</span></span><br><span class="line"><span class="comment">// to accept early data in the past, which we can&#x27;t handle. For now, all</span></span><br><span class="line"><span class="comment">// 0-RTT enabled session tickets need to expire before a Go server can</span></span><br><span class="line"><span class="comment">// replace a server or join a pool. That&#x27;s the same requirement that</span></span><br><span class="line"><span class="comment">// applies to mixing or replacing with any TLS 1.2 server.</span></span><br><span class="line">c.sendAlert(alertUnsupportedExtension)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;tls: client sent unexpected early data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>服务端选择和客户端同样支持的 <font style="color:#483D8B"> CurveID </font>(代码中的 selectedGroup，并且是Client支持的Key Share)。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">params, err := generateECDHEParameters(c.config.rand(), selectedGroup)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.sendAlert(alertInternalError)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">hs.hello.serverShare = keyShare&#123;group: selectedGroup, data: params.PublicKey()&#125;</span><br><span class="line">hs.sharedKey = params.SharedKey(clientKeyShare.data)</span><br><span class="line"><span class="keyword">if</span> hs.sharedKey == <span class="literal">nil</span> &#123;</span><br><span class="line">c.sendAlert(alertIllegalParameter)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;tls: invalid client key share&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样以来，客户端和服务端便直接完成了 <font style="color:#483D8B">ECDHE</font> 密钥交换</p><ul><li>客户端生成随机数x，确定了曲线类型如Golang TLS SDK只支持的 <font style="color:#483D8B"> x25519曲线</font> 即可得方程系数a、b，再调用<code>generateECDHEParameters</code> 获得 <font style="color:#483D8B"> PublicKey Q<sub>1</sub> </font>。客户端将 Q<sub>1</sub> 、a、 b、 P 传给服务端。</li><li>服务端生成随机数y，解析客户端传来的曲线和 Key_Share 对，得到曲线类型 <font style="color:#483D8B"> x25519 </font>既得方程系数a、b，再使用 selectedGroup 和 y 调用<code>generateECDHEParameters</code> 生成 <font style="color:#483D8B"> PublicKey Q<sub>2</sub> </font> ,传给客户端</li><li>这时客户端和服务端可以计算出一个公共的值 <font style="color:#483D8B"> <strong>K</strong> </font></li></ul><p>如下图</p><p><img src="/images/network/TLSDetailAnalysis/ECDHE.png"></p><h3 id="PSK-Pre-Shared-Key"><a href="#PSK-Pre-Shared-Key" class="headerlink" title=" PSK (Pre-Shared Key)"></a><font style="color:#87CEEB"> PSK (Pre-Shared Key)</font></h3><p>这里在接着解析代码之前，先插播一个 TLS1.3 的feature 0RTT是如何实现的。这里介绍一下实现的原理 — <font style="color:#483D8B"> <strong>PSK</strong> </font></p><p>一旦一次握手完成，server 就能给 client 发送一个与一个独特密钥对应的 PSK 密钥，这个密钥来自初次握手。然后 client 能够使用这个 PSK 密钥在将来的握手中协商相关 PSK 的使用。如果 server 接受它，新连接的安全上下文在密码学上就与初始连接关联在一起，从初次握手中得到的密钥就会用于装载密码状态来替代完整的握手。在 TLS 1.2 以及更低的版本中，这个功能由 “session IDs” 和 “session tickets” [RFC5077]来提供。这两个机制在 TLS 1.3 中都被废除了。</p><p>PSK 可以与 (EC)DHE 密钥交换算法一同使用以便使共享密钥具备前向安全，或者 PSK 可以被单独使用，这样是以丢失了应用数据的前向安全为代价。</p><p>下图显示了两次握手，第一次建立了一个 PSK，第二次时使用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">       Client                                               Server</span><br><span class="line"></span><br><span class="line">Initial Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share               --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                       + key_share</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                             &#123;CertificateRequest*&#125;</span><br><span class="line">                                                    &#123;Certificate*&#125;</span><br><span class="line">                                              &#123;CertificateVerify*&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Certificate*&#125;</span><br><span class="line">       &#123;CertificateVerify*&#125;</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">                                 &lt;--------      [NewSessionTicket]</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subsequent Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share*</span><br><span class="line">       + pre_shared_key          --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                  + pre_shared_key</span><br><span class="line">                                                      + key_share*</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 server 通过一个 PSK 进行认证时，它不会发送一个 Certificate 或一个 CertificateVerify 消息。当一个 client 通过 PSK 想恢复会话的时候，它也应当提供一个 “key_share” 给 server，以允许 server 拒绝恢复会话的时候降级到重新回答一个完整的握手流程中。Server 响应 “pre_shared_key” 扩展，使用 PSK 密钥协商建立连接，同时响应 “key_share” 扩展来进行 (EC)DHE 密钥建立，由此提供前向安全。</p><p>当 PKS 在带外提供时，PSK 密钥和与 PSK 一起使用的 KDF hash 算法也必须被提供。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0 RTT"></a><font style="color:#87CEEB">0 RTT</font></h3><p>当 client 和 server 共享一个 PSK（从外部获得或通过一个以前的握手获得）时，TLS 1.3 允许 client 在第一个发送出去的消息中携带数据（”application data”）。Client 使用这个 PSK 来认证 server 并加密 early data 信息，最终实现Application数据的0RTT发送。</p><p>如下图所示，0-RTT 数据在第一个发送的消息中被加入到 1-RTT 握手过程中。握手的其余消息与带 PSK 会话恢复的 1-RTT 握手消息相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">+ early_data</span><br><span class="line">+ key_share*</span><br><span class="line">+ psk_key_exchange_modes</span><br><span class="line">+ pre_shared_key</span><br><span class="line">(Application Data*)     --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                           + pre_shared_key</span><br><span class="line">                                               + key_share*</span><br><span class="line">                                      &#123;EncryptedExtensions&#125;</span><br><span class="line">                                              + early_data*</span><br><span class="line">                                                 &#123;Finished&#125;</span><br><span class="line">                        &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;              --------&gt;</span><br><span class="line">[Application Data]      &lt;-------&gt;        [Application Data]</span><br></pre></td></tr></table></figure><p>上图是 0-RTT 的信息流</p><p>0-RTT 数组安全性比其他类型的 TLS 数据要弱一些，特别是：</p><ol><li>0-RTT 的数据是没有前向安全性的，它使用的是被提供的 PSK 中导出的密钥进行加密的。</li><li>在多个连接之间不能保证不存在重放攻击。普通的 TLS 1.3 1-RTT 数据为了防止重放攻击的保护方法是使用 server 下发的随机数，现在 0-RTT 不依赖于 ServerHello 消息，因此保护措施更差。如果数据与 TLS client 认证或与应用协议里一起验证，这一点安全性的考虑尤其重要。这个警告适用于任何使用 early_exporter_master_secret 的情况。</li></ol><p>参考 <strong><a href="https://halfrost.com/tls_1-3_introduction/">TLS 1.3 Introduction</a></strong> — Halfrost’s Field | 冰霜之地</p><h3 id="checkForResumption-—-Go"><a href="#checkForResumption-—-Go" class="headerlink" title=" checkForResumption — Go"></a><font style="color:#87CEEB"> checkForResumption — Go</font></h3><p>上面2个小节其实就是在介绍 <a href="https://golang.org/src/crypto/tls/handshake_server_tls13.go#226"><code>checkForResumption()</code></a> 这个函数的作用。</p><p>在Client Hello 包的扩展里如果有 <strong>psk_key_exchange_modes</strong> 和  <strong>pre_shared_key</strong> 就表示客户端想要会话复用，即类似TLS1.2的 <strong>Session Ticket</strong> or <strong>Session Id</strong> 的概念。</p><p>如下所示：</p><p><img src="/images/network/TLSDetailAnalysis/tls-1.3-psk_key_exchange_modes.png"></p><font style="color:#483D8B"> **psk_key_exchange_modes**</font>是 psk 密钥交互模式选择. 此处的PSK模式为(EC)DHE下的PSK，客户端和服务器必须提供KeyShare, 如果是仅PSK模式，则服务器不需要提供KeyShare。<img src="/images/network/TLSDetailAnalysis/tls-1.3-pre_shared_key.png"><font style="color:#483D8B"> **pre_shared_key**</font> 是预共享密钥认证机制，相当于session ticket再加一些检验的东西.Identity中包含的是客户端愿意进行协商的服务器身份列表。PSK binder表示已经构建当前PSK与当前握手之间的绑定。下面函数中，服务端会将 <font style="color:#483D8B">identity</font> 解析成 <font style="color:#483D8B">plaintext</font>，<font style="color:#483D8B">plaintext</font>中包含TLS版本、证书、复用秘钥、超时时间 等多个信息，如果unmarshal成功，即可以会话复用，继续向下。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, identity := <span class="keyword">range</span> hs.clientHello.pskIdentities &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= maxClientPSKIdentities &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">plaintext, _ := c.decryptTicket(identity.label)</span><br><span class="line"><span class="keyword">if</span> plaintext == <span class="literal">nil</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">sessionState := <span class="built_in">new</span>(sessionStateTLS13)</span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> ok := sessionState.unmarshal(plaintext); !ok &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">       </span><br><span class="line">       createdAt := time.Unix(<span class="keyword">int64</span>(sessionState.createdAt), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> c.config.time().Sub(createdAt) &gt; maxSessionTicketLifetime &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don&#x27;t check the obfuscated ticket age because it&#x27;s affected by</span></span><br><span class="line"><span class="comment">// clock skew and it&#x27;s only a freshness signal useful for shrinking the</span></span><br><span class="line"><span class="comment">// window for replay attacks, which don&#x27;t affect us as we don&#x27;t do 0-RTT.</span></span><br><span class="line"></span><br><span class="line">pskSuite := cipherSuiteTLS13ByID(sessionState.cipherSuite)</span><br><span class="line"><span class="keyword">if</span> pskSuite == <span class="literal">nil</span> || pskSuite.hash != hs.suite.hash &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">...</span><br><span class="line">psk := hs.suite.expandLabel(sessionState.resumptionSecret, <span class="string">&quot;resumption&quot;</span>,</span><br><span class="line"><span class="literal">nil</span>, hs.suite.hash.Size())</span><br><span class="line">hs.earlySecret = hs.suite.extract(psk, <span class="literal">nil</span>)</span><br><span class="line">binderKey := hs.suite.deriveSecret(hs.earlySecret, resumptionBinderLabel, <span class="literal">nil</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>## <font style="color:#4682B4"> Change Cipher Space</font><p>发送一个 <font style="color:#483D8B"><strong>ChangeCipherSpec record</strong></font> 报文，之后的加密方式将会改变。详见 See RFC 8446, Appendix D.4.</p><h2 id="EncryptedExtensions"><a href="#EncryptedExtensions" class="headerlink" title=" EncryptedExtensions "></a><font style="color:#4682B4"> EncryptedExtensions </font></h2><p>随后 Server 会发来建立 EncryptedExtensions Server 参数: 对 ClientHello 扩展的响应，不需要确定加密参数，而不是特定于各个证书的加密参数。一般ALPN会在这里添加。</p><h2 id="Certificate-amp-amp-Certificate-Verify-amp-amp-Finished"><a href="#Certificate-amp-amp-Certificate-Verify-amp-amp-Finished" class="headerlink" title=" Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished "></a><font style="color:#4682B4"> Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished </font></h2><p>最后，Client 和 Server 交换认证消息。TLS 在每次基于证书的认证时使用相同的消息集，(基于 PSK 的认证是密钥交换中的一个副作用)特别是：</p><ul><li><p><font style="color:#483D8B">Certificate</font>: 终端的证书和每个证书的扩展。 服务器如果不通过证书进行身份验证，并且如果服务器没有发送CertificateRequest（由此指示客户端不应该使用证书进行身份验证），客户端将忽略此消息。 请注意，如果使用原始公钥 [RFC7250] 或缓存信息扩展 [RFC7924]，则此消息将不包含证书，而是包含与服务器长期密钥相对应的其他值。</p></li><li><p><font style="color:#483D8B">CertificateVerify</font>: 使用与证书消息中的公钥配对的私钥对整个握手消息进行签名。如果终端没有使用证书进行验证则此消息会被忽略。</p></li><li><p><font style="color:#483D8B">Finished</font>: 对整个握手消息的 MAC(消息认证码)。这个消息提供了密钥确认，将终端身份与交换的密钥绑定在一起，这样在 PSK 模式下也能认证握手。</p></li></ul><p>接收到 Server 的消息之后，Client 会响应它的认证消息，即 Certificate，CertificateVerify (如果需要), 和 Finished。</p><p>这时握手已经完成，client 和 server 会提取出密钥用于记录层交换应用层数据，这些数据需要通过认证的加密来保护。应用层数据不能在 Finished 消息之前发送数据，必须等到记录层开始使用加密密钥之后才可以发送。需要注意的是 server 可以在收到 client 的认证消息之前发送应用数据，任何在这个时间点发送的数据，当然都是在发送给一个未被认证的对端。</p><h2 id="New-Session-Ticket"><a href="#New-Session-Ticket" class="headerlink" title=" New Session Ticket "></a><font style="color:#4682B4"> New Session Ticket </font></h2><p>实际等同于发送 PSK 数据。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">shouldSendSessionTickets</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> hs.c.config.SessionTicketsDisabled &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t send tickets the client wouldn&#x27;t use. See RFC 8446, Section 4.2.9.</span></span><br><span class="line"><span class="keyword">for</span> _, pskMode := <span class="keyword">range</span> hs.clientHello.pskModes &#123;</span><br><span class="line"><span class="keyword">if</span> pskMode == pskModeDHE &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="tls" scheme="http://kiosk007.top/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>Git Quick Start</title>
    <link href="http://kiosk007.top/2020/12/19/Git-Quick-Start/"/>
    <id>http://kiosk007.top/2020/12/19/Git-Quick-Start/</id>
    <published>2020-12-19T11:11:00.000Z</published>
    <updated>2020-12-19T11:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>只是git入门的简单指南。没什么大不了的 :)</p><a id="more"></a><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br><img src="https://img1.kiosk007.top/static/images/git/git.png" style="height:340px"></p><p>参考: <a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><p><a href="https://git-scm.com/download/linux">安装 Git Linux 版</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install git</span><br><span class="line">$ apt-get install gitk</span><br></pre></td></tr></table></figure><br>gitk 是可以可视化的git客户端工具，更多工具参考 <a href="https://git-scm.com/download/gui/linux">git-gui</a> ，如 <a href="https://juejin.cn/post/6844903904451231757">Gitkraken (小章鱼)</a>、 <a href="https://magit.vc/manual/magit/Installing-from-the-Git-Repository.html#Installing-from-the-Git-Repository">magit</a> 等等</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li><strong>配置 user 信息</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name  <span class="string">&quot;your_name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;your_name@domain.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --local 只对某个分支有效</span></span><br><span class="line"><span class="comment"># --global 对当前用户所有仓库有效</span></span><br><span class="line"><span class="comment"># --system 对系统所有用户有效</span></span><br><span class="line"></span><br><span class="line">$ git config --global core.editor <span class="string">&quot;vim&quot;</span>    <span class="comment"># git 交互改为vim</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><strong>查看config的配置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>区域划分</p><ul><li><strong>工作区(Working Area)</strong>：当前工作目录</li><li><strong>暂存区(Staging Area)</strong> ：下次会被提交的部分</li><li><strong>本地仓库(Local Repository)</strong>：本地代码仓库，维护本地已提交的部分</li><li><strong>远程仓库本地镜像(Remote/Origin Repository)</strong>：远程仓库的一份本地副本，用于跟踪远程</li><li><strong>远程仓库(Remote Repository)</strong>：远程代码仓库</li></ul><p><img src="https://img1.kiosk007.top/static/images/git/git_workfull.png"></p><p>改动操作使得文件处于不同状态，git status可以查看改动的文件所处于的状态</p><ul><li><strong>未跟踪状态(Untracked)</strong>:  尚未被仓库管理的文件，即仓库里没有的文件</li><li><strong>已修改状态(Modified)</strong>：仓库里有，本地修改</li><li><strong>已暂存状态(Staged)</strong>:  仓库里有，本地修改并加入暂存，改动会被提交</li><li><strong>未修改状态(Unmodified)</strong>: 文件提交后由仓库管理，本地无修改</li></ul><h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><ul><li><font color="#EEB422"> 新建仓库 </font></li></ul><p>远程项目不存在时，本地初始化后上传</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;项目目录&gt;</span><br><span class="line">git init  //初始化，生成.git子目录</span><br><span class="line">git remote add origin &lt;项目git地址&gt;</span><br><span class="line">git add .  //当前目录下所有内容加入暂存区</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>远程项目已存在时，直接从远程下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;项目git地址&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;项目目录&gt;</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;add README&quot;</span>  //参数m表示提交信息</span><br><span class="line">git push -u origin master   //参数u表示关联远程分支</span><br></pre></td></tr></table></figure><h2 id="基本工作流"><a href="#基本工作流" class="headerlink" title="基本工作流"></a>基本工作流</h2><p><img src="https://img1.kiosk007.top/static/images/git/git_base_workflow.png"></p><ul><li><font color="#EEB422"> 添加和推送 </font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 使用如下命令：git add &lt;filename&gt; 或者 git add *</span><br><span class="line">2. 使用如下命令以实际提交改动：git commit -m <span class="string">&quot;代码提交信息&quot;</span></span><br><span class="line">3. 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</span><br></pre></td></tr></table></figure><ul><li><font color="#EEB422"> 添加和推送 </font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 通过git fetch把远程改动拉取到本地</span><br><span class="line">2. 将远程修改与本地融合merge/rebase</span><br><span class="line">- 基于merge: 合并远程和本地改动</span><br><span class="line">  - git pull等价于git fetch+git merge</span><br><span class="line">- 基于rebase: 以远程为基准，将本地修改操作重放</span><br><span class="line">  - git pull --rebase等价于git fetch+git rebase</span><br></pre></td></tr></table></figure><h2 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><img src="https://img1.kiosk007.top/static/images/git/branches.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 创建一个叫做“feature_x”的分支，并切换过去： git checkout -b feature_x</span><br><span class="line">- 切换回主分支： git checkout master</span><br><span class="line">- 删除分支： git branch -d feature_x</span><br><span class="line">- 将自己的分支推送到远端： git push origin &lt;branch&gt;</span><br><span class="line">- 删除远程分支：git push origin --delete &lt;分支名&gt; </span><br><span class="line">- 列出本地分支：git branch</span><br><span class="line">- 列出远程分支：git branch --remotes</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h2><ul><li><font color="#EEB422"> 删除文件 </font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 本地删除文件，删除动作不加入暂存区，此时提交库内文件不会被删除：rm &lt;文件&gt;</span><br><span class="line">- 本地删除文件，同时把删除动作加入暂存区: git rm，相当于rm &lt;文件&gt;+ git add &lt;文件&gt;</span><br><span class="line">- 希望删除仓库文件，但是本地文件依然保留，成为未跟踪状态：git rm --cached &lt;文件&gt;</span><br></pre></td></tr></table></figure><ul><li><font color="#FF8247">**基本命令**</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line">$ git mv old_filename new_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">$ git rm filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作区的状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为软件发布创建标签, 如v1.0.0</span></span><br><span class="line">$ git tag v1.0.0 1b2e1d63ff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看git提交后日志</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline     <span class="comment"># 一行显示</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 4          <span class="comment"># 查看最近的几次</span></span><br><span class="line">$ git <span class="built_in">log</span> --all --graph <span class="comment"># 以图形化方式显示所有的提交日志</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline --decorate --all  <span class="comment"># 通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签 </span></span><br><span class="line">$ git <span class="built_in">log</span> --author=bob  <span class="comment"># 只看某一个人的提交记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看 diff</span></span><br><span class="line">$ git diff              <span class="comment"># 对比工作区和暂存区的差异</span></span><br><span class="line">$ git diff --cached  <span class="comment"># 对比暂存区和HEAD所含文件(commit)的差异</span></span><br><span class="line">$ git diff -- style.css <span class="comment"># 只查看对某个文件的 diff 差异 (工作区和暂存区)</span></span><br><span class="line">$ git diff tmp master -- &lt;file&gt; <span class="comment"># 比较 tmp 和 master 分支的文件差异(也可以将branch改成commit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 取消提交</span></span><br><span class="line">$ git reset HEAD        <span class="comment"># 取消暂存 （取消 git add）</span></span><br><span class="line">$ git restore --staged &lt;file&gt;  <span class="comment"># 功能同上, 取消暂存 （可以 git status 查看当前的暂存状态）</span></span><br><span class="line"></span><br><span class="line">$ git checkout -- &lt;file&gt;      <span class="comment"># 在工作区的修改撤销到最近一次git add 或 git commit时的内容</span></span><br><span class="line">$ git reset --hard c04b46549  <span class="comment"># 恢复到历史上的某个 commit (工作区和暂存区都会清空)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><font color="#FF8247"> 版本管理 </font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">$ git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于某个历史版本创建分支(基于 ac886ae 创建一个tmp分支)</span></span><br><span class="line">$ git checkout -b tmp ac886ae </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个分支</span></span><br><span class="line">$ git checkout -d ac886ae  <span class="comment"># 没有merge的分支不能通过 -d 删除</span></span><br><span class="line">$ git checkout -D ac886ae</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###################### commit 相关 ###########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最近一次提交的 commit 信息</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改前几次提交的 commit 信息</span></span><br><span class="line">$ git rebase -i ac224ct   <span class="comment"># 交互式操作，ac224ct 是要修改的commit的父commit</span></span><br><span class="line">将pick改为r  :wq退出，</span><br><span class="line">变更内容     :wq退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="git常见使用"><a href="#git常见使用" class="headerlink" title="git常见使用"></a>git常见使用</h1><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a><font color="#FF4500"><strong>分离头指针</strong></font></h2><p>通常，我们工作在某一个分支上，比如 master 分支。这个时候 master 指针和 HEAD 指针是一起前进的，每做一次提交，这两个指针就会一起向前挪一步。但是在某种情况下（例如 checkout 了某个具体的 commit），master 指针 和 HEAD 指针这种「绑定」的状态就被打破了，变成了分离头指针状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜ git checkout fb7d808</span><br><span class="line">注意：正在切换到 <span class="string">&#x27;fb7d808&#x27;</span>。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 <span class="literal">false</span> 来关闭此建议</span><br><span class="line"></span><br><span class="line">HEAD 目前位于 fb7d808 Learn CSS demo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git 在对于这种没有 branch 的变更会被清除掉。所以如果想要变更最好跟着分支进行变更。</p><h2 id="git-stash-命令实用指南"><a href="#git-stash-命令实用指南" class="headerlink" title="git stash 命令实用指南"></a>git stash 命令实用指南</h2><p>为什么 git stash 很重要，假设Git没有暂存变更命令，当你在有2个分支（A和B）的仓库上工作时，假设这两个分支已经分叉很长时间，并且有不同的头，当你处理A的时候，团队要求修复B分支的一个错误，你迅速将你的修改保存到A分支(但没有提交 commit),并且尝试用 <code>git checkout B</code> 来切到B分支，git 会立即终止这个操作，并报错。“你对以下文件的本地修改会被签出覆盖… …请在切换分之前提交你的修改或者将他们暂存起来”</p><p>在这种情况下有几种方法来分支切换。</p><ul><li>在分支A中创建一个提交（git switch -c），提交并推送你的修改，以修复 B 中的错误。然后签出A，并运行 <code>git reset HEAD</code>, 来恢复修改。</li><li>手动保留不被Git 追踪文件中的改动。</li></ul><p>第二种就不说了，一点也不极客。第一种方法虽然看起来很传统，但是不灵活，因为保存未完成工作的修改会被当做一个检查点，而不是一个仍在进行中的补丁。这就是 <code>git stash</code> 的场景。</p><p><code>git stash</code> 将未提交的改动保存在本地，让你可以进行修改，切换分支及其他的操作。然后当你需要的时候，你可以重新应用这些存储的改动。暂存是本地范围的，不会被<code>git push</code> 推送的远端。</p><p>以下是一次 <code>git stash</code> 的操作顺序</p><ol><li>将修改保存到分支A</li><li>运行 <code>git stash</code></li><li>签出分支B</li><li>修正B分支的错误</li><li>提交并推送到远程</li><li>查看分支A</li><li>运行 <code>git stash pop</code> 来取回暂存的改动。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现将工作区的内容保存到暂存区</span></span><br><span class="line">$ git add *</span><br><span class="line"><span class="comment"># 将暂存区的内容 暂时保存</span></span><br><span class="line">$ git stash   </span><br><span class="line">$ git stash save <span class="string">&quot;message&quot;</span>   <span class="comment"># 功能同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切到历史版本修复bug ... </span></span><br><span class="line"></span><br><span class="line">$ git stash apply  <span class="comment"># 将临时保存区的内容恢复，但不会删除记录，pop会删除。</span></span><br><span class="line">$ git stash pop </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title=" cherry pick "></a><font color="#FF4500"> cherry pick </font></h2><p>假设你在一个分支上已经做了很多次提交，但你意识到这个分支是错误的，该怎么办。<br>要么切换到正确的分支重复所有的变更。然后重新提交。要么呢就要用到 <code>cherry pick</code> 这个工具。</p><p><code>git cherry-pick</code> 可以将相同的commit提交复制到另一个分支上。就没有必要在不同的分支上做相同的操作。</p><blockquote><p>注意：<code>cherry-pick</code> 出来的提交会在另一个分支中创建带有新hash的提交，</p></blockquote><ul><li>它是如何工作的</li></ul><p>假设有2个分支，<code>toC</code> 和 <code>toB</code>, 现在有个bug在2个版本上都存在。我们在<code>toC</code> 分支上已经修复了这个bug。在 <code>toC</code>分支上运行<code>git log</code>命令，获取这次提交的 hash 值, 简单起见复制 25560 即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 255604842840febb7e11bbb443013fa584e76219 (HEAD -&gt; master, tag: v1.0.1, origin/master, origin/HEAD)</span><br><span class="line">Author: igolaizola &lt;11333576+igolaizola@users.noreply.github.com&gt;</span><br><span class="line">Date:   Thu Sep 26 09:31:17 2019 +0200</span><br></pre></td></tr></table></figure><br>然后切换到<code>toB</code>分支上，将刚刚的bugfix提交合入。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout toB</span><br><span class="line">$ git cherry-pick 25560</span><br></pre></td></tr></table></figure></p><ul><li><p>如果遇到了 “nothing to commit,working tree clean The previous cherry-pick is now empty,possibly due to conflict resolution” 不要惊慌，按照建议运行 <code>git commit --allow-empty</code> 即可。这个将打开你的编辑器，编辑提交信息即可。</p></li><li><p>如果遇到了合并重提，解决冲突后，输入 <code>git cherry-pick --continue</code> 恢复。</p></li></ul><p>参考: <a href="https://mp.weixin.qq.com/s/J7sVxIoIVClEirClBQoUtA">https://mp.weixin.qq.com/s/J7sVxIoIVClEirClBQoUtA</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/156726632">https://zhuanlan.zhihu.com/p/156726632</a></p><h2 id="指定文件不需要git管理"><a href="#指定文件不需要git管理" class="headerlink" title="指定文件不需要git管理"></a><font color="#FF4500"><strong>指定文件不需要git管理</strong></font></h2><p>在项目根目录下创建 <strong><code>.gitignore</code></strong> ,写入不需管理的文件名即可</p><h2 id="Git创建本地分支并关联远程分支"><a href="#Git创建本地分支并关联远程分支" class="headerlink" title="Git创建本地分支并关联远程分支"></a><font color="#FF4500"><strong><code>Git创建本地分支并关联远程分支</code></strong></font></h2><p>当我想从远程仓库里拉取一条本地不存在的分支时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><p>如果出现以下报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#39;dev2&#39; at the same time.</span><br><span class="line">Did you intend to checkout &#39;origin&#x2F;dev2&#39; which can not be resolved as commit?</span><br></pre></td></tr></table></figure><br>表示拉取不成功。我们需要先执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br></pre></td></tr></table></figure><br>再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><p>修改之后再推送的话，可以执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --set-upstream origin 远程分支名</span><br></pre></td></tr></table></figure></p><h1 id="git目录功能"><a href="#git目录功能" class="headerlink" title=".git目录功能"></a>.git目录功能</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ .git git:(master) ls   </span><br><span class="line">branches  COMMIT_EDITMSG  config  description  gitk.cache  HEAD  hooks  index  info  logs  objects  refs</span><br></pre></td></tr></table></figure><ul><li><code>HEAD</code>: 当前工作的分支</li><li><code>config</code>: 配置信息，包含着 repository 的配置，包括 remote 的地址，提交时的 email、 username 等等.</li><li><code>refs</code>: 这个目录一般包括三个子文件夹：heads、remotes和tags，heads中的文件标识了项目中的各个分支指向的当前commit</li><li><code>info</code>: 包含仓库的一些信息</li><li><code>hooks</code>: 这个目录存放一些shell脚本，可以设置特定的git命令后出发相应的脚本；在搭建gitweb系统或其他git托管系统会经常用到hook script</li><li><code>logs</code>: 保存所有更新的引用记录</li><li><code>index</code>: 这个文件就是暂存区（stage），是一个二进制文件</li><li><code>description</code>: 仓库的描述信息，主要给gitweb等git托管系统使用</li><li><code>objects</code>: 所有的Git对象都会存放在这个目录中，对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名</li></ul><p>git 中的对象如下图所示，每一个 commit 提交都会包含 tree、committer、blob。其中committer是提交者，tree可粗略理解为目录，blob为文件。<br><img src="https://img1.kiosk007.top/static/images/git/git_commit_tree_blob.png" style="height:350px"></p><p>比如查看一次 commit<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看一次 commit</span></span><br><span class="line">$ git cat-file -p ac886ae797a9ee60962461b50993bc2bd09920fd</span><br><span class="line">tree 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">parent 4f41c2512ce8fcfbde05622c4d0cd75f14708a84</span><br><span class="line">author orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line">committer orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line"></span><br><span class="line">Add CS JS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该commit中的 tree</span></span><br><span class="line">$ git cat-file -p 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">100644 blob dac138d9e013a2e9a10e67d793bd4703c1b86bd1index.css</span><br><span class="line">100644 blob e1d99bb43375f52095059d6d79a9c6d3045c048bindex.html</span><br><span class="line">100644 blob 7b4dcb5b597195d0469fec0787c2a7b7a4656d81index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该tree中的blob</span></span><br><span class="line">$ git cat-file -p 7b4dcb5b597195d0469fec0787c2a7b7a4656d81</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">&quot;My First JavaScript&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="git-备份"><a href="#git-备份" class="headerlink" title="git 备份"></a>git 备份</h1><p><img src="https://img1.kiosk007.top/static/images/git/git_transport.webp" style="height:400px"></p><p>前两个协议是本地协议，后两个是远端托管平台。<br>哑协议传输进度不可见，智能协议传输可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个文件仓库 clone</span></span><br><span class="line"><span class="comment"># 哑协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare /home/kiosk/Project/Git/kiosk_demo/.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 智能协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare file:///home/kiosk/Project/Git/kiosk_demo/.git</span><br></pre></td></tr></table></figure><ul><li><font color="#FF8C00">**创建远程**</font></li></ul><p>可以使用 git remote add 命令将远程 URL 与名称匹配，例如<br><strong><code>git remote add origin  &lt;REMOTE_URL&gt;</code></strong><br>这会将名称 origin 与 REMOTE_URL 关联。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/user/repo.git</span><br><span class="line"><span class="comment"># Set a new remote</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># Verify new remote</span></span><br><span class="line">&gt; origin  https://github.com/user/repo.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/user/repo.git (push)</span><br></pre></td></tr></table></figure><p>远程 name 已存在,此错误消息表示您尝试添加的远程与本地仓库中的远程名称相同。可以尝试修改远程名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 查看现有远程</span></span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote rename origin destination</span><br><span class="line"><span class="comment"># 将远程名称从 &#x27;origin&#x27; 更改为 &#x27;destination&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 验证远程的新名称</span></span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (push)</span><br></pre></td></tr></table></figure><p>若远程的url发生了变化，可以通过<br><strong><code>git remote set-url origin https://github.com/USERNAME/REPOSITORY.git</code></strong><br>修改</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;只是git入门的简单指南。没什么大不了的 :)&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://kiosk007.top/categories/git/"/>
    
    
  </entry>
  
</feed>
