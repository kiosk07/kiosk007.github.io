<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kiosk007&#39;s Blog</title>
  
  <subtitle>专注! 量变产生质变 !</subtitle>
  <link href="http://kiosk007.top/atom.xml" rel="self"/>
  
  <link href="http://kiosk007.top/"/>
  <updated>2021-01-23T02:33:00.000Z</updated>
  <id>http://kiosk007.top/</id>
  
  <author>
    <name>kiosk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>探索 Webtransport</title>
    <link href="http://kiosk007.top/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/"/>
    <id>http://kiosk007.top/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/</id>
    <published>2021-01-23T02:33:00.000Z</published>
    <updated>2021-01-23T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://wicg.github.io/web-transport/">WebTransport</a> 是一个新一代的浏览器API，提供客户端-服务端之间的双向低延迟交互，并在顶部使用常见 API 来实现其下的可插拔协议（<font style="color:#FF7F50">尤其是基于<a style="color:#FF7F50" href=" https://www.chromium.org/quic">QUIC</a></font>）。该 API 与 WebSocket 相似，也是客户端和服务器的双向连接，但允许进一步减少客户端和服务器之间的网络通信延迟，并且还支持多个流、单向流、乱序和不可靠传输。基于QUIC的Webtransport (Quictransport)即支持通过 datagram API 发送不可靠的数据，也支持通过 stream API 实现可靠数据传输。</p><p>使用场景包括使用不可靠且乱序的消息向服务器重复发送低延迟的游戏状态、从服务器到客户端的媒体片段的低延迟传输以及大多数逻辑在服务器上运行的云场景。</p><p>WebTransport 提案详细介绍：<font style="color:#FF7F50"> <a href="https://wicg.github.io/web-transport/">https://wicg.github.io/web-transport/</a> </font></p><p><strong>重点</strong></p><ol><li>Webtransport 支持不可靠传输，通过轻量级、低延迟的UDP协议传输。</li><li>Webtransport 可基于 QUIC 实现 Client-Server 可靠的流式传输。</li><li>可支持多条流的相互独立 + QUIC 多路复用\非队头阻塞特性 完美代替当前的 Websocket。Webtransport 提供了一些当前websocket规范不可能提供的功能。可消除当前多个数据包之间的队头阻塞。</li></ol><p><strong>标准规范</strong></p><ol><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-overview-01"> WebTransport overview </a> : Webtransport 的概述及对传输层的要求。</li><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-quic"> WebTransport over QUIC</a> : 定义了基于QUIC的 Webtransport</li><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-http3-02"> WebTransport over HTTP/3 </a>: 定义了基于HTTP/3的 Webtransport （实际上 HTTP/3 也是基于QUIC的）</li></ol><p>当前 Chrome 团队只实现了基于 QUIC 的 Webtransport 。然而目前也仅仅是实验性的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transport = <span class="keyword">new</span> QuicTransport(<span class="string">&#x27;quic-transport://localhost:4433/path&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Webtransport draft 标明是支持TCP的， 但显然目前大家都在UDP上了投入了大量精力，也主要是以UDP去实现的。</p><img src="/images/network/WebTransport/common_transport_requirements.png"><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>当前的Webtransport 必须基于 QUIC draft-29 或更高版本。客户端主要以 chrome 浏览器为主，版本必须 &gt;= 85 。服务端我们将基于 <a href="github.com/lucas-clemente/quic-go" style="color:#FF7F50"> github.com/lucas-clemente/quic-go </a>  go library 。因为是本地测试，我们还需要签发一个自签名证书。</p><h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>因为当前Webtransport的底层实现是基于 QUIC or HTTP/3 ，所以我们必须要实现自签名证书，确保通信过程的安全性。这里我们使用的是 <code>openssl</code> </p><p>首先需要确保你的 <code>openssl</code> 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ <span class="built_in">which</span> openssl</span><br><span class="line">/usr/bin/openssl</span><br><span class="line">➜ openssl version</span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建证书和私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl req -newkey rsa:2048 -nodes -keyout certificate.key \</span><br><span class="line">-x509 -out certificate.pem -subj <span class="string">&#x27;/CN=Test Certificate&#x27;</span> \</span><br><span class="line">-addext <span class="string">&quot;subjectAltName = DNS:localhost&quot;</span></span><br></pre></td></tr></table></figure><p>计算证书的指纹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl x509 -pubkey -noout -<span class="keyword">in</span> certificate.pem |</span><br><span class="line">openssl rsa -pubin -outform der |</span><br><span class="line">openssl dgst -sha256 -binary | base64</span><br><span class="line"><span class="comment">#      The result should be a base64-encoded blob that looks like this:</span></span><br><span class="line"><span class="comment">#          &quot;Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=&quot;</span></span><br></pre></td></tr></table></figure><p>向chrome传入参数指明允许使用自签证书的服务端地址+端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--origin-to-force-quic-on=localhost:4433</span><br></pre></td></tr></table></figure><p>使用如下参数以信任证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ignore-certificate-errors-spki-list=Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=</span><br></pre></td></tr></table></figure><p>更多可以参考： <a href="https://www.chromium.org/developers/how-tos/run-chromium-with-flags">docs on how to run Chrome/Chromium with custom flags.</a></p><p>最后打开 <a style="color:#FF7F50" href="https://googlechrome.github.io/samples/webtransport/client.html">https://googlechrome.github.io/samples/webtransport/client.html</a></p><img src="/images/network/WebTransport/webtransport_client.png" style="height:550px"><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>我们使用 github.com/lucas-clemente/quic-go 来实现QUIC。</p><p>Run 方法来实现接受客户端的连接请求。quic.ListenAddr 创建一个监听器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   listener, err := quic.ListenAddr(s.config.ListenAddr, s.generateTLSConfig(), s.generateQUICConfig())</span><br><span class="line">   utils.Logging.Info().Err(err)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;WebTransport Engine v0.1 Start ...&quot;</span>)</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;Listening for %s connections on %s&quot;</span>,<span class="string">&quot;udp&quot;</span>, s.config.ListenAddr)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      session, err := listener.Accept(context.Background())</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      utils.Logging.Info().Msgf(<span class="string">&quot;session accepted: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _ = session.CloseWithError(<span class="number">0</span>, <span class="string">&quot;bye&quot;</span>)</span><br><span class="line">            utils.Logging.Info().Msgf(<span class="string">&quot;close session: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line">         &#125;()</span><br><span class="line">         s.handleSession(session)</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端需要在 ALPN 中携带 alpnQuicTransport = “wq-vvv-01” 服务端读取后就会针对开始Webtransport 传输。<br><img src="/images/network/WebTransport/wq-vvv-01_alpn.png" style="height:550px"></p><p>代码参见：<a href="https://github.com/weijiaxiang007/webtransport/" style="color:#FF7F50"> https://github.com/weijiaxiang007/webtransport/ </a></p><h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p><font style="color:#6495ED">QUIC使用流ID的最低两位指示流标识以下信息</font></p><ol><li><p>单向 or 双向流</p></li><li><p>由客户端 or 服务端发起。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+----------------------------------+</span><br><span class="line">| Bits | Stream Type                      |</span><br><span class="line">+======+==================================+</span><br><span class="line">| 0x0  | Client-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x1  | Server-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x2  | Client-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x3  | Server-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br></pre></td></tr></table></figure></li></ol><ul><li>对于每一个双向流，流的发起方和流的接收方均可以在一条双向流上传输数据。</li><li>对于每一条单向流，只能是流的发起方向流的接收方发送数据。接收方可以在一条新的单向流上回复数据。</li><li>对于数据报格式的数据，由于 quic-go 底层不支持，这里不再赘述。不过已经有相关的提交去支持 <a href="https://github.com/lucas-clemente/quic-go/pull/2162" style="color:#FF7F50"> https://github.com/lucas-clemente/quic-go/pull/2162 </a></li></ul><p>更多信息参见：<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1" style="color:#FF7F50">https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1</a></p><p><font style="color:#6495ED">客户端请求</font><br>客户端请求一般 按照 Key – Value 的方式携带请求的资源标识。如下是请求的 Origin 和 Path。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientIndicationKey <span class="keyword">int16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   clientIndicationKeyOrigin clientIndicationKey = <span class="number">0</span></span><br><span class="line">   clientIndicationKeyPath                       = <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Key (16)            |          Length (16)          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Value (*)                         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>这里只实现了双向流，可以看到双向流建立之前会先建立一个单向流用于认证信息。之后的数据会在双向流上传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">handleSession</span><span class="params">(sess quic.Session)</span></span> &#123;</span><br><span class="line">stream, err := sess.AcceptUniStream(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utils.Logging.Info().Msgf(<span class="string">&quot;unidirectional stream accepted, id: %d&quot;</span>, stream.StreamID())</span><br><span class="line">indication, err := receiveClientIndication(stream)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utils.Logging.Info().Msgf(<span class="string">&quot;client indication: %+v&quot;</span>, indication)</span><br><span class="line"><span class="keyword">if</span> err := s.validateClientIndication(indication); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = s.communicate(sess)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="QUIC" scheme="http://kiosk007.top/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>Go Reflect </title>
    <link href="http://kiosk007.top/2021/01/18/Go-Reflect/"/>
    <id>http://kiosk007.top/2021/01/18/Go-Reflect/</id>
    <published>2021-01-18T15:57:00.000Z</published>
    <updated>2021-01-18T15:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言标准库 <a href="https://golang.org/pkg/reflect/">reflect</a> 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。</p><a id="more"></a><h1 id="类型和接口-Types-and-interfaces"><a href="#类型和接口-Types-and-interfaces" class="headerlink" title="类型和接口 (Types and interfaces)"></a>类型和接口 (Types and interfaces)</h1><p>因为反射是建立在类型之上的，所以想要了解反射必须先知道Go 语言中所有的变量都有一个静态类型。例如 <code>int</code>、<code>[]byte</code>、<code>float32</code>、<code>*MyType</code>等等。<br>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure><p>接口是一种特殊的类型，它表示固定的方法集。接口变量可以存储任何具体（非接口）值,只要该值实现接口的方法。最经典的例子便是 io.Reader \ io.Writer 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人说Go的接口是动态类型的，但这是误导。它们是静态类型。一个特殊的例子是空接口，即 <code>interface&#123;&#125;</code>。</p><p>在这个例子中。<font style="color:#00008B">os.OpenFile</font> 的返回参数tty的类型是 <code>*os.File</code>，由于 <code>*os.File</code> 实现了 <font style="color:#00008B">Read()</font> 方法，所以该类型可以被赋于类型 io.Reader (io.Reader是一个interface)。尽管 <code> *os.File</code> 实现了很多方法，但是变量r仅有一个方法Read。但内部的值仍包含有关该值的所有类型信息。这就是为什么我们可以做 <code>w=r.(io.Writer)</code> 的原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>) <span class="comment">// tty *os.File</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> &#125;</span><br><span class="line">r = tty</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer    </span><br><span class="line">w = r.(io.Writer)  <span class="comment">// 由于r实际内部是有Write方法的，所以r可以被断言成 io.Writer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;12345&quot;</span>));err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">_ = tty.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以继续执行下面的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br><span class="line">fmt.Println(reflect.TypeOf(empty))</span><br></pre></td></tr></table></figure><h2 id="反射基本用法"><a href="#反射基本用法" class="headerlink" title="反射基本用法"></a>反射基本用法</h2><h3 id="从接口值到反射对象"><a href="#从接口值到反射对象" class="headerlink" title="从接口值到反射对象"></a><font style="color:#483D8B"><strong>从接口值到反射对象</strong></font></h3><p>ValueOf用来获取输入参数接口中的数据的值。如果是空接口则返回 invalid 。<br>TypeOf用来动态获取输入参数接口中的值的类型，如果空接口则返回nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>,reflect.TypeOf(num))     <span class="comment">// type:  float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>,reflect.ValueOf(num))   <span class="comment">// value:  1.2345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以判断类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(v)</span><br><span class="line"><span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line">fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;   <span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从反射对象到接口值"><a href="#从反射对象到接口值" class="headerlink" title="从反射对象到接口值"></a><font style="color:#483D8B"><strong>从反射对象到接口值</strong></font></h3><p>go 提供了反射和反射的逆，可以通过 <code>.(type)</code> 断言的方式将一个Interface()转成他真正的类型。如果断言的类型不匹配，会发生panic。</p><p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p><table><thead><tr><th>方法名</th><th>说 明</th></tr></thead><tbody><tr><td>Interface() interface{}</td><td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td>Int() int64</td><td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td>Uint() uint64</td><td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td>Float() float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td>Bool() bool</td><td>将值以 bool 类型返回</td></tr><tr><td>Bytes() []bytes</td><td>将值以字节数组 []bytes 类型返回</td></tr><tr><td>String() string</td><td>将值以字符串类型返回</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi <span class="keyword">float64</span></span><br><span class="line">pi = <span class="number">3.1415926</span></span><br><span class="line">v := reflect.ValueOf(pi)</span><br><span class="line">y := v.Interface().(<span class="keyword">float64</span>) <span class="comment">// y will have type float64.</span></span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></table></figure><h3 id="要修改反射对象，该值必须可设置"><a href="#要修改反射对象，该值必须可设置" class="headerlink" title="要修改反射对象，该值必须可设置"></a><font style="color:#483D8B"><strong>要修改反射对象，该值必须可设置</strong></font></h3><p>如果运行下面的代码将会 <font style="color:#8B0000"> panic </font> ，这时因为 v 是不可设置的。</p><table><thead><tr><th>方法名</th><th>备  注</th></tr></thead><tbody><tr><td>Elem() Value</td><td>取值指向的元素值，类似于语言层*操作</td></tr><tr><td>Addr() Value</td><td>对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机</td></tr><tr><td>CanAddr() bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet() bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>通过 <code>CanSet()</code> 即可判断，<code>CanSet()</code> 报告 v 的值是否可以改变。值只能在可寻址的情况下更改，并且不能通过使用未导出的结构字段获取。如果 CanSet 返回 false ，则调用 Set 或任何类型特定的 setter （例如 SetBool ，SetInt ）将会发生panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><p>v 不可寻址，因为 v 只是 x 的拷贝，即便把 x 换成 &amp;x,还是不可寻址，因为 <code>reflect.ValueOf(&amp;x)</code> 也仅仅是 x 指针的拷贝。实际上，所有通过 <code>reflect.ValueOf(x)</code> 返回的 reflect.Value 都是不可取地址的。但是通过调用 <code>reflect.ValueOf(&amp;x).Elem()</code>，来获取任意变量x对应的可取地址的 Value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span></span><br><span class="line">x = <span class="number">3.1415</span></span><br><span class="line">pv := reflect.ValueOf(&amp;x)</span><br><span class="line">pv = pv.Elem()</span><br><span class="line">pv.SetFloat(<span class="number">7.1</span>) </span><br><span class="line"></span><br><span class="line">fmt.Println(x)   <span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure><h2 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h2><p>| 方法  | 说明 |<br>| –   |  –  |<br>| Field(i int) StructField |    根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生panic |<br>| NumField() int |    返回结构体成员字段数量。当类型不是结构体或索引超界时发生panic |<br>| FieldByName(name string) (StructField, bool) | 根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生 panic |<br>| FieldByIndex(index []int) StructField | 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时发生 panic |<br>| FieldByNameFunc( match func(string) bool) (StructField,bool)    | 根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生panic |</p><h3 id="普通结构体"><a href="#普通结构体" class="headerlink" title="普通结构体"></a>普通结构体</h3><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>假设有以下 <code>User struct</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int</span></span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Work    Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">Id           <span class="keyword">int</span></span><br><span class="line">Occupation   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;My Id :%d ,My Name :%s ,My Occupation :%s&quot;</span>,u.Id,u.Name,u.Work.Occupation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFuncHasArgs</span><span class="params">(foo <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;This is number %d \n&quot;</span>, foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来演示的是如何通过反射区打印结构体中的所有对象、打印结构体中的所有字段、调用方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">Work: Worker&#123;</span><br><span class="line">Id: <span class="number">1</span>,</span><br><span class="line">Occupation: <span class="string">&quot;farmer&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(user)</span><br><span class="line">fmt.Println(<span class="string">&quot;get type is: &quot;</span>,getType.Name())  <span class="comment">// get type is:  User</span></span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line">fmt.Println(<span class="string">&quot;get all Fields is &quot;</span>, getValue) <span class="comment">// get all Fields is  &#123;1 Kiosk &#123;1 farmer&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字段进行遍历 获取方法的字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumField();i++ &#123;</span><br><span class="line">field := getType.Field(i)</span><br><span class="line">value := getValue.Field(i).Interface()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: %v = %v \n&quot;</span>,field.Name,field.Type,value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Id: int = 1</span></span><br><span class="line"><span class="comment">Name: string = Kiosk</span></span><br><span class="line"><span class="comment">Work: main.Worker = &#123;1 farmer&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumMethod();i++ &#123;</span><br><span class="line">m := getType.Method(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s : %v\n&quot;</span>,m.Name,m.Type)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ReflectCallFunc : func(main.User)</span></span><br><span class="line"><span class="comment">   ReflectCallFuncHasArgs : func(main.User, int)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="comment">// 有参数调用</span></span><br><span class="line">methodValue := getValue.MethodByName(<span class="string">&quot;ReflectCallFuncHasArgs&quot;</span>)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(<span class="number">2</span>)&#125;</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is number 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数调用</span></span><br><span class="line">methodValue = getValue.MethodByName(<span class="string">&quot;ReflectCallFunc&quot;</span>)</span><br><span class="line">args = <span class="built_in">make</span>([]reflect.Value,<span class="number">0</span>)</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">My Id :1 ,My Name :Kiosk ,My Occupation :farmer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带tag的struct"><a href="#带tag的struct" class="headerlink" title="带tag的struct"></a>带tag的struct</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int</span> <span class="string">`json:&quot;id&quot;   bson:&quot;id&quot;`</span></span><br><span class="line">Name    <span class="keyword">string</span><span class="string">`json:&quot;name&quot; bson:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(user)</span><br><span class="line">fmt.Printf(<span class="string">&quot;get type is: %v \n&quot;</span>,getType.String())  <span class="comment">// get type is:  main.User</span></span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line">fmt.Println(getValue) <span class="comment">// &#123;1 Kiosk&#125;</span></span><br><span class="line"></span><br><span class="line">name := getValue.FieldByName(getType.Field(<span class="number">1</span>).Name).String()</span><br><span class="line">fmt.Printf(<span class="string">&quot;name is %s \n&quot;</span>, name)  <span class="comment">// name is Kiosk</span></span><br><span class="line"></span><br><span class="line">tag := getType.Field(<span class="number">0</span>).Tag</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %v  tag: &#x27;%v&#x27;\n&quot;</span>, getType.Field(<span class="number">0</span>).Name, tag) <span class="comment">// name: Id  tag: &#x27;json:&quot;id&quot;   bson:&quot;id&quot;&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;tag is %s, %s \n&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), tag.Get(<span class="string">&quot;bson&quot;</span>)) <span class="comment">//  tag is id, id </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断反射值的有效性和空"><a href="#判断反射值的有效性和空" class="headerlink" title="判断反射值的有效性和空"></a>判断反射值的有效性和空</h2><p>IsNil()和IsValid() – 判断反射值的空和有效性</p><p>反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。</p><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>IsNil() bool</td><td>返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的v== nil操作</td></tr><tr><td>IsValid() bool</td><td>判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*int的空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;var a *int:&quot;</span>, reflect.ValueOf(a).IsNil())  </span><br><span class="line">    <span class="comment">// var a *int: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//nil值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;nil:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid()) </span><br><span class="line">    <span class="comment">// nil: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*int类型的空指针</span></span><br><span class="line">fmt.Println(<span class="string">&quot;(*int)(nil):&quot;</span>, reflect.ValueOf((*<span class="keyword">int</span>)(<span class="literal">nil</span>)).Elem().IsValid()) </span><br><span class="line">    <span class="comment">// (*int)(nil): false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个结构体</span></span><br><span class="line">s := <span class="keyword">struct</span> &#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从结构体中查找一个不存在的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(s).FieldByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的结构体成员: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从结构体中查找一个不存在的方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的方法:&quot;</span>, reflect.ValueOf(s).MethodByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的方法: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个map</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的键:&quot;</span>, reflect.ValueOf(m).MapIndex(reflect.ValueOf(<span class="number">3</span>)).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的键: false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 语言标准库 &lt;a href=&quot;https://golang.org/pkg/reflect/&quot;&gt;reflect&lt;/a&gt; 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。&lt;/p&gt;</summary>
    
    
    
    <category term="programming" scheme="http://kiosk007.top/categories/programming/"/>
    
    
    <category term="Go" scheme="http://kiosk007.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>TLS详解（三）</title>
    <link href="http://kiosk007.top/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://kiosk007.top/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-01-16T08:48:00.000Z</published>
    <updated>2021-01-16T08:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。</p><a id="more"></a><ul><li><a href="https://www.kiosk007.top/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/">TLS 详解一</a></li><li><a href="https://www.kiosk007.top/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/">TLS 详解二</a></li></ul><h1 id="TLS1-3-Feature"><a href="#TLS1-3-Feature" class="headerlink" title="TLS1.3 Feature"></a>TLS1.3 Feature</h1><ul><li><font color="#7B68EE">Speed Benefits of TLS 1.3</font></li></ul><p>TLS1.3 可以使用1RTT建立握手，比1.2版本能节约一个网络来回。</p><img style="height:300px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-performance.png"><ul><li><font color="#7B68EE">Improved Security With TLS 1.3</font></li></ul><p>TLS1.3 移除了RC4、DES、MD5 等诸多脆弱不安全的算法，目前仅保持了支持AEAD的ECDH类等算法。</p><ul><li><font color="#7B68EE"> 1.3 Browser Support</font></li></ul><p>从 Chrome65 开始，Google公司就可以支持 <a href="http://www.chromium.org/Home/tls13">draft version of TLS 1.3 </a> , 2018年10月的 Chrome70 就完全支持了TLS1.3。同样Firefox63也在同年10月支持了TLS1.3。Microsoft Edge version 76 及 Safari 12.1 on macOS 10.14.4. 也都支持了TLS1.3 。</p><h1 id="The-TLS-handshake"><a href="#The-TLS-handshake" class="headerlink" title="The TLS handshake"></a>The TLS handshake</h1><p>总体握手流程如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">handshake</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c := hs.c</span><br><span class="line"></span><br><span class="line"><span class="comment">// For an overview of the TLS 1.3 handshake, see RFC 8446, Section 2.</span></span><br><span class="line"><span class="keyword">if</span> err := hs.processClientHello(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.checkForResumption(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.pickCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">c.buffering = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerParameters(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="comment">// Note that at this point we could start sending application data without</span></span><br><span class="line"><span class="comment">// waiting for the client&#x27;s second flight, but the application might not</span></span><br><span class="line"><span class="comment">// expect the lack of replay protection of the ClientHello parameters.</span></span><br><span class="line"><span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err  &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.readClientCertificate(); err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> err  &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.readClientFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"></span><br><span class="line">atomic.StoreUint32(&amp;c.handshakeStatus, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/network/TLSDetailAnalysis/tls-1.3.png"><h2 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a><font style="color:#4682B4">Client Hello</font></h2><p>由于TLS1.2已经在互联网上存在了10年。网络中大量的网络中间设备都十分老旧，这些网络设备会识别中间的TLS握手头部，所以TLS1.3的出现如果引入了未知的TLS Version 必然会存在大量的握手失败，为了解决这一点，TLS1.3 的握手头部默认是TLS1.2。</p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-clienthello.png"><p>如果客户端支持TLS1.3 则在 <strong><font style="color:#483D8B">Client Hello</font></strong> 发出时在Extensions中携带 supported_versions 并标明客户端是支持TLS1.3的，同样为了1RTT快速握手，会将客户端Key_share 发送给服务端。Key_Share是客户端提前生成好的公钥信息。其密钥派生过程依赖于密码套件的 HKDF Extract 和 HKDF Expand 函数以及 Hash函数。</p><p>在密钥交换之前，客户端和服务端使用HKDF生成密钥。（它取代了基于HMAC的伪随机密钥生成函数PRF。</p><p>下面用代码过一遍客户端的Client Hello流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> params ecdheParameters</span><br><span class="line"><span class="keyword">if</span> hello.supportedVersions[<span class="number">0</span>] == VersionTLS13 &#123;</span><br><span class="line">hello.cipherSuites = <span class="built_in">append</span>(hello.cipherSuites, defaultCipherSuitesTLS13()...)</span><br><span class="line"></span><br><span class="line">curveID := config.curvePreferences()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> _, ok := curveForCurveID(curveID); curveID != X25519 &amp;&amp; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;tls: CurvePreferences includes unsupported curve&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">params, err = generateECDHEParameters(config.rand(), curveID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">hello.keyShares = []keyShare&#123;&#123;group: curveID, data: params.PublicKey()&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，如果客户端是支持  <font style="color:#483D8B">VersionTLS13</font>, 则在创建 <font style="color:#483D8B"> Client Hello </font> 时,添加TLS1.3支持的秘钥套件，并使用 x25519 曲线和随机数生成 <font style="color:#483D8B"> PublickKey </font>放入 <font style="color:#483D8B"> Client Hello Extension</font> 中的 <font style="color:#483D8B"> KeyShares </font> 中。</p><h2 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a><font style="color:#4682B4">Server Hello</font></h2><p>服务端的TLS Version仍为TLS1.2（实际上后续的TLS版本均为1.2），如果服务端支持TLS1.3，则会在  <font style="color:#483D8B">supported_versions</font> 中的携带TLS1.3，这样后续的会话便均在TLS1.3下通信。</p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-serverhello.png"><p>服务端会在<font style="color:#483D8B"> Server Hello </font> 中的 <font style="color:#483D8B"> key_share </font> 中携带公钥信息。</p><p>下面是完整的握手过程，BTW <font style="color:red">虽然0RTT是各大博客都吹嘘的TLS1.3亮点，但是0RTT 当前大多数的官方库都还没有实现（Nginx似乎是支持了）</font> ，比如看这里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hs.clientHello.earlyData &#123;</span><br><span class="line"><span class="comment">// See RFC 8446, Section 4.2.10 for the complicated behavior required</span></span><br><span class="line"><span class="comment">// here. The scenario is that a different server at our address offered</span></span><br><span class="line"><span class="comment">// to accept early data in the past, which we can&#x27;t handle. For now, all</span></span><br><span class="line"><span class="comment">// 0-RTT enabled session tickets need to expire before a Go server can</span></span><br><span class="line"><span class="comment">// replace a server or join a pool. That&#x27;s the same requirement that</span></span><br><span class="line"><span class="comment">// applies to mixing or replacing with any TLS 1.2 server.</span></span><br><span class="line">c.sendAlert(alertUnsupportedExtension)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;tls: client sent unexpected early data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务端选择和客户端同样支持的 <font style="color:#483D8B"> CurveID </font>(代码中的 selectedGroup，并且是Client支持的Key Share)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">params, err := generateECDHEParameters(c.config.rand(), selectedGroup)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.sendAlert(alertInternalError)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">hs.hello.serverShare = keyShare&#123;group: selectedGroup, data: params.PublicKey()&#125;</span><br><span class="line">hs.sharedKey = params.SharedKey(clientKeyShare.data)</span><br><span class="line"><span class="keyword">if</span> hs.sharedKey == <span class="literal">nil</span> &#123;</span><br><span class="line">c.sendAlert(alertIllegalParameter)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;tls: invalid client key share&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以来，客户端和服务端便直接完成了 <font style="color:#483D8B">ECDHE</font> 密钥交换</p><ul><li>客户端生成随机数x，确定了曲线类型如Golang TLS SDK只支持的 <font style="color:#483D8B"> x25519曲线</font> 即可得方程系数a、b，再调用<code>generateECDHEParameters</code> 获得 <font style="color:#483D8B"> PublicKey Q<sub>1</sub> </font>。客户端将 Q<sub>1</sub> 、a、 b、 P 传给服务端。</li><li>服务端生成随机数y，解析客户端传来的曲线和 Key_Share 对，得到曲线类型 <font style="color:#483D8B"> x25519 </font>既得方程系数a、b，再使用 selectedGroup 和 y 调用<code>generateECDHEParameters</code> 生成 <font style="color:#483D8B"> PublicKey Q<sub>2</sub> </font> ,传给客户端</li><li>这时客户端和服务端可以计算出一个公共的值 <font style="color:#483D8B"> <strong>K</strong> </font></li></ul><p>如下图</p><img src="/images/network/TLSDetailAnalysis/ECDHE.png"><h3 id="PSK-Pre-Shared-Key"><a href="#PSK-Pre-Shared-Key" class="headerlink" title=" PSK (Pre-Shared Key)"></a><font style="color:#87CEEB"> PSK (Pre-Shared Key)</font></h3><p>这里在接着解析代码之前，先插播一个 TLS1.3 的feature 0RTT是如何实现的。这里介绍一下实现的原理 – <font style="color:#483D8B"> <strong>PSK</strong> </font></p><p>一旦一次握手完成，server 就能给 client 发送一个与一个独特密钥对应的 PSK 密钥，这个密钥来自初次握手。然后 client 能够使用这个 PSK 密钥在将来的握手中协商相关 PSK 的使用。如果 server 接受它，新连接的安全上下文在密码学上就与初始连接关联在一起，从初次握手中得到的密钥就会用于装载密码状态来替代完整的握手。在 TLS 1.2 以及更低的版本中，这个功能由 “session IDs” 和 “session tickets” [RFC5077]来提供。这两个机制在 TLS 1.3 中都被废除了。</p><p>PSK 可以与 (EC)DHE 密钥交换算法一同使用以便使共享密钥具备前向安全，或者 PSK 可以被单独使用，这样是以丢失了应用数据的前向安全为代价。</p><p>下图显示了两次握手，第一次建立了一个 PSK，第二次时使用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">       Client                                               Server</span><br><span class="line"></span><br><span class="line">Initial Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share               --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                       + key_share</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                             &#123;CertificateRequest*&#125;</span><br><span class="line">                                                    &#123;Certificate*&#125;</span><br><span class="line">                                              &#123;CertificateVerify*&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Certificate*&#125;</span><br><span class="line">       &#123;CertificateVerify*&#125;</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">                                 &lt;--------      [NewSessionTicket]</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subsequent Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share*</span><br><span class="line">       + pre_shared_key          --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                  + pre_shared_key</span><br><span class="line">                                                      + key_share*</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 server 通过一个 PSK 进行认证时，它不会发送一个 Certificate 或一个 CertificateVerify 消息。当一个 client 通过 PSK 想恢复会话的时候，它也应当提供一个 “key_share” 给 server，以允许 server 拒绝恢复会话的时候降级到重新回答一个完整的握手流程中。Server 响应 “pre_shared_key” 扩展，使用 PSK 密钥协商建立连接，同时响应 “key_share” 扩展来进行 (EC)DHE 密钥建立，由此提供前向安全。</p><p>当 PKS 在带外提供时，PSK 密钥和与 PSK 一起使用的 KDF hash 算法也必须被提供。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0 RTT"></a><font style="color:#87CEEB">0 RTT</font></h3><p>当 client 和 server 共享一个 PSK（从外部获得或通过一个以前的握手获得）时，TLS 1.3 允许 client 在第一个发送出去的消息中携带数据（”application data”）。Client 使用这个 PSK 来认证 server 并加密 early data 信息，最终实现Application数据的0RTT发送。</p><p>如下图所示，0-RTT 数据在第一个发送的消息中被加入到 1-RTT 握手过程中。握手的其余消息与带 PSK 会话恢复的 1-RTT 握手消息相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">+ early_data</span><br><span class="line">+ key_share*</span><br><span class="line">+ psk_key_exchange_modes</span><br><span class="line">+ pre_shared_key</span><br><span class="line">(Application Data*)     --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                           + pre_shared_key</span><br><span class="line">                                               + key_share*</span><br><span class="line">                                      &#123;EncryptedExtensions&#125;</span><br><span class="line">                                              + early_data*</span><br><span class="line">                                                 &#123;Finished&#125;</span><br><span class="line">                        &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;              --------&gt;</span><br><span class="line">[Application Data]      &lt;-------&gt;        [Application Data]</span><br></pre></td></tr></table></figure><p>上图是 0-RTT 的信息流</p><p>0-RTT 数组安全性比其他类型的 TLS 数据要弱一些，特别是：</p><ol><li>0-RTT 的数据是没有前向安全性的，它使用的是被提供的 PSK 中导出的密钥进行加密的。</li><li>在多个连接之间不能保证不存在重放攻击。普通的 TLS 1.3 1-RTT 数据为了防止重放攻击的保护方法是使用 server 下发的随机数，现在 0-RTT 不依赖于 ServerHello 消息，因此保护措施更差。如果数据与 TLS client 认证或与应用协议里一起验证，这一点安全性的考虑尤其重要。这个警告适用于任何使用 early_exporter_master_secret 的情况。</li></ol><p>参考 <strong><a href="https://halfrost.com/tls_1-3_introduction/">TLS 1.3 Introduction</a></strong> – Halfrost’s Field | 冰霜之地</p><h3 id="checkForResumption-–-Go"><a href="#checkForResumption-–-Go" class="headerlink" title=" checkForResumption – Go"></a><font style="color:#87CEEB"> checkForResumption – Go</font></h3><p>上面2个小节其实就是在介绍 <a href="https://golang.org/src/crypto/tls/handshake_server_tls13.go#226"><code>checkForResumption()</code></a> 这个函数的作用。</p><p>在Client Hello 包的扩展里如果有 <strong>psk_key_exchange_modes</strong> 和  <strong>pre_shared_key</strong> 就表示客户端想要会话复用，即类似TLS1.2的 <strong>Session Ticket</strong> or <strong>Session Id</strong> 的概念。</p><p>如下所示：</p><img src="/images/network/TLSDetailAnalysis/tls-1.3-psk_key_exchange_modes.png"><p><font style="color:#483D8B"> <strong>psk_key_exchange_modes</strong></font>是 psk 密钥交互模式选择. 此处的PSK模式为(EC)DHE下的PSK，客户端和服务器必须提供KeyShare, 如果是仅PSK模式，则服务器不需要提供KeyShare。</p><img src="/images/network/TLSDetailAnalysis/tls-1.3-pre_shared_key.png"><p><font style="color:#483D8B"> <strong>pre_shared_key</strong></font> 是预共享密钥认证机制，相当于session ticket再加一些检验的东西.<br>Identity中包含的是客户端愿意进行协商的服务器身份列表。PSK binder表示已经构建当前PSK与当前握手之间的绑定。</p><p>下面函数中，服务端会将 <font style="color:#483D8B">identity</font> 解析成 <font style="color:#483D8B">plaintext</font>，<font style="color:#483D8B">plaintext</font>中包含TLS版本、证书、复用秘钥、超时时间 等多个信息，如果unmarshal成功，即可以会话复用，继续向下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, identity := <span class="keyword">range</span> hs.clientHello.pskIdentities &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= maxClientPSKIdentities &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">plaintext, _ := c.decryptTicket(identity.label)</span><br><span class="line"><span class="keyword">if</span> plaintext == <span class="literal">nil</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">sessionState := <span class="built_in">new</span>(sessionStateTLS13)</span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> ok := sessionState.unmarshal(plaintext); !ok &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">       </span><br><span class="line">       createdAt := time.Unix(<span class="keyword">int64</span>(sessionState.createdAt), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> c.config.time().Sub(createdAt) &gt; maxSessionTicketLifetime &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don&#x27;t check the obfuscated ticket age because it&#x27;s affected by</span></span><br><span class="line"><span class="comment">// clock skew and it&#x27;s only a freshness signal useful for shrinking the</span></span><br><span class="line"><span class="comment">// window for replay attacks, which don&#x27;t affect us as we don&#x27;t do 0-RTT.</span></span><br><span class="line"></span><br><span class="line">pskSuite := cipherSuiteTLS13ByID(sessionState.cipherSuite)</span><br><span class="line"><span class="keyword">if</span> pskSuite == <span class="literal">nil</span> || pskSuite.hash != hs.suite.hash &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">...</span><br><span class="line">psk := hs.suite.expandLabel(sessionState.resumptionSecret, <span class="string">&quot;resumption&quot;</span>,</span><br><span class="line"><span class="literal">nil</span>, hs.suite.hash.Size())</span><br><span class="line">hs.earlySecret = hs.suite.extract(psk, <span class="literal">nil</span>)</span><br><span class="line">binderKey := hs.suite.deriveSecret(hs.earlySecret, resumptionBinderLabel, <span class="literal">nil</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h2 id="Change-Cipher-Space"><a href="#Change-Cipher-Space" class="headerlink" title=" Change Cipher Space"></a><font style="color:#4682B4"> Change Cipher Space</font></h2><p>发送一个 <font style="color:#483D8B"><strong>ChangeCipherSpec record</strong></font> 报文，之后的加密方式将会改变。详见 See RFC 8446, Appendix D.4.</p><h2 id="EncryptedExtensions"><a href="#EncryptedExtensions" class="headerlink" title=" EncryptedExtensions "></a><font style="color:#4682B4"> EncryptedExtensions </font></h2><p>随后 Server 会发来建立 EncryptedExtensions Server 参数: 对 ClientHello 扩展的响应，不需要确定加密参数，而不是特定于各个证书的加密参数。一般ALPN会在这里添加。</p><h2 id="Certificate-amp-amp-Certificate-Verify-amp-amp-Finished"><a href="#Certificate-amp-amp-Certificate-Verify-amp-amp-Finished" class="headerlink" title=" Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished "></a><font style="color:#4682B4"> Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished </font></h2><p>最后，Client 和 Server 交换认证消息。TLS 在每次基于证书的认证时使用相同的消息集，(基于 PSK 的认证是密钥交换中的一个副作用)特别是：</p><ul><li><p><font style="color:#483D8B">Certificate</font>: 终端的证书和每个证书的扩展。 服务器如果不通过证书进行身份验证，并且如果服务器没有发送CertificateRequest（由此指示客户端不应该使用证书进行身份验证），客户端将忽略此消息。 请注意，如果使用原始公钥 [RFC7250] 或缓存信息扩展 [RFC7924]，则此消息将不包含证书，而是包含与服务器长期密钥相对应的其他值。</p></li><li><p><font style="color:#483D8B">CertificateVerify</font>: 使用与证书消息中的公钥配对的私钥对整个握手消息进行签名。如果终端没有使用证书进行验证则此消息会被忽略。</p></li><li><p><font style="color:#483D8B">Finished</font>: 对整个握手消息的 MAC(消息认证码)。这个消息提供了密钥确认，将终端身份与交换的密钥绑定在一起，这样在 PSK 模式下也能认证握手。</p></li></ul><p>接收到 Server 的消息之后，Client 会响应它的认证消息，即 Certificate，CertificateVerify (如果需要), 和 Finished。</p><p>这时握手已经完成，client 和 server 会提取出密钥用于记录层交换应用层数据，这些数据需要通过认证的加密来保护。应用层数据不能在 Finished 消息之前发送数据，必须等到记录层开始使用加密密钥之后才可以发送。需要注意的是 server 可以在收到 client 的认证消息之前发送应用数据，任何在这个时间点发送的数据，当然都是在发送给一个未被认证的对端。</p><h2 id="New-Session-Ticket"><a href="#New-Session-Ticket" class="headerlink" title=" New Session Ticket "></a><font style="color:#4682B4"> New Session Ticket </font></h2><p>实际等同于发送 PSK 数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">shouldSendSessionTickets</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> hs.c.config.SessionTicketsDisabled &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t send tickets the client wouldn&#x27;t use. See RFC 8446, Section 4.2.9.</span></span><br><span class="line"><span class="keyword">for</span> _, pskMode := <span class="keyword">range</span> hs.clientHello.pskModes &#123;</span><br><span class="line"><span class="keyword">if</span> pskMode == pskModeDHE &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="tls" scheme="http://kiosk007.top/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>Git Quick Start</title>
    <link href="http://kiosk007.top/2020/12/19/Git-Quick-Start/"/>
    <id>http://kiosk007.top/2020/12/19/Git-Quick-Start/</id>
    <published>2020-12-19T11:11:00.000Z</published>
    <updated>2020-12-19T11:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>只是git入门的简单指南。没什么大不了的 :)</p><a id="more"></a><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br><img src="/images/git/git.png" style="height:340px"></p><h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><p><a href="https://git-scm.com/download/linux">安装 Git Linux 版</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install git</span><br><span class="line">$ apt-get install gitk</span><br></pre></td></tr></table></figure><p>gitk 是可以可视化的git客户端工具，更多工具参考 <a href="https://git-scm.com/download/gui/linux">git-gui</a> ，如 <a href="https://juejin.cn/post/6844903904451231757">Gitkraken (小章鱼)</a>、 <a href="https://magit.vc/manual/magit/Installing-from-the-Git-Repository.html#Installing-from-the-Git-Repository">magit</a> 等等</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li><strong>配置 user 信息</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name  <span class="string">&quot;your_name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;your_name@domain.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --local 只对某个分支有效</span></span><br><span class="line"><span class="comment"># --global 对当前用户所有仓库有效</span></span><br><span class="line"><span class="comment"># --system 对系统所有用户有效</span></span><br><span class="line"></span><br><span class="line">$ git config --global core.editor <span class="string">&quot;vim&quot;</span>    <span class="comment"># git 交互改为vim</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><strong>查看config的配置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>工作流</strong>:<br>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p><h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><ul><li><font color="#EEB422"><strong>init 仓库</strong></font></li></ul><p>创建新文件夹，打开，然后执行 <strong><code>git init</code></strong> 以创建新的 git 仓库。</p><ul><li><font color="#EEB422"><strong>添加 和 提交</strong></font></li></ul><ol><li>你可以提出更改（把它们添加到暂存区），使用如下命令：**<code>git add &lt;filename&gt;</code>**  或者  <strong><code>git add *</code></strong></li><li>使用如下命令以实际提交改动：**<code>git commit -m &quot;代码提交信息&quot;</code>**</li><li>现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</li></ol><ul><li><font color="#EEB422"><strong>推送改动</strong></font></li></ul><ol><li>改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：**<code>git push origin master</code>** (master 可以换成想要推送的分支)</li><li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：**<code>git remote add origin &lt;server&gt;</code>** , 如此你就能够将你的改动推送到所添加的服务器上去了。</li></ol><h2 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><img src="/images/git/branches.png"><ul><li>创建一个叫做“feature_x”的分支，并切换过去：**<code>git checkout -b feature_x</code>**</li><li>切换回主分支：**<code>git checkout master</code>**</li><li>删除分支：**<code>git branch -d feature_x</code>**</li><li>将自己的分支推送到远端：**<code>git push origin &lt;branch&gt;</code>**</li></ul><h2 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h2><ul><li><font color="#FF8247"><strong>基本命令</strong></font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line">$ git mv old_filename new_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">$ git rm filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作区的状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为软件发布创建标签, 如v1.0.0</span></span><br><span class="line">$ git tag v1.0.0 1b2e1d63ff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看git提交后日志</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline     <span class="comment"># 一行显示</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 4          <span class="comment"># 查看最近的几次</span></span><br><span class="line">$ git <span class="built_in">log</span> --all --graph <span class="comment"># 以图形化方式显示所有的提交日志</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline --decorate --all  <span class="comment"># 通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签 </span></span><br><span class="line">$ git <span class="built_in">log</span> --author=bob  <span class="comment"># 只看某一个人的提交记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看 diff</span></span><br><span class="line">$ git diff              <span class="comment"># 对比工作区和暂存区的差异</span></span><br><span class="line">$ git diff --cached  <span class="comment"># 对比暂存区和HEAD所含文件(commit)的差异</span></span><br><span class="line">$ git diff -- style.css <span class="comment"># 只查看对某个文件的 diff 差异 (工作区和暂存区)</span></span><br><span class="line">$ git diff tmp master -- &lt;file&gt; <span class="comment"># 比较 tmp 和 master 分支的文件差异(也可以将branch改成commit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 取消提交</span></span><br><span class="line">$ git reset HEAD        <span class="comment"># 取消暂存 （取消 git add）</span></span><br><span class="line">$ git restore --staged &lt;file&gt;  <span class="comment"># 功能同上, 取消暂存 （可以 git status 查看当前的暂存状态）</span></span><br><span class="line"></span><br><span class="line">$ git checkout -- &lt;file&gt;      <span class="comment"># 在工作区的修改撤销到最近一次git add 或 git commit时的内容</span></span><br><span class="line">$ git reset --hard c04b46549  <span class="comment"># 恢复到历史上的某个 commit (工作区和暂存区都会清空)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><font color="#FF8247"><strong>版本管理</strong></font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">$ git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于某个历史版本创建分支(基于 ac886ae 创建一个tmp分支)</span></span><br><span class="line">$ git checkout -b tmp ac886ae </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个分支</span></span><br><span class="line">$ git checkout -d ac886ae  <span class="comment"># 没有merge的分支不能通过 -d 删除</span></span><br><span class="line">$ git checkout -D ac886ae</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###################### commit 相关 ###########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最近一次提交的 commit 信息</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改前几次提交的 commit 信息</span></span><br><span class="line">$ git rebase -i ac224ct   <span class="comment"># 交互式操作，ac224ct 是要修改的commit的父commit</span></span><br><span class="line">将pick改为r  :wq退出，</span><br><span class="line">变更内容     :wq退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="git常见使用"><a href="#git常见使用" class="headerlink" title="git常见使用"></a>git常见使用</h1><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a><font color="#FF4500"><strong>分离头指针</strong></font></h2><p>通常，我们工作在某一个分支上，比如 master 分支。这个时候 master 指针和 HEAD 指针是一起前进的，每做一次提交，这两个指针就会一起向前挪一步。但是在某种情况下（例如 checkout 了某个具体的 commit），master 指针 和 HEAD 指针这种「绑定」的状态就被打破了，变成了分离头指针状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜ git checkout fb7d808</span><br><span class="line">注意：正在切换到 <span class="string">&#x27;fb7d808&#x27;</span>。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 <span class="literal">false</span> 来关闭此建议</span><br><span class="line"></span><br><span class="line">HEAD 目前位于 fb7d808 Learn CSS demo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git 在对于这种没有 branch 的变更会被清除掉。所以如果想要变更最好跟着分支进行变更。</p><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry pick"></a><font color="#FF4500"><strong>cherry pick</strong></font></h2><p><code>git cherry-pick</code> 可以选择某一个分支中的一个或几个commit(s)来进行操作。例如，假设我们有个稳定版本的分支，叫v2.0，另外还有个开发版本的分支v3.0，我们不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个v3.0中的功能到v2.0中，这里就可以使用cherry-pick了,其实也就是对已经存在的commit 进行再次提交.<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout v2.0分支</span><br><span class="line">$ git cherry-pick 38361a55 <span class="comment"># 这个 38361a55 号码，位于v3.0分支中：</span></span><br></pre></td></tr></table></figure><h2 id="临时修复切分支修-bug"><a href="#临时修复切分支修-bug" class="headerlink" title="临时修复切分支修 bug"></a><font color="#FF4500"><strong>临时修复切分支修 bug</strong></font></h2><p>通常我们在开发新版本功能的时候会遇到老版本有bug，需要对老版本进行修复。这个时候就需要将当前开发的工作区暂时保存而切到有问题的分支上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现将工作区的内容保存到暂存区</span></span><br><span class="line">$ git add *</span><br><span class="line"><span class="comment"># 将暂存区的内容 暂时保存</span></span><br><span class="line">$ git stash   </span><br><span class="line">$ git stash save <span class="string">&quot;message&quot;</span>   <span class="comment"># 功能同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切到历史版本修复bug ... </span></span><br><span class="line"></span><br><span class="line">$ git stash apply  <span class="comment"># 将临时保存区的内容恢复，但不会删除记录，pop会删除。</span></span><br><span class="line">$ git stash pop </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="指定文件不需要git管理"><a href="#指定文件不需要git管理" class="headerlink" title="指定文件不需要git管理"></a><font color="#FF4500"><strong>指定文件不需要git管理</strong></font></h2><p>在项目根目录下创建 <strong><code>.gitignore</code></strong> ,写入不需管理的文件名即可</p><h1 id="git目录功能"><a href="#git目录功能" class="headerlink" title=".git目录功能"></a>.git目录功能</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ .git git:(master) ls   </span><br><span class="line">branches  COMMIT_EDITMSG  config  description  gitk.cache  HEAD  hooks  index  info  logs  objects  refs</span><br></pre></td></tr></table></figure><ul><li><code>HEAD</code>: 当前工作的分支</li><li><code>config</code>: 配置信息，包含着 repository 的配置，包括 remote 的地址，提交时的 email、 username 等等.</li><li><code>refs</code>: 这个目录一般包括三个子文件夹：heads、remotes和tags，heads中的文件标识了项目中的各个分支指向的当前commit</li><li><code>info</code>: 包含仓库的一些信息</li><li><code>hooks</code>: 这个目录存放一些shell脚本，可以设置特定的git命令后出发相应的脚本；在搭建gitweb系统或其他git托管系统会经常用到hook script</li><li><code>logs</code>: 保存所有更新的引用记录</li><li><code>index</code>: 这个文件就是暂存区（stage），是一个二进制文件</li><li><code>description</code>: 仓库的描述信息，主要给gitweb等git托管系统使用</li><li><code>objects</code>: 所有的Git对象都会存放在这个目录中，对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名</li></ul><p>git 中的对象如下图所示，每一个 commit 提交都会包含 tree、committer、blob。其中committer是提交者，tree可粗略理解为目录，blob为文件。<br><img src="/images/git/git_commit_tree_blob.png" style="height:350px"></p><p>比如查看一次 commit </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看一次 commit</span></span><br><span class="line">$ git cat-file -p ac886ae797a9ee60962461b50993bc2bd09920fd</span><br><span class="line">tree 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">parent 4f41c2512ce8fcfbde05622c4d0cd75f14708a84</span><br><span class="line">author orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line">committer orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line"></span><br><span class="line">Add CS JS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该commit中的 tree</span></span><br><span class="line">$ git cat-file -p 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">100644 blob dac138d9e013a2e9a10e67d793bd4703c1b86bd1index.css</span><br><span class="line">100644 blob e1d99bb43375f52095059d6d79a9c6d3045c048bindex.html</span><br><span class="line">100644 blob 7b4dcb5b597195d0469fec0787c2a7b7a4656d81index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该tree中的blob</span></span><br><span class="line">$ git cat-file -p 7b4dcb5b597195d0469fec0787c2a7b7a4656d81</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">&quot;My First JavaScript&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="git-备份"><a href="#git-备份" class="headerlink" title="git 备份"></a>git 备份</h1><img src="/images/git/git_transport.webp" style="height:400px"><p>前两个协议是本地协议，后两个是远端托管平台。<br>哑协议传输进度不可见，智能协议传输可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个文件仓库 clone</span></span><br><span class="line"><span class="comment"># 哑协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare /home/kiosk/Project/Git/kiosk_demo/.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 智能协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare file:///home/kiosk/Project/Git/kiosk_demo/.git</span><br></pre></td></tr></table></figure><ul><li><font color="#FF8C00"><strong>创建远程</strong></font></li></ul><p>可以使用 git remote add 命令将远程 URL 与名称匹配，例如<br><strong><code>git remote add origin  &lt;REMOTE_URL&gt; </code></strong><br>这会将名称 origin 与 REMOTE_URL 关联。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/user/repo.git</span><br><span class="line"><span class="comment"># Set a new remote</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># Verify new remote</span></span><br><span class="line">&gt; origin  https://github.com/user/repo.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/user/repo.git (push)</span><br></pre></td></tr></table></figure><p>远程 name 已存在,此错误消息表示您尝试添加的远程与本地仓库中的远程名称相同。可以尝试修改远程名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 查看现有远程</span></span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote rename origin destination</span><br><span class="line"><span class="comment"># 将远程名称从 &#x27;origin&#x27; 更改为 &#x27;destination&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 验证远程的新名称</span></span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (push)</span><br></pre></td></tr></table></figure><p>若远程的url发生了变化，可以通过<br><strong><code>git remote set-url origin https://github.com/USERNAME/REPOSITORY.git </code></strong><br>修改</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;只是git入门的简单指南。没什么大不了的 :)&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://kiosk007.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>gRPC Quick Start </title>
    <link href="http://kiosk007.top/2020/11/25/gRPC-Quick-Start/"/>
    <id>http://kiosk007.top/2020/11/25/gRPC-Quick-Start/</id>
    <published>2020-11-25T15:37:00.000Z</published>
    <updated>2020-11-25T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>RPC 全称 (Remote Procedure Call)，远程过程调用，指的是一台计算机通过网络请求另一台计算机的上服务，从而不需要了解底层网络细节，RPC 是构建在已经存在的协议（TCP/IP，HTTP 等）之上的。<code>gRPC</code> 是云原生计算基金会（CNCF）项目，gRPC 一开始由 google 开发，是一款语言中立、平台中立的服务间通信框架，使用 gRPC 可以使得客户端像调用本地方法一样，调用远程主机提供的服务。可以在任何地方运行，它使客户端和服务器应用程序能够透明地进行通信，并使构建连接系统变得更加容易。</p><a id="more"></a><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><ul><li>gRPC 默认采用 protocol buffer 作为 IDL (Interface Description Lanage) 接口描述语言，服务之间通信的数据序列化和反序列化也是基于 protocol buffer 的，因为 protocol buffer 的特殊性，所以 gRPC 框架是跨语言的通信框架（与编程语言无关性）</li><li>gRPC 是基于 http2 协议实现,多路复用支持通过同一连接发送多个并行请求,双向全双工通信，用于同时发送客户端请求和服务器响应,内置流式传输使请求和响应能够异步流式传输大数据集</li><li>gRPC 并没有直接实现负载均衡和服务发现的功能，但是已经提供了自己的设计思路。已经为命名解析和负载均衡提供了接口。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service Greeter &#123;</span><br><span class="line">   &#x2F;*</span><br><span class="line">   以下 分别是 服务端 推送流， 客户端 推送流 ，双向流。</span><br><span class="line">   *&#x2F;</span><br><span class="line">  rpc GetStream (StreamReqData) returns (stream StreamResData)&#123;&#125;</span><br><span class="line">  rpc PutStream (stream StreamReqData) returns (StreamResData)&#123;&#125;</span><br><span class="line">  rpc AllStream (stream StreamReqData) returns (stream StreamResData)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Protocal-Buffer"><a href="#Protocal-Buffer" class="headerlink" title="Protocal Buffer"></a>Protocal Buffer</h1><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p><a href="https://developers.google.cn/protocol-buffers">Protocol buffers</a> 是一个灵活的、高效的、自动化的用于对结构化数据进行序列化的协议，与XML相比，Protocol buffers序列化后的码流更小、速度更快、操作更简单。</p><p><code>序列化(serialization、marshalling)</code>的过程是指将数据结构或者对象的状态转换成可以存储(比如文件、内存)或者传输的格式(比如网络)。反向操作就是反序列化<code>(deserialization、unmarshalling)</code>的过程。</p><ul><li>二十世纪九十年代后期，XML开始流行，它是一种人类易读的基于文本的编码方式，易于阅读和理解，但是失去了紧凑的基于字节流的编码的优势。</li><li>JSON是一种更轻量级的基于文本的编码方式，经常用在client/server端的通讯中。</li><li>YAML类似JSON，新的特性更强大，更适合人类阅读，也更紧凑。</li></ul><p>除了上面这些和Protobuf，还有许许多多的序列化格式，比如Thrift、Avro、BSON、CBOR、MessagePack, 还有很多非跨语言的编码格式。项目<a href="https://github.com/smallnest/gosercomp">gosercomp</a>对比了各种go的序列化库，包括序列化和反序列的性能，以及序列化后的数据大小。总体来说Protobuf序列化和反序列的性能都是比较高的，编码后的数据大小也不错。</p><p><font color="blue">如果你并不希望一定要在传输过程中消息数据可读，那么可以用 Protocal Buffer 来代替 Json 。</font></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;      &#x2F;&#x2F; 版本定义</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  int32  id &#x3D; 1;</span><br><span class="line">  string name &#x3D; 2;</span><br><span class="line">  bool   rich &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行指定<code>protobuf</code>的版本，这里是以proto3格式定义。</p><p>第三行 <code>message</code> 表示定义了一个结构体，在这个结构体里，最常见的类型有以下几种</p><ol><li><font color="#FFB90F">数值型</font> ，如 double, float, int32, int64 …</li><li><font color="#FFB90F">布尔型</font>，bool 只有True和False</li><li><font color="#FFB90F">字符型</font>，string 表示任意字符，但是长度不可超过2的32次方</li><li><font color="#FFB90F">字节型</font>，bytes表示任意的byte数组序列，但是长度也不可以超过2的32次方，比如可以用来传递一个图片。</li><li><font color="#FFB90F">枚举型</font>，enum 表示枚举。可独立在 message 之外。可通过 <code>option allow_alias = true;</code> 给枚举定义别名。</li><li>字典型，map类型需要设置键和值的类型。</li><li><font color="#FFB90F">Well-Known类型</font>, Protobuf也提供了定义，比如Timestamp和Duration。这些定义被放在<code>github.com/golang/protobuf/ptypes/</code>。</li></ol><p><strong>引入其它proto文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import  &quot;other.proto&quot;;</span><br><span class="line">import public &quot;other2.proto&quot;;</span><br><span class="line">import weak &quot;other.proto&quot;;</span><br></pre></td></tr></table></figure><p>比较少使用的是public和weak关键字。默认情况下weak引入的文件允许不存在(missing)，只为了google内部使用。public具有传递性，如果你在文件中通过public引入第三方的proto文件，那么引入你这个文件同时也会引入第三方的proto。</p><p><strong>关键字：</strong></p><ol><li><font color="#FFB90F"> option</font> ：option可以用在proto的scope中，或者message、enum、service的定义中。一般常用的就是定义某语言生成后的package名，最常见的用法，如 <code>option go_package = &quot;xxx&quot;;</code></li><li><font color="#FFB90F">repeated</font> : 指定某一个字段可以存放同一个类型的多个数据, 相当于golang里的slice。可采用<code>[packed=true]</code>以实现更高<br>效的编码。<code>repeated int32 samples = 4 [packed=true];</code></li><li><font color="#FFB90F"> reserved</font> : 保护某字段或定义，如在message中指定 数字1 被保护，或变量名 person 被保护。一般用来保护废弃的数字定义。如<code>reserved 5;  reserved &quot;salary&quot;;</code> 如果再使用5 或者 salary 则会报错。</li></ol><p><strong>demo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package my.project; </span><br><span class="line"></span><br><span class="line">import &quot;google&#x2F;protobuf&#x2F;timestamp.proto&quot;;</span><br><span class="line"></span><br><span class="line">option go_package &#x3D; &quot;pb&quot;;</span><br><span class="line"></span><br><span class="line">message PersonMessage &#123;</span><br><span class="line">  int32   id &#x3D; 1;</span><br><span class="line">  bool    is_adult &#x3D;2;</span><br><span class="line">  string  name &#x3D; 3;</span><br><span class="line">  float   height &#x3D; 4;</span><br><span class="line">  float   weight &#x3D; 5;</span><br><span class="line">  bytes   avatar &#x3D; 6;</span><br><span class="line">  string  email &#x3D; 7;</span><br><span class="line">  bool    email_verified &#x3D; 8;</span><br><span class="line">  repeated string phone_numbers &#x3D; 9;  &#x2F;&#x2F; packed</span><br><span class="line">  Gender  gender &#x3D; 11;</span><br><span class="line">  Date    birthday &#x3D; 12;</span><br><span class="line">  repeated Address addresses &#x3D; 13;</span><br><span class="line">  google.protobuf.Timestamp lastModified &#x3D; 14;</span><br><span class="line"></span><br><span class="line">  enum Gender &#123;</span><br><span class="line">    option allow_alias &#x3D; true;</span><br><span class="line">    Not_SPECIFIED &#x3D; 0;</span><br><span class="line">    MALE &#x3D; 1;</span><br><span class="line">    FEMALE &#x3D; 2;</span><br><span class="line">    MAN &#x3D; 1;</span><br><span class="line">    WOMAN &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message Address &#123;</span><br><span class="line">    string province &#x3D; 1;</span><br><span class="line">    string city &#x3D; 2;</span><br><span class="line">    string zip_code &#x3D; 3;</span><br><span class="line">    string street &#x3D; 4;</span><br><span class="line">    string number &#x3D; 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reserved 10, 20 to 100, 200 to max;</span><br><span class="line">  reserved &quot;foo&quot;,&quot;bar&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Date &#123;</span><br><span class="line">  int32 year &#x3D; 1;</span><br><span class="line">  int32 month &#x3D; 2;</span><br><span class="line">  int32 day &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Golang-protocol-buffer"><a href="#Golang-protocol-buffer" class="headerlink" title="Golang protocol buffer"></a>Golang protocol buffer</h2><p>定义 <code>.proto</code> 文件后，使用命令<br><code>protoc --protoc_path src/ -go_out=src/ src/person.proto</code> 生成golang 文件</p><p><strong>定义一个pb</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonMessage</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">PersonMessage</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.PersonMessage&#123;</span><br><span class="line">Id: <span class="number">1</span>,</span><br><span class="line">IsAdult: <span class="literal">true</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">Height: <span class="number">177</span>,</span><br><span class="line">Weight: <span class="number">140</span>,</span><br><span class="line">Gender: pb.PersonMessage_MALE,</span><br><span class="line">PhoneNumbers: []<span class="keyword">string</span>&#123;<span class="string">&quot;15667026708&quot;</span>,<span class="string">&quot;17610660213&quot;</span>&#125;,</span><br><span class="line">Email: <span class="string">&quot;weijiaxiang007@foxmail.com&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 将 pb 写入文件 **</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToFile</span><span class="params">(filename <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">dataBytes, err := proto.Marshal(pb)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;无法序列化&quot;</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(filename, dataBytes, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;无法写入文件&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;成功写入到文件&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pm := NewPersonMessage()</span><br><span class="line">_ = writeToFile(<span class="string">&quot;person.bin&quot;</span>,pm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 从文件读出 pb **</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromFile</span><span class="params">(filename <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">dataBytes, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;读取文件错误&quot;</span>,err.Error()) &#125;</span><br><span class="line"><span class="keyword">if</span> err := proto.Unmarshal(dataBytes, pb); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;反序列化失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pm := &amp;demo.PersonMessage&#123;&#125;</span><br><span class="line">_ = readFromFile(<span class="string">&quot;person.bin&quot;</span>, pm)</span><br><span class="line">fmt.Println(pm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pb 转 json &amp;&amp; json 转 pb</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toJson</span><span class="params">(pb proto.Message)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">marshaler := jsonpb.Marshaler&#123;Indent: <span class="string">&quot;    &quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">str ,err := marshaler.MarshalToString(pb)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;转换为JSON时发生错误&quot;</span>,err.Error()) &#125;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fromJson</span><span class="params">(in <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> jsonpb.UnmarshalString(in, pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gogo库</strong></p><p>虽然官方库 <font color="#68228B"><a href="https://github.com/golang/protobuf">golang/protobu</a> </font>提供了对Protobuf的支持，但是使用最多还是第三方实现的库<a href="https://github.com/gogo/protobuf">gogo/protobuf</a>。</p><p>gogo库基于官方库开发，增加了很多的功能，包括：</p><ol><li>快速的序列化和反序列化</li><li>更规范的Go数据结构</li><li>goprotobuf兼容</li><li>可选择的产生一些辅助方法，减少使用中的代码输入</li><li>可以选择产生测试代码和benchmark代码</li><li>其它序列化格式</li></ol><blockquote><p>更多参考github： <a href="http://github.com/gogo/protobuf">http://github.com/gogo/protobuf</a></p></blockquote><h1 id="gRPC-Start"><a href="#gRPC-Start" class="headerlink" title="gRPC Start"></a>gRPC Start</h1><p>进入主题了, gRPC 是Google发布的基于HTTP 2.0传输层协议承载的高性能开源软件框架。提供了支持多种编程语言的、对网络设备进行配置和纳管的方法。</p><p>RPC是远程函数调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间。因此传统的RPC方法调用对于上传和下载较大数据量场景并不适合。同时传统RPC模式也不适用于对时间不确定的订阅和发布模式。为此，gRPC框架针对服务器端和客户端分别提供了流特性。<br><font color="#483D8B">支持 服务端 推送流， 客户端 推送流 ，双向流。</font></p><img alt="Smiley face" height="420" src="/images/network/gRPC/grpc_concept_diagram.png"><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>gRPC要求 Go 版本 &gt;= 1.6</p><ol><li>安装grpc<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u -v google.golang.org/grpc</span><br></pre></td></tr></table></figure></li><li>安装 Protocol Buffers v3、protoc-gen-go:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -v -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure></li><li>生成grpc代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc -I. --go_out=plugins=grpc:. helloworld.proto</span><br></pre></td></tr></table></figure><h2 id="define-proto"><a href="#define-proto" class="headerlink" title="define proto"></a>define proto</h2></li></ol><p>gRPC需要事先定义proto文件，如下所示。定义完成后需要执行命令 <code>protoc --go_out=plugins=grpc:. message.proto</code> 生成相关的go语言代码。更多详细的操作参考官方例子 <a href="https://grpc.io/docs/languages/go/quickstart/">Quick start - gRPC</a><br>              <br><a href="/images/network/gRPC/message.proto">点击查看</a></p><h2 id="gRPC-server"><a href="#gRPC-server" class="headerlink" title="gRPC server"></a>gRPC server</h2><p>gRPC服务的启动流程和标准库的RPC服务启动流程类似：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> port  = <span class="string">&quot;:5001&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  log.Fatalln(err.Error() &#125;</span><br><span class="line"><span class="keyword">var</span> options []grpc.ServerOption</span><br><span class="line">options = <span class="built_in">append</span>(options, grpc.HeaderTableSize(<span class="number">2048</span>))</span><br><span class="line"></span><br><span class="line">server := grpc.NewServer(options...)</span><br><span class="line">pb.RegisterEmployeeServiceServer(server, <span class="built_in">new</span>(example.EmployeeService))</span><br><span class="line">log.Printf(<span class="string">&quot;gRPC Server started ...\n Listen on port %s&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">_ = server.Serve(listen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里设置监听在 tcp 的 5001 端口.</li><li><code>grpc.ServerOption</code> 可以设置gRPC的服务端监听参数， 这里我仅设置了 H2 的 header 动态表大小。除此之外，如设置 TLS证书载入：<code>grpc.Creds(c credentials.TransportCredentials)</code>。<br>最大并发数、收发最大消息Size等等，详见 <a href="https://godoc.org/google.golang.org/grpc#ServerOption">https://godoc.org/google.golang.org/grpc#ServerOption</a></li><li><code>pb.RegisterEmployeeServiceServer</code> 是proto生成的 message.pb.go 提供的服务端注册方法。<code>example.EmployeeService</code> 是我们后面手动创建的空结构，后面的函数方法都需要基于这个空结构实现。</li><li>server.Serve 将监听套接字传入。</li></ul><p><strong>实现 EmployeeService</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service EmployeeService &#123;</span><br><span class="line">  rpc GetByNo(GetByNoRequest) returns (EmployeeResponse);         &#x2F;&#x2F; 一元请求</span><br><span class="line">  rpc GetAll(GetAllRequest) returns (stream EmployeeResponse);    &#x2F;&#x2F; 客户端推送流</span><br><span class="line">  rpc AddPhoto(stream AddPhotoRequest) returns (AddPhotoResponse); &#x2F;&#x2F; 服务端推送流</span><br><span class="line">  rpc SaveAll(stream EmployeeRequest) returns (stream EmployeeResponse); &#x2F;&#x2F; 双向流</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对应的pb生成代码</span><br><span class="line">&#x2F;&#x2F; EmployeeServiceServer is the server API for EmployeeService service.</span><br><span class="line">type EmployeeServiceServer interface &#123;</span><br><span class="line">GetByNo(context.Context, *GetByNoRequest) (*EmployeeResponse, error)</span><br><span class="line">GetAll(*GetAllRequest, EmployeeService_GetAllServer) error</span><br><span class="line">AddPhoto(EmployeeService_AddPhotoServer) error</span><br><span class="line">SaveAll(EmployeeService_SaveAllServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要定义 <code>type EmployeeService struct &#123;&#125;</code> 后面的所有方法都需要基于这个实现，这个也是服务端注册的参数。</p><ul><li>**一元请求 <code>GetByNo()</code> **<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">GetByNo</span><span class="params">(ctx context.Context, request *pb.GetByNoRequest)</span> <span class="params">(*pb.EmployeeResponse, error)</span></span> &#123;</span><br><span class="line">log.Println(request.No)</span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line"><span class="keyword">if</span> request.No == e.No &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.EmployeeResponse&#123;</span><br><span class="line">Employee:           &amp;e,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;the employee does not exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>请求参数是 <code>GetByNoRequest</code>， 通过上面的pb定义得知，这个message是有一个No参数。所以可以取出来当请求参数。返回的参数是<code>EmployeeResponse</code>，通过pb定义得知，其返回参数是 <code>Employee</code> 对象。</li></ul><ul><li><p><strong>服务端返回流 <code>GetAll()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">GetAll</span><span class="params">(request *pb.GetAllRequest, stream pb.EmployeeService_GetAllServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">err := stream.Send(&amp;pb.EmployeeResponse&#123;</span><br><span class="line">Employee: &amp;e,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，返回的参数是一条流，其流发送的方法也可以使用Send函数，这里是一个循环，将employee对象循环写入这条流中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type EmployeeService_GetAllServer interface &#123;</span><br><span class="line">Send(*EmployeeResponse) error</span><br><span class="line">grpc.ServerStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端推送流 <code>AddPhoto()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">AddPhoto</span><span class="params">(stream pb.EmployeeService_AddPhotoServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">md, ok := metadata.FromIncomingContext(stream.Context())</span><br><span class="line"><span class="keyword">if</span> ok &#123; fmt.Printf(<span class="string">&quot;employee: %s&quot;</span>, md[<span class="string">&quot;no&quot;</span>][<span class="number">0</span>]) &#125;</span><br><span class="line"><span class="keyword">var</span> images []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">data, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;File Size %d\n&quot;</span>, <span class="built_in">len</span>(images))</span><br><span class="line"><span class="keyword">return</span> stream.SendAndClose(&amp;pb.AddPhotoResponse&#123;IsOk: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;File received: %d\n&quot;</span>, <span class="built_in">len</span>(data.Data))</span><br><span class="line">images = <span class="built_in">append</span>(images, data.Data...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实现了客户端将一张图片拆分成 bytes 再一点一点发送给服务端的demo。读到EOF表示成功读完。Data正是在 pb 里定义的<code>AddPhotoRequest</code>的客户端请求内容。</p></li><li><p><strong>双向流 <code>SaveAll()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">SaveAll</span><span class="params">(stream pb.EmployeeService_SaveAllServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">empReq, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">employees = <span class="built_in">append</span>(employees, *empReq.Employee)</span><br><span class="line">time.Sleep(<span class="number">1000</span> * time.Microsecond)</span><br><span class="line">_ = stream.Send(&amp;pb.EmployeeResponse&#123;Employee: empReq.Employee&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _ , emp := <span class="keyword">range</span> employees &#123;</span><br><span class="line">fmt.Println(emp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，服务端每读一份数据，休眠100ms，再将读入的数据原封不动的返回给客户端。</p></li></ul><h2 id="gRPC-client"><a href="#gRPC-client" class="headerlink" title="gRPC client"></a>gRPC client</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> options []grpc.DialOption</span><br><span class="line">options = <span class="built_in">append</span>(options, grpc.WithInsecure())</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;localhost&quot;</span> + port, options...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;can&#x27;t dial server &quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">client := pb.NewEmployeeServiceClient(conn)</span><br><span class="line"><span class="comment">// GetByNo(client)</span></span><br><span class="line"><span class="comment">// getAll(client)</span></span><br><span class="line"><span class="comment">//addPhoto(client)</span></span><br><span class="line">saveAll(client)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端也有一个类似Server端的<code>grpc.DialOption</code>, 这里因为服务端没有使用证书，所以客户端必须添加 <code>WithInsecure</code> 选项。调用 <code>pb.NewEmployeeServiceClient(conn)</code> 会返回一个 Client <code>employeeServiceClient</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> employeeServiceClient <span class="keyword">struct</span> &#123;</span><br><span class="line">cc grpc.ClientConnInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个client拥有之前定义的客户端可调用的 RPC 方法。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; For semantics around ctx use and closing&#x2F;ending streaming RPCs, please refer to https:&#x2F;&#x2F;godoc.org&#x2F;google.golang.org&#x2F;grpc#ClientConn.NewStream.</span><br><span class="line">type EmployeeServiceClient interface &#123;</span><br><span class="line">GetByNo(ctx context.Context, in *GetByNoRequest, opts ...grpc.CallOption) (*EmployeeResponse, error)</span><br><span class="line">GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (EmployeeService_GetAllClient, error)</span><br><span class="line">AddPhoto(ctx context.Context, opts ...grpc.CallOption) (EmployeeService_AddPhotoClient, error)</span><br><span class="line">SaveAll(ctx context.Context, opts ...grpc.CallOption) (EmployeeService_SaveAllClient, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现 Client 调用</strong></p><ul><li><strong>一元请求 <code>GetByNo()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetByNo</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">res, err := client.GetByNo(context.Background(), &amp;pb.GetByNoRequest&#123;No: <span class="number">1996</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>传入的参数拥有 <code>GetByNo()</code> 这个方法，直接调用即可。</li></ul><p>抓包可以看到，整个gRPC的调用过程是基于HTTP2的, 本质是发起了一个H2的POST请求, 和传统H2不同的是，response 的 Header帧有2个，结尾处还有一个。第2个表示调用结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stream: HEADERS, Stream ID: 1, Length 80, POST /employee.EmployeeService/GetByNo</span><br><span class="line">    Length: 80</span><br><span class="line">    Type: HEADERS (1)</span><br><span class="line">    Flags: 0x04</span><br><span class="line">    0... .... .... .... .... .... .... .... = Reserved: 0x0</span><br><span class="line">    .000 0000 0000 0000 0000 0000 0000 0001 = Stream Identifier: 1</span><br><span class="line">    [Pad Length: 0]</span><br><span class="line">    Header Block Fragment: 3fe10f8386459960b4d741fd14abe0a6ba0fe8a5dc5b3b98…</span><br><span class="line">    [Header Length: 202]</span><br><span class="line">    [Header Count: 8]</span><br><span class="line">    Header table size update</span><br><span class="line">    Header: :method: POST</span><br><span class="line">    Header: :scheme: http</span><br><span class="line">    Header: :path: /employee.EmployeeService/GetByNo</span><br><span class="line">    Header: :authority: localhost:5001</span><br><span class="line">    Header: content-type: application/grpc</span><br><span class="line">    Header: user-agent: grpc-go/1.33.2</span><br><span class="line">    Header: te: trailers</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/network/gRPC/grpc_v1.png"></p><ul><li><strong>服务端返回流 <code>GetAll()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAll</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">stream, err := client.GetAll(context.Background(), &amp;pb.GetAllRequest&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>服务端返回的流可以使用 <code>stream.Recv()</code> 循环接收。<br><img src="/images/network/gRPC/grpc_v2.png"></li></ul><ul><li><strong>客户端推送流 <code>AddPhoto()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">imgFile,err := os.Open(<span class="string">&quot;/home/kiosk007/Pictures/2020-09-22_00-15.png&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> imgFile.Close()</span><br><span class="line"></span><br><span class="line">md := metadata.New(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;no&quot;</span>: <span class="string">&quot;1996&quot;</span>&#125;)</span><br><span class="line">context := context.Background()</span><br><span class="line">context = metadata.NewOutgoingContext(context, md)</span><br><span class="line">stream,err := client.AddPhoto(context)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">chunk := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>*<span class="number">24</span>)</span><br><span class="line">chunkSize,err := imgFile.Read(chunk)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chunkSize &lt; <span class="built_in">len</span>(chunk) &#123;</span><br><span class="line">chunk = chunk[:chunkSize]</span><br><span class="line">&#125;</span><br><span class="line">_ = stream.Send(&amp;pb.AddPhotoRequest&#123;Data: chunk&#125;)</span><br><span class="line">&#125;</span><br><span class="line">res, err := stream.CloseAndRecv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.IsOk)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>客户端推送流实现了一个照片流式上传的功能。每次发送 3072字节 (128*24)。</li></ul><ul><li><strong>双向流 <code>SaveAll()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveAll</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">employees := []pb.Employee&#123;</span><br><span class="line">pb.Employee&#123;</span><br><span class="line">Id:                   <span class="number">300</span>,</span><br><span class="line">No:                   <span class="number">5001</span>,</span><br><span class="line">FirstName:            <span class="string">&quot;Monica&quot;</span>,</span><br><span class="line">LastName:             <span class="string">&quot;Geller&quot;</span>,</span><br><span class="line">MonthSalary:          <span class="number">15500</span>,</span><br><span class="line">Status:               pb.EmployeeStatus_RETIRED,</span><br><span class="line">LastModified:         &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix() &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">pb.Employee&#123;</span><br><span class="line">Id:                   <span class="number">301</span>,</span><br><span class="line">No:                   <span class="number">5002</span>,</span><br><span class="line">FirstName:            <span class="string">&quot;Joey&quot;</span>,</span><br><span class="line">LastName:             <span class="string">&quot;Green&quot;</span>,</span><br><span class="line">MonthSalary:          <span class="number">200</span>,</span><br><span class="line">Status:               pb.EmployeeStatus_RESIGNED,</span><br><span class="line">LastModified:         &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix() &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">stream, err := client.SaveAll(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">finishChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res,err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">finishChannel &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">err := stream.Send(&amp;pb.EmployeeRequest&#123;Employee: &amp;e&#125;)</span><br><span class="line">time.Sleep(<span class="number">500</span> * time.Microsecond)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_ = stream.CloseSend()</span><br><span class="line">&lt;- finishChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>参考：</strong></p><ol><li><a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go">Protobuf 终极教程  – 鸟窝</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPC 全称 (Remote Procedure Call)，远程过程调用，指的是一台计算机通过网络请求另一台计算机的上服务，从而不需要了解底层网络细节，RPC 是构建在已经存在的协议（TCP/IP，HTTP 等）之上的。&lt;code&gt;gRPC&lt;/code&gt; 是云原生计算基金会（CNCF）项目，gRPC 一开始由 google 开发，是一款语言中立、平台中立的服务间通信框架，使用 gRPC 可以使得客户端像调用本地方法一样，调用远程主机提供的服务。可以在任何地方运行，它使客户端和服务器应用程序能够透明地进行通信，并使构建连接系统变得更加容易。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="grpc" scheme="http://kiosk007.top/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>基于Nginx的实时音频直播服务</title>
    <link href="http://kiosk007.top/2020/11/16/%E5%9F%BA%E4%BA%8ENginx%E5%AE%9E%E7%8E%B0%E7%9A%84RTMP%E6%9C%8D%E5%8A%A1/"/>
    <id>http://kiosk007.top/2020/11/16/%E5%9F%BA%E4%BA%8ENginx%E5%AE%9E%E7%8E%B0%E7%9A%84RTMP%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-11-16T15:02:00.000Z</published>
    <updated>2020-11-16T15:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在百度云上下了一些学习视频（别想歪..），苦于一台笔记本不方便同时跟着操作变播放，那么既然都有笔记本了，何不搭建一个视频播放服务呢？笔记本使用Nginx搭建一个视频服务器，iPad上使用播放器（Aplayer），不仅是播放还可以直播，这不正契合了当前的高热话题“实时音视频直播技术”么，最近也找了一部分资料，趁着直播的热度在这里总结一下。</p><a id="more"></a><p>  随着互联网用户消费内容和交互方式的升级，支撑这些内容和交互方式的基础设施也正在悄悄发生变革。手机设备拍摄视频能力和网络的升级催生了大家对视频直播领域的关注，吸引了很多互联网创业者或者成熟企业进入该领域。</p><h1 id="直播中的各个环节"><a href="#直播中的各个环节" class="headerlink" title="直播中的各个环节"></a>直播中的各个环节</h1><h2 id="完整的直播流程"><a href="#完整的直播流程" class="headerlink" title="完整的直播流程"></a>完整的直播流程</h2><p><img src="/images/live/live.jpg"></p><ul><li><font color="red"><code>音视频采集</code></font>: 采集是播放环节中的第一环，iOS 系统因为软硬件种类不多，硬件适配性较好，所以比较简单。Android 则不同，市面上硬件机型非常多，难以做到一个库适配所有硬件。PC 端的采集也跟各种摄像头驱动有关，推荐使用目前市面上最好用的 PC 端开源免费软件 OBS。</li><li><code>音视频处理</code>: 美颜、水印等也都是在这个环节做。目前 iOS 端比较知名的是 GPUImage 这个库，提供了丰富端预处理效果，还可以基于这个库自己写算法实现更丰富端效果。Android 也有 GPUImage 这个库的移植，叫做 android-gpuimage。</li><li><code>音视频编码</code>: iOS 端硬件兼容性较好，可以直接采用硬编。而 Android 的硬编的支持则难得多，需要支持各种硬件机型，推荐使用软编。</li><li><code>推流和传输</code>: 涉及 1、从主播端到服务端 2、从收流服务端到边缘节点 3、从边缘节点到观众端 。推流端和分发端理论上需要支持的并发用户数应该都是亿级的，不过毕竟产生内容的推流端在少数，和消费内容端播放端不是一个量级。对推流稳定性和速度的要求比播放端高很多，这涉及到所有播放端能否看到直播，以及直播端质量如何。</li><li><code>实时音视频转码</code>: 为了让主播推上来的流适配各个平台端各种不同协议，需要在服务端做一些流处理工作，比如转码成不同格式支持不同协议如 RTMP、HLS 和 FLV，一路转多路流来适配各种不同的网络状况和不同分辨率的终端设备。</li><li><code>解码和渲染</code>: 解码和渲染，也即音视频的播放，目前 iOS 端的播放兼容性较好，在延迟可接受的情况下使用 HLS 协议是最好的选择，市面上也提供了能够播放 RTMP 和 HLS 的播放器 SDK。</li></ul><p>参考：<a href="http://www.52im.net/thread-853-1-1.html">《移动端实时音视频直播技术详解》</a></p><p>编码器的介绍可以参考 <a href="http://www.52im.net/thread-965-1-1.html">编码与封装</a>，下面主要说一说“推流和拉流”</p><h2 id="推流和拉流"><a href="#推流和拉流" class="headerlink" title="推流和拉流"></a>推流和拉流</h2><h3 id="推送协议"><a href="#推送协议" class="headerlink" title="推送协议"></a><strong>推送协议</strong></h3><p>推流，指的是把采集阶段封包好的内容传输到服务器的过程。其实就是将现场的视频信号传到网络的过程。</p><p>“推流”对网络要求比较高，如果网络不稳定，直播效果就会很差，观众观看直播时就会发生卡顿等现象，观看体验很是糟糕。</p><p>要想用于推流还必须把音视频数据使用传输协议进行封装，变成流数据。常用的流传输协议有RTSP、RTMP、WebRTC、HLS等，使用RTMP传输的延时通常在1–3秒，对于手机直播这种实时性要求非常高的场景，RTMP也成为手机直播中最常用的流传输协议。</p><p>下面介绍一下以下协议以及他们在直播领域的现状和优缺点：<strong>1、RTMP 2、WebRTC</strong></p><h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a><strong>RTMP</strong></h4><p>RTMP 是 Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash/AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media Server/red5 等。<br>RTMP 是目前主流的流媒体传输协议，广泛用于直播领域，可以说市面上绝大多数的直播产品都采用了这个协议。<br>另外，RTMPT封装在HTTP请求之上，可穿透防火墙；</p><p><strong>优点:</strong></p><blockquote><p>CDN 支持良好，主流的 CDN 厂商都支持；<br>协议简单，在各平台上实现容易。</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>基于 TCP ，传输成本高，在弱网环境丢包率高的情况下问题显著；<br>不支持浏览器推送；<br>Adobe 私有协议，Adobe 已经不再更新。</p></blockquote><h4 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a><strong>WebRTC</strong></h4><p>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的 API。它于 2011 年 6 月 1 日开源并在 Google、Mozilla、Opera 支持下被纳入万维网联盟的 W3C 推荐标准<br><a href="https://webrtc.org.cn/">WebRTC</a> </p><p><strong>目前主要应用于视频会议和连麦中</strong></p><p><strong>优点：</strong></p><blockquote><p>W3C 标准，主流浏览器支持程度高，Google 在背后支撑，并在各平台有参考实现；<br>底层基于 SRTP 和 UDP，弱网情况优化空间大；<br>可以实现点对点通信，通信双方延时低。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>ICE、STUN、TURN 传统 CDN 没有类似的服务提供</p></blockquote><h3 id="拉流协议"><a href="#拉流协议" class="headerlink" title="拉流协议"></a><strong>拉流协议</strong></h3><p>拉流是指服务器已有直播内容，根据协议类型（如RTMP、RTP、RTSP、HTTP等），与服务器建立连接并接收数据，进行拉取的过程。</p><p>拉流端的核心处理在播放器端的解码和渲染，在互动直播中还需集成聊天室、点赞和礼物系统等功能。下面介绍几个常见的拉流协议。</p><h4 id="RTMP-1"><a href="#RTMP-1" class="headerlink" title="RTMP"></a><strong>RTMP</strong></h4><p>没错，推流和拉流都是RTMP所擅长的。现在 PC 市场巨大，PC 主要是 Windows，Windows 的浏览器基本上都支持 Flash。另外RTMP适合长时间播放，曾经有过测试，联系 100 万秒，即 10 天多连续播放没有出现问题。最后 RTMP 的延迟相对较低，一般延时在 1-3s 之间，一般的视频会议，互动式直播，完全是够用的。</p><p>不过，在移动端上，Flash Player 已经被杀绝了，那为啥还会出现这个呢？<br>因为它主要是针对 PC 端的。现在推流协议各大云厂商基本都是直接支持 rtmp 。</p><p><strong>拉流用 rtmp 的话就不太现实了，现在对 flash 支持都不友好了。</strong></p><h4 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a><strong>HLS</strong></h4><p>HLS 是苹果提出的基于HTTP的流媒体传输协议，优点是跨平台性比较好，HTML5可以直接打开播放，移动端兼容性良好，但是缺点是延迟比较高。</p><p>HLS 主要的两块内容是 .m3u8 文件和 .ts 播放文件。接受服务器会将接受到的视频流进行缓存，然后缓存到一定程度后，会将这些视频流进行编码格式化，同时会生成一份 .m3u8 文件和其它很多的 .ts 文件。</p><p>HLS 支持的功能，并不只是分片播放（专门适用于直播），它还包括其他应有的功能。</p><blockquote><p>使用 HTTPS 加密 ts 文件<br>快/倒放<br>广告插入<br>不同分辨率视频切换</p></blockquote><p><strong>HLS 之所以能这么流行，关键在于它的支持度是真的广，所以，对于一般 H5 直播来说，应该是非常友好的。</strong></p><h4 id="HDL-HTTP-FLV"><a href="#HDL-HTTP-FLV" class="headerlink" title="HDL(HTTP-FLV)"></a><strong>HDL(HTTP-FLV)</strong></h4><p>HTTP-FLV 和 RTMPT 类似，都是针对于 FLV 视频格式做的直播分发流。<br>但，两者有着很大的区别：</p><p><strong>相同点：</strong></p><blockquote><p>两者都是针对 FLV 格式<br>两者延时都很低<br>两者都走的 HTTP 通道</p></blockquote><p><strong>不同点：</strong></p><blockquote><p>HTTP-FLV直接发起长连接，下载对应的 FLV 文件<br>头部信息简单</p></blockquote><p>RTMPT握手协议过于复杂。分包，组包过程耗费精力大，因为 RTMP 发的包很容易处理，通常 RTMP 协议会作为视频上传端来处理，然后经由服务器转换为 FLV 文件，通过 HTTP-FLV 下发给用户。</p><p>参考：<a href="https://driverzhang.github.io/post/%E7%9B%B4%E6%92%AD%E5%8D%8F%E8%AE%AErtmphlshttp-flv/">直播协议RTMP、HLS、HTTP FLV</a></p><h1 id="基于Nginx搭建视频服务"><a href="#基于Nginx搭建视频服务" class="headerlink" title="基于Nginx搭建视频服务"></a>基于Nginx搭建视频服务</h1><blockquote><p>系统版本: Ubuntu 20.04 focal<br>Nginx版本:1.17.3<br>Nginx Rtmp模块: nginx-rtmp-module</p></blockquote><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><strong>Nginx</strong></h2><p>我是基于 XPS 上的Ubuntu搭建的，搭建过程之前在 <a href="https://kiosk007.top/2020/04/18/%E8%87%AA%E5%BB%BA-Nginx-%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2/">自建 Nginx 部署</a> 文章中已经提过，这里需要注意的是需要安装 <code>nginx-rtmp-module</code> 模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -m</span></span><br><span class="line">KServer version: KServer/2.3.2</span><br><span class="line">nginx version: nginx/1.17.3</span><br><span class="line">nginx: loaded modules:</span><br><span class="line">nginx:     ngx_core_module (static)</span><br><span class="line">...</span><br><span class="line">nginx:     ngx_rtmp_module (static)</span><br><span class="line">nginx:     ngx_rtmp_core_module (static)</span><br><span class="line">nginx:     ngx_rtmp_cmd_module (static)</span><br><span class="line">nginx:     ngx_rtmp_codec_module (static)</span><br><span class="line">nginx:     ngx_rtmp_access_module (static)</span><br><span class="line">nginx:     ngx_rtmp_record_module (static)</span><br><span class="line">nginx:     ngx_rtmp_live_module (static)</span><br><span class="line">nginx:     ngx_rtmp_play_module (static)</span><br><span class="line">nginx:     ngx_rtmp_flv_module (static)</span><br><span class="line">nginx:     ngx_rtmp_mp4_module (static)</span><br><span class="line">nginx:     ngx_rtmp_netcall_module (static)</span><br><span class="line">nginx:     ngx_rtmp_relay_module (static)</span><br><span class="line">nginx:     ngx_rtmp_exec_module (static)</span><br><span class="line">nginx:     ngx_rtmp_auto_push_module (static)</span><br><span class="line">nginx:     ngx_rtmp_auto_push_index_module (static)</span><br><span class="line">nginx:     ngx_rtmp_notify_module (static)</span><br><span class="line">nginx:     ngx_rtmp_log_module (static)</span><br><span class="line">nginx:     ngx_rtmp_limit_module (static)</span><br><span class="line">nginx:     ngx_rtmp_hls_module (static)</span><br><span class="line">nginx:     ngx_rtmp_dash_module (static)</span><br><span class="line">nginx:     ngx_openssl_module (static)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="视频直播服务"><a href="#视频直播服务" class="headerlink" title="视频直播服务"></a>视频直播服务</h2><p>Nginx本身是一个非常出色的HTTP服务器,FFMPEG是非常好的音视频解决方案.这两个东西通过一个Nginx的模块nginx-rtmp-module,组合在一起即可以搭建一个功能相对比较完善的流媒体服务器. 这个流媒体服务器可以支持RTMP和HLS(Live Http Stream)。</p><p>配置时需要在Nginx的主配置加上一句<code>include /home/work/nginx/rtmp/*.conf;</code>，因为 rtmp 是单独一个块，等价于 http 块。再创建目录 <code>/home/work/nginx/rtmp/</code>，之后 rtmp 的配置会放在该目录下。</p><h3 id="安装FFmpeg"><a href="#安装FFmpeg" class="headerlink" title="安装FFmpeg"></a><strong>安装FFmpeg</strong></h3><p>FFmpeg 是视频处理最常用的开源软件。名称来自MPEG视频编码标准，前面的“FF”代表“Fast Forward”，FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。可以轻易地实现多种视频格式之间的相互转换，FFmpeg的用户有Google，Facebook，Youtube，优酷，爱奇艺，土豆等。可参考阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">FFmpeg 视频处理</a> 这篇文章。</p><p>安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure><h3 id="RTMP-直播"><a href="#RTMP-直播" class="headerlink" title="RTMP 直播"></a>RTMP 直播</h3><p>在 <code>/home/work/nginx/rtmp/live.conf</code> 里创建如下内容。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">notify_method</span> get;</span><br><span class="line">        <span class="attribute">access_log</span>  /home/work/log/nginx/http_rtmp.log;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line">        <span class="attribute">application</span> rtmplive &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;                <span class="comment"># 开启直播模式</span></span><br><span class="line">            <span class="attribute">allow</span> publish all;      <span class="comment"># 允许从任何源push流</span></span><br><span class="line">            <span class="attribute">allow</span> play all;         <span class="comment"># 允许从任何地方来播放流</span></span><br><span class="line">            <span class="attribute">drop_idle_publisher</span> <span class="number">20s</span>; <span class="comment"># 20秒内没有push，就断开链接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查nginx配置后reload nginx,使之生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /home/work/nginx/sbin/nginx -t</span></span><br><span class="line"><span class="comment"># /home/work/nginx/sbin/nginx -s reload</span></span><br></pre></td></tr></table></figure><p><strong>试验</strong></p><p>使用 ffmpeg 推流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i .&#x2F;Golang从入门到癫狂.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv &#39;rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;room&#39;</span><br></pre></td></tr></table></figure><p>ipad 上去App Store下载 <strong>Aplyer</strong><br><img src="/images/live/aplyer.jpeg" style="height:350px"></p><p>打开Aplayer，选择最下方的“网络”，在输入框中输入<code>rtmp://192.168.1.10/live/room</code> 即可观看直播了。</p><h3 id="HLS直播"><a href="#HLS直播" class="headerlink" title="HLS直播"></a>HLS直播</h3><p>配置hls需要有两个步骤</p><ol><li>配置rtmp流产生hls文件</li><li>设置nginx来访问hls文件</li></ol><p><strong>配置rtmp流产生hls文件</strong><br>创建存放hls文件的目录, 确保 Nginx worker 用户可以读写该目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;work&#x2F;data&#x2F;hls</span><br><span class="line">chown work:work &#x2F;home&#x2F;work&#x2F;data&#x2F;hls</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改配置，增加hls相关配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>; <span class="comment"># Listen on standard RTMP port</span></span><br><span class="line">        <span class="attribute">notify_method</span> get;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">application</span> hlslive &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;   <span class="comment"># Turn on HLS</span></span><br><span class="line">            <span class="attribute">hls</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">hls_path</span> /home/work/data/hls;</span><br><span class="line">            </span><br><span class="line">            <span class="attribute">allow</span> publish all;          <span class="comment"># 允许从任何源push流</span></span><br><span class="line">            <span class="attribute">allow</span> play all;             <span class="comment"># 允许从任何地方来播放流</span></span><br><span class="line">            <span class="attribute">drop_idle_publisher</span> <span class="number">20s</span>;    <span class="comment"># 20秒内没有push，就断开链接。</span></span><br><span class="line">            <span class="attribute">hls_fragment</span> <span class="number">3</span>;</span><br><span class="line">            <span class="attribute">hls_playlist_length</span> <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加了如下两个配置:</p><ul><li><code>hls on</code> : 开启HLS</li><li><code>hls_path /home/work/data/hls</code> : 设置hls目录</li></ul><p>此时使用ffmpeg进行推流后，在/home/work/data/hls目录下，就会有HLS要用到的m3u8和ts文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls</span><br><span class="line">room1-0.ts  room1-1.ts  room1.m3u8</span><br></pre></td></tr></table></figure><p>设置nginx来访问hls文件<br>配置nginx通过http访问hls文件, 在server中添加如下location。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /hls &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Cache-Control&#x27;</span> <span class="string">&#x27;no-cache&#x27;</span>;   <span class="comment"># Disable cache</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># CORS setup</span></span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span> always;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="string">&#x27;Content-Length&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># allow CORS preflight requests</span></span><br><span class="line">        <span class="attribute">if</span> ($request_method = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain charset=UTF-8&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">types</span> &#123;</span><br><span class="line">            application/dash+xml mpd;</span><br><span class="line">            application/vnd.apple.mpegurl m3u8;</span><br><span class="line">            video/mp2t ts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /home/work/data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后使用支持 HLS 拉流的播放器输入 <code>http://192.168.1.8:8081/hls/room1.m3u8</code></p><p>参考：<a href="https://www.vultr.com/docs/setup-nginx-rtmp-on-centos-7#Security_Note">Setup Nginx-RTMP on CentOS 7</a></p><h2 id="视频播放服务"><a href="#视频播放服务" class="headerlink" title="视频播放服务"></a>视频播放服务</h2><p>毕竟是已经下载好的视频，这里是不存在直播推流的，那么可以直接播放已经存在的视频。视频的格式最好是 mp4 格式，Nginx 配置文件如下即可：</p><h3 id="mp4"><a href="#mp4" class="headerlink" title="mp4"></a>mp4</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">8088</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#错误日志和访问日志的路径配置</span></span><br><span class="line">   <span class="attribute">access_log</span>  /home/work/log/nginx/http_video.log  jxjson;</span><br><span class="line">   <span class="attribute">error_log</span>   /home/work/log/nginx/video-<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">#项目的路径 </span></span><br><span class="line">   <span class="attribute">root</span> /home/work/data/mp4;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#所有的mp4文件的自动解析</span></span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~ \.mp4$</span> &#123;</span><br><span class="line">      mp4;</span><br><span class="line">      <span class="attribute">mp4_buffer_size</span>     <span class="number">1m</span>;</span><br><span class="line">      <span class="attribute">mp4_max_buffer_size</span> <span class="number">5m</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器输入 <code>192.168.1.8:8088/2-1.mp4</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在百度云上下了一些学习视频（别想歪..），苦于一台笔记本不方便同时跟着操作变播放，那么既然都有笔记本了，何不搭建一个视频播放服务呢？笔记本使用Nginx搭建一个视频服务器，iPad上使用播放器（Aplayer），不仅是播放还可以直播，这不正契合了当前的高热话题“实时音视频直播技术”么，最近也找了一部分资料，趁着直播的热度在这里总结一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://kiosk007.top/categories/Nginx/"/>
    
    
    <category term="点播" scheme="http://kiosk007.top/tags/%E7%82%B9%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>玩转 tshark 命令行工具</title>
    <link href="http://kiosk007.top/2020/11/07/%E7%8E%A9%E8%BD%AC-tshark-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://kiosk007.top/2020/11/07/%E7%8E%A9%E8%BD%AC-tshark-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</id>
    <published>2020-11-07T14:26:00.000Z</published>
    <updated>2020-11-07T14:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>玩转TShark（Wireshark的命令行版）<br>wireshark 是一个伟大的网络问题分析工具，当然它也是有终端命令行工具的。<strong>tshark</strong>就是wireshark的命令行之一。WireShark的功能基本都有，还能组合grep/awk等编程处理分析抓包文件。</p><a id="more"></a><h1 id="wireshark-自带命令集"><a href="#wireshark-自带命令集" class="headerlink" title="wireshark 自带命令集"></a>wireshark 自带命令集</h1><p>Wireshark除了能够手动的分析报文之外，还额外的提供了几个命令行工具，方便开发者日常的报文处理需求，比如批量的合并以及编辑报文。这几个命令都是安装wireshark之后能够直接使用的，同时有的有对应的wireshark GUI 的操作。这些命令分别有<code>tshark</code>、<code>tcpdump</code>、<code>capinfos</code>、<code>dumpcap</code>、<code>text2cap</code>、<code>editcap</code>、<code>reordercap</code>、<code>rawshark</code>、<code>mergecap</code>、<code>pcapfix(需单独安装)</code>。</p><ul><li>tshark：基于终端的Wireshark</li><li>tcpdump：使用“tcpdump”捕获以便使用Wireshark查看</li><li>dumpcap：捕获“dumpcap”以便使用Wireshark查看</li><li>capinfos：打印有关捕获文件的信息</li><li>rawshark：转储和分析网络流量。</li><li>editcap：编辑捕获文件</li><li>mergecap：将多个捕获文件合并为一个</li><li>text2pcap：将ASCII hexdumps转换为网络捕获</li><li>reordercap：重新排序捕获文件</li><li>pcapfix: 修复pcap文件</li></ul><h1 id="pcap"><a href="#pcap" class="headerlink" title="pcap"></a>pcap</h1><h2 id="认识-pcap"><a href="#认识-pcap" class="headerlink" title="认识 pcap"></a>认识 pcap</h2><p>尝试查找网络问题的根源时，有助于查看可能是症状的数据包。为了查看这些数据包，必须首先捕获它们。</p><p>Wireshark默认的存储方式是pcap格式，最新版本的wireshark默认存储方式是pcapng。ng是next generation 的缩写，pcap和pcapng格式文件有是存在一定的差异。</p><p>pcap报文文件结构示意图<br><img src="/images/tshark/pcap_file_format.png" alt="pcap_format"></p><ol><li>Global Header是整个文件的文件头，包含文件格式标识，pcap格式版本号等文件指示信息。</li><li>Packet Header是每一片数据报文的头部信息，这些信息都是在形成pcap 报文的过程中由抓包软件wireshark添加的额外信息，例如报文捕获时间等。</li><li>Packet Data是抓取通信过程中的实际数据，包括协议数据和内容数据。</li></ol><p>Wireshark 中对 Global Header 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcap_hdr_s</span> &#123;</span></span><br><span class="line">        guint32 magic_number;   <span class="comment">/* magic number */</span></span><br><span class="line">        guint16 version_major;  <span class="comment">/* major version number */</span></span><br><span class="line">        guint16 version_minor;  <span class="comment">/* minor version number */</span></span><br><span class="line">        gint32  thiszone;       <span class="comment">/* GMT to local correction */</span></span><br><span class="line">        guint32 sigfigs;        <span class="comment">/* accuracy of timestamps */</span></span><br><span class="line">        guint32 snaplen;        <span class="comment">/* max length of captured packets, in octets */</span></span><br><span class="line">        guint32 network;        <span class="comment">/* data link type */</span></span><br><span class="line">&#125; <span class="keyword">pcap_hdr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Wireshark 中对 Packet Header 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcaprec_hdr_s</span> &#123;</span></span><br><span class="line">        guint32 ts_sec;         <span class="comment">/* timestamp seconds */</span></span><br><span class="line">        guint32 ts_usec;        <span class="comment">/* timestamp microseconds */</span></span><br><span class="line">        guint32 incl_len;       <span class="comment">/* number of octets of packet saved in file */</span></span><br><span class="line">        guint32 orig_len;       <span class="comment">/* actual length of packet */</span></span><br><span class="line">&#125; <span class="keyword">pcaprec_hdr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取-pcap"><a href="#获取-pcap" class="headerlink" title="获取 pcap"></a>获取 pcap</h2><ul><li><strong>服务器</strong> :推荐使用 tcpdump or tshark (tshark –color 可以染色哦) 命令行</li><li><strong>个人电脑</strong>: 推荐使用 wireshark </li><li><strong>Android 移动设备</strong>: 推荐使用 <a href="https://github.com/egorovandreyrm/pcap-remote">Pcap Remote</a> (需要在 Google Play 下载) </li><li><strong>iOS 移动设备</strong>: 推荐使用 <code>rvictl -s [设备udid]</code> 方式抓包，参考 <a href="https://www.jianshu.com/p/c67baf5fce6d">Wireshark 抓包iOS设备</a></li></ul><p>更多获取 pcap 方法参考 <a href="https://tshark.dev/capture/">捕获pcap</a></p><h1 id="tshark"><a href="#tshark" class="headerlink" title="tshark"></a>tshark</h1><p><a href="https://www.wireshark.org/docs/man-pages/tshark.html">tshark官方文档</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TShark是一个网络分析工具。它能帮你在实时网络中捕获数据包，或是从预先保存好的捕获文件中读取数据包，或是打印出这些数据包的解码形式到标准输出，再或是把数据包写入到一个文件中。TShark的本地捕获文件格式是pcapng格式，这种pcapng格式也被wireshark和多种其他工具使用。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><a href="https://tshark.dev/packetcraft/arcana/profiles/#-o-keyvalue">-o ${key:value} </a> : 配置首选项中的settings, 一般可配置显示时间戳、是否相关seq number，或者TLS、WPA 解密等。</li></ul><img src="/images/tshark/tshark_o.png" style="height:200px"><ul><li><a href="https://www.wireshark.org/docs/man-pages/tshark.html">-z ${statistics} </a> : 集各种类型的统计信息, 这里面有一些信息是很有用的，如专家信息、时序统计飞行中的报文、时序丢包都需要这个参数来</li></ul><img src="/images/tshark/tshark_z.png" style="height:350px"><p><strong>其余参数如下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓包接口类</span></span><br><span class="line">-i 设置抓包的网络接口，不设置则默认为第一个非自环接口。</span><br><span class="line">-D 列出当前存在的网络接口。在不了解OS所控制的网络设备时，一般先用“tshark -D”查看网络接口的编号以供-i参数使用。</span><br><span class="line">-f 设定抓包过滤表达式（capture filter expression）。抓包过滤表达式的写法雷同于tcpdump</span><br><span class="line">-s 设置每个抓包的大小，默认为65535，多于这个大小的数据将不会被程序记入内存、写入文件</span><br><span class="line">-p 设置网络接口以非混合模式工作，即只关心和本机有关的流量</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止抓包参数</span></span><br><span class="line">-c 抓取的packet数，在处理一定数量的packet后，停止抓取，程序退出。</span><br><span class="line">-a 设置tshark抓包停止向文件书写的条件，事实上是tshark在正常启动之后停止工作并返回的条件。条件写为<span class="built_in">test</span>:value的形式，如“-a duration:5”表示tshark启动后在5秒内抓包然后停止；“-a filesize:10”表示tshark在输出文件达到10kB后停止；“-a files:n”表示tshark在写满n个文件后停止。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理类</span></span><br><span class="line">-R 设置读取（显示）过滤表达式（<span class="built_in">read</span> filter expression）。不符合此表达式的流量同样不会被写入文件。</span><br><span class="line">-n 禁止所有地址名字解析（默认为允许所有）。</span><br><span class="line">-N 启用某一层的地址名字解析。“m”代表MAC层，“n”代表网络层，“t”代表传输层，“C”代表当前异步DNS查找。如果-n和-N参数同时存在，-n将被忽略。如果-n和-N参数都不写，则默认打开所有地址名字解析。</span><br><span class="line">-d 将指定的数据按有关协议解包输出。如要将tcp 8888端口的流量按http解包，应该写为“-d tcp.port==8888,http”。注意选择子和解包协议之间不能留空格。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类</span></span><br><span class="line">-w 设置raw数据的输出文件。这个参数不设置，tshark将会把解码结果输出到stdout。“-w-”表示把raw输出到stdout。如果要把解码结果输出到文件，使用重定向“&gt;”而不要-w参数。</span><br><span class="line">-F 设置输出raw数据的格式，默认为libpcap。“tshark -F”会列出所有支持的raw格式。</span><br><span class="line">-V 设置将解码结果的细节输出，否则解码结果仅显示一个packet一行的summary。</span><br><span class="line">-x 设置在解码输出结果中，每个packet后面以HEX dump的方式显示具体数据。</span><br><span class="line">-T 设置解码结果输出的格式，包括text,ps,psml和pdml，默认为text。</span><br><span class="line">-E: -E &lt;fieldsoption&gt;=&lt;value&gt;如果-T fields选项指定，使用-E来设置一些属性，比如</span><br><span class="line">　　　　header=y|n</span><br><span class="line">　　　　separator=/t|/s|&lt;char&gt;</span><br><span class="line">　　　　occurrence=f|l|a</span><br><span class="line">　　　　aggregator=,|/s|&lt;char&gt;</span><br><span class="line">-t 设置解码结果的时间格式。“ad”表示带日期的绝对时间，“a”表示不带日期的绝对时间，“r”表示从第一个包到现在的相对时间，“d”表示两个相邻包之间的增量时间（delta）。</span><br><span class="line">-S 在向raw文件输出的同时，将解码结果打印到控制台。</span><br><span class="line">-l 在处理每个包时即时刷新输出。</span><br><span class="line">-X 扩展项。</span><br><span class="line">-q 设置安静的stdout输出（例如做统计时）</span><br><span class="line">-z 设置统计参数。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line">-h 显示命令行帮助。</span><br><span class="line">-v 显示tshark的版本信息。</span><br><span class="line">-o 重载选项</span><br></pre></td></tr></table></figure><h2 id="利用-tshark-打印pcap"><a href="#利用-tshark-打印pcap" class="headerlink" title="利用 tshark 打印pcap"></a>利用 tshark 打印pcap</h2><p>我们通过tcpdump或者wireshark抓到 pcap 文件，接下来就可以利用 <code>tshark</code> 这个强大的命令行工具进行抓包。其中 <code>-o </code>的几个选项可以指定 ssl 解密（需要sslkeylog），<code>-T</code> 指定输出格式，<code>-e</code> 指定都需要输出哪些字段（字段列表参考 <a href="https://www.wireshark.org/docs/dfref/%EF%BC%89%E3%80%82%E8%BE%93%E5%87%BA%E6%98%AF%E5%B0%86%E6%AF%8F%E4%B8%AAPackage%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E6%AE%B5%E8%BE%93%E5%87%BA%E3%80%82">https://www.wireshark.org/docs/dfref/）。输出是将每个Package中指定的字段输出。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tshark -o ssl.keylog_file:./sslkeylog.txt \</span><br><span class="line">-o <span class="string">&quot;ssl.desegment_ssl_records: TRUE&quot;</span> \</span><br><span class="line">-o <span class="string">&quot;ssl.desegment_ssl_application_data: TRUE&quot;</span> \</span><br><span class="line">-e ssl.handshake.ciphersuite \  </span><br><span class="line">-e tcp.analysis.zero_window \</span><br><span class="line">-e http.host \</span><br><span class="line">-e dns.time \</span><br><span class="line">-e tcp.flags.urg \</span><br><span class="line">-e http.request.line \</span><br><span class="line">-e dns.qry.name \</span><br><span class="line">-e ip.version \</span><br><span class="line">-e tcp.analysis.window_full \</span><br><span class="line">-e ipv6.dst \</span><br><span class="line">-e http.request.version \</span><br><span class="line">-e udp.dstport \</span><br><span class="line">-e dns.flags.response \</span><br><span class="line">.... \</span><br><span class="line">-T json -r <span class="string">&quot;./capturedump.pcap&quot;</span></span><br></pre></td></tr></table></figure><p>其余更多的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//打印http协议流相关信息</span><br><span class="line">tshark -s 512 -i eth0 -n -f <span class="string">&#x27;tcp dst port 80&#x27;</span> -Y <span class="string">&#x27;http.host and http.request.uri&#x27;</span> -T fields -e http.host -e http.request.uri -l</span><br><span class="line"></span><br><span class="line">//实时打印当前mysql查询语句</span><br><span class="line">tshark -s 512 -i eth0 -n -f <span class="string">&#x27;tcp dst port 3306&#x27;</span> -Y <span class="string">&#x27;mysql.query&#x27;</span> -T fields -e mysql.query</span><br><span class="line"></span><br><span class="line">//解析MySQL协议</span><br><span class="line">tshark -r ./mysql-compress.cap -o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields -e mysql.caps.cp -e frame.number \</span><br><span class="line">-e frame.time_epoch  -e frame.time_delta_displayed  \</span><br><span class="line">-e ip.src -e tcp.srcport -e tcp.dstport -e ip.dst \</span><br><span class="line">-e tcp.time_delta -e frame.time_delta_displayed \</span><br><span class="line">-e tcp.stream -e tcp.len -e mysql.query</span><br><span class="line"></span><br><span class="line">//抓取详细SQL语句, 快速确认client发过来的具体SQL内容：</span><br><span class="line">sudo tshark -i any -f <span class="string">&#x27;port 3306&#x27;</span> -s 0 -l -w - |strings</span><br><span class="line">sudo tshark -i eth0 -d tcp.port==3306,mysql -T fields -e mysql.query <span class="string">&#x27;port 3306&#x27;</span></span><br><span class="line">sudo tshark -i eth0 -Y <span class="string">&quot;ip.addr==11.163.182.137&quot;</span> -d tcp.port==3306,mysql -T fields -e mysql.query <span class="string">&#x27;port 3306&#x27;</span></span><br><span class="line">sudo tshark -i eth0 -Y <span class="string">&quot;tcp.srcport==62877&quot;</span> -d tcp.port==3001,mysql -T fields -e tcp.srcport -e mysql.query <span class="string">&#x27;port 3001&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查看请求目标信息"><a href="#查看请求目标信息" class="headerlink" title="查看请求目标信息"></a>查看请求目标信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcap -o <span class="string">&#x27;gui.column.format:&quot;Source Net Addr&quot;,&quot;%uns&quot;,&quot;Dest Net Addr&quot;, &quot;%und&quot;&#x27;</span> -Y <span class="string">&quot;ip&quot;</span> | sort | uniq</span><br><span class="line">111.206.101.25 → 192.168.100.115</span><br><span class="line">111.206.4.92 → 192.168.100.115</span><br><span class="line">119.167.215.208 → 192.168.100.115</span><br><span class="line">122.14.230.129 → 192.168.100.115</span><br><span class="line">123.125.102.19 → 192.168.100.115</span><br><span class="line">192.168.100.115 → 111.161.111.119</span><br><span class="line">192.168.100.115 → 111.206.101.25</span><br><span class="line">192.168.100.115 → 111.206.4.92</span><br><span class="line">192.168.100.115 → 119.167.215.208</span><br></pre></td></tr></table></figure><h2 id="查看所有请求对象的传输数据情况"><a href="#查看所有请求对象的传输数据情况" class="headerlink" title="查看所有请求对象的传输数据情况"></a>查看所有请求对象的传输数据情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 统计 ip 情况</span><br><span class="line">$ tshark -r wechat.pcap -q -z conv,ip</span><br><span class="line">// 跟踪一条流打印 16进制数据</span><br><span class="line">$ tshark -r wechat.pcap -q -z <span class="string">&quot;follow,tcp,hex,0&quot;</span> </span><br></pre></td></tr></table></figure><p><img src="/images/tshark/tshark_conv.png" alt="conv"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcap -q -z io,<span class="built_in">stat</span>,1,<span class="string">&quot;COUNT(tcp.analysis.retransmission) tcp.analysis.retransmission&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.fast_retransmission) tcp.analysis.fast_retransmission&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.duplicate_ack) tcp.analysis.duplicate_ack&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.lost_segment) tcp.analysis.lost_segment&quot;</span></span><br></pre></td></tr></table></figure><p>分析整个抓包的吞吐量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -o tcp.desegment_tcp_streams:FALSE -n -q -r wechat.pcapng -z io,stat,1,&quot;BYTES()tcp.stream&#x3D;&#x3D;0&quot;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">| IO Statistics               |</span><br><span class="line">|                             |</span><br><span class="line">| Duration: 50.712225 secs    |</span><br><span class="line">| Interval:  1 secs           |</span><br><span class="line">|                             |</span><br><span class="line">| Col 1: BYTES()tcp.stream&#x3D;&#x3D;0 |</span><br><span class="line">|-----------------------------|</span><br><span class="line">|          |1       |         |</span><br><span class="line">| Interval |  BYTES |         |</span><br><span class="line">|-------------------|         |</span><br><span class="line">|  0 &lt;&gt;  1 |      0 |         |</span><br><span class="line">|  1 &lt;&gt;  2 |      0 |         |</span><br><span class="line">...</span><br><span class="line">|  8 &lt;&gt;  9 | 128301 |         |</span><br><span class="line">|  9 &lt;&gt; 10 | 127132 |         |</span><br><span class="line">| 10 &lt;&gt; 11 | 128667 |         |</span><br><span class="line">| 11 &lt;&gt; 12 | 127749 |         |</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>wireshark 的TCP流图中的吞吐量</p><img src="/images/tshark/wireshark_throughput.png" style="height:300px"><p>对比通过 tshark的 io graph 绘出的图。</p><img src="/images/tshark/tshark_throughput.png" style="weight:300px"><p>同理可以绘 丢包重传、飞行中的报文等。</p><p>对于排查网络延时/应用问题有一些过滤条件是非常有用的：</p><ul><li><code>tcp.analysis.lost_segment</code>：表明已经在抓包中看到不连续的序列号。报文丢失会造成重复的ACK，这会导致重传。</li><li><code>tcp.analysis.duplicate_ack</code>：显示被确认过不止一次的报文。大量的重复ACK是TCP端点之间高延时的迹象。</li><li><code>tcp.analysis.retransmission</code>：显示抓包中的所有重传。如果重传次数不多的话还是正常的，过多重传可能有问题。这通常意味着应用性能缓慢和/或用户报文丢失。</li><li><code>tcp.analysis.window_update</code>：将传输过程中的TCP window大小图形化。如果看到窗口大小下降为零，这意味着发送方已经退出了，并等待接收方确认所有已传送数据。这可能表明接收端已经不堪重负了。</li><li><code>tcp.analysis.bytes_in_flight</code>：某一时间点网络上未确认字节数。未确认字节数不能超过你的TCP窗口大小（定义于最初3此TCP握手），为了最大化吞吐量你想要获得尽可能接近TCP窗口大小。如果看到连续低于TCP窗口大小，可能意味着报文丢失或路径上其他影响吞吐量的问题。</li><li><code>tcp.analysis.ack_rtt</code>：衡量抓取的TCP报文与相应的ACK。如果这一时间间隔比较长那可能表示某种类型的网络延时（报文丢失，拥塞，等等）。</li></ul><h2 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h2><ul><li>分析SQL查询的时间分布</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">tshark -r gege_drds.pcap \</span><br><span class="line">-Y <span class="string">&quot;mysql.query or (tcp.srcport==3306  and tcp.len&gt;60)&quot;</span> \</span><br><span class="line">-o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields \</span><br><span class="line">-e frame.number -e frame.time_epoch  \</span><br><span class="line">-e frame.time_delta_displayed  \</span><br><span class="line">-e ip.src -e tcp.srcport -e tcp.dstport -e ip.dst \</span><br><span class="line">-e tcp.time_delta -e tcp.stream -e tcp.len \</span><br><span class="line">| awk <span class="string">&#x27;BEGIN &#123; \</span></span><br><span class="line"><span class="string">sum0=0;sum3=0;sum10=0;sum30=0;sum50=0; \</span></span><br><span class="line"><span class="string">sum100=0;sum300=0;sum500=0;sum1000=0;\</span></span><br><span class="line"><span class="string">sumo=0;count=0;sum=0</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">&#123; \</span></span><br><span class="line"><span class="string">rt=$8; \</span></span><br><span class="line"><span class="string">if(rt&gt;=0.000) sum=sum+rt; count=count+1; \</span></span><br><span class="line"><span class="string">if(rt&lt;=0.000) sum0=sum0+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.003) sum3=sum3+1 ;\</span></span><br><span class="line"><span class="string">else if(rt&lt;0.01) sum10=sum10+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.03) sum30=sum30+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.05) sum50=sum50+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.1) sum100=sum100+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.3) sum300=sum300+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.5) sum500=sum500+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 1) sum1000=sum1000+1; \</span></span><br><span class="line"><span class="string">else sum=sum+1 ; \</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">END &#123; printf &quot;-------------\n3ms:\t%s \n10ms:\t%s \n30ms:\t%s \n50ms:\t%s \n100ms:\t%s \n300ms:\t%s \n500ms:\t%s \n1000ms:\t%s \n&gt;1s:\t %s\n-------------\navg: %.6f \n&quot; , sum3,sum10,sum30,sum50,sum100,sum300,sum500,sum1000,sumo,sum/count;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"> -------------</span><br><span class="line">3ms:    145037 </span><br><span class="line">10ms:    78811 </span><br><span class="line">30ms:    7032 </span><br><span class="line">50ms:    2172 </span><br><span class="line">100ms:    1219 </span><br><span class="line">300ms:    856 </span><br><span class="line">500ms:    449 </span><br><span class="line">1000ms:118</span><br><span class="line">&gt;1s:    0</span><br><span class="line">-------------</span><br><span class="line">avg: 0.005937 </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>分析每个包的response time</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r rsb2.cap -o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields -e frame.number -e frame.time_epoch \</span><br><span class="line">-e ip.src -e ip.dst -e tcp.stream -e tcp.len \</span><br><span class="line">-e tcp.analysis.initial_rtt -e tcp.time_delta</span><br><span class="line"></span><br><span class="line">14811465269331.308138000100.98.199.3610.25.92.1330200.002276000</span><br><span class="line">14821465269331.30818600010.25.92.13    100.98.199.36361110.000063000</span><br><span class="line">14831465269331.308209000100.98.199.3610.25.92.1349600.004950000</span><br><span class="line">14841465269331.308223000100.98.199.3610.25.92.1351300.000000000</span><br><span class="line">14851465269331.308238000100.98.199.3610.25.92.1332600.055424000</span><br><span class="line">14861465269331.308246000100.98.199.3610.25.92.1351400.000000000</span><br><span class="line">14871465269331.30826100010.25.92.71    10.25.92.134800.000229000</span><br><span class="line">14881465269331.308277000100.98.199.3610.25.92.1325400.055514000</span><br></pre></td></tr></table></figure><ul><li>分析rtt时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcapng -q -z \</span><br><span class="line">io,<span class="built_in">stat</span>,5,<span class="string">&quot;MIN(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span>,\</span><br><span class="line"><span class="string">&quot;MAX(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span>,\</span><br><span class="line"><span class="string">&quot;AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br><span class="line"></span><br><span class="line">========================================================</span><br><span class="line">| IO Statistics                                        |</span><br><span class="line">|                                                      |</span><br><span class="line">| Duration: 50.712225 secs                             |</span><br><span class="line">| Interval:  5 secs                                    |</span><br><span class="line">|                                                      |</span><br><span class="line">| Col 1: MIN(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|     2: MAX(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|     3: AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|------------------------------------------------------|</span><br><span class="line">|          |1         |2         |3         |          |</span><br><span class="line">| Interval |    MIN   |    MAX   |    AVG   |          |</span><br><span class="line">|-------------------------------------------|          |</span><br><span class="line">|  0 &lt;&gt;  5 | 0.000000 | 0.000000 | 0.000000 |          |</span><br><span class="line">|  5 &lt;&gt; 10 | 0.000987 | 0.358817 | 0.293383 |          |</span><br><span class="line">| 10 &lt;&gt; 15 | 0.001537 | 1.125008 | 0.336217 |          |</span><br><span class="line">| 15 &lt;&gt; 20 | 0.001598 | 0.745323 | 0.632126 |          |</span><br><span class="line">| 20 &lt;&gt; 25 | 0.002196 | 1.454920 | 0.584168 |          |</span><br><span class="line">| 25 &lt;&gt; 30 | 0.002674 | 0.892343 | 0.771408 |          |</span><br><span class="line">| 30 &lt;&gt; 35 | 0.001505 | 1.406873 | 1.066937 |          |</span><br><span class="line">| 35 &lt;&gt; 40 | 0.001333 | 1.372204 | 1.267557 |          |</span><br><span class="line">| 40 &lt;&gt; 45 | 0.001366 | 1.410311 | 1.204430 |          |</span><br><span class="line">| 45 &lt;&gt; 50 | 0.001513 | 1.360609 | 1.008420 |          |</span><br><span class="line">| 50 &lt;&gt; Dur| 0.001609 | 1.378431 | 0.956597 |          |</span><br><span class="line">========================================================</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="tshark-抓包"><a href="#tshark-抓包" class="headerlink" title="tshark 抓包"></a>tshark 抓包</h1><p>最后让我们来用伟大的tshark抓包吧，快放弃古老的 tcpdump。</p><p>执行 <code>sudo tshark -Y &#39;ip.addr == 8.8.8.8&#39; --color</code><br>会在终端以wireshark的风格开始抓包。<br><img src="/images/tshark/tshark_capture.png"></p><p>参考：</p><ul><li><a href="https://plantegg.github.io/2019/06/21/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82%E6%8A%93%E5%8C%85--WireShark%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88tshark/">就是让你懂抓包–WireShark之命令行版tshark</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;玩转TShark（Wireshark的命令行版）&lt;br&gt;wireshark 是一个伟大的网络问题分析工具，当然它也是有终端命令行工具的。&lt;strong&gt;tshark&lt;/strong&gt;就是wireshark的命令行之一。WireShark的功能基本都有，还能组合grep/awk等编程处理分析抓包文件。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式（Design Pattern）</title>
    <link href="http://kiosk007.top/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Pattern%EF%BC%89/"/>
    <id>http://kiosk007.top/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Pattern%EF%BC%89/</id>
    <published>2020-10-24T08:08:00.000Z</published>
    <updated>2020-10-24T08:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><a id="more"></a><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>“设计模式”总的来说有设计原则6个.</p><ul><li><strong>单一职责原则(Single Responsibility Principle, SRP)</strong> : 每个模块或类都应该对软件提供的功能的一部分负责，而这个责任应该完全由类来封装。它的所有服务都应严格遵守这一职责。</li><li><strong>开闭原则(Open Close Principle, OCP)</strong> : 软件中的对象(类、模块、函数等)对扩展是开放的，对修改是封闭的。</li><li><strong>里氏替换原则(Liskov Substitution Principle, LSP)</strong> : 所有使用基类的地方必须能透明地使用其子类的对象</li><li><strong>依赖倒转原则(Dependence Inversion Principle, DIP)</strong> : 是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</li><li><strong>接口隔离原则(Interface Segregation Principle, ISP)</strong> : 客户端不应该依赖它不需要的接口。</li><li><strong>迪米特法则(Law of Demeter, LoD), 最少知识原则(Principle of Least Knowledge)</strong> : 1. 每个对象应该对其他对象尽可能最少的知道 2. 每个对象应该仅和其朋友通信；不和陌生人通信 3. 仅仅和直接朋友通信</li></ul><hr><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 (Singleton)"></a>单例模式 (Singleton)</h2><ul><li><font color="#808080"><strong>定义以及使用场景</strong></font></li></ul><ol><li>确保某一个类只有一个实例，而且向整个系统提供这个实例</li><li>确保某个类有且仅有一个对象的场景，避免产生多个对象消耗过多的资源；或者某种类型的对象应该有且只有一个。（如 Logger 实例、Config 实例等）</li></ol><ul><li><font color="#808080"><strong>实现单例模式的几个关键点</strong></font></li></ul><ol><li>构造函数不对外开放，一般为private</li><li>通过一个静态方法或者枚举返回单例类对象</li><li>确保单例类的对象有且只有一个，尤其是在多线程环境下</li><li>确保单例类对象在反序列化时不会重新构建对象</li></ol><ul><li><font color="#200000"><strong>饥汉模式</strong></font></li></ul><p>直接创建好对象，这样不需要判断为空，同时也是线程安全。唯一的缺点是在导入包的同时会创建该对象，并持续占有在内存中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance Tool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="#200000"><strong>懒汉模式 (Lazy Loading)</strong></font></li></ul><p>只有需要时才会初始化，在一定程度上节约了资源。如果不加锁的话非线程安全，即在多线程下可能会创建多次对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private</span></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// public</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">instance = &amp;singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="#200000"><strong>DCL(双重检查)模式 (推荐)</strong></font></li></ul><p>DCL的优点就是资源利用率高，只有第一次执行getInstance才会初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> instance Tool</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第一次判断不加锁，第二次加锁保证线程安全，一旦对象建立后,获取对象就不用加锁了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">            instance = <span class="built_in">new</span>(Tool)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在golang中还可以使用 <code>sync.Once</code> 保证单例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = <span class="built_in">new</span>(Tool)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="工厂方法模式-Factory-method"><a href="#工厂方法模式-Factory-method" class="headerlink" title="工厂方法模式(Factory method)"></a>工厂方法模式(Factory method)</h2><ul><li><font color="#808080"><strong>定义以及使用场景</strong></font></li></ul><p>创建一个用户创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p><p><strong>使用场景</strong>：</p><ol><li>工厂方法模式通过依赖抽象来达到解耦的效果，并且将实例化的任务交给子类去完成，有非常好的扩展性</li><li>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂方法</li><li>工厂方法模式的应用非常广泛，然而缺点也很明显，就是每次我们为工厂方法添加新的产品时，都需要编写一个新的产品类，所以要根据实际情况来权衡是否要用工厂方法模式</li></ol><p>类似我要造汽车，将造汽车的通用的几个方法定义好，就可以创建一个接口。任何实现了这套造汽车标准的厂商都可以被初始化。并造出一辆汽车。</p><ul><li><font color="#808080"><strong>举例实现工厂方法模式</strong></font></li></ul><p>假设我们在做一款小型翻译软件，软件可以将德语、英语、日语都翻译成目标中文，并显示在前端。</p><ul><li><font color="#200000"><strong>简单工厂模式</strong></font></li></ul><p>我们会有三个具体的语言翻译结构体，或许以后还有更多，但现在分别是GermanTranslater、EnglishTranslater、JapaneseTranslater，他们都共同实现了一个接口Translator。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻译接口</span></span><br><span class="line"><span class="keyword">type</span> Translator <span class="keyword">interface</span> &#123;</span><br><span class="line">Translate(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//德语翻译类</span></span><br><span class="line"><span class="keyword">type</span> GermanTranslator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*GermanTranslator)</span> <span class="title">Translate</span><span class="params">(words <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;德语&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//英语翻译类</span></span><br><span class="line"><span class="keyword">type</span> EnglishTranslator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*EnglishTranslator)</span> <span class="title">Translate</span><span class="params">(words <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;英语&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在程序入口获取用户输入的文本，并将其翻译</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lan <span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s ,%s&quot;</span>, <span class="string">&quot;以下是可翻译的语言种类，请输入代表数字&quot;</span>, <span class="string">&quot;1：德语、2：英语&quot;</span>)</span><br><span class="line">_, _ = fmt.Scanln(&amp;lan)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入要翻译成中文的文本：&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> inputWords <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;inputWords)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> translator Translator</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的语言种类，实例化不同的翻译类</span></span><br><span class="line"><span class="keyword">switch</span> lan &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">translator = <span class="built_in">new</span>(GermanTranslator)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">translator = <span class="built_in">new</span>(EnglishTranslator)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;no such translator&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(translator.Translate(inputWords))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ol><li>违背了开闭原则，以后还可能有法语、俄语、阿拉伯语等其他翻译器，每一次添加翻译器都要在客户端代码增加对应的switch分支，维护成本高。倘若还有不止一处调用了创建逻辑，还要维护多处代码。</li><li>违背了单一职责原则，客户端处理类的职责应该只是负责接收用户的输入并将其打印，现在还负责翻译类的创建逻辑，导致这个类的职责过多。</li></ol><p>改造</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTranslator</span><span class="params">(lan <span class="keyword">int</span>)</span> <span class="title">Translator</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> translator Translator</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> lan &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">translator = <span class="built_in">new</span>(GermanTranslator)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">translator = <span class="built_in">new</span>(EnglishTranslator)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;no such translator&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> translator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">...</span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入要翻译成中文的文本：&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> inputWords <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;inputWords)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端只关注如何获取翻译类，而不用关注创建翻译类的细节</span></span><br><span class="line">translator:=CreateTranslator(lan)</span><br><span class="line"></span><br><span class="line">fmt.Println(translator.Translate(inputWords))</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式(Builder)"></a>建造者模式(Builder)</h2><ul><li><font color="#808080"><strong>定义以及使用场景</strong></font></li></ul><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>使用场景：</strong></p><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果却又不相同时<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的结果，这个时候使用建造者模式非常合适</li><li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时</li></ol><blockquote><p><strong>Product</strong> 产品类——产品的抽象类<br><strong>Builder</strong> 抽象Builder类，规范产品的组建，一般由子类实现具体的组建过程<br><strong>ConcreteBuilder</strong> 具体的Builder类<br><strong>Director</strong> 统一组装过程</p></blockquote><ul><li><font color="#200000"><strong>举个例子</strong></font></li></ul><p>我们需要创建汽车，而汽车有轮胎的个数以及车身的颜色可定制，那么用Builder模式可以这样。</p><p>我们的目标是建一辆车</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一辆车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Wheels <span class="keyword">string</span></span><br><span class="line">Chassis <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Builder Complete ...&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Wheels : %s Chassis: %s \n&quot;</span>, c.Wheels, c.Chassis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计出完整的建设规划</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为建造者实现 Builder 接口</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">NewProduct()       <span class="comment">// 创建一个空产品</span></span><br><span class="line">BuildWheels()      <span class="comment">// 建造轮子</span></span><br><span class="line">BuildChassis()    <span class="comment">// 建造底盘</span></span><br><span class="line">GetResult() <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 获取建造好的产品</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照Builder规划一个大型项目构造者CarBuilder, 包含如何具体实现Build</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义汽车建造项目 CarBuilder</span></span><br><span class="line"><span class="keyword">type</span> CarBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">Car *Car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> cb.Car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">NewProduct</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car = <span class="built_in">new</span>(Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">BuildWheels</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car.Wheels = <span class="string">&quot;米其林轮胎&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">BuildChassis</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car.Chassis = <span class="string">&quot;沃尔沃底盘&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面要把具体建造者传入指挥者:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把建造者传入指挥者</span></span><br><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span> &#123;</span><br><span class="line">builder Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">SetBuilder</span><span class="params">(builder Builder)</span></span> &#123;</span><br><span class="line">d.builder = builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建造实施</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">CarBuilderImpl</span><span class="params">()</span> *<span class="title">Car</span></span> &#123;</span><br><span class="line">d.builder.NewProduct()</span><br><span class="line">d.builder.BuildChassis()</span><br><span class="line">d.builder.BuildWheels()</span><br><span class="line"><span class="keyword">return</span> d.builder.GetResult().(*Car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个指挥者</span></span><br><span class="line">director := <span class="built_in">new</span>(Director)</span><br><span class="line"><span class="comment">// 创建建造者</span></span><br><span class="line">builder := <span class="built_in">new</span>(CarBuilder)</span><br><span class="line"></span><br><span class="line">director.SetBuilder(builder)</span><br><span class="line">car := director.CarBuilderImpl()</span><br><span class="line">car.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h2><ul><li><font color="#808080"><strong>定义以及使用场景</strong></font></li></ul><p>原型模式用于创建重复的对象。当一个类在创建时开销比较大时(比如大量数据准备，数据库连接)，我们可以缓存该对象，当下一次调用时，返回该对象的克隆。</p><p><strong>使用场景</strong></p><ol><li>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗</li><li>原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好滴体现其优点</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝</li></ol><ul><li><font color="#200000"><strong>举个例子</strong></font></li></ul><p>定义一个原型管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样品（原型）Clone能力约定类</span></span><br><span class="line"><span class="keyword">type</span> Cloneable <span class="keyword">interface</span> &#123;</span><br><span class="line">Clone() Cloneable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样品（原型）管理器类</span></span><br><span class="line"><span class="keyword">type</span> PrototypeManager <span class="keyword">struct</span> &#123;</span><br><span class="line">prototypes <span class="keyword">map</span>[<span class="keyword">string</span>]Cloneable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(that *PrototypeManager)</span> <span class="title">Set</span><span class="params">( cloneName <span class="keyword">string</span>, cloneable Cloneable)</span></span> &#123;</span><br><span class="line">that.prototypes[cloneName] = cloneable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(that *PrototypeManager)</span> <span class="title">Get</span><span class="params">(cloneName <span class="keyword">string</span>)</span> <span class="params">(prototype Cloneable, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> prototype, ok:=that.prototypes[cloneName]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> prototype, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;%s 不存在&quot;</span>, cloneName))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取一个样品（原型）管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个样品（原型）管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrototypeManager</span> <span class="params">()</span> *<span class="title">PrototypeManager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PrototypeManager&#123;</span><br><span class="line">prototypes:<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Cloneable),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manager *PrototypeManager</span><br></pre></td></tr></table></figure><p>定义一个样品原型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个样品（原型） 实现 Clone 方法 相当于把自己做成了一个样品</span></span><br><span class="line"><span class="keyword">type</span> PT <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(that *PT)</span> <span class="title">Clone</span><span class="params">()</span> <span class="title">Cloneable</span></span> &#123;</span><br><span class="line">temp := *that</span><br><span class="line"><span class="keyword">return</span> &amp;temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">prototypeOne,_ := manager.Get(<span class="string">&quot;prototypeOne&quot;</span>)</span><br><span class="line">prototypeTwo := prototypeOne.Clone()</span><br><span class="line">prototypeThree := prototypeOne.Clone()</span><br><span class="line">fmt.Printf(<span class="string">&quot; prototypeOne地址:%v \n &quot;</span> +</span><br><span class="line"><span class="string">&quot;prototypeTwo地址: %v \n &quot;</span> +</span><br><span class="line"><span class="string">&quot;prototypeThree地址: %v \n&quot;</span>, &amp;prototypeOne, &amp;prototypeTwo, &amp;prototypeThree)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">manager = NewPrototypeManager()</span><br><span class="line">pt1 := &amp;PT&#123;&#125;</span><br><span class="line">manager.Set(<span class="string">&quot;prototypeOne&quot;</span>, pt1)</span><br><span class="line">Test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"> prototypeOne地址:   <span class="number">0xc000010200</span> </span><br><span class="line"> prototypeTwo地址:   <span class="number">0xc000010210</span> </span><br><span class="line"> prototypeThree地址: <span class="number">0xc000010220</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="过滤器模式-Pipe-filter"><a href="#过滤器模式-Pipe-filter" class="headerlink" title="过滤器模式 (Pipe-filter)"></a>过滤器模式 (Pipe-filter)</h2><ul><li><font color="#808080"><strong>定义以及使用场景</strong></font></li></ul><p>对一数据需要经过顺序的多个过滤器函数处理。</p><p><strong>使用场景</strong></p><ol><li>多个对象可以处理同一请求，其架构适用于 解析，过滤，处理，返回这样的架构，如数据分析。</li><li>在请求处理者不明确的情况下向多个对象中的一个提交一个请求需要动态指定一组对象处理请求<img style="height:320px" src="/images/design_pattern/pipe_filter.webp"></li></ol><ul><li><font color="#200000"><strong>举个例子</strong></font></li></ul><p>下面的例子是一个将 字符串“1，2，3” 按逗号切分后，再字符转数字相加的过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1,2,3&quot;</span> --&gt; [SplitFilter] --&gt; [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>] --&gt; [ToIntFilter] --&gt; [1,2,3] -&gt; [SumFilter] --&gt; 6</span><br></pre></td></tr></table></figure><p>首先实现一个 filter 的接口。该接口定义了数据的来源接口，输出接口，该filter接口必须拥有的处理方法, 所有的过滤器必须参考这个接口实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request is the input of the filter</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response is the output of the filter</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter interface is the definition of the data processing components</span></span><br><span class="line"><span class="comment">// Pipe-Filter structure</span></span><br><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(data Request) (Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现SplitFilter，SplitFilter必须实现处理器Process。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SplitFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SplitFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">    delimiter <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSplitFilter</span><span class="params">(delimiter <span class="keyword">string</span>)</span> *<span class="title">SplitFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SplitFilter&#123;delimiter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SplitFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    str, ok := data.(<span class="keyword">string</span>) <span class="comment">//检查数据格式/类型，是否可以处理</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, SplitFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    parts := strings.Split(str, sf.delimiter)</span><br><span class="line">    <span class="keyword">return</span> parts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现ToIntFilter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ToIntFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ToIntFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToIntFilter</span><span class="params">()</span> *<span class="title">ToIntFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ToIntFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tif *ToIntFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    parts, ok := data.([]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ToIntFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">        s, err := strconv.Atoi(part)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 SumFilter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SumFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []int&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SumFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSumFilter</span><span class="params">()</span> *<span class="title">SumFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SumFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SumFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    elems, ok := data.([]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, SumFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">        ret += elem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个pipe-line， 目的是为了将所有的filter串起来。循环遍历整个filter并执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewStraightPipeline create a new StraightPipelineWithWallTime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStraightPipeline</span><span class="params">(name <span class="keyword">string</span>, filters ...Filter)</span> *<span class="title">StraightPipeline</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;StraightPipeline&#123;</span><br><span class="line">        Name:    name,</span><br><span class="line">        Filters: &amp;filters,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StraightPipeline is composed of the filters, and the filters are piled as a straigt line.</span></span><br><span class="line"><span class="keyword">type</span> StraightPipeline <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Filters *[]Filter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process is to process the coming data by the pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *StraightPipeline)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> _, filter := <span class="keyword">range</span> *f.Filters &#123;</span><br><span class="line">        ret, err = filter.Process(data)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret, err</span><br><span class="line">        &#125;</span><br><span class="line">        data = ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    spliter := pipe_filter.NewSplitFilter(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    converter := pipe_filter.NewToIntFilter()</span><br><span class="line">    sum := pipe_filter.NewSumFilter()</span><br><span class="line">    sp := pipe_filter.NewStraightPipeline(<span class="string">&quot;p1&quot;</span>, spliter, converter, sum)</span><br><span class="line">    ret, err := sp.Process(<span class="string">&quot;1,2,3&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ret != <span class="number">6</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;The expected is 6, but the actual is %d&quot;</span>, ret)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="微内核模式-Micro-Kernel"><a href="#微内核模式-Micro-Kernel" class="headerlink" title="微内核模式 (Micro Kernel)"></a>微内核模式 (Micro Kernel)</h2><ul><li><font color="#808080"><strong>定义以及使用场景</strong></font></li></ul><p>可以将 微核心架构理解成一个 核心要添加新功能就是加插件。其特点为 易扩展，错误隔离，保持架构的一致性。</p><p><strong>使用场景</strong></p><ol><li>如Nginx，启动前可以加载多个某块功能在应用上，不需要的时候可以剔除，但不影响整个应用的生命周期，适合一个应用的整体架构设计</li></ol><ul><li><font color="#200000"><strong>举个例子</strong></font></li></ul><p><strong>Agent</strong>: agent 相当于一个注册中心，所有要Agent去做的事情都注册到Agent里面来，注册进Agent的操作叫做 Collector 。每个Collector有一个名字。用map存储。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Agent <span class="keyword">struct</span> &#123;</span><br><span class="line">    collectors <span class="keyword">map</span>[<span class="keyword">string</span>]Collector  <span class="comment">//  注册进 Agent的collector</span></span><br><span class="line">    evtBuf     <span class="keyword">chan</span> Event            <span class="comment">//  collector 回传给 Agent 的事件</span></span><br><span class="line">    cancel     context.CancelFunc <span class="comment">//  任务取消的方法</span></span><br><span class="line">    ctx        context.Context    <span class="comment">//  任务取消的上下文</span></span><br><span class="line">    state      <span class="keyword">int</span>                <span class="comment">//  Agent 的运行状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Collector</strong>: Collector 是一个执行器，是需要注册进上面的Agent的。每个Collector需要实现 Init，Start，Stop，Destroy 方法，到时候由 Agent 统一进行Init，Start等操作，这里在Init中提到了 EventReceiver，所有的Collector在初始化的时候传入一个事件接收源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Collector <span class="keyword">interface</span> &#123;</span><br><span class="line">    Init(evtReceiver EventReceiver) error    <span class="comment">// Collector 将收集到的数据回传到 Agent （任何实现EventReceiver的对象）</span></span><br><span class="line">    Start(agtCtx context.Context) error      <span class="comment">// 启动所有的Collector（参数为agent中的取消上下文）</span></span><br><span class="line">    Stop() error                              <span class="comment">//   停止</span></span><br><span class="line">    Destroy() error                           <span class="comment">//   摧毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Event</strong>: Agent 实现了 OnEvent 方法，所以Agent 可以作为上面Init 方法的参数，作为事件的接收者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">    Source  <span class="keyword">string</span>   <span class="comment">// 事件源</span></span><br><span class="line">    Content <span class="keyword">string</span>   <span class="comment">// 事件内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EventReceiver <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnEvent(evt Event)  <span class="comment">// 实现OnEvent 既可以作为 EventReciver来接收事件 如下面的 Agent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">OnEvent</span><span class="params">(evt Event)</span></span> &#123;</span><br><span class="line">    agt.evtBuf &lt;- evt  <span class="comment">// Agent 可以来接收事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>开始起一个微内核</strong>: 整个 微内核的架构就是这样了，刚才提到了，Agent会统一对注册进去的Collector进行初始化（Init），启动（Start），停止（Stop）的操作。 所以这里还差一个注册函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">RegisterCollector</span><span class="params">(name <span class="keyword">string</span>, collector Collector)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line">        <span class="keyword">return</span> WrongStateError</span><br><span class="line">    &#125;</span><br><span class="line">    agt.collectors[name] = collector   <span class="comment">// agent map注册</span></span><br><span class="line">    <span class="keyword">return</span> collector.Init(agt)  <span class="comment">// 注册完立即进行Init 操作。且事件接收者为Agent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>启动、停止、摧毁</strong><br>启动会将所有的Controller都拉起来，同理停止和摧毁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> agt.state != Waiting &#123;     <span class="comment">// 状态不对，直接报错</span></span><br><span class="line">        <span class="keyword">return</span> WrongStateError</span><br><span class="line">    &#125;</span><br><span class="line">    agt.state = Running    <span class="comment">// 启动了，更改状态</span></span><br><span class="line">    agt.ctx, agt.cancel = context.WithCancel(context.Background())  <span class="comment">// 来一个取消的上下文和取消函数</span></span><br><span class="line">    <span class="keyword">go</span> agt.EventProcessGroutine()    <span class="comment">// 收集事件 (具体业务了)</span></span><br><span class="line">    <span class="keyword">return</span> agt.startCollectors()    <span class="comment">//  启动所有的Collector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的收集具体的业务事件。这里的事件是由各个 collector 上报的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">EventProcessGroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> evtSeg [<span class="number">10</span>]Event</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> evtSeg[i] = &lt;-agt.evtBuf:   <span class="comment">// 将 collector 收集的事件放到 evtBuf 中</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-agt.ctx.Done():           <span class="comment">// 执行上下文完成，结束 </span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(evtSeg)   <span class="comment">// 当 collector 收集的事件满 10 个，打印一次。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Agent 来拉起所有的 Collectors</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">startCollectors</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">var</span> errs CollectorsError</span><br><span class="line">    <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, collector Collector, ctx context.Context)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">            &#125;()</span><br><span class="line">            err = collector.Start(ctx)</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                errs.CollectorErrors = <span class="built_in">append</span>(errs.CollectorErrors,</span><br><span class="line">                    errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(name, collector, agt.ctx)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorErrors) == <span class="number">0</span> &#123;     <span class="comment">// 这里需要判断有没有错误，确定没有错误，返回nil。否则其实返回的也不是nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模拟</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DemoCollector <span class="keyword">struct</span> &#123;      <span class="comment">// 示例 Collector</span></span><br><span class="line">    evtReceiver microkernel.EventReceiver   <span class="comment">// 事件发给这里</span></span><br><span class="line">    stopChan    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;    <span class="comment">// 用来停止该Collector</span></span><br><span class="line">    name        <span class="keyword">string</span>    <span class="comment">// Collector 名字</span></span><br><span class="line">    content     <span class="keyword">string</span>    <span class="comment">// Collector 的要做的内容（假设，这个根据业务场景，都不一定是string）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCollect</span><span class="params">(name <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> *<span class="title">DemoCollector</span></span> &#123;   <span class="comment">// 创建一个 Collect</span></span><br><span class="line">    <span class="keyword">return</span> &amp;DemoCollector&#123;</span><br><span class="line">        stopChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        name:     name,</span><br><span class="line">        content:  content,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Init</span><span class="params">(evtReceiver microkernel.EventReceiver)</span> <span class="title">error</span></span> &#123;   <span class="comment">// 初始化一个这个 Collect</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;initialize collector&quot;</span>, c.name)</span><br><span class="line">    c.evtReceiver = evtReceiver    <span class="comment">// Agent 作为数据的上报源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Start</span><span class="params">(agtCtx context.Context)</span> <span class="title">error</span></span> &#123;   <span class="comment">// 拉起一个 Collect</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;start collector&quot;</span>, c.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;    <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-agtCtx.Done():      <span class="comment">// 收到 Done 了</span></span><br><span class="line">            c.stopChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="comment">// 停掉该 Collect （Stop 方法那里会等 stopChan 这个信号）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">            c.evtReceiver.OnEvent(microkernel.Event&#123;c.name, c.content&#125;) <span class="comment">// 向 Agent 上报事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;stop collector&quot;</span>, c.name)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-c.stopChan:   <span class="comment">// 收到停止信号了，停掉</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// 一般停完再做点啥，在这做些善后吧</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;failed to stop for timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Destroy</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(c.name, <span class="string">&quot;released resources.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error = <span class="literal">nil</span></span><br><span class="line">    agt := microkernel.NewAgent(<span class="number">100</span>)</span><br><span class="line">    c1 := NewCollect(<span class="string">&quot;c1&quot;</span>, <span class="string">&quot;1a&quot;</span>)</span><br><span class="line">    c2 := NewCollect(<span class="string">&quot;c2&quot;</span>, <span class="string">&quot;2b&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err = agt.RegisterCollector(<span class="string">&quot;c1&quot;</span>, c1);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = agt.RegisterCollector(<span class="string">&quot;c2&quot;</span>, c2);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = agt.Start();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err = agt.Stop();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ERR:</span><br><span class="line">    fmt.Println(<span class="string">&quot;An Error Occur :&quot;</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 (Command)"></a>命令模式 (Command)</h2><ul><li><font color="#808080"><strong>定义以及使用场景</strong></font></li></ul><p>它可将请求或简单操作转换为一个对象。此类转换让你能够延迟进行或远程执行请求， 还可将其放入队列中。</p><p><strong>使用场景</strong></p><ol><li>需要抽象出待执行的行动，然后以参数的形式提供出来——类似于过程设计中的回调机制，而命令模式正是回调机制的一个面向对象的代替品。</li><li>在不同的时刻指定、排列和执行请求，一个命令对象可以有与初始请求无关的生存期</li><li>需要支持事务操作</li></ol><ul><li><font color="#200000"><strong>举个例子</strong></font></li></ul><p><strong>电视遥控器</strong>:</p><p>遥控器从实现 ON 命令对象并以电视机作为接收者入手。 当在此命令上调用 execute执行方法时， 方法会调用 TV.on打开电视函数。 最后的工作是定义请求者： 这里实际上有两个请求者： 遥控器和电视机。 两者都将嵌入 ON 命令对象。</p><ul><li>实现 command 和 device </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command define</span></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">interface</span> &#123;</span><br><span class="line">execute()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> button <span class="keyword">struct</span> &#123;</span><br><span class="line">command command</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *button)</span> <span class="title">press</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.command.execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// device define ， 设备可执行的命令</span></span><br><span class="line"><span class="keyword">type</span> device <span class="keyword">interface</span> &#123;</span><br><span class="line">on()</span><br><span class="line">off()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现要执行命令</span></span><br><span class="line"><span class="keyword">type</span> onCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">device device</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *onCommand)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.device.on()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> offCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">device device</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *offCommand)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.device.off()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建命令的发出者和执行者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令的执行者</span></span><br><span class="line"><span class="keyword">type</span> tv <span class="keyword">struct</span> &#123;</span><br><span class="line">isRunning <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tv)</span> <span class="title">on</span><span class="params">()</span></span> &#123;</span><br><span class="line">t.isRunning = <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Turning tv on&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tv)</span> <span class="title">off</span><span class="params">()</span></span> &#123;</span><br><span class="line">t.isRunning = <span class="literal">false</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Turning tv off&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行者就是按下按钮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tv := &amp;tv&#123;&#125;</span><br><span class="line"></span><br><span class="line">onButton := &amp;button&#123;</span><br><span class="line">command: &amp;onCommand&#123; device: tv &#125;,</span><br><span class="line">&#125;</span><br><span class="line">onButton.press()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
    <category term="design pattern" scheme="http://kiosk007.top/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>算法 - (二叉树)</title>
    <link href="http://kiosk007.top/2020/10/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://kiosk007.top/2020/10/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-10-17T02:44:00.000Z</published>
    <updated>2020-10-17T02:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。以下会以几道 LeetCode 巩固自己的基础</p><a id="more"></a><p><a href="https://leetcode-cn.com/leetbook/detail/data-structure-binary-tree/?utm_campaign=leetbook&utm_medium=%E9%A2%98%E5%BA%93&utm_source=leetcode-cn&utm_term=%E9%A2%98%E5%BA%93%E9%A1%B5%E6%A0%87%E7%AD%BE&gio_link_id=q9A0Bxko">leetcode 树</a></p><h1 id="生成一个二叉树"><a href="#生成一个二叉树" class="headerlink" title="生成一个二叉树"></a>生成一个二叉树</h1><h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">Val int</span><br><span class="line">Left *TreeNode</span><br><span class="line">Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的工厂模式"><a href="#二叉树的工厂模式" class="headerlink" title="二叉树的工厂模式"></a>二叉树的工厂模式</h2><ul><li>创建节点、打印节点、设置节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">Print</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Print(node.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">SetVal</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">node.Val = val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">Add</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val &lt; node.Val &#123;</span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Left = CreateNode(val)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">node.Left.Add(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Right = CreateNode(val)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">node.Right.Add(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/">动画演示</a><br><img src="/images/leetcode/tree_1.jpg"></p><ul><li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p></li><li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p></li><li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = <span class="built_in">print</span> r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：(中序排列结果为有序数组)</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;<span class="built_in">print</span> r-&gt;inOrder(r-&gt;right) </span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;<span class="built_in">print</span> r</span><br></pre></td></tr></table></figure><h2 id="LC二叉树-前序遍历"><a href="#LC二叉树-前序遍历" class="headerlink" title="LC二叉树 前序遍历"></a>LC二叉树 前序遍历</h2><p>例题链接：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span> <span class="title">preorderTraversal</span><span class="params">(f <span class="keyword">func</span>(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f(root)</span><br><span class="line">root.Left.preorderTraversal(f)</span><br><span class="line">root.Right.preorderTraversal(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line">list = <span class="built_in">append</span>(list, root.Val)</span><br><span class="line">resLeft := preorderTraversal(root.Left)</span><br><span class="line">resRight := preorderTraversal(root.Right)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(list, resLeft...), resRight...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 channel 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TraversalTreeWithChannel</span><span class="params">(rootNode *TreeNode)</span> <span class="params">(out <span class="keyword">chan</span> *TreeNode)</span></span> &#123;</span><br><span class="line">out = <span class="built_in">make</span>(<span class="keyword">chan</span> *TreeNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rootNode.preorderTraversal(<span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">out &lt;- node</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">treeRoot := CreateNode(<span class="number">0</span>)</span><br><span class="line">treeRoot.Add(<span class="number">1</span>)</span><br><span class="line">treeRoot.Add(<span class="number">2</span>)</span><br><span class="line">fmt.Println(preorderTraversal(treeRoot))</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line">treeRoot.preorderTraversal(<span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">cnt++</span><br><span class="line">node.Print()</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;All Count: &quot;</span>, cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过通道的方式遍历二叉树</span></span><br><span class="line">out := TraversalTreeWithChannel(treeRoot)</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> out &#123;</span><br><span class="line">c.Print()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树的层次遍历（BFS广度优先遍历）"><a href="#二叉树的层次遍历（BFS广度优先遍历）" class="headerlink" title="二叉树的层次遍历（BFS广度优先遍历）"></a>二叉树的层次遍历（BFS广度优先遍历）</h2><p>例题链接：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/</a></p><p>题解：<br>创建一个先进先出的队列，从最顶层的节点依次加入节点，并遍历该层，每遍历该层的一个节点，把该层的子节点加入的队列的后面，这样就可以实现层次遍历，如果要蛇形遍历也是一个道理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> level [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line">queue := list.New()  <span class="comment">// 一个先进先出的队列,所有的元素需要依次进队</span></span><br><span class="line">queue.PushFront(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> curLevel []<span class="keyword">int</span></span><br><span class="line">curLevelLength := queue.Len()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; curLevelLength; i++ &#123;</span><br><span class="line">node := queue.Remove(queue.Back()).(*TreeNode)</span><br><span class="line">curLevel = <span class="built_in">append</span>(curLevel, node.Val)</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;  <span class="comment">// 下一层遍历做准备, 把当前节点的子节点都加进去</span></span><br><span class="line">queue.PushFront(node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue.PushFront(node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">level = <span class="built_in">append</span>(level, curLevel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="剑指Offer-判断平衡二叉树"><a href="#剑指Offer-判断平衡二叉树" class="headerlink" title="剑指Offer - 判断平衡二叉树"></a>剑指Offer - 判断平衡二叉树</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a></li><li>思路：平衡二叉树的判断方式即某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br> 而一个数的高度为左子树和右子树中最高的。即只要比对左右子树的高度即可判断是否为平衡二叉树。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTreeDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(getTreeDepth(root.Left)), <span class="keyword">float64</span>(getTreeDepth(root.Right)))) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">left := getTreeDepth(root.Left)</span><br><span class="line">right := getTreeDepth(root.Right)</span><br><span class="line">    <span class="comment">// 判断左子树和右子树的绝对差值小于1 且 左子树 和 右子树 也满足平衡</span></span><br><span class="line"><span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(left) - <span class="keyword">float64</span>(right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-235-二叉搜索树的公共祖先"><a href="#No-235-二叉搜索树的公共祖先" class="headerlink" title="No.235 二叉搜索树的公共祖先"></a>No.235 二叉搜索树的公共祖先</h2><ul><li><p>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p></li><li><p>思路：</p></li><li><p>通过搜索的方式查找节点，并记录所有节点，查到2个点之后，比对两个查找链路上的最后一个公共节点即可</p></li><li><p>判断P,Q 两个节点如果在都小于root，则公共节点一定是在左子树，反之同理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || root == q || root == p &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.Val &lt;= root.Val &amp;&amp; q.Val &lt;= root.Val &#123;   <span class="comment">//p和q都小于root,公共祖先节点一定在root的左边</span></span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root.Left,p,q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.Val &gt;= root.Val &amp;&amp; q.Val &gt;= root.Val &#123;   <span class="comment">//p和q都大于root,公共祖先节点一定在root的右边</span></span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root.Right,p,q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-112-路径总和"><a href="#No-112-路径总和" class="headerlink" title="No.112 路径总和"></a>No.112 路径总和</h2></li><li><p>链接：<a href="https://leetcode-cn.com/submissions/detail/23501756/">https://leetcode-cn.com/submissions/detail/23501756/</a></p></li><li><p>思路：这种类似与 二叉树的深度遍历DFS肯定是要用到递归了。。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sum == root.Val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.Left, sum-root.Val) || hasPathSum(root.Right, sum-root.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。以下会以几道 LeetCode 巩固自己的基础&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>算法 - (数组、链表)</title>
    <link href="http://kiosk007.top/2020/09/26/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/"/>
    <id>http://kiosk007.top/2020/09/26/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</id>
    <published>2020-09-26T02:58:00.000Z</published>
    <updated>2020-09-26T02:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组、链表是编程语言中最常见的数据结构，也是最基础的数据结构。以下会以几道 LeetCode 巩固自己的基础</p><a id="more"></a><h1 id="结构对比"><a href="#结构对比" class="headerlink" title="结构对比"></a>结构对比</h1><p>数组和链表各有各的优势，比如数组的随机插入和删除都是O(n)的，可谓是很低效了。但是数组的查找是是O(1)，直接指定下标即可找到对应的元素。而链表必须遍历，也就是想要查找你一个元素的时间复杂度是 O(n)。所以数组和链表各有各的优势，互相补充。</p><p>| 数据结构      |  操作           |  时间复杂度  |<br>| ——–    | —–:       | :—-:  |<br>| 数组         | prepend         |   O(1)     |<br>|             | append          |   O(1)      |<br>|             | lookup       |   O(1)      |<br>|             | insert       |   O(n)      |<br>|             | delete       |   O(n)      |<br>|             | –       |      –   |<br>| 链表         | prepend         |   O(1)    |<br>|             | append          |   O(1)      |<br>|             | lookup       |   O(n)     |<br>|             | insert       |   O(1)     |<br>|             | delete       |   O(1)     |</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">int</span></span><br><span class="line">b = <span class="built_in">append</span>(c, <span class="number">11</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, a...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// make( []Type, size, cap )</span></span><br><span class="line"><span class="comment">// 其中 Type 是指切片的元素类型，</span></span><br><span class="line"><span class="comment">// size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，</span></span><br><span class="line"><span class="comment">// 这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)  </span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义单链表</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;     </span><br><span class="line">Val <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *ListNode)</span> <span class="title">add</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ln == <span class="literal">nil</span> &#123;</span><br><span class="line">ln = &amp;ListNode&#123;Val: v,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ln.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">ln = ln.Next</span><br><span class="line">&#125;</span><br><span class="line">ln.Next = &amp;ListNode&#123;Val: v,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *ListNode)</span> <span class="title">traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ln != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>,ln.Val)</span><br><span class="line">ln = ln.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="No-1-两数之和"><a href="#No-1-两数之和" class="headerlink" title="No.1 两数之和"></a>No.1 两数之和</h3><ul><li>链接：<a href="https://leetcode-cn.com/problems/two-sum/submissions/">https://leetcode-cn.com/problems/two-sum/submissions/</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line"><span class="keyword">if</span> index, ok := tmp[target-nums[i]]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;index,i&#125;</span><br><span class="line">&#125;</span><br><span class="line">tmp[nums[i]] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="No-26-删除排序数组中的重复项"><a href="#No-26-删除排序数组中的重复项" class="headerlink" title="No.26 删除排序数组中的重复项"></a>No.26 删除排序数组中的重复项</h3><ul><li>链接: <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></li><li>思路1：<strong>双指针法</strong> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/26-shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xia-89/">题解动画</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">j++</span><br><span class="line">nums[j] = nums[i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路2： *<strong>旋转数组法</strong> 旋转数组应该是我比较喜欢的一种方式，比较简单，那就是数组翻转2次，可以将首位数转到末尾曲，重复项判断刚好使用这种方式，<font style="color:red">对于移动数组类的题是比较通吃的一个方法</font>问题就是时间复杂度比较大<img src="/images/leetcode/list_1.jpeg" style="height:300px"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversal</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; length &gt; <span class="number">1</span> &amp;&amp; i &lt; length/<span class="number">2</span>; i ++ &#123;</span><br><span class="line">nums[i],nums[length<span class="number">-1</span>-i] = nums[length<span class="number">-1</span>-i],nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i ++ &#123;</span><br><span class="line"><span class="keyword">if</span> i + <span class="number">1</span> &lt; length &amp;&amp; nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">reversal(nums[i+<span class="number">1</span>:length])</span><br><span class="line">reversal(nums[i+<span class="number">1</span>:length<span class="number">-1</span>])</span><br><span class="line">length = length - <span class="number">1</span></span><br><span class="line">i = i - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h3 id="No-21-合并两个链表"><a href="#No-21-合并两个链表" class="headerlink" title="No.21 合并两个链表"></a>No.21 合并两个链表</h3><ul><li>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/">https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/</a></li><li>思路1: <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">迭代法</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">tmp := &amp;ListNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">prev := tmp</span><br><span class="line"><span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt; l2.Val&#123;</span><br><span class="line">prev.Next = l1</span><br><span class="line">prev = prev.Next</span><br><span class="line"></span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">prev.Next = l2</span><br><span class="line">prev = prev.Next</span><br><span class="line"></span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">prev.Next = l2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">prev.Next = l1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-83-删除排序链表重复项"><a href="#No-83-删除排序链表重复项" class="headerlink" title="No.83 删除排序链表重复项"></a>No.83 删除排序链表重复项</h2></li><li>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></li><li>思路1：题解感觉和我差不太多，我的思路是先把重复项移到尾端，然后cur 指针指向重复项的尾端就好了。但不知道为啥 8ms 打败 7.3% 。理论就是 O(N) 啊。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur := &amp;ListNode&#123;&#125; </span><br><span class="line">tmp := cur   <span class="comment">// 记录链表头</span></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> head.Next != <span class="literal">nil</span> &amp;&amp; head.Val == head.Next.Val &#123;</span><br><span class="line"> head = head.Next</span><br><span class="line">&#125;</span><br><span class="line">cur.Next = head</span><br><span class="line">cur = cur.Next</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-141-环形链表"><a href="#No-141-环形链表" class="headerlink" title="No.141 环形链表"></a>No.141 环形链表</h2></li><li>链接: <a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></li><li>思路1：这道题思路非常简单，就是快慢指针，慢指针每次前进一步，快指针每次前进两步。如果存在环快指针一定会追上慢指针，<strong>问题就是边界条件太多，需要仔细判断。</strong></li><li>思路2：hash表存已有的数据做对比，这个最简单，不演示啦~</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow := head</span><br><span class="line">fast := head.Next</span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line"><span class="keyword">if</span> slow == fast &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-206-反转链表"><a href="#No-206-反转链表" class="headerlink" title="No.206 反转链表"></a>No.206 反转链表</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></li><li>思路1：<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/206-fan-zhuan-lian-biao-shuang-zhi-zhen-fa-di-gui-/">双指针</a>  本质还是遍历 head， 上面的<code>next := head.Next</code>和下面的<code>head = next</code> 就是为了遍历， 中间的三行是 当前head的节点的下一个指向之前，cur即为当前head节点，cur 成为历史 prev</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prev *ListNode = <span class="literal">nil</span></span><br><span class="line">cur := prev</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">next := head.Next  <span class="comment">// 存下一个</span></span><br><span class="line"></span><br><span class="line">head.Next = prev <span class="comment">// haed 的Next指向 prev</span></span><br><span class="line">cur = head       <span class="comment">// cur 就是 head</span></span><br><span class="line">prev = cur <span class="comment">// cur 成为 prev</span></span><br><span class="line"></span><br><span class="line">head = next   <span class="comment">// head 前进</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个-LRU-缓存"><a href="#实现一个-LRU-缓存" class="headerlink" title="实现一个 LRU 缓存"></a>实现一个 LRU 缓存</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lru</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/list&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MemoryOverFlow<span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">MemorySizeError<span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">NotFoundObject<span class="keyword">int</span> = <span class="number">11</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lruErrorName = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">MemoryOverFlow:      <span class="string">&quot;MemoryOverFlow&quot;</span>,</span><br><span class="line">MemorySizeError:  <span class="string">&quot;MemorySizeError&quot;</span>,</span><br><span class="line">NotFoundObject:  <span class="string">&quot;NotFoundObject&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录存储数据的大小</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">Len() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储的对象</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key <span class="keyword">string</span></span><br><span class="line">value Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">maxBytes <span class="keyword">int64</span>        <span class="comment">// 最大使用内存</span></span><br><span class="line">nBytes  <span class="keyword">int64</span>        <span class="comment">// 当前已使用内存</span></span><br><span class="line">ll *list.List         <span class="comment">// 链表存储淘汰关系</span></span><br><span class="line">cache  <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element   <span class="comment">//节点放到字典中，加速查找</span></span><br><span class="line">OnEvicted  <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value Value)</span>   //某条记录被删除时候的回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateLRUCache</span><span class="params">(maxByte <span class="keyword">int64</span>,evicted <span class="keyword">func</span>(<span class="keyword">string</span>,Value)</span>) *<span class="title">Cache</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">maxBytes:  maxByte,</span><br><span class="line">nBytes:    <span class="number">0</span>,</span><br><span class="line">ll:        <span class="built_in">new</span>(list.List),</span><br><span class="line">cache:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element),</span><br><span class="line">OnEvicted: evicted,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value Value,err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class="line">c.ll.MoveToFront(ele)</span><br><span class="line"><span class="keyword">return</span> ele.Value.(*entry).value, <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(lruErrorName[NotFoundObject])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">string</span>, value Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断是否可以加入(太大会把所有缓存冲掉)</span></span><br><span class="line"><span class="keyword">if</span> c.isOutOfMaxMemory(value.Len()) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(lruErrorName[MemoryOverFlow])   <span class="comment">// 内存不足以添加该缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断缓存中已有该键, 更新</span></span><br><span class="line"><span class="keyword">if</span> v, ok := c.cache[key]; ok &#123;</span><br><span class="line">oldValue := v.Value.(*entry)</span><br><span class="line"><span class="comment">// 可以加入,将该键移动到队头</span></span><br><span class="line">c.ll.MoveToFront(v)</span><br><span class="line">c.cache[oldValue.key] = &amp;list.Element&#123;Value: &amp;entry&#123;key,value&#125;&#125;</span><br><span class="line">c.nBytes = c.nBytes - oldValue.value.Len() + value.Len()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有该键,第一次添加</span></span><br><span class="line">ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">c.cache[key] = ele</span><br><span class="line">c.nBytes = c.nBytes + value.Len()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若内存不够，需要循环删除掉最老的</span></span><br><span class="line"><span class="keyword">for</span> c.maxBytes != <span class="number">0</span> &amp;&amp; c.maxBytes &lt; c.nBytes &#123;</span><br><span class="line"><span class="keyword">if</span> err := c.RemoveOldest(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">oldest := c.ll.Back()</span><br><span class="line"><span class="keyword">if</span> oldest != <span class="literal">nil</span> &#123;</span><br><span class="line">oldestEntry := oldest.Value.(*entry)</span><br><span class="line">c.ll.Remove(oldest) <span class="comment">// 删除链表节点</span></span><br><span class="line">c.nBytes = c.nBytes - oldestEntry.value.Len() <span class="comment">// 删除字节长度</span></span><br><span class="line"><span class="built_in">delete</span>(c.cache, oldestEntry.key)  <span class="comment">// 删除字典</span></span><br><span class="line"><span class="keyword">if</span> c.nBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(lruErrorName[MemorySizeError])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">c.OnEvicted(oldestEntry.key, oldestEntry.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(c.ll.Len())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">isOutOfMaxMemory</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> size &gt; c.maxBytes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GeeByte <span class="keyword">struct</span> &#123;</span><br><span class="line">Value []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GeeByte)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(g.Value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLruCache</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">lruObject := lru.CreateLRUCache(<span class="number">20</span>, <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value lru.Value)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 被删除了, 释放了 %d 字节的空间\n&quot;</span>, key, value.Len())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">_ = lruObject.Add(<span class="string">&quot;key1&quot;</span>, GeeByte&#123;[]<span class="keyword">byte</span>(<span class="string">&quot;Hello, Golang&quot;</span>)&#125;)</span><br><span class="line">_ = lruObject.Add(<span class="string">&quot;key2&quot;</span>, GeeByte&#123;[]<span class="keyword">byte</span>(<span class="string">&quot;Hello, ByteDance&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value, err := lruObject.Get(<span class="string">&quot;key2&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>,value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组、链表是编程语言中最常见的数据结构，也是最基础的数据结构。以下会以几道 LeetCode 巩固自己的基础&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>systemd 基本概念</title>
    <link href="http://kiosk007.top/2020/09/20/systemd-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://kiosk007.top/2020/09/20/systemd-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-09-20T15:29:00.000Z</published>
    <updated>2020-09-20T15:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>systemd 是 PID 为1的一个程序，负责初始化系统。所有的程序不是systemd直接启动就是由systemd的子系统启动。systemd是内核直接启动，所以信号9(KILL)对systemd也无效。</p><p>systemd 使用Linux控制组跟踪进程，维护安装和自动挂载点，并实现基于事务性依赖关系的详尽服务控制逻辑。其他部分包括日志记录守护程序，用于控制基本系统配置的实用程序，例如主机名，日期，区域设置，维护已登录用户和正在运行的容器和虚拟机的列表，系统帐户，运行时目录和设置，以及用于管理简单网络的守护程序配置，网络时间同步，日志转发和名称解析。</p><a id="more"></a><img src="/images/systemd/systemd.png" style="height:400px"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="对比-systemV"><a href="#对比-systemV" class="headerlink" title="对比 systemV"></a>对比 systemV</h2><p>从CentOS 7.x 以后，Red Hat 系列的 distribution 放弃沿用多年的System V 开机启动服务的流程. systemd 也是当年我从6.x 到 7.x 过度时感觉到最大的变化了，直到今天，MySQL的启动脚本还是可以通过 <code>service mysqld start </code> 启动的，但是升级到 CentOS 7.x 之后，就变成了 <code>systemd start mysqld</code> 了。当然还有经典的<code>init 0</code>的关机指令。</p><p>相比于 initd，systemd有以下几个大的进步。</p><ul><li><font color="blue">并行启动</font>：旧的 init 启动脚本是一项一项任务依序启动的模式，因此不相依的服务也是得要一个一个的等待。systemd可以让所有的服务同时启动，因此你会发现到，系统启动的速度变快了！</li><li><font color="blue">一经要求就回应的on-demand启动方式</font>：systemd全部就是仅有一只systemd服务搭配systemctl指令来处理，无须其他额外的指令来支援。不像systemV还要init, chkconfig, service…等等指令。此外， systemd由于常驻记忆体，因此任何要求(on-demand)都可以立即处理后续的daemon启动的任务。</li><li><font color="blue">服务相依性的自我检查</font>：由于systemd可以自订服务相依性的检查，因此如果B服务是架构在A服务上面启动的，那当你在没有启动A服务的情况下仅手动启动B服务时， systemd会自动帮你启动A服务。</li><li><font color="blue">依daemon功能分类</font>：systemd下管理的服务非常多，为了厘清所有服务的功能，因此，首先systemd先定义所有的服务为一个服务单位(unit)，并将该unit归类到不同的服务类型(type)去。旧的init仅分为stand alone与super daemon，systemd将服务单位(unit)区分为service, socket, target, path, snapshot, timer等多种不同的类型(type)，方便管理员的分类与记忆。</li><li><font color="blue">将多个daemons集合成为一个群组</font>：如同systemV的init里头有个runlevel的特色，systemd亦将许多的功能集合成为一个所谓的target项目，这个项目主要在设计操作环境的建置，所以是集合了许多的daemons，亦即是执行某个target就是执行好多个daemon的意思！</li><li><font color="blue">向下相容旧有的init服务脚本</font>：基本上， systemd是可以相容于init的启动脚本的，因此，旧的init启动脚本也能够透过systemd来管理，这也是为什么到现在还可以使用<code>serivce mysqld start</code> 这样命令的原因。</li></ul><blockquote><p><strong>综上可知，systemd 已经足够强大，可以管理一个进程的生命周期，如果是自己写的一套代码完全可以交给systemd 来维护呀，以前公司使用 <a href="https://ruby-china.org/topics/21354">god</a>(进程监控守护工具) 来管理服务，god 提供了服务启动、服务宕机自动拉起、环境变量和chroot、服务资源限制、定时任务等，但是systemd 的出现已经足够替代 god 这样的第三方服务，systemd 已经足够实现服务托管。</strong></p></blockquote><img src="/images/systemd/systemd_components2.png" style="height:400px"><h2 id="systemd-的配置文件"><a href="#systemd-的配置文件" class="headerlink" title="systemd 的配置文件"></a>systemd 的配置文件</h2><p>基本上， systemd 将过去所谓的daemon 执行脚本通通称为一个服务单位(unit)，而每种服务单位依据功能来区分时，就分类为不同的类型(type)。在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p><ul><li><font color="blue">automount</font>：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li><li><font color="blue">device</font>：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li><li><font color="blue">mount</font>：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li><li><font color="blue">path</font>：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li><li><font color="blue">scope</font>：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li><li><font color="blue">service</font>：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li><li><font color="blue">slice</font>：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li><li><font color="blue">snapshot</font>：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li><li><font color="blue">socket</font>：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li><li><font color="blue">swap</font>：定义一个用户做虚拟内存的交换分区</li><li><font color="blue">target</font>：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式。其实是一群unit 的集合，例如上面表格中谈到的multi-user.target 其实就是一堆服务的集合～也就是说， 选择执行multi-user.target 就是执行一堆其他.service 或/及.socket 之类的服务就是了！</li><li><font color="blue">timer</font>：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li></ul><p><strong>文件目录</strong><br>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p><ul><li><font color="blue">/etc/systemd/system/</font>：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能。</li><li><font color="blue">/run/systemd/system/</font>：系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li><font color="blue">/usr/lib/systemd/system/</font>：每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li></ul><p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p><h1 id="Systemd-Service-Unit"><a href="#Systemd-Service-Unit" class="headerlink" title="Systemd Service Unit"></a>Systemd Service Unit</h1><h2 id="Unit-文件结构"><a href="#Unit-文件结构" class="headerlink" title="Unit 文件结构"></a>Unit 文件结构</h2><p>一般可以使用 <font style="color=blue">systemctl cat networking</font> 查看 Unit 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Hello World</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker <span class="built_in">kill</span> busybox1</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm busybox1</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c <span class="string">&quot;while true; do echo Hello World; sleep 1; done&quot;</span></span><br><span class="line">ExecStop=<span class="string">&quot;/usr/bin/docker stop busybox1&quot;</span></span><br><span class="line">ExecStopPost=<span class="string">&quot;/usr/bin/docker rm busybox1&quot;</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><strong><font style="color:red"><code>[Unit]</code></font></strong> 区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p><blockquote><ul><li><code>Description</code>：简短描述</li><li><code>Documentation</code>：文档地址</li><li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li><li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li><li><code>BindsTo</code>：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li><li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li><li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li><li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li><li><code>Condition</code>：当前 Unit 运行必须满足的条件，否则不会运行</li><li><code>Assert</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li></ul></blockquote><p><strong><font style="color:red"><code>[Service]</code></font></strong> 区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><blockquote><ul><li><code>Type</code>：定义启动时的进程行为。它有以下几种值。</li><li><code>Type=simple</code>：默认值，执行ExecStart指定的命令，启动主进程</li><li><code>Type=forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li><li><code>Type=oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li><li><code>Type=dbus</code>：当前服务通过D-Bus启动</li><li><code>Type=notify</code>：当前服务启动完毕，会通知Systemd，再继续往下执行</li><li><code>Type=idle</code>：若有其他任务执行完毕，当前服务才会运行</li><li><code>ExecStart</code>：启动当前服务的命令</li><li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li><li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li><li><code>ExecReload</code>：重启当前服务时执行的命令</li><li><code>ExecStop</code>：停止当前服务时执行的命令</li><li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li><li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li><li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li><li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li><li><code>Environment</code>：指定环境变量</li><li><code>EnvironmentFile</code>：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li><li><code>Nice</code>：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li><li><code>WorkingDirectory</code>：指定服务的工作目录</li><li><code>RootDirectory</code>：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li><li><code>User</code>：指定运行服务的用户</li><li><code>Group</code>：指定运行服务的用户组</li><li><code>MountFlags</code>：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private</li></ul></blockquote><ul><li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li><li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li><li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上<blockquote><ul><li><code>LimitCPU</code> / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li></ul></blockquote></li></ul><p><strong><font style="color:red"><code>[Install]</code></font></strong> 通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><blockquote><ul><li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</li><li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</li><li><code>Alias</code>：当前 Unit 可用于启动的别名</li><li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li></ul></blockquote><p><strong>Unit 配置文件的完整字段清单，请参考 <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">官方文档</a>。</strong></p><h2 id="Unit-管理"><a href="#Unit-管理" class="headerlink" title="Unit 管理"></a>Unit 管理</h2><p><font style="color:blue">systemctl list-units </font>命令可以查看当前系统的所有 Unit 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出正在运行的 Unit</span></span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有没有运行的 Unit</span></span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有加载失败的 Unit</span></span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看开机自启动的 service</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span> service |grep enabled</span><br></pre></td></tr></table></figure><h1 id="Systemd-Target"><a href="#Systemd-Target" class="headerlink" title="Systemd Target"></a>Systemd Target</h1><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p><p>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的所有 Target</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动时的默认 Target</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动时的默认 Target</span></span><br><span class="line">$ sudo systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span></span><br><span class="line"><span class="comment"># systemctl isolate 命令改变这种行为，</span></span><br><span class="line"><span class="comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure><p>Target 与 传统 RunLevel 的对应关系如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Traditional runlevel      New target name     Symbolically linked to...</span><br><span class="line"></span><br><span class="line">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</span><br><span class="line">Runlevel 1           |    runlevel1.target -&gt; rescue.target</span><br><span class="line">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</span><br><span class="line">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</span><br><span class="line">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</span><br><span class="line">Runlevel 5           |    runlevel5.target -&gt; graphical.target</span><br><span class="line">Runlevel 6           |    runlevel6.target -&gt; reboot.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它与<font style="color:blue">init</font>进程的主要差别如下。</p><p>（1）默认的 RunLevel（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p><p>（2）启动脚本的位置，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p><p>（3）配置文件的位置，以前init进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p><h1 id="Systemd-管理"><a href="#Systemd-管理" class="headerlink" title="Systemd 管理"></a>Systemd 管理</h1><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p><font style="color:blue"> systemctl </font> 是 Systemd 的主命令，用于管理系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU停止工作</span></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停系统</span></span><br><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入冬眠状态</span></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入交互式休眠状态</span></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure><h2 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h2><p><font style="color:blue"> systemd-analyze </font> 命令用于查看启动耗时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure><h2 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h2><p><font style="color:blue"> hostnamectl </font> 命令用于查看当前主机的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure><h2 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h2><p><font style="color:blue"> localectl </font> 命令用于查看本地化设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ sudo localectl set-locale LANG=en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure><h2 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h2><p><font style="color:blue"> timedatectl </font>命令用于查看当前时区设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ sudo timedatectl set-timezone America/New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure><h2 id="loginctl"><a href="#loginctl" class="headerlink" title="loginctl"></a>loginctl</h2><p><font style="color:blue"> loginctl </font> 命令用于查看当前登录的用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<font style="color:blue"><code>journalctl</code></font>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since=<span class="string">&quot;2012-10-30 18:17:16&quot;</span></span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;20 min ago&quot;</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;2015-01-10&quot;</span> --until <span class="string">&quot;2015-01-11 03:00&quot;</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">&quot;1 hour ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部的最新10行日志</span></span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"> -o json-pretty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">systemd 入门教程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;systemd 是 PID 为1的一个程序，负责初始化系统。所有的程序不是systemd直接启动就是由systemd的子系统启动。systemd是内核直接启动，所以信号9(KILL)对systemd也无效。&lt;/p&gt;
&lt;p&gt;systemd 使用Linux控制组跟踪进程，维护安装和自动挂载点，并实现基于事务性依赖关系的详尽服务控制逻辑。其他部分包括日志记录守护程序，用于控制基本系统配置的实用程序，例如主机名，日期，区域设置，维护已登录用户和正在运行的容器和虚拟机的列表，系统帐户，运行时目录和设置，以及用于管理简单网络的守护程序配置，网络时间同步，日志转发和名称解析。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://kiosk007.top/categories/Linux/"/>
    
    
    <category term="devops" scheme="http://kiosk007.top/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 调度对象</title>
    <link href="http://kiosk007.top/2020/08/22/Kubernetes-Pod/"/>
    <id>http://kiosk007.top/2020/08/22/Kubernetes-Pod/</id>
    <published>2020-08-22T01:53:00.000Z</published>
    <updated>2020-08-22T01:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在容器的世界中，Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统，而如果仅仅是这样的化，容器是没有价值的，因为这样很难实现线上生产环境迁移到容器集群中，线上环境复杂多变，多个服务需要通过本地socket通信或者通过文件交互内容，所以在 k8s 中，pod才是最小的调度单元。</p><a id="more"></a><p>Pod是Kubernetes创建或部署的最小/最简单的基本单位，一个Pod代表集群上正在运行的一组进程。Pod 在 k8s 中扮演着重要的角色：<strong>容器的设计模式</strong>。</p><blockquote><p>Docker是Kubernetes Pod中最常见的runtime ，Pods也支持其他容器runtimes。</p></blockquote><h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><strong>首先要了解的一个事实是 Pod 只是一个逻辑概念，简单的理解是一组超亲密关系的容器</strong></p><p>这些容器共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。<br>在Docker中就有诸如 <code>$ docker run --net=B --volumes-from=B -name =A ...</code> 这样的命令可以让多个容器共享一个Namespace。</p><p>没错既然需要共享，那么就需要有容器的启动顺序，先启动一个基础容器，再将后启动的容器共享该基础容器的Namespace。<br><img src="/images/k8s/k8s_infra1.png" style="height:400px"></p><p>正如上图所示，在其他容器启动之前会先启动一个infra容器，infra容器一定只占用很少的资源，这个容器叫做‘k8s.gcr.io/pause’。这个镜像使用汇编编写，永远处于“暂停”状态，而infra容器提供基础的Namespace环境供该Pod里的其他容器共享。</p><p>所以，对于同一个Pod的里的所有容器来讲，他们的进出流量可以认为是通过 infra 容器完成的。<strong>之后如果要给k8s开发一个网络插件，应该考虑配置该Pod的Network Namesapce，Infra容器的rootfs里几乎什么东西都没有</strong></p><p>Pod 只是 k8s 里面的一个概念，提供的是一个编排思想，而不是具体的技术方案，比如 Mirantis 公司的 <a href="https://github.com/Mirantis/virtlet">virtlet</a> , 可以实现一个带有 systemd 进程的容器，来模拟传统的操作系统。</p><h2 id="Pod-配置文件"><a href="#Pod-配置文件" class="headerlink" title="Pod 配置文件"></a>Pod 配置文件</h2><p>Pod的创建时基于k8s 的配置文件 – yaml 文件创建的，这样的好处是可以记录每一个Pod的基础信息,<strong>凡是调度、网络、存储、安全相关的属性，基本上都是Pod级别的</strong></p><p>下面是Pod中的几个重要字段的含义和用法。具体更多的用法可以参考 <code>$GOPATH/src/k8s.io/kubernetes/vendor/k8s.io/api/core/v1/types.go</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1    # 版本号</span><br><span class="line">kind: Pod         # Pod</span><br><span class="line">metadata:         # 元数据</span><br><span class="line">  name: nginx     # Pod名称</span><br><span class="line">  namespace: string    # Pod所属的命名空间</span><br><span class="line">  labels:         # 自定义标签</span><br><span class="line">    - name: string   # 自定义标签名字</span><br><span class="line">  annotations:       # 自定义注释列表</span><br><span class="line">    - name: string </span><br><span class="line">spec:          # Pod中容器的详细定义</span><br><span class="line">  hostNetwork: true   # 共享宿主机网络</span><br><span class="line">  hostIPC: true       # 共享宿主机IPC</span><br><span class="line">  hostPID: true       # 共享宿主机PID</span><br><span class="line">  shareProcessNamespace: true   # Pod间共享PID</span><br><span class="line">  nodeSelector:       # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">  imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br><span class="line">    - name: string</span><br><span class="line">   disktype: ssd        </span><br><span class="line">  hostAliases:        # 设置 &#x2F;etc&#x2F;hosts</span><br><span class="line">   - ip: &quot;10.1.2.3&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.remote&quot;</span><br><span class="line">    - &quot;bar.remote&quot;</span><br><span class="line">  restartPolicy: [Always | Never | OnFailure]  # Pod的重启策略</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: shell</span><br><span class="line">    image: busybox</span><br><span class="line">    stdin: true</span><br><span class="line">    tty: true</span><br></pre></td></tr></table></figure><ul><li><strong>spec</strong></li></ul><p><strong>nodeSeletor</strong> 是一个供用户将 Pod 与 Node 进行绑定的字段<br>这样的配置意味着该Pod只能运行在携带了“disktype：ssd”标签（Label）的节点上；否则会调度失败。</p><p><strong>hostAliases</strong> 定义了Pod中的 hosts 文件（比如 /etc/hosts）里的内容<br>在k8s中如果想要设置hosts文件的内容一定要通过这种方式，否则，Pod被删除重建后，kubelet会自动覆盖掉修改过的内容。</p><p><strong>restartPolicy</strong> ，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod。</p><blockquote><p>Pod在恢复过程中，永远是发生在当前的Node节点上，而不会去别的节点。如果想要Pod出现在其他可用节点，就需要使用 Deployment 这样的调度器来管理Pod，</p></blockquote><ul><li><strong>Namespace共享</strong></li></ul><p>凡是和Namespace相关的内容那么也一定是Pod级别的，Pod的设计就是要让Pod里的容器共享Namesapce，<code>shareProcessNamespace: true</code> 这条指令就可以实现Pod内的容器共享PID Namespace。</p><blockquote><p>创建Pod之后可以通过 <code>kubectl attach -it nginx -c shell</code> 后就可以通过ps 命令查看该Pod中的所有进程。</p></blockquote><p>同样添加 <code>hostNetwork</code>、<code>hostIPC</code>、<code>hostPID</code> 即可共享宿主机资源。</p><ul><li><strong>容器 &amp;&amp; 镜像</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:     # Pod中容器列表</span><br><span class="line">  - name: demo    # 容器名</span><br><span class="line">    image: nginx:1.19.2</span><br><span class="line">    command: [string]    # 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">    args: [string]       # 容器的启动命令参数列表</span><br><span class="line">    workingDir: string   # 容器的工作目录</span><br><span class="line">    imagePullPolicy: [Always | Never | IfNotPresent] # 容器拉取策略</span><br><span class="line">    nodeSelector: obeject  # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">    lifecycle:      # 容器生命周期</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; &#x2F;usr&#x2F;share&#x2F;message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]</span><br><span class="line">    volumes:       #在该pod上定义共享存储卷列表</span><br><span class="line">    - name: string     #共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">      emptyDir: &#123;&#125;     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br><span class="line">      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br><span class="line">        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录</span><br><span class="line">      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span><br><span class="line">        scretname: string  </span><br><span class="line">        items:     </span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br><span class="line">        name: string</span><br><span class="line">        items:</span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">    volumeMounts:    #挂载到容器内部的存储卷配置</span><br><span class="line">    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br><span class="line">      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符</span><br><span class="line">      readOnly: boolean    #是否为只读模式</span><br><span class="line">    ports:       #需要暴露的端口库号列表</span><br><span class="line">    - name: string     #端口号名称</span><br><span class="line">      containerPort: int   #容器需要监听的端口号</span><br><span class="line">      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同</span><br><span class="line">      protocol: string     #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    env:       #容器运行前需设置的环境变量列表</span><br><span class="line">    - name: string     #环境变量名称</span><br><span class="line">      value: string    #环境变量的值</span><br><span class="line">    resources:       #资源限制和请求的设置</span><br><span class="line">      limits:      #资源限制的设置</span><br><span class="line">        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br><span class="line">        memory: string     #内存限制，单位可以为Mib&#x2F;Gib，将用于docker run --memory参数</span><br><span class="line">      requests:      #资源请求的设置</span><br><span class="line">        cpu: string    #Cpu请求，容器启动的初始可用数量</span><br><span class="line">        memory: string     #内存请求，容器启动的初始可用数量</span><br><span class="line">    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span><br><span class="line">      exec:      #对Pod容器内检查方式设置为exec方式</span><br><span class="line">        command: [string]  #exec方式需要制定的命令或脚本</span><br><span class="line">      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式</span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged:false</span><br></pre></td></tr></table></figure><p><strong>ImagePullPolicy</strong> 定义了镜像拉取的策略，是一个Container级别的属性，默认值是Always，即每次创建Pod都重新拉取一次镜像，如果被定义为Never或者 ifNotPresent 时，则意味着Pod永远不会主动拉取这个镜像，或者只有宿主机不存在这个镜像时才会拉取。</p><p><strong>Lifecycle</strong> 定义了容器生命周期的一些钩子，可以执行容器启动前启动后的一些命令，</p><ul><li><strong>Projected Volume</strong></li></ul><p>在 k8s 中有一种特殊的Volume，叫做Projected Volume，存在的意义不是为了存放容器内的数据，也不是用来做数据交换，<strong>而是提供预先准备好的数据，所以从容器的角度来看就仿佛是被 k8s “投射”（Project）进入容器的，这正是Projected Volume 的含义。</strong></p><p>到目前为止，k8s共支持4种 Projected Volume.</p><ol><li>Secret   (例如加载数据库密码等)</li><li>ConfigMap   (例如加载配置文件等)</li><li>Downward API  (暴露Pod的meta信息给容器)</li><li>ServiceAccountToken  (保存授权信息)</li></ol><p>以Secret为例，其存在的意义其实就是将一些重要的数据投射进容器，比如数据库密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-projected-volume </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - &quot;86400&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: &quot;&#x2F;projected-volume&quot;</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: user</span><br><span class="line">      - secret:</span><br><span class="line">          name: pass</span><br></pre></td></tr></table></figure><p>数据库的用户名和密码，正是以Secret对象交付给 k8s 保存的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat .&#x2F;username.txt</span><br><span class="line">admin</span><br><span class="line">$ cat .&#x2F;password.txt</span><br><span class="line">c1oudc0w!</span><br><span class="line"></span><br><span class="line">$ kubectl create secret generic user --from-file&#x3D;.&#x2F;username.txt</span><br><span class="line">$ kubectl create secret generic pass --from-file&#x3D;.&#x2F;password.txt</span><br><span class="line"></span><br><span class="line">$ kubectl get secrets</span><br><span class="line">NAME           TYPE                                DATA      AGE</span><br><span class="line">user          Opaque                                1         51s</span><br><span class="line">pass          Opaque                                1         51s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以通过yaml文件的格式创建Secret对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  user: YWRtaW4&#x3D;</span><br><span class="line">  pass: MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>Pod 看似复杂的API对象，实际上是容器的进一步抽象和封装。而控制器（Deployment）则是控制Pod的抽象。有了控制器，我们可以定义需要2个pod，当pod个数不够时，自动创建pod直到pod个数满足配置文件 replicas 里 定义的个数。</p><p>在 k8s 架构中，有一个叫做 kube-controller-manager 的组件，这个组件负责了k8s集群中的集群属性。使用Deployment控制的pod在生产环境才有意义。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>定义Deployment来创建Pod和ReplicaSet</li><li>滚动升级和回滚应用</li><li>扩容和缩容</li><li>暂停和继续Deployment</li></ol><p>Deployment 本质也是从Etcd中获取到所有携带了“app：nginx” 标签的Pod，统计其数量，并根据 ReplicaSet 字段进行调整。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1   </span><br><span class="line">kind: Deployment                 </span><br><span class="line">metadata:</span><br><span class="line">  name: string         # Deployment名称</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3            # 目标副本数量</span><br><span class="line">  revisonHistoryLimit: 0 # 控制历史版本个数，0的话就没办法再进行回滚操作</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:       # 滚动更新</span><br><span class="line">      maxSurge: 1        # 滚动升级时最大同时升级1个pod</span><br><span class="line">      maxUnavailable: 1  # 滚动升级时最大允许不可用的pod个数</span><br><span class="line">  template:         </span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: string      # 模板名称</span><br><span class="line">    sepc:                # 定义容器模板，该模板可以包含多个容器</span><br><span class="line">      containers:                               </span><br><span class="line">        - name: string                                 </span><br><span class="line">          image: string </span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 8080  # 对service暴露端口</span><br></pre></td></tr></table></figure><p><strong>template</strong> Deployment里的template 字段和一个标准的Pod对象的API定义丝毫不差，而所有被这个Deployment管理的Pod实例就是根据这个template创建出来的。</p><ul><li><strong>ReplicaSet 对象</strong></li></ul><p>滚动更新不仅仅是 Deployment 中的一个字段，而是可以单独作为一个 k8s 中的重要的 API 对象。一个 ReplicaSet 对象，其实就是由副本数目的定义和一个Pod模板的组成。其实ReplicaSet是Deployment的一个子集。</p><p>滚动更新的过程可以通过 <code>kubectl rollout status xxx(deployment)</code>指令查看。或者 <code>kubectl describe deployment xxx(deployment)</code> 查看<br>，当修改了Pod 模板之后，Deployment Controller 会使用这个修改过的Pod模板，创建一个新的 ReplicaSet （hash=173242546624），这个新的 ReplicaSet 的初始化Pod的副本数是 0 。然后会扩展出一个新的Pod集群。</p><ol><li>想要查看replicaSet 对象 <code>kubectl get rs </code> </li><li>想要查看滚动升级历史 <code>kubectl rollout history xxx(deployment)</code></li><li>想要回滚升级至历史版本2 <code>kubectl rollout undo xxx(deployment) --revision=2</code></li><li>暂停更新和恢复 <code>kubectl rolllout pause xxxx</code> 和 <code>kubectl roolout resume xxxx</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在容器的世界中，Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统，而如果仅仅是这样的化，容器是没有价值的，因为这样很难实现线上生产环境迁移到容器集群中，线上环境复杂多变，多个服务需要通过本地socket通信或者通过文件交互内容，所以在 k8s 中，pod才是最小的调度单元。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://kiosk007.top/categories/k8s/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu20.04 部署 Kubernetes (k8s)</title>
    <link href="http://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/"/>
    <id>http://kiosk007.top/2020/07/24/ubuntu20-04-%E9%83%A8%E7%BD%B2-Kubernetes-k8s/</id>
    <published>2020-07-24T13:47:00.000Z</published>
    <updated>2020-07-24T13:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes（k8s）是一个免费的开源容器编排工具。它用于部署，扩展和管理基于容器的应用程序。在这篇文章中，这里将演示如何安装Kubernetes集群的Ubuntu 20.04 LTS服务器使用（Focal Fossa）kubeadm。在实验室设置中，我使用了三台Ubuntu 20.04 LTS服务器。</p><a id="more"></a><hr><p>以下为搭建环境。</p><ul><li>ubuntu 20.04 TLS Server</li><li>Minimum of 2 GB RAM</li><li>10 GB Free Space on /var</li><li>Privileged user with sudo rights</li></ul><p>结构：</p><ul><li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-master – 172.16.101.131</li><li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-node0 – 172.16.101.132</li><li>Machine 1 (Ubuntu 20.04 LTS Server) – K8s-node1 – 172.16.101.133</li></ul><img src="/images/k8s/k8s.png"><h1 id="安装-kubernetes"><a href="#安装-kubernetes" class="headerlink" title="安装 kubernetes"></a>安装 kubernetes</h1><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><h3 id="Step1-设置-hostname-amp-amp-增加解析-etc-hosts"><a href="#Step1-设置-hostname-amp-amp-增加解析-etc-hosts" class="headerlink" title="Step1) 设置 hostname &amp;&amp; 增加解析 /etc/hosts"></a>Step1) 设置 hostname &amp;&amp; 增加解析 /etc/hosts</h3><p>使用 <font color="Blue">hostnamectl </font> 为每一个节点命令设置 hostname , 示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-master&quot;     &#x2F;&#x2F; Run this command on master node</span><br><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-node0&quot;     &#x2F;&#x2F; Run this command on node-0</span><br><span class="line">$ sudo hostnamectl set-hostname &quot;k8s-node1&quot;     &#x2F;&#x2F; Run this command on node-1</span><br></pre></td></tr></table></figure><p>在 <font color="Blue"> /etc/hosts </font> 下添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">172.16.101.131 k8s-master</span><br><span class="line">172.16.101.132 k8s-node0</span><br><span class="line">172.16.101.132 k8s-node1</span><br><span class="line"></span><br><span class="line">172.16.101.131 api-server.k8s.top  # kube API Server Lb</span><br></pre></td></tr></table></figure><h3 id="Step2-确保禁止掉swap分区-amp-amp-确保时间对齐-amp-amp-开启ip转发"><a href="#Step2-确保禁止掉swap分区-amp-amp-确保时间对齐-amp-amp-开启ip转发" class="headerlink" title="Step2) 确保禁止掉swap分区 &amp;&amp; 确保时间对齐 &amp;&amp; 开启ip转发"></a>Step2) 确保禁止掉swap分区 &amp;&amp; 确保时间对齐 &amp;&amp; 开启ip转发</h3><p>K8s的要求，在每个宿主机上关闭 swap，swap会将不活跃匿名页写入磁盘，降低应用程序的性能。使用 <font color="blue"> swapoff -a </font> 来关掉 swap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"># &#x2F;swap.img      none    swap    sw      0       0</span><br></pre></td></tr></table></figure><p>每个宿主机上都要确保时区和时间是正确的。如果时区不正确，请使用下面的命令来修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><p>永久开启ip转发功能，编辑 “<font color="blue"> /etc/sysctl.d/k8s.conf </font>“ 添加 “<strong>net.ipv4.ip_forward=1</strong>” ，加载 “<strong>br_netfilter</strong>” 模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><h3 id="Step3）安装-docker-Container-Runtime-到三个节点"><a href="#Step3）安装-docker-Container-Runtime-到三个节点" class="headerlink" title="Step3）安装 docker (Container Runtime) 到三个节点"></a>Step3）安装 docker (Container Runtime) 到三个节点</h3><p>在三台机器分别执行如下命令。Ubuntu 20.04 提供的这个包也很新（目前是docker 19.03）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install docker.io -y</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 docker 运行状态，docker 版本</span></span><br><span class="line">systemctl status docker</span><br><span class="line">docker info</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件驱动默认由<code>systemd</code>改成<code>cgroupfs</code>.而我们安装的docker使用的文件驱动是systemd, 造成不一致, 导致镜像无法启动</p><p>修改或创建 <font color="blue"> /etc/docker/daemon.json </font>，加入下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启docker <code>systemctl restart docker</code>.</p><blockquote><p>不然会遇到 failed to create kubelet: misconfiguration: kubelet cgroup driver: “cgroupfs” is different from docker cgroup driver: “systemd” 错误</p></blockquote><p>参考：<a href="https://www.cnblogs.com/hongdada/p/9771857.html">https://www.cnblogs.com/hongdada/p/9771857.html</a></p><h2 id="安装k8s-master"><a href="#安装k8s-master" class="headerlink" title="安装k8s master"></a>安装k8s master</h2><p>以下的操作只在master宿主机上执行，适合中国大陆地区使用（因为弃用谷歌的源和repo，转而使用阿里云的镜像）：</p><h3 id="Step1）安装kubeadm-kubeadm-kubectl"><a href="#Step1）安装kubeadm-kubeadm-kubectl" class="headerlink" title="Step1）安装kubeadm kubeadm kubectl"></a>Step1）安装kubeadm kubeadm kubectl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https curl</span><br><span class="line"></span><br><span class="line">curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;<span class="string">EOF </span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br><span class="line"><span class="comment"># 标记该软件包不被自动更新</span></span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h3 id="Step2）通过-kubeadm-Kubernetes-初始化集群-from-master-node"><a href="#Step2）通过-kubeadm-Kubernetes-初始化集群-from-master-node" class="headerlink" title="Step2）通过 kubeadm Kubernetes 初始化集群 (from master node)"></a>Step2）通过 kubeadm Kubernetes 初始化集群 (from master node)</h3><p>查看完整配置选项 <a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vim .&#x2F;kubeadm-config.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.18.6</span><br><span class="line">imageRepository: registry.aliyuncs.com&#x2F;k8sxio</span><br><span class="line">controlPlaneEndpoint: &quot;api-server.k8s.top:6443&quot;</span><br><span class="line">apiServer:</span><br><span class="line">  certSANs:</span><br><span class="line">  - &quot;k8s-master&quot;</span><br><span class="line">  - &quot;api-server.k8s.top&quot;</span><br><span class="line">  - &quot;172.16.101.131&quot;</span><br><span class="line">networking:</span><br><span class="line">  serviceSubnet: &quot;10.96.0.0&#x2F;16&quot;</span><br><span class="line">  podSubnet: &quot;10.100.0.1&#x2F;16&quot;</span><br><span class="line">  dnsDomain: &quot;cluster.local&quot;</span><br><span class="line">controllerManagerExtraArgs:  </span><br><span class="line">  horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;  </span><br><span class="line">  horizontal-pod-autoscaler-sync-period: &quot;10s&quot;  </span><br><span class="line">  node-monitor-grace-period: &quot;10s&quot;</span><br><span class="line">apiServerExtraArgs:  </span><br><span class="line">  runtime-config: &quot;api&#x2F;all&#x3D;true&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># kubeadm init</span><br><span class="line"># 根据您服务器网速的情况，您需要等候 3 - 10 分钟</span><br><span class="line">kubeadm init --config&#x3D;kubeadm-config.yaml --upload-certs -v 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Kubernetes 集群默认需要加密方式访问。</span><br><span class="line"># 所以，这几条命令，就是将刚刚部署生成的 Kubernetes 集群的安全配置文件，保存到当前用户的.kube 目录下，</span><br><span class="line"># kubectl 默认会使用这个目录下的授权信息访问 Kubernetes 集群。如果不这么做的话，我们每次都需要通过 </span><br><span class="line"># export KUBECONFIG 环境变量告诉 kubectl 这个安全配置文件的位置。</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>podSubnet: Kubernetes</code> 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中</li><li><code>horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;: </code> kube-controller-manager 能够使用自定义资源（Custom Metrics）进行自动水平扩展。</li><li><code>controlPlaneEndpoint</code> 负载均衡器的地址始终与kubeadm相连接（方便kubeapi-server 横向扩展），既然是lb，那么最好不要填 k8s-master的hostname了，这里我写的是 <font color="red">api-server.k8s.top:6443 </font> </li><li><code>upload-certs</code> 将控制平面证书上传到 kubeadm-certs Secret。</li><li><code>-v 6</code> 更可能输出详细的日志，建议开启。</li></ul><p>初始化完成之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You can now join any number of the control-plane node running the following command on each as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join api-server.k8s.top:6443 --token km8rml.3mnits2sbfh2srex \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3 \</span><br><span class="line">    --control-plane --certificate-key 619272158ec6c0a14c0539e032f5686df4d6c5576aa549412098ca50592315e6</span><br><span class="line"></span><br><span class="line">Please note that the certificate-key gives access to cluster sensitive data, keep it secret!</span><br><span class="line">As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use</span><br><span class="line">&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join api-server.k8s.top:6443 --token km8rml.3mnits2sbfh2srex \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>查看Master节点的初始化状态 （only exec on master）</strong><br>执行<font color="blue"> kubectl get nodes -o wide </font> 可以看到我们的容器当前属于 NotReady 状态。NodeNotReady 的原因在于，我们尚未部署任何网络插件。通过 kubectl 检查这个节点上各个系统 Pod 的状态。可以看到，CoreDNS、kube-controller-manager 等依赖于网络的 Pod 都处于 Pending 状态，即调度失败。这当然是符合预期的：因为这个 Master 节点的网络尚未就绪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get nodes -o wide</span><br><span class="line">NAME         STATUS     ROLES    AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE           KERNEL-VERSION     CONTAINER-RUNTIME</span><br><span class="line">k8s-master   NotReady   master   22m   v1.18.6   172.16.101.131   &lt;none&gt;        Ubuntu 20.04 LTS   5.4.0-42-generic   docker:&#x2F;&#x2F;19.3.8</span><br><span class="line"></span><br><span class="line"># kubectl get pod -n kube-system -o wide</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-66db54ff7f-s4696             0&#x2F;1     Pending   0          26m   &lt;none&gt;           &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66db54ff7f-xxtvz             0&#x2F;1     Pending   0          26m   &lt;none&gt;           &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-k8s-master                      1&#x2F;1     Running   1          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-k8s-master            1&#x2F;1     Running   0          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-k8s-master   1&#x2F;1     Running   2          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-lvrkh                     1&#x2F;1     Running   0          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-k8s-master            1&#x2F;1     Running   2          26m   172.16.101.131   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p><strong>安装网络插件</strong><br><br>安装 calico 网络插件<br><br>参考文档 <a href="https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises">https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;kuboard.cn&#x2F;install-script&#x2F;calico&#x2F;calico-3.13.1.yaml</span><br><span class="line">kubectl apply -f calico-3.13.1.yaml</span><br></pre></td></tr></table></figure><h2 id="安装k8s-Worker"><a href="#安装k8s-Worker" class="headerlink" title="安装k8s Worker"></a>安装k8s Worker</h2><p>Kubernetes 的 Worker 节点跟 Master 节点几乎是相同的，它们运行着的都是一个 kubelet 组件。唯一的区别在于，在 kubeadm init 的过程中，kubelet 启动后，Master 节点上还会自动运行 kube-apiserver、kube-scheduler、kube-controller-manger 这三个系统 Pod。</p><p>所以，相比之下，部署 Worker 节点反而是最简单的，只需要两步即可完成。<br><br>第一步，在所有 Worker 节点(node0 node1)上执行“安装 kubeadm”。<br><br>第二步，执行部署 Master 节点时生成的 kubeadm join 指令：<br></p><p>操作在 worker 节点（k8s-node0 k8s-node1）之上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 第一步骤：安装</span><br><span class="line">curl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list &lt;&lt;EOF </span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F; kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt-get install -y kubeadm</span><br><span class="line">apt-mark hold kubeadm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二步： 加入（初始化完成时的输出）</span><br><span class="line"></span><br><span class="line">kubeadm join api-server.k8s.top:6443 --token n9ksnt.zgxthovqoyl2weyq     --discovery-token-ca-cert-hash sha256:4005adc5c09d7aaa6a5693acf36402eb0273f009a9ce83b8bb208686ed73abd3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第三步： 添加环境变量</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">cp -i &#x2F;etc&#x2F;kubernetes&#x2F;kubelet.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>不记得安装后的输出的话可以在 master节点执行 <font color="blue">kubeadm token create –print-join-command</font> 查看，该 token 的有效时间为 2 个小时，2小时内，您可以使用此 token 初始化任意数量的 worker 节点。</p></blockquote><p>参考：</p><ul><li><a href="https://www.kuboard.cn/install/install-k8s.html">使用kubeadm安装kubernetes_v1.18.x</a></li><li><a href="https://zhuanlan.zhihu.com/p/138554103">基于Ubuntu 20.04安装Kubernetes 1.18</a></li><li><a href="https://www.bookstack.cn/read/k8s-1.18-reference/e8ce7efca72fde85.md">Kubernetes v1.18 参考指南</a></li></ul><h2 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h2><h3 id="部署-Dashboard-可视化插件"><a href="#部署-Dashboard-可视化插件" class="headerlink" title="部署 Dashboard 可视化插件"></a>部署 Dashboard 可视化插件</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>由于 Dashboard 是一个 Web Server，很多人经常会在自己的公有云上无意地暴露 Dashboard 的端口，从而造成安全隐患。所以，1.7 版本之后的 Dashboard 项目部署完成后，默认只能通过 Proxy 的方式在本地访问。具体的操作，你可以查看 <a href="https://github.com/kubernetes/dashboard">Dashboard</a> 项目的官方文档。</p><p>Dashboard 向 Kubernetes 集群部署容器化应用诊断容器化应用的问题</p><ul><li>管理集群的资源</li><li>查看集群上所运行的应用程序</li><li>创建、修改Kubernetes 上的资源（例如 Deployment、Job、DaemonSet等）</li><li>展示集群上发生的错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.0.3&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后可以使用 <code>kubectl get pods</code> 命令来查看部署状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">...</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-6b4884c9d5-gs97j   1&#x2F;1     Running   0          100m</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-7f99b75bf4-h576c        1&#x2F;1     Running   0          100m</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>首先创建一个叫 <font color="blue"> admin-user </font> 的服务账号，并放在 <font color="blue">kubernetes-dashboard</font> 名称空间下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># admin-user.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>执行 <font color="blue"> kubectl create </font> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f admin-user.yaml</span><br></pre></td></tr></table></figure><h4 id="绑定角色"><a href="#绑定角色" class="headerlink" title="绑定角色"></a>绑定角色</h4><p>默认情况下，kubeadm 创建集群时已经创建了admin角色，我们直接绑定即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># admin-user-role-binding.yaml</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行 <font color="blue">kubectl create </font>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f  admin-user-role-binding.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h4><p>们需要找到新创建的用户的Token，以便用来登录dashboard：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;&#123;print $1&#125;&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>Kubernetes API服务器是公开的，并可以从外部访问，那我们可以直接使用API Server的方式来访问，也是比较推荐的方式。</p><p>Dashboard的访问地址为：<a href="https://172.16.101.131:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/node/k8s-node1?namespace=default">https://172.16.101.131:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/node/k8s-node1?namespace=default</a></p><p>但是直接访问会是403</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;services \&quot;https:kubernetes-dashboard:\&quot; is forbidden: User \&quot;system:anonymous\&quot; cannot get services&#x2F;proxy in the namespace \&quot;kube-system\&quot;&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;https:kubernetes-dashboard:&quot;,</span><br><span class="line">    &quot;kind&quot;: &quot;services&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为最新版的k8s默认启用了RBAC，并为未认证用户赋予了一个默认的身份：<font color="blue">anonymous</font><br>对于API Server来说，它是使用证书进行认证的，我们需要先创建一个客户端证书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 生成client-certificate-data</span><br><span class="line">grep &#39;client-certificate-data&#39; ~&#x2F;.kube&#x2F;config | head -n 1 | awk &#39;&#123;print $2&#125;&#39; | base64 -d &gt;&gt; kubecfg.crt</span><br><span class="line"></span><br><span class="line"># 生成client-key-data</span><br><span class="line">grep &#39;client-key-data&#39; ~&#x2F;.kube&#x2F;config | head -n 1 | awk &#39;&#123;print $2&#125;&#39; | base64 -d &gt;&gt; kubecfg.key</span><br><span class="line"></span><br><span class="line"># 生成p12</span><br><span class="line">openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name &quot;kubernetes-client&quot;</span><br></pre></td></tr></table></figure><img src="/images/k8s/k8s_dashboard.png"><p>参考：</p><ul><li><a href="https://www.cnblogs.com/RainingNight/p/deploying-k8s-dashboard-ui.html">kubernetes-dashboard(1.8.3)部署与踩坑</a></li></ul><h3 id="部署持久化存储插件-rock"><a href="#部署持久化存储插件-rock" class="headerlink" title="部署持久化存储插件 rock"></a>部署持久化存储插件 rock</h3><p>Rook 项目是一个基于 Ceph 的 Kubernetes 存储插件（它后期也在加入对更多存储实现的支持）。不过，不同于对 Ceph 的简单封装，Rook 在自己的实现中加入了水平扩展、迁移、灾难备份、监控等大量的企业级功能，使得这个项目变成了一个完整的、生产级别可用的容器存储插件。</p><blockquote><p>友情提示，这玩意巨占空间，如果是本地虚拟机搭建的话需要磁盘稍微再大点。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/common.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/operator.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/cluster.yaml</span><br></pre></td></tr></table></figure><h2 id="通过-Taint-Toleration-调整-Master-执行-Pod-的策略-附加"><a href="#通过-Taint-Toleration-调整-Master-执行-Pod-的策略-附加" class="headerlink" title="通过 Taint/Toleration 调整 Master 执行 Pod 的策略 (附加)"></a>通过 Taint/Toleration 调整 Master 执行 Pod 的策略 (附加)</h2><p>默认情况下 Master 节点是不允许运行用户 Pod 的。而 Kubernetes 做到这一点，依靠的是 Kubernetes 的 Taint/Toleration 机制。</p><p>原理非常简单：一旦某个节点被加上了一个 Taint，即被“打上了污点”，那么所有 Pod 就都不能在这个节点上运行，因为 Kubernetes 的 Pod 都有“洁癖”。除非，有个别的 Pod 声明自己能“容忍”这个“污点”，即声明了 Toleration，它才可以在这个节点上运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建 taint</span><br><span class="line">kubectl taint nodes k8s-nodeXX foo&#x3D;bar:NoSchedule</span><br><span class="line"></span><br><span class="line"># 删除 taint</span><br><span class="line">kubectl taint nodes k8s-nodeXX foo&#x3D;bar:NoSchedule-</span><br></pre></td></tr></table></figure><p>master 默认已经有了一个 taint。即<font color="blue"> role.kubernetes.io/master:NoSchedule</font> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node k8s-master</span><br><span class="line">Name:               k8s-master</span><br><span class="line">Roles:              master</span><br><span class="line">...</span><br><span class="line">CreationTimestamp:  Sat, 25 Jul 2020 09:44:07 +0800</span><br><span class="line">Taints:             node-role.kubernetes.io&#x2F;master:NoSchedule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="创建-k8s容器化应用"><a href="#创建-k8s容器化应用" class="headerlink" title="创建 k8s容器化应用"></a>创建 k8s容器化应用</h1><p>这里创建一个Nginx, 准备一个 <font color="blue"> nginx-deployment.yaml </font> 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.19.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &quot;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&quot;</span><br><span class="line">          name: nginx-vol</span><br><span class="line">      volumes:</span><br><span class="line">      - name: nginx-vol</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &quot;&#x2F;root&#x2F;data&quot;</span><br></pre></td></tr></table></figure><ul><li><code>spec.replicas</code>：Pod 副本个数 ：2</li><li><code>spec.containers.image</code>: 容器镜像 ：Nginx:latest</li><li><code>containerPort</code>: 容器端口：80</li><li><code>volumes.emptyDir</code>: 不显式声明宿主机目录的 Volume。所以，Kubernetes 也会在宿主机上创建一个临时目录，这个目录将来就会被绑定挂载到容器所声明的 Volume 目录上。当然，Kubernetes 也提供了显式的 Volume 定义，它叫作 hostPath。比如下面的这个 YAML 文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...   </span><br><span class="line">   volumes:</span><br><span class="line">     - name: nginx-vol</span><br><span class="line">       hostPath: </span><br><span class="line">         path:  &quot; &#x2F;var&#x2F;data&quot;</span><br></pre></td></tr></table></figure>使用 kubectl create 创建这个容器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure><p>查看运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l app&#x3D;nginx</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-d4544f9cb-b24wq   1&#x2F;1     Running   0          5m13s</span><br><span class="line">nginx-deployment-d4544f9cb-f88bk   1&#x2F;1     Running   0          5m13s</span><br><span class="line"></span><br><span class="line"># 查看一个 API 对象的细节，通过 Events 字段</span><br><span class="line">kubectl describe pod nginx-deployment-d4544f9cb-b24wq</span><br></pre></td></tr></table></figure><p>查看API对象细节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod nginx-deployment-57f45cfc58-9fpzt</span><br><span class="line">Name:         nginx-deployment-57f45cfc58-9fpzt</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         k8s-node1&#x2F;172.16.101.133</span><br><span class="line">Start Time:   Sat, 25 Jul 2020 18:00:01 +0800</span><br><span class="line">Labels:       app&#x3D;nginx</span><br><span class="line">              pod-template-hash&#x3D;57f45cfc58</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 kubectl describe 命令返回的结果中，可以看到这个 Pod 的详细信息，比如它的 IP 地址等等。其中，有一个部分值得你特别关注，就是 <strong>Events（事件）</strong>。</p><p>在 Kubernetes 执行的过程中，对 API 对象的所有重要操作，都会被记录在这个对象的 Events 里，并且显示在 kubectl describe 指令返回的结果中。</p><p>如果 pod 信息有改变，比如想要将Nginx的版本换成1.18。修改完 yaml 文件后，只需要执行<code>kubectl apply -f nginx-deployment.yaml</code> 即可。</p><p><strong>进入到pod中，即这个namesapce中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it  nginx-deployment-57f45cfc58-9fpzt -- &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>**从 Kubernetes 集群中删除这个 Nginx Deployment **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure><h1 id="k8s-的最小调度单元-pod"><a href="#k8s-的最小调度单元-pod" class="headerlink" title="k8s 的最小调度单元 pod"></a>k8s 的最小调度单元 pod</h1><p>前面已经完全搭建起来了一个 k8s 集群，并跑起来了第一个Nginx服务。但是这距离线上的生成环境还差的很远。</p><p>试想一下，Nginx 假设需要为静态资源前端文件提供服务部署能力，那么该如何实现呢？将前端文件内容和Nginx绑定部署？这显然是不合适的。</p><p>Linux 下的很多服务其实也是多个进程相互协作的，比如两个进程是通过本地socket通信的，那么就必须让两个进程处于同一个 namespace中，而在docker的世界，容器即进程，也就是一个容器跑着一个进程。</p><blockquote><p>再次强调一下：容器的“单进程模型”，并不是指容器里只能运行“一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程。可是，用户编写的应用，并不能够像正常操作系统里的 init 进程或者 systemd 那样拥有进程管理的功能。比如，你的应用是一个 Java Web 程序（PID=1），然后你执行 docker exec 在后台启动了一个 Nginx 进程（PID=3）。可是，当这个 Nginx 进程异常退出的时候，你该怎么知道呢？这个进程退出后的垃圾收集工作，又应该由谁去做呢？</p></blockquote><p>这就需要多个容器组成一个pod，pod里的容器可以共享namespace，比如共享<code>network namespace</code>或者共享volume的<code>mnt namesapce</code>。这就像 <code>docker run --net=B --volumes-from=B --name=A image-A ...</code>这样的联盟式容器一样的操作。</p><p>在k8s中，需要有一个初始的容器来提供初始化的环境，这个容器（k8s.grc.io/pause）会最先启动,并提供初始的各种namesapce环境，infra容器所占用的资源是最小的。<strong>k8s.gcr.io/pause</strong> 这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有 100~200 KB 左右。<br><img src="/images/k8s/k8s_infra.png" style="height:400px"></p><p>如果要开发容器的网络插件，也就是针对这个infra容器的，而不是应用本身的容器。</p><p>在web场景中经常即需要war包也需要运行war包的tomcat web服务器。web包需要放在tomcat的webapp下运行。<br>如果用容器去可能的2个实现方法是。</p><ol><li>把 WAR 包直接放在 Tomcat 镜像的 webapps 目录下，做成一个新的镜像运行起来。可是，这时候，如果你要更新 WAR 包的内容，或者要升级 Tomcat 镜像，就要重新制作一个新的发布镜像，非常麻烦。</li><li>压根儿不管 WAR 包，永远只发布一个 Tomcat 容器。不过，这个容器的 webapps 目录，就必须声明一个 hostPath 类型的 Volume，从而把宿主机上的 WAR 包挂载进 Tomcat 容器当中运行起来。不过，这样你就必须要解决一个问题，即：如何让每一台宿主机，都预先准备好这个存储有 WAR 包的目录呢？这样来看，你只能独立维护一套分布式存储系统了。</li></ol><p>有了 Pod 之后，这样的问题就很容易解决了。我们可以把 WAR 包和 Tomcat 分别做成镜像，然后把它们作为一个 Pod 里的两个容器“组合”在一起。<br>这里定义了2个容器 <code>war</code> 和 <code>tomcat</code>。war容器只专心提供war包，而tomcat基<br>本不变。不过，<code>war</code> 容器的类型不再是一个普通容器，而是一个 <strong>Init Container</strong> 类型的容器。Init Container 类型的 WAR 包容器启动后，执行了<code>cp /sample.war /app</code>，把应用的 WAR 包拷贝到 /app 目录下，然后退出。</p><ul><li>这种组合即“sidecar”，sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。</li></ul><blockquote><p>Init Container 定义的容器，都会比 spec.containers 定义的用户容器先启动。并且，Init Container 容器会按顺序逐一启动，而直到它们都启动并且退出了，用户容器才会启动。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: javaweb-2</span><br><span class="line">spec:</span><br><span class="line">  initContainers:</span><br><span class="line">  - image: geektime&#x2F;sample:v2</span><br><span class="line">    name: war</span><br><span class="line">    command: [&quot;cp&quot;, &quot;&#x2F;sample.war&quot;, &quot;&#x2F;app&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &#x2F;app</span><br><span class="line">      name: app-volume</span><br><span class="line">  containers:</span><br><span class="line">  - image: geektime&#x2F;tomcat:7.0</span><br><span class="line">    name: tomcat</span><br><span class="line">    command: [&quot;sh&quot;,&quot;-c&quot;,&quot;&#x2F;root&#x2F;apache-tomcat-7.0.42-v2&#x2F;bin&#x2F;start.sh&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &#x2F;root&#x2F;apache-tomcat-7.0.42-v2&#x2F;webapps</span><br><span class="line">      name: app-volume</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      hostPort: 8001 </span><br><span class="line">  volumes:</span><br><span class="line">  - name: app-volume</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kubernetes（k8s）是一个免费的开源容器编排工具。它用于部署，扩展和管理基于容器的应用程序。在这篇文章中，这里将演示如何安装Kubernetes集群的Ubuntu 20.04 LTS服务器使用（Focal Fossa）kubeadm。在实验室设置中，我使用了三台Ubuntu 20.04 LTS服务器。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://kiosk007.top/categories/k8s/"/>
    
    
    <category term="k8s" scheme="http://kiosk007.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Android 信任自签名证书</title>
    <link href="http://kiosk007.top/2020/07/22/Android-%E4%BF%A1%E4%BB%BB%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/"/>
    <id>http://kiosk007.top/2020/07/22/Android-%E4%BF%A1%E4%BB%BB%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/</id>
    <published>2020-07-22T15:23:00.000Z</published>
    <updated>2020-07-22T15:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章 <a href="https://kiosk007.top/2020/05/30/VMTrafficShark-%E8%87%AA%E5%88%B6%E5%BC%B1%E7%BD%91%E6%A8%A1%E6%8B%9F%E5%99%A8/">VMTrafficShark 自制弱网模拟器</a> 中介绍了如何搭建一个弱网模拟器，并且进行弱网模拟，中间人，劫持重放测试等等。对了这里一般的测试设备是Android手机，那么这篇文章介绍一下Android 手机应该如何支持自签名证书。</p><a id="more"></a><hr><h1 id="Android-root"><a href="#Android-root" class="headerlink" title="Android root"></a>Android root</h1><p>Android 本身可以理解为一个Linux操作系统的终端，只是没有root权限，普通用户 <code>adb</code> 连上之后只有普通用户的权限。而root不是那么容易的，这里推荐 <code>Magisk Root</code> 这款软件，目前我的 Mi3， RedMi Note 8 Pro 都是已经root了的（曾经是米粉…）</p><p>甩几个链接参考</p><ul><li><a href="https://www.magiskroots.com/">Magic Mask To Enhance Your Default Android | The First Systemless Root Tool</a></li><li><a href="https://devsjournal.com/how-to-setup-magisk-manager-on-rooted-android-device-to-hide-root.html#:~:text=Installing%20Magisk%20Root%20via%20TWRP%3A%201%20Make%20sure,Zip%20and%20confirm%20flashing.%20...%20More%20items...%20">How To Setup Magisk Manager On Rooted Android Device To Hide “Root”</a></li><li><a href="https://c.mi.com/thread-1808315-1-0.html">How to Root Xiaomi Redmi Note 5</a></li></ul><h1 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h1><h2 id="X509-证书简介"><a href="#X509-证书简介" class="headerlink" title="X509 证书简介"></a>X509 证书简介</h2><p>首先介绍一下证书体系吧</p><p>公钥基础设施（PKI）是一种用于验证网络世界中的用户和设备的技术。基本思想是让一个或多个受信方对数据进行数字签名，以证明特定的加密密钥属于特定的用户或设备。然后该密钥可以用作证明该用户的身份。</p><p>而 x509 正是当下最常见的证书标准，<a href="https://tools.ietf.org/html/rfc5280">RFC5280</a> 阐述了IETF对X509证书的定义。x509证书的格式在google chrome 浏览器地址栏左边的小锁即可查看。</p><p>以cloudflare的官网域名 <a href="https://1.1.1.1/">https://1.1.1.1</a> 举例（没错，还有ip证书）</p><p><strong>第一组详细信息包括有关主题的信息，包括公司名称和地址以及证书旨在保护的网站的通用名称（Fully Qualified Domain Name）</strong><br><img src="/images/network/AndroidRoot/cert_fqdn.png" style="height:450px"></p><p><strong>向下滑动，是发行者的信息（Issuer）, 这里可以看到签发者是 DigiCert。在颁发者下方，我们可以看到证书的序列号，X.509版本（3），签名算法以及指定证书有效期的日期。</strong><br><img src="/images/network/AndroidRoot/cert_sign.png" style="height:450px"></p><p><strong>X.509 v3证书还包括一组扩展，这些扩展在证书使用方面提供了更多的灵活性。例如，主题备用名称扩展名允许证书绑定到多个身份。（因此，有时将多域证书称为 <a href="https://www.ssl.com/faqs/what-is-a-san-certificate/">SAN</a> 证书）。这里提供了很多其他域名，这里还可以提供ip地址,可以看到 cloudflare 的1.1.1.1</strong></p><img src="/images/network/AndroidRoot/cert_san.png" style="height:450px"><h2 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h2><ul><li>.DER .CER，文件是二进制格式，只保存证书，不保存私钥。</li><li>.PEM，一般是文本格式，可保存证书，可保存私钥。</li><li>.CRT，可以是二进制格式，可以是文本格式，与 .DER 格式相同，不保存私钥。</li><li>.PFX .P12，二进制格式，同时包含证书和私钥，一般有密码保护。</li><li>.JKS，二进制格式，同时包含证书和私钥，一般有密码保护。</li></ul><h2 id="利用-Mitm-的-Root-CA-制作自签名证书"><a href="#利用-Mitm-的-Root-CA-制作自签名证书" class="headerlink" title="利用 Mitm 的 Root CA 制作自签名证书"></a>利用 Mitm 的 Root CA 制作自签名证书</h2><p><a href="https://docs.mitmproxy.org/stable/">mitmproxy</a> 是一款中间人工具，通过代理来实现https流量嗅探。</p><p>安装好 mitmproxy 后再家目录下就放着 mitm 的root ca。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ls ~/.mitmproxy</span><br><span class="line">mitmproxy-ca-cert.cer  mitmproxy-ca-cert.p12  mitmproxy-ca-cert.pem  mitmproxy-ca.p12  mitmproxy-ca.pem  mitmproxy-dhparam.pem</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们取 <code>mitmproxy-ca.pem</code> 这个文件制作自签名证书。</p><h3 id="分离CA证书和私钥"><a href="#分离CA证书和私钥" class="headerlink" title="分离CA证书和私钥"></a>分离CA证书和私钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  mkdir mitm &amp;&amp; <span class="built_in">cd</span> mitm</span><br><span class="line">➜  cp ~/.mitmproxy/mitmproxy-ca.pem .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离私钥</span></span><br><span class="line">➜  openssl pkey -<span class="keyword">in</span> mitmproxy-ca.pem -out mitmproxy-ca-private.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有证书，包括CA Chain</span></span><br><span class="line">➜  openssl crl2pkcs7 -nocrl -certfile mitmproxy-ca.pem | openssl pkcs7 -print_certs -out mitmproxy-ca-certificate.cert</span><br></pre></td></tr></table></figure><h3 id="创建自签名证书"><a href="#创建自签名证书" class="headerlink" title="创建自签名证书"></a>创建自签名证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成证书私钥（your-domain.com 换成你要签名的域名）</span></span><br><span class="line">➜  openssl genrsa -out your-domain.com.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书请求文件(并按要求填写 CN、SPN、LN等，不想填就全部回车)</span></span><br><span class="line">➜  openssl req -new -key your-domain.com.key -out your-domain.com.csr</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Chrome 58 之后，改为使用 SAN(Subject Alternative Name) 检查域名的一致性。</p><p>而 SAN 属于 x509 扩展里面的内容，所以我们需要通过 -extfile 参数来指定存放扩展内容的文件。创建一个 your-domain.com.ext 文件用来保存 SAN 信息，通过指定多个 DNS 从而可以实现多域名证书。<br>参考：<a href="http://wiki.cacert.org/FAQ/subjectAltName">FAQ/subjectAltName (SAN)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  vim your-domain.com.ext</span><br><span class="line">[req]</span><br><span class="line">req_extensions = v3_req</span><br><span class="line"></span><br><span class="line">[v3_req]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = your-domain.com.</span><br><span class="line">DNS.2 = *.your-domain.com.</span><br><span class="line">IP.1 = 127.0.0.1</span><br><span class="line">IP.2 = 192.168.0.107</span><br></pre></td></tr></table></figure><p>使用 mitm 的CA 公私钥对 签署自己域名的证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  openssl x509 -req -sha256 -<span class="keyword">in</span> your-domain.com.csr \</span><br><span class="line">-CA mitmproxy-ca-certificate.cert \</span><br><span class="line">-CAkey mitmproxy-ca-private.key \</span><br><span class="line">-CAcreateserial \</span><br><span class="line">-out your-domain.com.crt \</span><br><span class="line">-days 365 \</span><br><span class="line">-extfile kiosk007.top.ext \</span><br><span class="line">-extensions v3_req</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，自签名证书已经生成完毕，自签名的证书为 <code>your-domain.crt</code> , 自签名的私钥为 <code>your-domain.key</code> 。只需要将 <code>mitmproxy-ca-certificate.cert</code> 导入到Android手机中，手机便会信任由这个root 证书签名的证书，如刚才的 <code>your-domian.crt</code></p><h2 id="导入根证书到Android手机"><a href="#导入根证书到Android手机" class="headerlink" title="导入根证书到Android手机"></a>导入根证书到Android手机</h2><h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到hash值</span></span><br><span class="line">➜  openssl x509 -subject_hash_old -<span class="keyword">in</span> mitmproxy-ca-certificate.cert |head -n 1</span><br><span class="line">➜  cp mitmproxy-ca-certificate.cert &lt;Certificate_Hash&gt;.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装到Android机"><a href="#安装到Android机" class="headerlink" title="安装到Android机"></a>安装到Android机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  adb push c8750f0d.0 /sdcard/</span><br><span class="line">➜  adb shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手机中操作</span></span><br><span class="line">begonia:/ $ su root</span><br><span class="line">:/ <span class="comment"># mount -o rw,remount /</span></span><br><span class="line">:/ <span class="comment"># mv /sdcard/c8750f0d.0 /system/etc/security/cacerts/</span></span><br><span class="line">:/ <span class="comment"># chmod 644 /system/etc/security/cacerts/c8750f0d.0</span></span><br><span class="line">:/ <span class="comment"># chown root:root /system/etc/security/cacerts/c8750f0d.0</span></span><br><span class="line">:/ <span class="comment"># mount -o ro,remount /</span></span><br><span class="line">:/ <span class="comment"># reboot</span></span><br><span class="line">➜  </span><br><span class="line">➜  </span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.ssl.com/faqs/what-is-an-x-509-certificate/">What Is an X.509 Certificate?</a></li><li><a href="https://www.ssh.com/pki/">PKI - Public Key Infrastructure</a></li><li><a href="https://blog.freessl.cn/ssl-cert-format-introduce/">SSL 证书格式普及，PEM、CER、JKS、PKCS12</a></li></ul><h1 id="Android-ssh-终端-附加"><a href="#Android-ssh-终端-附加" class="headerlink" title="Android ssh 终端 (附加)"></a>Android ssh 终端 (附加)</h1><p>这一步主要是可以通过ssh操作终端（已经和信任自签名证书无关了哈，只是附加的。哈哈），因为<code>adb shell</code>实在是太难操作了。</p><p>这里先安装 Termux （可以在 google play 或者 豌豆荚下载）</p><p>安装 Termux 之后，安装sshd<br>手机上操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkg install openssh -y</span><br><span class="line"># start ssh</span><br><span class="line">sshd</span><br></pre></td></tr></table></figure><p>配置远程登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># PC copy ssh 公钥 (没有的化，执行 ssh-keygen 生成)</span><br><span class="line">➜  copy id_rsa.pub</span><br><span class="line"></span><br><span class="line"># Termux 粘贴公钥</span><br><span class="line">cd .ssh</span><br><span class="line">vim authorized_keys</span><br><span class="line">粘贴保存</span><br><span class="line"></span><br><span class="line">查看当前用户，后面登录用</span><br><span class="line">whoami</span><br><span class="line"></span><br><span class="line"># PC 上配置端口转发</span><br><span class="line">（如果是远程的话配置一下 adb connect xxxxxx:xxx）</span><br><span class="line">➜  adb forward --list</span><br><span class="line">➜  adb forward --remove-all</span><br><span class="line">➜  adb forward tcp:8022 tcp:8022</span><br><span class="line">➜  ssh u0_a221@127.0.0.1 -p 8022</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Tips: 界面左滑，长按 <code>KEYBOARD</code> 可以出现辅助按钮， ESC、CTR、ALT 等。再次单按 <code>KEYBOARD</code> 可出现键盘。</p></blockquote><img src="/images/network/AndroidRoot/android_root.png">]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的文章 &lt;a href=&quot;https://kiosk007.top/2020/05/30/VMTrafficShark-%E8%87%AA%E5%88%B6%E5%BC%B1%E7%BD%91%E6%A8%A1%E6%8B%9F%E5%99%A8/&quot;&gt;VMTrafficShark 自制弱网模拟器&lt;/a&gt; 中介绍了如何搭建一个弱网模拟器，并且进行弱网模拟，中间人，劫持重放测试等等。对了这里一般的测试设备是Android手机，那么这篇文章介绍一下Android 手机应该如何支持自签名证书。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://kiosk007.top/categories/Linux/"/>
    
    
    <category term="Certificate" scheme="http://kiosk007.top/tags/Certificate/"/>
    
  </entry>
  
  <entry>
    <title>理解协程</title>
    <link href="http://kiosk007.top/2020/07/18/%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"/>
    <id>http://kiosk007.top/2020/07/18/%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-07-18T08:30:00.000Z</published>
    <updated>2020-07-18T08:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>协程</strong> 在如今在高并发场景下最容易提到的一个技术，协程即能暂停执行以在之后恢复的函数。。下面是关于 <a href="https://en.cppreference.com/w/cpp/language/coroutines">GCC11 编辑器</a> 对协程的介绍 （ A coroutine is a function that can suspend execution to be resumed later. Coroutines are stackless: they suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. ）</p><a id="more"></a><hr><p>试想以下场景，百万级别的高并发场景下，如何实现用户访问静态资源的Web服务，需要的工作如下</p><ol><li>通过网络调用远程服务来进行身份验证</li><li>检查Memcache中是否存在相关的资源 </li><li>将请求的资源从磁盘中读取数据放入 HTTP Body的 Buffer中 </li><li>再将访问记录插入到MySQL数据库中。</li></ol><p>那么都有哪些技术呢？</p><ul><li>多进程？进程是操作系统资源分配（内存，显卡，磁盘）的最小单位。多进程面临着 CPU 寄存器和程序计数器等上下文的切换。</li><li>多线程？线程是执行调度（即cpu调度）的最小单位（cpu看到的都是线程而不是进程）。计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位)　一个进程可以有一个或多个线程，线程之间共享进程的资源。</li></ul><p>如果使用阻塞API写同步代码将最简单，但是一个线程同一时间只能处理一个请求，也就是每新建一个链接就需要新创建一个线程去处理，而CPU在处理越来越多的请求时，会切换线程来服务其他的线程,这样的做法能满足我们高并发的需求吗？</p><img src="/images/coroutines/mutli_pthread.jpeg"><p>无论是多进程还是多线程都有以下问题。</p><ul><li><font color="red">资源消耗的问题</font>: 比如 64 位Linux为每个线程的栈分配了8MB 的内存，C库还预分配了６４MB的内存池，在同时存在数十万的连接情况下没有足够的内存开启如此之多的线程。</li><li><font color="red">上下文切换</font>：CPU资源消耗，<strong>当调度到阻塞的方法时，内核为了让CPU充分工作，也会切换到其他的线程执行</strong>　进程的切换会有很多寄存器，堆栈的切换，也会造成缓存命中率差，线程虽然切换会轻量一些，但还是会存在部分私有数据和寄存器数据的切换。一次的切换成本也会在几十纳秒到几微秒间。</li></ul><p>那么该怎样实现高并发？如果将本来应该由内核实现的请求切换工作，交给用户态的代码完成就能实现切换成本的降低，异步化改造依赖ＩＯ多路复用机制和非阻塞，然而写异步化代码很容易出错。异步化改造需要将阻塞的函数通过非阻塞的系统调用拆分成２个函数，第一个函数显式调用，第二个函数多路复用的调用。所以异步化改造程序是很复杂的。<br><img src="/images/coroutines/coroutine.jpeg"></p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程出现了，在异步化之上包了一层外衣，这就是异步框架。协程与异步编程的<strong>相似的地方</strong>在于他们都使用了非阻塞的系统调用与内核交互。把切换请求的实现放到了用户态。<strong>不同的地方</strong>在于协程把异步化中的两段函数封装成了一个阻塞的协程函数。这也是对用户友好的编程格式。函数在执行时，调用的协程无感知的放弃执行权，由协程框架切换到准备就绪的其他协程上。当这个函数满足执行条件时，协程框架再选择合适的时机，切换回它所在的协程执行。</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>协程不需要什么“回调函数”，它允许用户调用“阻塞的函数”，即用同步编程的方式去写业务逻辑。解决了异步化通过大量的回调函数来完成请求函数的切换的复杂编程方式。</p><img src="/images/coroutines/coroutine_stack.png">实际上，**用户态的代码协程切换和内核协程切换的原理是一样的**，内核通过管理CPU的寄存器来切换线程，而协程的切换是将内核的工作移到了协程框架实现而已，创建协程时，会从进程的堆中分配一段内存作为协程的栈。线程的栈有8MB，而协程的栈只有几十ＫＢ，并且Ｃ库的内存池也不会为协程预分配内存，因为它感知不到协程的存在。这样以来协程需要的内存空间就十分少了，几十万的并发也不需要很多的内存消耗<blockquote><p><strong>当然：栈缩小了，就尽量不要在协程中使用递归函数了</strong></p></blockquote><p>由此可见，协程就是用户态的线程。协程框架在用户空间做了线程切换等内核要做的事情。另外协程封装了所有阻塞的系统调用，例如<code>sleep()</code>函数会让当前的线程休眠，而线程一旦休眠，协程也就无法执行了。（协程是工作于线程之上的）。这就需要内核来唤醒sleep函数，协程化改造之后，<code>sleep()</code>函数只会让当前的协程休眠，由协程框架在指定时间后唤醒协程。</p><p><strong>所以协程的高性能就是建立在所有的切换由用户态代码实现，这就要求协程的生态是完整的，要覆盖所有组件。</strong>如果一个协程框架没有考虑到如<code>sleep()</code>函数的协程化改造，就会造成线程休眠，线程休眠就会造成在线程之上的协程也伴随着休眠。</p><h2 id="协程-线程"><a href="#协程-线程" class="headerlink" title="协程+线程"></a>协程+线程</h2><p>实际上面对当下服务器动辄几百核的多核CPU架构，线程也就需要和协程结合起来使用，因为协程的载体是线程。而CPU的执行对象是线程，线程在同一时刻只能拥有一颗CPU，那么好的设计是开启更多的线程，然后将协程分布在这些线程之上，这样就能充分的利用CPU资源。</p><p>除此之外，为了让协程获得更多的CPU时间，只要所在线程的优先级调高即可，甚至可以将CPU绑定到某个CPU上，增加协程执行时命中CPU的缓存几率。（要知道CPU的三级缓存SRAM是要比内存DRAM快很多的，如果多个线程频繁在不同的CPU切换来切换去就会造成缓存命中率低下，TLB根本起不到作用）</p><p>很多的协程库只提供了创建、挂起、恢复执行的基本方法，并没有协程框架的概念出现，这就需要业务在代码中自行实现调度协程。在协程的运行条件不满足需求时，多路复用框架会将它挂起，并根据优先级策略选择另一个协程执行。也就是不只是选择协程库，还需要结合IO多路复用的协程框架，这样就可以加快开发的速度。</p><p>比如OpenResty中的<code>cosocket</code>，<code>cosocket = coroutine + socket</code> ，<code>cosocket</code>利用lua的协程特性支持，又结合了Nginx事件机制。遇到网络I/O就会交出控制权（yield），把网络事件注册到Nginx的事件监听表中，并把权限重新交给Nginx，当有Nginx事件达到触发条件，会唤醒对应的协程继续处理（resume）</p><h2 id="golang协程"><a href="#golang协程" class="headerlink" title="golang协程"></a>golang协程</h2><p>Go在语言级别支持了协程（Goroutine）来实现高并发。作为程序员不必再考虑 像<code>Python</code> 那样引入一个异步协程库，利用其代码来实现异步协程化。</p><p>Goroutine天生对协程的完美支持，也让Goroutine传承了协程本身的优良特性。<br>Goroutine堆栈只有几十kb。如果某一线程之上的协程不幸发生阻塞，那么系统可以将其与协程移动到新的线程上执行，这一切不用程序员关心。多个协程之间通信的管道。信道可以防止多个协程访问共享内存时发生资源争抢的问题。(但是注意：多个goroutine 访问一个map时一定需要加锁！！)</p><p>在GO1.14之前golang的协程还是<code>非抢占式调度</code>.而在1.14之后，协程添加了一个重要的特性便是<code>抢占式调度</code>。</p><ul><li>非抢占式调度</li></ul><p>非抢占式的含义就是其他任务不会抢我的cpu，而是等待我主动让出去。别的goroutine才可以执行。而io等操作会主动让出去goroutine的执行权。如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">20</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i&lt; <span class="number">20</span>;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                a[i]++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.13 版本下的Go SDK 执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  go version</span><br><span class="line">go version go1.13.14 linux&#x2F;amd64</span><br><span class="line">➜  go run main.go</span><br></pre></td></tr></table></figure><img src="/images/coroutines/goroutine_NonPreemptive.png"><p>这个程序会卡住。因为main函数也是一个goroutine。而程序中对一个变量++ 是不会交出控制权的（io操作可以交出控制权，如fmt.println，一次IO系统调用等，或者手动交出控制权<code>runtime.Gosched()</code>），所以main也得不到运行了，可以看到这段程序死机了。可以看到，我是8核CPU，这个程序在执行时发生了死循环，占用CPU 738%(约等于800%)对应8个核。</p><ul><li>抢占式调度</li></ul><p><strong>Go1.14 引入了基于系统信号的抢占式调度</strong>, 在抢占式情况下，如果一个goroutine运行时间过长，它就会被剥夺运行权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ go version</span><br><span class="line">go version go1.14.5 linux/amd64</span><br><span class="line">➜ go run main.go </span><br><span class="line">[223473156 204013472 207617086 235368900 147990153 216776090 245417848 278086836 299956269 268087158]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次用1.14 的go sdk可以看到程序快速的输出了最终++的答案，抢占式下，一个goroutine不能一直占CPU不放。</p><blockquote><p>垃圾回收器是需要stop the world的。如果垃圾回收器想要运行了，那么它必须先通知其它的goroutine合作停下来，这会造成较长时间的等待时间。考虑一种很极端的情况，所有的goroutine都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。(非抢占式存在这种情况，而抢占式不存在)</p></blockquote><h3 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h3><p><strong>M，P，G</strong></p><p>Go 的调度器内部有三个十分重要的结构，M，P，G。(M&gt;P 如上个例子的 6 个M，4个P)</p><ul><li>M 表示真正的内核OS线程，和POSIX里的thread差不多，真正干活的人。</li><li>P 局部的调度器，使go代码在一个线程上跑，它是实现从N:1 （多个用户线程在一个内核线程上跑）到 N:M 映射的关键。</li><li>G 代表一个 goroutine，它有自己的栈，用于调度。</li></ul><img src="/images/coroutines/MPG.wepb"><p>上图表示有两个物理线程M，每个M都拥有一个context（P），每一个P上又拥有一个正在运行的G和很多等待运行的G。<br>P 的总数量可以通过 GOMAXPROCS() 设置。它表示真正的并发量，即有多少个goroutine可以同时运行。<br>上面等待的（灰色）goroutine处于ready的就绪态。而每个P都维护着一个队列（runqueue）</p><img src="/images/coroutines/MPG_block.webp"><p>当一个OS线程M0陷入阻塞时（如上图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。</p><p>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，<br>如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。</p><img src="/images/coroutines/MPG_banlance.webp"><p>某一个P所分配的任务G很快被执行完了（分配不均），这就导致一个context P 闲着，如果 global runqueue 上没有 G 了，那么它会偷其他P 的G。一般偷的话会偷一半。确保每个OS线程都能得到充分的使用。</p><blockquote><p>这段参考知乎 <a href="https://www.zhihu.com/question/20862617">Golang 的 goroutine 是如何实现的？</a> Yi Wang 的回答</p></blockquote><p>以刚才上面的代码为例。我是8核CPU，这里的线程却创建了10个线程，TID 为74261和74262 是空闲的。而实际跑的是8个线程，这对应了 20 个 G （goroutine）、10个M、8个P。<br>（如下图）<br><img src="/images/coroutines/goroutine_dispatch.png"></p><p>还有其他语言的异步协程库，比如python通过 syncio 包实现协程，而c++也有阿里大神多隆写的 libeasy 。但是都不如 go 的原生支持来的方便。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;协程&lt;/strong&gt; 在如今在高并发场景下最容易提到的一个技术，协程即能暂停执行以在之后恢复的函数。。下面是关于 &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/coroutines&quot;&gt;GCC11 编辑器&lt;/a&gt; 对协程的介绍 （ A coroutine is a function that can suspend execution to be resumed later. Coroutines are stackless: they suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. ）&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://kiosk007.top/categories/Linux/"/>
    
    
    <category term="golang" scheme="http://kiosk007.top/tags/golang/"/>
    
    <category term="协程" scheme="http://kiosk007.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>docker 容器技术基础</title>
    <link href="http://kiosk007.top/2020/07/11/docker-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://kiosk007.top/2020/07/11/docker-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-10T16:32:00.000Z</published>
    <updated>2020-07-10T16:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hijiangtao.github.io/2018/04/17/Docker-in-Action/">docker</a> 容器是随着PaaS技术的普及随之诞生的，Docker公司推出了docker并通过“容器镜像”解决了容器打包的根本性难题。而容器本身没有价值，有价值的是“容器编排技术”。Docker项目则通过容器技术解决了应用打包的根本性难题。</p><a id="more"></a><hr><p>为什么在开头就放出了 “容器本身没有价值” 的大话呢？</p><p>因为容器本身只是一个沙盒技术，其使用<strong>Cgroups</strong>和<strong>Namespace</strong>技术创建出来一个隔离环境，而docker项目之所以能得到如此之高的关注也是因为他解决了应用打包和发布这个困扰运维人员的多年的技术难题。能够把应用装到集装箱内方便搬来搬去才是PaaS的最理想状态。</p><p>Docker本身所用到的隔离技术也并不是什么黑科技，都是把已有的功能翻出来拼装了一下而已。<strong>容器的本质是一个“单进程”模型，本质是一个特殊的进程而已</strong></p><blockquote><p>Docker 容器技术由 Namespace、Cgroups、rootfs 三种技术构建出,其中Namespace、Cgroups 构建了容器的动态视图（称为 运行时），rootfs构建了容器的静态视图。</p></blockquote><h1 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h1><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p><strong>Namespace</strong>是Linux很早版本就实现的一个系统调用，他可以实现新创建一个进程的时候，为这个进程创建一个沙盒，比如让新的进程以为自己是1号PID进程，或者是让自己以为自己有一个新的网卡等等。</p><p>Linux创建新进程的时候有一个可选参数，加上 <strong>CLONE_NEWPID</strong> 就可以让创建的进程拥有一个全新的进程空间，在宿主机的真实进程空间，其PID还是那个PID，但是新进程自己认为自己是当前空间里的1号进程。他们无法看到真实的进程空间。也无法看到其他Namespace里的进程空间。</p><p><code>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</code></p><p>类似的参数还有</p><ul><li><code>CLONE_NEWNS</code>: 用于指定Mount Namespace (挂载点)</li><li><code>CLONE_NEWUTS</code>: 用于指定UTS Namespace (HOSTNAME和DOMAIN)</li><li><code>CLONE_NEWIPC</code>: 用于指定IPC Namespace (共享内存、信号量和消息队列)</li><li><code>CLONE_NEWPID</code>: 用于指定PID Namespace (进程号)</li><li><code>CLONE_NEWNET</code>: 用于指定Network Namespace （网络）</li><li><code>CLONE_NEWUSER</code>: 用于指定User Namespace  （用户）</li></ul><p>用户可以在**/proc/$pid/ns**文件下看到本进程所属的Namespace的文件信息。</p><p>比如使用 <code>docker run -it busybox /bin/sh</code> 启动一个容器，然后在另外一个终端看到</p><img src="/images/docker/docker_namespace.png"><p>同样，Linux也提供了其他系统调用，可以让其他进程加入到一个Namespace中，<code>int setns(int fd, int nstype);</code>，这也为之后的联盟式容器创造了可能。即多个进程使用相同的Namespace。系统调用<code>int unshare(int flags);</code>也为相同Namespace分家提供了技术支持。</p><p>所以，Docker容器这个听起来高端大气的概念，只不过是在创建容器进程时，指定了这个进程一组Namespace参数而已。</p><p>比如我们启动了一个容器。可以使用 <code>docker exec -it xxxxx /bin/bash</code> 进入到这个容器中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 25 </span><br><span class="line">83488</span><br><span class="line"></span><br><span class="line">➜  sudo ls -l /proc/`docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 25`/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 ipc -&gt; <span class="string">&#x27;ipc:[4026532521]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 mnt -&gt; <span class="string">&#x27;mnt:[4026532519]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:14 net -&gt; <span class="string">&#x27;net:[4026532586]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 pid -&gt; <span class="string">&#x27;pid:[4026532522]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 pid_for_children -&gt; <span class="string">&#x27;pid:[4026532522]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:35 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  24 14:28 uts -&gt; <span class="string">&#x27;uts:[4026532520]&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个进程的所有Linux Namespace，都在/proc/[pid 进程号]/ns 下有一个虚拟文件，并且链接到真实的Namespace上。这样其他进程就可以加入一个已经存在的Namespace中。这也为了之后的pod（联盟式容器）打下基础。如 <code>docker run -it  -net container:25836f0da751  busybox ifconfig</code>。这就是起一个容器，但是network namespace 用和 258xx 这个容器用一个。</p><p><strong>Namespace的问题</strong></p><p>既然容器技术只是一个特殊的进程被隔离而已，那么其缺点就很明显了，那就是容器的<strong>“隔离不彻底”</strong>。</p><p><font color="red">第一，容器既然是运行在宿主机上的一种特殊进程，那么多个进程还是共享同一个操作系统的内核（注意这里是Linux 内核 ，Mac和Windows上的容器首先是运行在Docker Machine上的，说白了运行在Linux虚拟机上）</font></p><p><font color="red">第二，容器并不是所有资源都可以Namespace化的，典型的不能被Namespace的例子就是：时间</font></p><p><font color="red">第三，由于避免不了多个容器共享宿主机内核的事实，那么就意味着容器的越狱比虚拟机简单的多了，一些危险的系统调用需要被监管加固</font></p><p>正是上述的问题，Docker的安全性会很差，一般不会直接把Docker暴露在公网上。</p><p>Refer:</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/73248894">浅谈Linux Namesapce机制 (知乎)</a></p></blockquote><h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>上面提到容器只是一个特殊的进程而已，那么这个容器进程和宿主机上其他的普通进程是平等的。如果容器进程可以占用宿主机全部资源的话，这显然不符合沙盒技术的特征。<strong>而Cgroups则正是 Linux 内核中用来限制资源的功能。</strong> </p><p>Cgroups 的本质是给进程挂上钩子 (hooks) ,当Task的运行涉及到某个资源的时就触发钩子上所携带的subsystem检测。最终进行资源限制和优先级分配。</p><img src="/images/docker/docker-cgroups.jpg"><p><strong>Cgroups全称是 Linux Control Group, 他最主要的作用就是限制一个进程组能够使用的资源上限，包括CPU，内存，磁盘，网络带宽等</strong></p><p>Cgroups 给用户直接暴露出来的操作接口是文件系统，即以文件和目录的方式组织在操作系统的 <code>/sys/fs/cgroups</code> 路径下，在这个路径下有很多诸如 <code>cpuset</code>、<code>cpu</code>、<code>memory</code> 这样的子目录。这些就是当前操作系统下可以被限制的资源类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怎么样去限制一个进程的资源呢？需要在这些目录之下再创建一个目录，如进入 <code>/sys/fs/cgroup/cpu</code> 目录下。创建目录 container 。这样一个目录，操作系统会自动在这个目录下生成子系统对应的资源限制文件。<br><img src="/images/docker/cgroups.png"></p><p>这下，我们创建一个死循环，将CPU吃满，记录该进程的PID。向 container 组里的 cfs_quota 文件写入 2ms，这意味着每 100ms 内的单位时间内，被该控制组限制的进程只能使用2ms的CPU时间，即只能用到2%的计算力。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># echo 2000 &gt; cpu.cfs_quota_us </span></span><br><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># echo 4918 &gt; tasks </span></span><br><span class="line">root@XPS-13:/sys/fs/cgroup/cpu/container<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开htop指令可以看到刚才的死循环只有2%的CPU占用。</p><blockquote><p>实验完成后可以使用  <code>cgdelete -r cpu:container</code> 删除</p></blockquote><p>这样就可以理解 Linux Cgroups 的设计，其限制进程的方式也是简单粗暴，为一个子目录系统上添加一组资源限制文件的组合即可。在docker容器中，也可以直接通过命令来查看。</p><p><code>docker run -it --cpu-period=100000 --cpu-quota=20000 busybox /bin/sh</code></p><img src="/images/docker/cgroups_docker.png"><p><strong>Cgroups 的问题</strong><br>容器的Cgroups只是限制了某个进程的使用资源而已，而进程本身看到的资源还是宿主机的资源。</p><p><font color="red"> /proc 文件系统并不知道 Cgroups 给某个进程做了什么限制。这就会造成在容器中使用 top,free,df 等命令看到的全部是宿主机上的资源。这会给应用的运行带来非常大的困惑。<br></font></p><p>不过在生产环境，已经有 <strong><code>lxcfs</code></strong> 这样的技术可以修正这种偏差。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ apt install -y lxcfs</span><br><span class="line">$ systemctl start lxcfs</span><br><span class="line">$ docker run -it -m 500m  \</span><br><span class="line">      -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/<span class="built_in">stat</span>:/proc/<span class="built_in">stat</span>:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/swaps:/proc/swaps:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw \</span><br><span class="line">      ubuntu:19.04 /bin/bash</span><br></pre></td></tr></table></figure><p>其原理是把宿主机上的 <code>/var/lib/lxcfs/proc/meminfo</code> 文件挂载到容器的 <code>/proc/meminfo</code> 位置。</p><p>refer:<br><a href="https://cuisongliu.github.io/2019/03/docker/lxcfs/">https://cuisongliu.github.io/2019/03/docker/lxcfs/</a></p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Namespace 和 Cgroups 使这个特殊的进程看到的是隔离环境，而且使用的资源也被限制。那么这样还有一个点，就是进程看到的文件系统是什么呢？这里没有新的技术，还是最开始提到的Mount Namespace技术，拥有这项技术，可以给容器挂载一个全新、独立的文件系统。</p><p>挂载完成之后使用 <code>chroot</code> 指令, 使得新的挂载点成为进程的 <code>/</code> 路径。一般为了让这个容器的根目录更为真实，一般会给进程容器的根目录下挂载一个完整操作系统的文件系统。比如 Ubuntu19.04 的ISO。<strong>而这个挂载在容器根目录上的、用来给容器进程提供隔离后执行环境的文件系统就是 rootfs（根文件系统）</strong></p><p><font color="red">这里我再来强调一遍，容器是一个特殊的进程而已！！！rootfs只是操作系统所包含的文件、配置和目录，并不包含内核，内核是宿主机的内核。所以说 rootfs只是操作系统的驱壳，并没有操作系统的灵魂<br></font></p><p>不过正是rootfs的存在，才有了容器作为PaaS的基础，一致性！开发的程序连同操作系统的整个目录环境被打包封装在一个集装箱里。真正的依赖库都放在了这个rootfs的<code>/var/lib/xxx</code> 里。</p><p>还没完，虽然这个时候已经解决了大部分问题，但是每个容器创建的时候都需要一个rootfs未免也太浪费空间了，Docker的解决方法是提出 <code>layer</code> 的概念。用户每制造出来一个镜像就生成一个层。</p><p>Linux操作系统又提供了一种联合文件系统（Union File System）的能力。<br>UFS 提供的能力是将多个目录挂载到同一个目录下，使得多个目录合并。</p><p>假设有两个目录<code>A</code>和<code>B</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│   ├── a</span><br><span class="line">│   └── x</span><br><span class="line">└── B</span><br><span class="line">    ├── b</span><br><span class="line">    └── x</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建目录<code>C</code>,并且将两个目录挂载到一个公共的目录<code>C</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir C</span><br><span class="line">$ mount -t aufs -o dirs&#x3D;.&#x2F;A:.&#x2F;B none .&#x2F;C</span><br><span class="line">$ tree C</span><br><span class="line">C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以Docker容器为例,这个挂载点就是在 <code>/var/lib/docker/overlay2</code> 下。不出意外，这个下面拥有一个完整的ubuntu操作系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2# ll 6f56172222645f34f4454ecdbfd592785245dc7b68511dc49723e0591aba54a8&#x2F;diff&#x2F;</span><br><span class="line">总用量 48</span><br><span class="line">drwxr-xr-x 10 root   root     4096 7月  11 01:04 .&#x2F;</span><br><span class="line">drwx------  3 root   root     4096 7月  11 01:04 ..&#x2F;</span><br><span class="line">drwxr-xr-x  2 root   root    12288 6月  27 08:21 bin&#x2F;</span><br><span class="line">drwxr-xr-x  2 root   root     4096 6月  27 08:21 dev&#x2F;</span><br><span class="line">drwxr-xr-x  3 root   root     4096 6月  27 08:21 etc&#x2F;</span><br><span class="line">drwxr-xr-x  2 nobody nogroup  4096 6月  27 08:21 home&#x2F;</span><br><span class="line">drwx------  2 root   root     4096 6月  27 08:21 root&#x2F;</span><br><span class="line">drwxrwxrwt  2 root   root     4096 6月  27 08:21 tmp&#x2F;</span><br><span class="line">drwxr-xr-x  3 root   root     4096 6月  27 08:21 usr&#x2F;</span><br><span class="line">drwxr-xr-x  4 root   root     4096 6月  27 08:21 var&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时也可以看到，对应的操作系统挂载信息里面的overlay信息。可以看到最终多个目录被联合挂载到<code>/var/lib/docker/overlay2/3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1/merged</code> 上，而这个merged会最终呈现一个文件系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;mounts |grep overlay2</span><br><span class="line">overlay &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;merged overlay rw,relatime,lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;N2BLQFHN3PRM3P4BR6LYEALQN5:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FYVKPJJ3TF7THIM4Z4J2OAQTZN:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;GPBK6EICFMAEBZR5IBE6XTWPSO:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FLBZS3ORDOYOD2ECQTRUMHAUBV:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;JAFCRW5O4V3HB7PWVABFY3SLRK,upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;diff,workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;3734ddb66fee5ad2339503f830d7d073f8179c98ccd74d3ce11077d7605f5ba1&#x2F;work,xino&#x3D;off 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/images/docker/aufs_image.png"><p>最下面的几层只读。上层的可写。而最上层是可读写。</p><blockquote><p>所以在运行容器的时候，只需要拉取不存在的 image layer。镜像一般完全拉下来的化需要3，4百M，一般的大厂都是采用 p2p 下载镜像，如 <a href="https://developer.aliyun.com/article/244897">阿里的蜻蜓 p2p 下载</a>。</p></blockquote><h1 id="制作Docker镜像"><a href="#制作Docker镜像" class="headerlink" title="制作Docker镜像"></a>制作Docker镜像</h1><p>使用 golang 编写一个web应用。准备一个main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">        log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q \n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>制作Dockerfile 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.12-alpine</span><br><span class="line"></span><br><span class="line"># Set ENV</span><br><span class="line">ENV GO111MODULE&#x3D;on \</span><br><span class="line">    CGO_ENABLED&#x3D;0 \</span><br><span class="line">    GOOS&#x3D;linux \</span><br><span class="line">    GOARCH&#x3D;amd64</span><br><span class="line"></span><br><span class="line"># Set the Current Working Directory inside the container</span><br><span class="line">WORKDIR $GOPATH&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Copy all file to &#x2F;app</span><br><span class="line">ADD . $GOPATH&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Build the Go app</span><br><span class="line">RUN go build main.go</span><br><span class="line"></span><br><span class="line"># This container exposes port 8000 to the outside world</span><br><span class="line">EXPOSE 8000</span><br><span class="line"></span><br><span class="line"># Run the binary program produced by &#96;.&#x2F;main&#96;</span><br><span class="line">ENTRYPOINT [&quot;.&#x2F;main&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>制作镜像在当前目录执行<code>docker build -t hello .</code><br>run 起来该容器<code>docker run -p 8000:8000 hello</code></p><h2 id="上传到-docker-hub"><a href="#上传到-docker-hub" class="headerlink" title="上传到 docker hub"></a>上传到 docker hub</h2><p>在docker hub 上创建一个 docker 账号<br><br>使用 <code>docker login</code> 登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为容器起一个完整的名字。</span></span><br><span class="line">docker tag helloworld your-docker-id/helloworld:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传到docker hub 上</span></span><br><span class="line">docker push your-docker-id/helloworld:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器中新建文件</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 29038er849jsa /bin/sh</span><br><span class="line">touch tmp.file</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新建的内容提交</span></span><br><span class="line">docker commit 29038er849jsa your-docker-id/helloworld:v2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://hijiangtao.github.io/2018/04/17/Docker-in-Action/&quot;&gt;docker&lt;/a&gt; 容器是随着PaaS技术的普及随之诞生的，Docker公司推出了docker并通过“容器镜像”解决了容器打包的根本性难题。而容器本身没有价值，有价值的是“容器编排技术”。Docker项目则通过容器技术解决了应用打包的根本性难题。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://kiosk007.top/categories/docker/"/>
    
    
    <category term="devops" scheme="http://kiosk007.top/tags/devops/"/>
    
    <category term="docker" scheme="http://kiosk007.top/tags/docker/"/>
    
    <category term="k8s" scheme="http://kiosk007.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Github 搜索</title>
    <link href="http://kiosk007.top/2020/06/13/Git-%E6%90%9C%E7%B4%A2%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://kiosk007.top/2020/06/13/Git-%E6%90%9C%E7%B4%A2%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-06-13T02:10:00.000Z</published>
    <updated>2020-06-13T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本着绝不重复造论子的理念（其实就是想抄袭），需要在github上这个平台搜索自己感兴趣的项目。但是在平常使用中，其实经常没有搜索到自己真正想要的git项目。</p><a id="more"></a><hr><h1 id="github的核心功能"><a href="#github的核心功能" class="headerlink" title="github的核心功能"></a>github的核心功能</h1><ul><li><strong>features</strong><img src="/images/git/github_feature.png"></li></ul><p>github 的核心功能可以查看 <a href="https://github.com/features">features</a> ，github的核心功能主要分为7大类 <code>持续继承/持续交付(CI/CD)</code>、<code>安全部署（Secure development）</code>、<code>代码检查（Code review）</code>、<code>Git应用（Apps）</code>、<code>代码托管 (Hosting)</code>、<code>项目管理 （Project managment）</code>、<code>团队管理（Team managment）</code></p><ul><li><strong>developer</strong><img src="/images/git/github_develop.png"></li></ul><p>github 的API可以查看 <a href="https://developer.github.com/">api</a> , 比如可以获取github上的自己的repo列表、OAuth2 token 认证、自动推送修改repo中文件等。</p><p>refer: <a href="https://segmentfault.com/a/1190000015144126">https://segmentfault.com/a/1190000015144126</a></p><h1 id="搜索git项目"><a href="#搜索git项目" class="headerlink" title="搜索git项目"></a>搜索git项目</h1><p>搜索项目可以在 Market Place 中找到一些火热的项目、工具等</p><ul><li><strong>Market Place</strong></li></ul><img src="/images/git/github_marketplace.png"><p>地址：<a href="https://github.com/marketplace/">https://github.com/marketplace/</a></p><p>里面有诸如监控、持续继承、devops的项目，大部分是免费的，可以免费安装使用。<br>如：</p><ul><li><a href="https://github.com/marketplace/sentry">Sentry</a> ：提供客户端APP实时的崩溃报告的平台。</li><li><a href="https://github.com/marketplace/jira-software-github">Jira Software + GitHub</a> ：将代码项目和项目管理平台Jira连接起来的平台。</li><li><a href="https://github.com/marketplace/gitpod-io">gitpod.io</a> : Github在线IDE gitpod.io</li></ul><p><strong>搜索技巧</strong></p><p>点击github左上角的搜索框，输入<code>Enter键</code>，弹出github搜索页，点击<code>advance search</code> 高级搜索。</p><img src="/images/git/advance_search.png"><p>高级搜索中可以按编程语言搜索，按repo时间搜索等等。</p><img src="/images/git/search_date.png"><p>默认直接在左上角的输入，只是搜索整个github所有repo的标题和描述。而我们其实要找的内容一般在readme中。</p><ul><li>搜索readme</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp 欺骗 in:readme</span><br></pre></td></tr></table></figure><img src="/images/git/search_readme.png"><ul><li>搜索star大于100</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp 欺骗 in:readme stars:&gt;100</span><br></pre></td></tr></table></figure><ul><li>搜索go语言</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp 欺骗 in:readme stars:&gt;10 language:Go</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本着绝不重复造论子的理念（其实就是想抄袭），需要在github上这个平台搜索自己感兴趣的项目。但是在平常使用中，其实经常没有搜索到自己真正想要的git项目。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://kiosk007.top/categories/git/"/>
    
    
    <category term="git" scheme="http://kiosk007.top/tags/git/"/>
    
    <category term="devops" scheme="http://kiosk007.top/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>性能大杀器epoll</title>
    <link href="http://kiosk007.top/2020/06/01/%E6%80%A7%E8%83%BD%E5%A4%A7%E6%9D%80%E5%99%A8epoll/"/>
    <id>http://kiosk007.top/2020/06/01/%E6%80%A7%E8%83%BD%E5%A4%A7%E6%9D%80%E5%99%A8epoll/</id>
    <published>2020-06-01T15:58:00.000Z</published>
    <updated>2020-06-01T15:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.kegel.com/c10k.html">C10K</a> 单机同时处理 1万个请求（并发连接 1 万）的问题，最早由 Dan Kegel 在 1999 年提出。那时的服务器还只是 32 位系统，运行着 Linux 2.2 版本（后来又升级到了 2.4 和 2.6，而 2.6 才支持 x86_64），只配置了很少的内存（2GB）和千兆网卡。在这样的系统能实现C10K问题吗？</p><p>这在当年看似十分难以实现的问题，在当下epoll这个性能大杀器实现了我们单机并发10K的梦想。</p><a id="more"></a><hr><img src="/images/network/epoll/c10k.jpg" style="height:300px;border-radius: 20px;"><h1 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h1><p>怎么实现单机并发 1W 条连接呢？我们先来算一笔账，对于一台 <code>通用型g6</code> (2核 8G 25 Gbit/s) 的 <a href="https://www.aliyun.com/product/ecs/">ECS</a> 来说。假设每条连接分配100KB内存，100Kbit带宽。1w 条连接也完全满足需求 1G内存，1000Mbit。硬件满足需求，那么看软件。</p><ul><li>每一条连接创建一个线程吗？</li></ul><p>64 位的 Linux 为每个线程的栈分配了 8MB 的内存，还预分配了 64MB 的内存作为堆内存池。单个线程的创建消耗过高，所以我们没有足够的内存创建上万级别的线程。</p><p>其次请求的切换，是Linux在内核中切换线程实现的。时间片用尽、调用阻塞方法都会导致线程切换，一次上下文的耗时在几十纳秒，但是短时间上万次的切换，会导致CPU大量的时间都浪费在切换线程上。</p><p>总上所述，每条连接创建一个线程是不合理的。（同理创建进程就更不合理了）</p><h1 id="I-O-模型优化"><a href="#I-O-模型优化" class="headerlink" title="I/O 模型优化"></a>I/O 模型优化</h1><p>这里就需要用到 多路复用/非阻塞 的IO框架模型了，那么什么是多路/非阻塞。<br>通俗来讲就是就是将很多的IO事件都收集起来统一管理，这样一个线程就可以做到分别运行不同的IO事件，哪个准备好了运行哪个。没有准备好的就先放在一边。</p><blockquote><p>IO 事件的类型非常多，比如：<br>1、标准输入文件描述符可读。2、标准输出文件描述符可写。3、新的连接建立成功。4、一个IO事件等待超过了10秒</p></blockquote><h2 id="IO-事件是如何产生的"><a href="#IO-事件是如何产生的" class="headerlink" title="IO 事件是如何产生的"></a>IO 事件是如何产生的</h2><p>简单的说，事件只有两种即读事件和写事件。<code>读事件</code>表示IO有消息到达需要处理，<code>写事件</code> 表示IO可以发送数据了（TCP的写缓冲区可写数据）。</p><p>在网络的视角，从三次握手开始。客户端发出SYN，服务端回复SYN+ACK。完成握手后，客户端即产生了<strong>写事件</strong>。如果缓冲区太小假设只有1M，而我们要发送的数据时2M，那么会先写入1M后，等待缓冲区空闲后，再次产生写事件。</p><p>同样四次挥手，当主动关闭方发送一个FIN，被动关闭方就会产生一个读事件。</p><blockquote><p>目前磁盘的异步IO技术还不成熟，它绕过了 PageCache 性能损失很大。所以当下的事件驱动，主要就是指网络事件。</p></blockquote><h2 id="IO-类型"><a href="#IO-类型" class="headerlink" title="IO 类型"></a>IO 类型</h2><h3 id="事件如何通知"><a href="#事件如何通知" class="headerlink" title="事件如何通知"></a>事件如何通知</h3><p>目前有两种 IO事件的通知方式<strong>水平触发</strong>和<strong>边缘触发</strong></p><ul><li><code>水平触发</code>：只要文件描述符可以非阻塞的执行IO，就会触发通知，也就是应用程序可以随时随地的检查文件描述符的状态，并根据其状态产生相应的动作。</li><li><code>边缘触发</code>：只有文件描述符的状态发生改变时，才发出一个通知，这时候应用程序需要尽可能多的执行IO操作，直到无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了。</li></ul><h3 id="IO-调用方式分哪几类"><a href="#IO-调用方式分哪几类" class="headerlink" title="IO 调用方式分哪几类"></a>IO 调用方式分哪几类</h3><ul><li><p><code>非阻塞</code>: 当应用程序调用阻塞 I/O 完成某个操作时，应用程序会被挂起，等待内核完成操作</p></li><li><p><code>阻塞</code>: 当应用程序调用非阻塞 I/O 完成某个操作时，内核立即返回，不会把 CPU 时间切换给其他进程，应用程序在返回后，可以得到足够的 CPU 时间继续完成其他事情。</p></li></ul><hr><h2 id="非阻塞IO-水平触发"><a href="#非阻塞IO-水平触发" class="headerlink" title="非阻塞IO+水平触发"></a>非阻塞IO+水平触发</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="select-用法"><a href="#select-用法" class="headerlink" title="select 用法"></a>select 用法</h4><ul><li>声明select函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">返回：若有就绪描述符则为其数目，若超时则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>maxfd 表示的是待测试的描述符基数，它的值是待测试的最大描述符加 1。</p><ul><li>设置描述字符集合</li></ul><p>分别是<code>读描述符集合</code> readset、<code>写描述符集合</code>writeset 和 <code>异常描述符集合 </code>exceptset，这三个分别通知内核，在哪些描述符上检测数据可以读，可以写和有异常发生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;　　#FD_ZERO 用来将这个向量的所有元素都设置成 <span class="number">0</span>；　　　　</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;　#FD_SET 用来把对应套接字 fd 的元素，a[fd]设置成 <span class="number">1</span>；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;　#FD_CLR 用来把对应套接字 fd 的元素，a[fd]设置成 <span class="number">0</span>；　　</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; #FD_ISSET 对这个向量进行检测，判断出对应套接字的元素 a[fd]是 <span class="number">0</span> 还是 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><blockquote><p>其中 0 代表不需要处理，1 代表需要处理。</p></blockquote><p>最后一个参数是 timeval 结构体时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span>   tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">long</span>   tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>超时事件，如果全是0，则立马返回不等待（基本没有这么用的）、非0值等待一段时间后返回，可以用作超时、NULL一直监听等待有返回。</p><ul><li>select 程序例子</li></ul><p>refer：<a href="https://github.com/froghui/yolanda/blob/master/chap-22/nonblockingserver.c">https://github.com/froghui/yolanda/blob/master/chap-22/nonblockingserver.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (select(maxfd + <span class="number">1</span>, &amp;readset, &amp;writeset, &amp;exset, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">&quot;select error&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 处理监听套接字事件</span></span><br><span class="line">   <span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;readset)) &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 处理已建立好连接上的套接字事件</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxfd + <span class="number">1</span>; ++i) &#123;      </span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">0</span>;            </span><br><span class="line">       <span class="keyword">if</span> (i == listen_fd)                </span><br><span class="line">           <span class="keyword">continue</span>;            </span><br><span class="line">       <span class="keyword">if</span> (FD_ISSET(i, &amp;readset)) &#123;</span><br><span class="line">           r = onSocketRead(i, buffer[i]);</span><br><span class="line">       &#125;       </span><br><span class="line">       <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; FD_ISSET(i, &amp;writeset)) &#123;                </span><br><span class="line">           r = onSocketWrite(i, buffer[i]);</span><br><span class="line">       &#125;            </span><br><span class="line">       <span class="keyword">if</span> (r) &#123;                </span><br><span class="line">           buffer[i]-&gt;connect_fd = <span class="number">0</span>; </span><br><span class="line">           close(i);            </span><br><span class="line">           &#125;        </span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="select-缺点"><a href="#select-缺点" class="headerlink" title="select 缺点"></a>select 缺点</h4><p>1、在 Linux 系统中，select 所支持的文件描述符的个数是有限的，默认最大值为 1024。（当然就不能做到 c10K 了）<br>2、应用程序每次调用 select 时，还需要把文件描述符的集合，从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p><font color="#A52A2A"> c10K 还好一点，当c10M时，并发1 千万连接。若每个 socket 是 4 字节，那么 1 千万连接就是 40M 字节。这样，每收集一次事件，就需要从用户态复制 40M 字节到内核态。而且，高性能 Server 必须及时地处理网络事件，所以每隔几十毫秒就要收集一次事件，性能消耗巨大。</font></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><h4 id="poll用法"><a href="#poll用法" class="headerlink" title="poll用法"></a>poll用法</h4><ul><li>声明poll函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>; </span><br><span class="line">　　　</span><br><span class="line">返回值：若有就绪描述符则为其数目，若超时则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>和select不同，poll每次检查完，不会修改之前的传入值，这样就不需要每次检查完毕还需要重置带检测的套结字。poll 还有一个相比select的好处，对请求出错有更友好的检测。</p><ul><li>poll 服务端程序例子</li></ul><p>refer： <a href="https://github.com/froghui/yolanda/blob/master/chap-21/pollserver.c">https://github.com/froghui/yolanda/blob/master/chap-21/pollserver.c</a></p><h4 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h4><p>还是同select一样，需要将用户空间的套结字复制到内核态。消耗内存资源。</p><hr><h2 id="非阻塞IO-边缘触发"><a href="#非阻塞IO-边缘触发" class="headerlink" title="非阻塞IO + 边缘触发"></a>非阻塞IO + 边缘触发</h2><img src="/images/network/epoll/libevent-benchmark2.jpg" style="height:600px;"><p>首先看看上面的图，随着文件描述符的增多，poll和select的性能越来越差，而epoll和kqueue却几乎没有什么变化。为什么呢？</p><p>解答上面的疑问之前需要知道 五中最常见的 IO 模型。<code>阻塞IO （blocking I/O）</code>、<code>非阻塞IO （nonblocking I/O）</code>、<code>IO多路复用 （I/O multiplexing ）</code>、<code>事件驱动IO （signal driven I/O (SIGIO)）</code> 、<code>异步IO (asynchronous I/O (the POSIX aio_functions))</code> 。具体的网上的例子太多了，图也太多了，这里就不再赘述了。可以参考下这篇文章。<a href="https://cloud.tencent.com/developer/article/1373483">各种IO复用模式之select，poll，epoll，kqueue，iocp分析</a></p><p>这5种IO模型如下图，越靠右，性能越强。当然还有更厉害的性能大杀器 AIO (比epoll 更强)，这个之后再介绍。很可惜，真正强大的AIO 是 windows 的IOCP（windows服务器有人用吗？你懂得）。而Linux aio 系列函数是由 POSIX 定义的异步操作接口，可惜的是，Linux 下的 aio 操作，不是真正的操作系统级别支持的，它只是由 GNU libc 库函数在用户空间借由 pthread 方式实现的，而且仅仅针对磁盘类 I/O，套接字 I/O 不支持。自出现就备受社区诟病。但是Linux作为最常用的应用服务器，epoll也就是Linux下最常见的性能杀器。</p><img src="/images/network/epoll/io.png" style="height:400px;"><blockquote><p><code>noblocking</code> + <code>I/O mutiplexing</code>（IO多路复用+非阻塞IO） 就是kqueue、epoll、select、poll的实现。 不过epoll 和 kqueue 比 select 和poll 强大的多。</p></blockquote><p><strong>Q：为什么 epoll、kqueue 比 select、poll</strong></p><p><strong>A:</strong>  因为epoll他们无轮询。他们用callback取代了。想想看，当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数或者直接告诉应用层具体哪些套接字处于活跃状态了，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>使用 epoll 进行网络程序的编写，需要三个步骤，分别是 epoll_create，epoll_ctl 和 epoll_wait。</p><img src="/images/network/epoll/epoll_API.png" style="height:400px;"><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">        返回值: 若成功返回一个大于<span class="number">0</span>的值，表示epoll实例；若返回<span class="number">-1</span>表示出错</span><br></pre></td></tr></table></figure><p>关于这个参数 size，在一开始的 epoll_create 实现中，是用来告知内核期望监控的文件描述字大小，然后内核使用这部分的信息来初始化内核数据结构，在新的实现中，这个参数不再被需要，因为内核可以动态分配需要的内核数据结构。每次将 size 设置成一个大于 0 的整数就可以了。</p><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">       返回值: 若成功返回<span class="number">0</span>；若返回<span class="number">-1</span>表示出错</span><br></pre></td></tr></table></figure><p>参数</p><ul><li>epfd：epoll_create 返回的句柄</li><li>op: 添加、删除、修改文件描述符。</li><li>fd: 注册事件的文件描述符</li><li>epoll_event: 注册的事件类型</li></ul><p>epoll_event:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">     <span class="keyword">void</span>        *ptr;</span><br><span class="line">     <span class="keyword">int</span>          fd;</span><br><span class="line">     <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">     <span class="keyword">uint64_t</span>     u64;</span><br><span class="line"> &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><ul><li>EPOLLIN：表示对应的文件描述字可以读；</li><li>EPOLLOUT：表示对应的文件描述字可以写；</li><li>EPOLLRDHUP：表示套接字的一端已经关闭，或者半关闭；</li><li>EPOLLHUP：表示对应的文件描述字被挂起；</li><li>EPOLLET：设置为 edge-triggered，默认为 level-triggered。</li></ul><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">  返回值: 成功返回的是一个大于<span class="number">0</span>的数，表示事件的个数；返回<span class="number">0</span>表示的是超时时间到；若出错返回<span class="number">-1.</span></span><br></pre></td></tr></table></figure><p>调用者进程被挂起，等待内核的IO事件分发</p><p>参数：</p><ul><li>epfd：epoll句柄</li><li>epoll_event: 返回用户空间需要处理的epoll事件列表，是个数组。</li><li>maxevents: 返回的最大事件值</li><li>timeout：超时时间</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listen_fd, socket_fd;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> efd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line"></span><br><span class="line">    listen_fd = tcp_nonblocking_server_listen(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll create failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 注册event事件，事件可读，边缘触发 */</span></span><br><span class="line">    event.data.fd = listen_fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="comment">/* 添加事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(efd, EPOLL_CTL_ADD, listen_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll_ctl add listen fd failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer where events are returned */</span></span><br><span class="line">    events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait wakeup\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) ||</span><br><span class="line">                (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">                (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                close(events[i].data.fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理监听套接字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (listen_fd == events[i].data.fd) &#123;</span><br><span class="line">                struct sockaddr_storage ss;</span><br><span class="line">                <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">                <span class="keyword">int</span> fd = accept(listen_fd, (struct sockaddr *) &amp;ss, &amp;slen);</span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    make_nonblocking(fd);</span><br><span class="line">                    event.data.fd = fd;</span><br><span class="line">                    event.events = EPOLLIN | EPOLLET; <span class="comment">//edge-triggered</span></span><br><span class="line">                    <span class="keyword">if</span> (epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                        error(<span class="number">1</span>, errno, <span class="string">&quot;epoll_ctl add connection fd failed&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                socket_fd = events[i].data.fd;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get event on socket fd == %d \n&quot;</span>, socket_fd);</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">                    <span class="comment">// 处理读事件</span></span><br><span class="line">                    <span class="keyword">if</span> ((n = read(socket_fd, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>) &#123;                      </span><br><span class="line">                        <span class="comment">// 读出错，关闭套接字</span></span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                            error(<span class="number">1</span>, errno, <span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                            close(socket_fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                        close(socket_fd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                            buf[i] = rot13_char(buf[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                     </span><br><span class="line">                        <span class="keyword">if</span> (write(socket_fd, buf, n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            error(<span class="number">1</span>, errno, <span class="string">&quot;write error&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    close(listen_fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里会把每个套结字处理为非阻塞模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll ，非阻塞IO + IO多路复用 + 边缘触发，造就了C10K，C100K 的问题解决。</p><h1 id="工作模型调整"><a href="#工作模型调整" class="headerlink" title="工作模型调整"></a>工作模型调整</h1><p>以Nginx为例，Nginx是典型的1个主Master进程 + 多个Worker进程。</p><ul><li>主进程执行 bind() 和 listen() 后，创建多个子进程。</li><li>每个子进程中通过都通过 accept() 或 epoll_wait() ，来处理相同的套接字。</li></ul><img src="/images/network/epoll/Nginx.png" style="height:600px;"><p>而这里面就需要用到epoll来作 IO 分法器。从而设计出基于套接字的事件驱动程序。</p><p>这样的模型被称为主从模型（master-worker） 或 反应堆模型（reactor），这样的技术核心思想有2点。<br>1、存在一个无限循环的事件分发线程或进程（Nginx是进程）。而事件分发的背后正是epoll这样的IO分发技术。</p><p>2、所有的IO操作可以抽象为事件，每个事件都有一个回调函数来处理。worker 进程上有已建立好的套接字、可读、可写的套接字。这一个个都是事件，通过事件分发并调用相应的回调函数被触发。</p><p>代码参考：<a href="https://github.com/froghui/yolanda/blob/master/chap-29/epoll-server-multithreads.c">https://github.com/froghui/yolanda/blob/master/chap-29/epoll-server-multithreads.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接建立之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onConnectionCompleted</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection completed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据读到buffer之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onMessage</span><span class="params">(struct buffer *input, struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get message from tcp connection %s\n&quot;</span>, tcpConnection-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, input-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">output</span> =</span> buffer_new();</span><br><span class="line">    <span class="keyword">int</span> size = buffer_readable_size(input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        buffer_append_char(output, rot13_char(buffer_read_char(input)));</span><br><span class="line">    &#125;</span><br><span class="line">    tcp_connection_send_buffer(tcpConnection, output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据通过buffer写完之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onWriteCompleted</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write completed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接关闭之后的callback</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onConnectionClosed</span><span class="params">(struct tcp_connection *tcpConnection)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection closed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">char</span> **v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主线程event_loop</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_loop</span> *<span class="title">eventLoop</span> =</span> event_loop_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化acceptor</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acceptor</span> *<span class="title">acceptor</span> =</span> acceptor_init(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始tcp_server，可以指定线程数目，这里线程是4，说明是一个acceptor线程，4个I/O线程，每一个I/O线程</span></span><br><span class="line">    <span class="comment">//tcp_server自己带一个event_loop</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TCPserver</span> *<span class="title">tcpServer</span> =</span> tcp_server_init(eventLoop, acceptor, onConnectionCompleted, onMessage, onWriteCompleted, onConnectionClosed, <span class="number">4</span>);</span><br><span class="line">    tcp_server_start(tcpServer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main thread for acceptor</span></span><br><span class="line">    event_loop_run(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置了很多Callback回调函数，会在客户端建立连接之后依次执行这些回调函数。</p><ul><li><code>event_loop_init()</code>：创建一个事件循环器</li><li><code>acceptor_init(SERV_PORT)</code>: 初始化acceptor线程，bind、listen</li><li><code>tcp_server_init()</code>: 创建线程池，传入回调函数，分别对应了连接建立完成、数据读取完成、数据发送完成、连接关闭完成几种操作，通过回调函数，让业务程序可以聚焦在业务层开发</li><li><code>tcp_server_start(tcpServer)</code>: 开始监听，acceptor主线程，开启多个线程，同时把tcpServer作为参数传给channel对象</li><li><code>event_loop_run(eventLoop)</code>: 调用dispatcher来进行事件分发,分发完回调事件处理函数</li></ul><h1 id="Linux-内核参数的调优"><a href="#Linux-内核参数的调优" class="headerlink" title="Linux 内核参数的调优"></a>Linux 内核参数的调优</h1><h2 id="打开的最大文件描述符"><a href="#打开的最大文件描述符" class="headerlink" title="打开的最大文件描述符"></a>打开的最大文件描述符</h2><p>Linux 下默认的最大文件描述符是1024个，也就是一个应用程序最多打开1024个文件描述符。如果连接数过多，会导致<code>Socket/File:Can&#39;t open so many files</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">ulimit</span> -n</span><br><span class="line">1024</span><br><span class="line">➜  sudo <span class="built_in">echo</span> <span class="string">&quot;fs.file-max = 1000000&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">➜  sudo sysctl -p</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="发送缓冲区的自动调节"><a href="#发送缓冲区的自动调节" class="headerlink" title="发送缓冲区的自动调节"></a>发送缓冲区的自动调节</h2><p>Socket编程时是可以可以在send函数中设置发送缓冲区大小的，而这个应该设为多少才合适呢？答案是不要设置！不要设置！不要设置！</p><p>正确的操作是让操作系统自己动态的改变 发送缓冲区大小（默认就是操作系统自己控制的，但是应用程序一旦自己设置了缓冲区大小，自动调节功能就失效了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  sysctl -a | grep tcp_moderate_rcvbuf</span><br><span class="line">net.ipv4.tcp_moderate_rcvbuf = 1</span><br></pre></td></tr></table></figure><p>refer : <a href="https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/">就是要你懂TCP–性能和发送接收Buffer的关系</a></p><h1 id="C10M-的仰望"><a href="#C10M-的仰望" class="headerlink" title="C10M 的仰望"></a>C10M 的仰望</h1><p>C10K、C100K、C1000K 都可以凭借强大的epoll解决问题。但是对性能的追求是永无止境的，同时并发1百万可能操作系统已经达到极限了，前面说到C10K的问题在于IO阻塞、频繁的CPU上下文切换、套接字从应用层到内核的反复拷贝。那 <a href="http://c10m.robertgraham.com/p/blog-page.html">C10M</a> 的瓶颈是什么呢？</p><p>究其根本，还是 Linux 内核协议栈做了太多太繁重的工作。从网卡中断带来的硬中断处理程序开始，到软中断中的各层网络协议处理，最后再到应用程序，这个路径实在是太长了，就会导致网络包的处理优化，到了一定程度后，就无法更进一步了。</p><p>要解决这个问题，最重要就是跳过内核协议栈的冗长路径，把网络包直接送到要处理的应用程序那里去。这里有两种常见的机制，DPDK 和 XDP。</p><ul><li><p>DPDK:是用户态网络的标准。它跳过内核协议栈，直接由用户态进程通过轮询的方式，来处理网络接收。</p></li><li><p>XDP（eXpress Data Path），则是 Linux 内核提供的一种高性能网络数据路径。它允许网络包，在进入内核协议栈之前，就进行处理，也可以带来更高的性能。</p></li></ul><p>比较牛的开源项目就是 iqiyi 的DPVS了，DPVS 是基于 DPDK 的高性能 Layer-4负载均衡器。它源自Linux虚拟服务器 LVS 及其修改阿里巴巴/LVS 。</p><p><a href="https://www.worldlink.com.cn/osdir/dpvs.html">DPVS</a></p><p><a href="https://github.com/iqiyi/dpvs">https://github.com/iqiyi/dpvs</a></p><p>refer:</p><ul><li>[-]  <a href="https://cloud.tencent.com/developer/article/1373483">https://cloud.tencent.com/developer/article/1373483</a></li><li>[-]<a href="https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/">https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/</a></li><li>[-]  <a href="https://time.geekbang.org/column/intro/214">https://time.geekbang.org/column/intro/214</a></li><li>[-]  <a href="https://time.geekbang.org/column/article/81268">https://time.geekbang.org/column/article/81268</a></li><li>[-] <a href="https://zhuanlan.zhihu.com/p/43720867">https://zhuanlan.zhihu.com/p/43720867</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.kegel.com/c10k.html&quot;&gt;C10K&lt;/a&gt; 单机同时处理 1万个请求（并发连接 1 万）的问题，最早由 Dan Kegel 在 1999 年提出。那时的服务器还只是 32 位系统，运行着 Linux 2.2 版本（后来又升级到了 2.4 和 2.6，而 2.6 才支持 x86_64），只配置了很少的内存（2GB）和千兆网卡。在这样的系统能实现C10K问题吗？&lt;/p&gt;
&lt;p&gt;这在当年看似十分难以实现的问题，在当下epoll这个性能大杀器实现了我们单机并发10K的梦想。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="socket编程" scheme="http://kiosk007.top/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
    <category term="network" scheme="http://kiosk007.top/tags/network/"/>
    
    <category term="epoll" scheme="http://kiosk007.top/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>etcd 的基本入门</title>
    <link href="http://kiosk007.top/2020/05/30/go-etcd-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://kiosk007.top/2020/05/30/go-etcd-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-05-30T13:01:00.000Z</published>
    <updated>2020-05-30T13:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>etcd</strong> 是一个强一致性的分布式键值存储系统，可以提供可靠的分布式集群的数据访问方式。</p><p>etcd is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be accessed by a distributed system or cluster of machines.</p><p>refer: <a href="https://etcd.io/">https://etcd.io/</a></p><a id="more"></a><hr><img src="/images/etcd/etcd.png"><h1 id="etcd简介"><a href="#etcd简介" class="headerlink" title="etcd简介"></a>etcd简介</h1><p>etcd 诞生于 CoreOS 公司，它最初是用于解决集群管理系统中 OS 升级的<strong>分布式并发控制</strong>、<strong>服务发现</strong>、<strong>集群状态存储</strong> 以及 <strong>配置文件的存储与分发</strong>等问题。基于此，etcd 被设计为提供高可用、强一致的小型 keyvalue 数据存储服务。</p><p>项目当前隶属于 CNCF 基金会，被 AWS、Google、Microsoft、Alibaba 等大型互联网公司广泛使用。</p><h1 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h1><ul><li>数据存储在集群中的高可用K-V存储</li><li>允许应用实时监听存储中的K-V的变化</li><li>能够容忍单点故障，能够应对网络分区</li></ul><blockquote><p>分布式的容灾策略是基于 <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/7215942.html">鸽巢理论</a> ，假设一个班级有60人，我将一个秘密告诉31人，那么随便在这个班级挑出30人来，肯定至少有一个人指导这个秘密。</p></blockquote><p><strong>etcd与Raft的关系</strong></p><p>Raft是强一致性的集群日志同步算法，etcd是一个分布式KV存储，etcd利用raft算法在集群中同步key-value 。etcd集群需要2N+1个节点。</p><img src="/images/etcd/raft_a_consensus_algorithm_for_replicated_logs_1440-21.jpg">日志一旦由 leader节点 复制到了大多数 follower节点 即可完成提交。上图可以看到7个节点的集群，log index 为9 的数据已经同步给 a,c,d 所以index 9 属于整个集群，index为11 的几个数据leader 不认，所以这个数据不属于集群。<blockquote><p><code>Raft 可以保证，给客户端承诺过的请求一定是不会丢失的</code><br><code>各个节点的数据一定是最终一致的</code> </p></blockquote><p><a href="http://thesecretlivesofdata.com/raft/">raft 算法英文动画演示</a></p><h1 id="交互协议"><a href="#交互协议" class="headerlink" title="交互协议"></a>交互协议</h1><ul><li>HTTP 基于JSON请求，例如 curl，简单通用。</li><li>SDK 内置GRPC协议，性能高效</li></ul><h1 id="etcd-功能"><a href="#etcd-功能" class="headerlink" title="etcd 功能"></a>etcd 功能</h1><p>refer： <a href="https://etcd.io/docs/v3.4.0/demo/">etcd 文档演示</a></p><ul><li><p>put、get、del 操作<br>   数据库普通的增加，查找，删除操作，如果想要更新，依旧使用put。</p></li><li><p>watch 监听</p><p> 支持监听某一key的变化，有变化即产生回调，另外还支持查找key 的历史版本。</p></li><li><p>lease 租约</p><p>  申请定时器，举例：申请一个TTL为10s的租约 lease，当 put 一个 key 时，携带该租约，当TTL到期时，key也会被删除，一个 lease id 可以关联多个key，也就是租约到期，多个key 可以被删除，想要防止被删除，可以用keepalive定期续租。  </p></li><li><p>txn 事物、loack 分布式锁<br>  etcd 支持将多个请求包装到一个事务中，或者添加一个分布式锁。</p></li></ul><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><ul><li>安装etcd</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  wget https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line">➜  tar -xf etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line">➜  <span class="built_in">cd</span> etcd-v3.4.9-linux-amd64/</span><br><span class="line">➜  sudo cp etcd /usr/<span class="built_in">local</span>/sbin/</span><br><span class="line">➜  sudo cp etcdctl /usr/<span class="built_in">local</span>/sbin/</span><br></pre></td></tr></table></figure><ul><li>设置集群信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TOKEN=token-01</span><br><span class="line">CLUSTER_STATE=new</span><br><span class="line">NAME_1=machine-1</span><br><span class="line">NAME_2=machine-2</span><br><span class="line">NAME_3=machine-3</span><br><span class="line">HOST_1=127.0.0.1</span><br><span class="line">HOST_2=127.0.0.1</span><br><span class="line">HOST_3=127.0.0.1</span><br><span class="line">CLUSTER=<span class="variable">$&#123;NAME_1&#125;</span>=http://<span class="variable">$&#123;HOST_1&#125;</span>:2381,<span class="variable">$&#123;NAME_2&#125;</span>=http://<span class="variable">$&#123;HOST_2&#125;</span>:2382,<span class="variable">$&#123;NAME_3&#125;</span>=http://<span class="variable">$&#123;HOST_3&#125;</span>:2383</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>启动集群</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For machine 1</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_1&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_1&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd1 --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2381 --listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2381 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2371 --listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2371 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> --initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For machine 2</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_2&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_2&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd2 --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2382 --listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2382 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2372 --listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2372 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> --initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For machine 3</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_3&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_3&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd3 --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2383 --listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2383 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2373 --listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2373 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> --initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br></pre></td></tr></table></figure><ul><li>使用etcdctl 连接到etcd</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">HOST_1=127.0.0.1</span><br><span class="line">HOST_2=127.0.0.1</span><br><span class="line">HOST_3=127.0.0.1</span><br><span class="line">ENDPOINTS=<span class="variable">$HOST_1</span>:2371,<span class="variable">$HOST_2</span>:2372,<span class="variable">$HOST_3</span>:2373</span><br><span class="line"></span><br><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> member list</span><br></pre></td></tr></table></figure><ul><li>尝试添加一个key</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> put <span class="string">&quot;key&quot;</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h1 id="golang-操作-etcd"><a href="#golang-操作-etcd" class="headerlink" title="golang 操作 etcd"></a>golang 操作 etcd</h1><p>github 官方示例代码：<a href="https://github.com/etcd-io/etcd/tree/master/clientv3">https://github.com/etcd-io/etcd/tree/master/clientv3</a></p><p>使用前先安装 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get go.etcd.io/etcd/clientv3</span><br></pre></td></tr></table></figure><p>解决Golang1.14 etcd/clientv3报错：etcd undefined: resolver.BuildOption</p><p>refer: <a href="https://blog.csdn.net/qq_43442524/article/details/104997539">https://blog.csdn.net/qq_43442524/article/details/104997539</a></p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client *clientv3.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Conn</span><span class="params">()</span></span> &#123;</span><br><span class="line">cli, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">&quot;localhost:2371&quot;</span>, <span class="string">&quot;localhost:2372&quot;</span>, <span class="string">&quot;localhost:2373&quot;</span>&#125;,</span><br><span class="line">DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> cli.Close()</span><br><span class="line">client = cli</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单操作-GET，PUT，DEL"><a href="#简单操作-GET，PUT，DEL" class="headerlink" title="简单操作 GET，PUT，DEL"></a>简单操作 GET，PUT，DEL</h2><p>refer：<a href="https://godoc.org/go.etcd.io/etcd/clientv3">https://godoc.org/go.etcd.io/etcd/clientv3</a></p><p>etcd的操作强大在可以添加 <code>WithOption</code> 比如 <code>WithPrevKV()</code> 获取前一个Key 和 <code>WithPrefix()</code> 遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EtcdApi <span class="keyword">struct</span> &#123;</span><br><span class="line">KV clientv3.KV</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">PutKey</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">ctx, _ := context.WithTimeout(context.Background(),<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// clientv3.WithPrevKV() 获取到删KV之前的值</span></span><br><span class="line"><span class="keyword">if</span> putResp, err := e.KV.Put(ctx,key,value,clientv3.WithPrevKV()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> putResp.PrevKv != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;PrevValue: &quot;</span>, <span class="keyword">string</span>(putResp.PrevKv.Value))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">GetKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">ctx, _ := context.WithTimeout(context.Background(),<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以遍历目录</span></span><br><span class="line"><span class="keyword">if</span> getResp, err := e.KV.Get(ctx,key,clientv3.WithPrefix());err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, getResp.Kvs),err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">DelKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">ctx, _ := context.WithTimeout(context.Background(),<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> delResp, err := e.KV.Delete(ctx,key,clientv3.WithPrevKV());err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value,<span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s&quot;</span>,delResp.PrevKvs),<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Lease-租期"><a href="#Lease-租期" class="headerlink" title="Lease 租期"></a>Lease 租期</h2><ul><li>创建租约</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">GrantLease</span><span class="params">()</span> <span class="params">(lease clientv3.Lease, leaseId clientv3.LeaseID,err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> leaseGrantResp *clientv3.LeaseGrantResponse</span><br><span class="line"></span><br><span class="line">lease = clientv3.NewLease(e.Client)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一个10s的租约</span></span><br><span class="line"><span class="keyword">if</span> leaseGrantResp, err = lease.Grant(e.Ctx,<span class="number">10</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leaseId = leaseGrantResp.ID</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put 一个KV, 关联租约，从而实现10s自动过期</span></span><br><span class="line"><span class="keyword">if</span> putResp,err := e.KV.Put(e.Ctx,<span class="string">&quot;/key1/lease&quot;</span>,<span class="string">&quot;v1&quot;</span>,clientv3.WithLease(leaseId)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(putResp.Header.Revision)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>续租</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EtcdApi)</span> <span class="title">KeepAlive</span><span class="params">(leaseId clientv3.LeaseID)</span></span> &#123;</span><br><span class="line"><span class="comment">// 自动续期</span></span><br><span class="line"><span class="keyword">var</span> keepResp *clientv3.LeaseKeepAliveResponse</span><br><span class="line">keepRespChan,err := e.Lease.KeepAlive(context.TODO(), leaseId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;ERROR :&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> keepResp = &lt;- keepRespChan:</span><br><span class="line"><span class="keyword">if</span> keepRespChan == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;租约实效&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> END</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">// 每秒续租一次</span></span><br><span class="line">fmt.Println(<span class="string">&quot;续租&quot;</span>, keepResp.ID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">END:</span><br><span class="line">fmt.Println(<span class="string">&quot;Return&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Watch-监听"><a href="#Watch-监听" class="headerlink" title="Watch 监听"></a>Watch 监听</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EtcdApi)</span> <span class="title">Watch</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个watcher</span></span><br><span class="line">e.Watcher = clientv3.Watcher(e.Client)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 30 s 后取消监听</span></span><br><span class="line">ctx, cancelFunc := context.WithCancel(context.TODO())</span><br><span class="line">time.AfterFunc(<span class="number">30</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cancelFunc()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动监听</span></span><br><span class="line">watchRespChan := e.Watcher.Watch(ctx,<span class="string">&quot;/key1/watcher&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理kv变化事件</span></span><br><span class="line"><span class="keyword">for</span> watchResp := <span class="keyword">range</span> watchRespChan &#123;</span><br><span class="line"><span class="keyword">for</span> _,event := <span class="keyword">range</span> watchResp.Events &#123;</span><br><span class="line"><span class="keyword">switch</span> event.Type &#123;</span><br><span class="line"><span class="keyword">case</span> mvccpb.PUT: &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot; 修改为： &quot;</span>, <span class="keyword">string</span>(event.Kv.Value), <span class="string">&quot;Revision: &quot;</span>, event.Kv.CreateRevision , event.Kv.ModRevision)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> mvccpb.DELETE: &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot; 删除： Revision: &quot;</span>, event.Kv.ModRevision)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h2><p>可以将上面提到的 <code>Get</code>、<code>Put</code>、<code>Delete</code>等操作抽象成一个Operation。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EtcdApi)</span> <span class="title">Op</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个OP：operation</span></span><br><span class="line">putOp := clientv3.OpPut(<span class="string">&quot;/key1/op&quot;</span>,<span class="string">&quot;value_op&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行OP</span></span><br><span class="line">opResp, err := e.KV.Do(e.Ctx,putOp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;写入Revision： &quot;</span>, &amp;opResp.Put().Header.Revision)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Txn"><a href="#Txn" class="headerlink" title="Txn"></a>Txn</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EtcdApi)</span> <span class="title">DoTxn</span><span class="params">(leaseId clientv3.LeaseID)</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建事物</span></span><br><span class="line">txn := e.KV.Txn(e.Ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事物</span></span><br><span class="line">txn.If(clientv3.Compare(clientv3.CreateRevision(<span class="string">&quot;/key1/lease&quot;</span>),<span class="string">&quot;=&quot;</span>,<span class="string">&quot;0&quot;</span>)).</span><br><span class="line">Then(clientv3.OpPut(<span class="string">&quot;/key1/lease&quot;</span>,<span class="string">&quot;value1&quot;</span>,clientv3.WithLease(leaseId))).</span><br><span class="line">Else(clientv3.OpGet(<span class="string">&quot;/key1/lease&quot;</span>))  <span class="comment">//抢锁失败</span></span><br><span class="line"></span><br><span class="line">txnResp,err := txn.Commit()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否抢到锁</span></span><br><span class="line"><span class="keyword">if</span> !txnResp.Succeeded &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;抢锁失败,锁被占用：&quot;</span> , <span class="keyword">string</span>(txnResp.Responses[<span class="number">0</span>].GetResponseRange().Kvs[<span class="number">0</span>].Value))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;etcd&lt;/strong&gt; 是一个强一致性的分布式键值存储系统，可以提供可靠的分布式集群的数据访问方式。&lt;/p&gt;
&lt;p&gt;etcd is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be accessed by a distributed system or cluster of machines.&lt;/p&gt;
&lt;p&gt;refer: &lt;a href=&quot;https://etcd.io/&quot;&gt;https://etcd.io/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="etcd" scheme="http://kiosk007.top/categories/etcd/"/>
    
    
    <category term="etcd" scheme="http://kiosk007.top/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>VMTrafficShark 自制弱网模拟器</title>
    <link href="http://kiosk007.top/2020/05/30/VMTrafficShark-%E8%87%AA%E5%88%B6%E5%BC%B1%E7%BD%91%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>http://kiosk007.top/2020/05/30/VMTrafficShark-%E8%87%AA%E5%88%B6%E5%BC%B1%E7%BD%91%E6%A8%A1%E6%8B%9F%E5%99%A8/</id>
    <published>2020-05-30T01:21:00.000Z</published>
    <updated>2020-05-30T01:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>VMTrafficShark是参考 <a href="http://geekluo.com/contents/2017/05/02/38-trafficshark-tool-for-network.html">TrafficShark</a> 改造后的弱网模拟和抓包工具。其本质是参考Facebook开源的弱网模拟器 <a href="https://github.com/facebookarchive/augmented-traffic-control">ATC</a> 。方便应用开发测试人员模拟弱网环境下的用户体验。VMTrafficShark是基于Vmware/VirtualBox 虚拟机，方便移动部署，一键开机，配置灵活，功能强大。</p><a id="more"></a><hr><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><img src="/images/network/VMTrafficShark/vmtrafficshark.png"><p>VMTrafficShark 可以模拟各种复杂网络场景.</p><ul><li><input checked disabled type="checkbox"> 低带宽、高丢包、高时延.</li><li><input checked disabled type="checkbox"> DNS空解析、DNS劫持.</li><li><input checked disabled type="checkbox"> 7层HTTP内容劫持、模拟服务端故障</li><li><input checked disabled type="checkbox"> 中间人抓包、方便导出 pcap、sslkey.log （设备只要应用层没有做 SSL Pinning 等反中间人措施的APP均可嗅探TLS加密后的应用层内容）</li><li><input disabled type="checkbox"> 可视化前端操作、多场景模拟一键操作</li><li><input disabled type="checkbox"> 接入设备管理</li></ul><h1 id="环境搭建与安装"><a href="#环境搭建与安装" class="headerlink" title="环境搭建与安装"></a>环境搭建与安装</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>硬件</strong></p><ul><li>笔记本电脑</li><li>USB无线网卡</li></ul><blockquote><p>本文使用的是 <a href="https://item.jd.com/100006507594.html">COMFAST CF-812AC双频千兆无线网卡 (不是打广告)</a></p></blockquote><p><strong>软件</strong></p><ul><li>vmware workstation</li><li>ubuntu 19.10</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装必须软件包"><a href="#安装必须软件包" class="headerlink" title="安装必须软件包"></a>安装必须软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo apt-get update</span><br><span class="line">➜ sudo apt install git gcc make vim libssl-dev net-tools -y</span><br></pre></td></tr></table></figure><h3 id="连接USB网卡，安装驱动"><a href="#连接USB网卡，安装驱动" class="headerlink" title="连接USB网卡，安装驱动"></a>连接USB网卡，安装驱动</h3><ul><li>连接USB网卡</li></ul><p><img src="/images/network/VMTrafficShark/netinterface_driver_install.png"></p><blockquote><p>最好将USB改称USB 3.0 ，2.0好像兼容性不是特别好<br><img src="/images/network/VMTrafficShark/net_interface_usb.png" style="height:250px"></p></blockquote><ul><li>安装驱动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="built_in">clone</span> https://github.com/cilynx/rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959.git </span><br><span class="line">➜ <span class="built_in">cd</span> rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959/</span><br><span class="line">➜ make</span><br><span class="line">➜ sudo make install</span><br><span class="line">➜ sudo modprobe 88x2bu</span><br><span class="line">➜ sudo lsmod | grep 88x2bu</span><br><span class="line">➜ sudo reboot</span><br></pre></td></tr></table></figure><h3 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h3><ul><li><p>添加一块 host-only 的网卡 <code>eth1</code> ，用于我们ssh登陆 虚拟机使用<br><img src="/images/network/VMTrafficShark/eth1.png" style="height:350px"><br>右键虚拟机tab，<code>settings</code> -&gt; <code>Add</code> -&gt; <code>Network Adapter</code> -&gt; <code>Host-only</code></p></li><li><p>修改网络内核参数</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认开启端口转发</span></span><br><span class="line">➜ sudo <span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 修改网络接口命名方式（默认为ens33规则，修改为eth0、wlan0规则，与上面对应）</span></span><br><span class="line">➜ sudo vim /etc/default/grub</span><br><span class="line"><span class="comment"># Modify GRUB_CMDLINE_LINUX</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;net.ifnames=0 biosdevname=0&quot;</span></span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line">➜ sudo reboot</span><br></pre></td></tr></table></figure><blockquote><p>重启后就ssh不上了…  另外注意 eth0 必须是桥接模式，nat的话会导致tcp option丢失。</p></blockquote><ul><li>配置网卡</li></ul><p>ubuntu从17.10开始，已放弃在/etc/network/interfaces里固定IP的配置，即使配置也不会生效，而是改成netplan方式</p><p>refer: <a href="https://netplan.io/examples">https://netplan.io/examples</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo vim /etc/netplan/50-cloud-init.yaml </span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            dhcp4: <span class="literal">true</span></span><br><span class="line">        eth1:</span><br><span class="line">            dhcp4: <span class="literal">true</span></span><br><span class="line">        wlan0:</span><br><span class="line">            dhcp4: no</span><br><span class="line">            dhcp6: no</span><br><span class="line">            addresses: [192.168.100.1/24]</span><br><span class="line">    version: 2</span><br><span class="line">    </span><br><span class="line">➜ sodu netplan apply</span><br></pre></td></tr></table></figure><ul><li>配置完成</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1&#x2F;128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 00:0c:29:1d:c7:31 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.104&#x2F;24 brd 192.168.0.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 6009sec preferred_lft 6009sec</span><br><span class="line">    inet6 fe80::20c:29ff:fe1d:c731&#x2F;64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 00:0c:29:1d:c7:3b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.246.128&#x2F;24 brd 172.16.246.255 scope global dynamic eth1</span><br><span class="line">       valid_lft 1510sec preferred_lft 1510sec</span><br><span class="line">    inet6 fe80::20c:29ff:fe1d:c73b&#x2F;64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 20:0d:b0:38:d2:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.100.1&#x2F;24 brd 192.168.100.255 scope global wlan0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::220d:b0ff:fe38:d2ea&#x2F;64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装dhcp服务"><a href="#安装dhcp服务" class="headerlink" title="安装dhcp服务"></a>安装dhcp服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo apt install isc-dhcp-server -y</span><br><span class="line"><span class="comment"># 备份</span></span><br><span class="line">➜ sudo cp /etc/default/isc-dhcp-server&#123;,.bak&#125; </span><br><span class="line"><span class="comment"># 更改DHCP生效网卡</span></span><br><span class="line">➜ sudo vim /etc/default/isc-dhcp-server</span><br><span class="line">DHCPDv4_CONF=/etc/dhcp/dhcpd.conf</span><br><span class="line">INTERFACESv4=<span class="string">&quot;wlan0&quot;</span></span><br><span class="line"><span class="comment"># 更改dhcp配置文件</span></span><br><span class="line">➜ sudo vim /etc/dhcp/dhcpd.cnf</span><br><span class="line">subnet 192.168.100.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    range 192.168.100.100 192.168.100.200;</span><br><span class="line">    option domain-name-servers 192.168.100.1;</span><br><span class="line">    option routers 192.168.100.1;</span><br><span class="line">&#125;</span><br><span class="line">➜ sudo systemctl restart isc-dhcp-server</span><br><span class="line">➜</span><br></pre></td></tr></table></figure><h3 id="安装hostapd服务"><a href="#安装hostapd服务" class="headerlink" title="安装hostapd服务"></a>安装hostapd服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo apt install hostapd -y</span><br><span class="line">➜ sudo sed -i <span class="string">&#x27;s|#DAEMON_CONF=&quot;&quot;|DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;|&#x27;</span> /etc/default/hostapd</span><br><span class="line">➜ sudo vim /etc/hostapd/hostapd.conf</span><br><span class="line">interface=wlan0</span><br><span class="line">driver=nl80211</span><br><span class="line">ssid=Traffic Shark</span><br><span class="line">hw_mode=g</span><br><span class="line">ieee80211n=1</span><br><span class="line">wmm_enabled=1</span><br><span class="line">channel=7</span><br><span class="line">macaddr_acl=0</span><br><span class="line">auth_algs=1</span><br><span class="line">ignore_broadcast_ssid=0</span><br><span class="line">wpa=2</span><br><span class="line">wpa_passphrase=12345678</span><br><span class="line">wpa_key_mgmt=WPA-PSK</span><br><span class="line">wpa_pairwise=TKIP</span><br><span class="line">rsn_pairwise=CCMP </span><br><span class="line">➜ sudo systemctl unmask hostapd</span><br><span class="line">➜ sudo systemctl <span class="built_in">enable</span> hostapd</span><br><span class="line">➜ sudo systemctl start hostapd</span><br></pre></td></tr></table></figure><h3 id="安装dnsmasq"><a href="#安装dnsmasq" class="headerlink" title="安装dnsmasq"></a>安装dnsmasq</h3><p>由于ubuntu 18.04 开始，多了一个系统的systemd-resolvd服务，与我们要安装的dnsmasq都监听在 53 端口，妨碍了我们启用dnsmasq，所以需要停掉。</p><ul><li>停止 systemd-resolved</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo systemctl <span class="built_in">disable</span> systemd-resolved</span><br><span class="line">➜ sudo systemctl stop systemd-resolved</span><br><span class="line">➜ ll /etc/resolv.conf </span><br><span class="line">lrwxrwxrwx 1 root root 39 Oct 17  2019 /etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br><span class="line">➜ rm -f /etc/resolv.conf </span><br><span class="line">➜ sudo tee /etc/resolv.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">nameserver 127.0.0.1</span></span><br><span class="line"><span class="string">nameserver 114.114.114.114</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>安装dnsmasq</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo apt-get install dnsmasq</span><br><span class="line">➜ touch /etc/hosts.chat.freenode.net</span><br><span class="line">➜ vim /etc/dnsmasq.conf</span><br><span class="line">interface=wlan0</span><br><span class="line">listen-address=192.168.100.1</span><br><span class="line">dhcp-range=192.168.100.100,192.168.100.199,255.255.255.0,24h</span><br><span class="line"></span><br><span class="line">address=/www.kiosk007.top/127.0.0.1</span><br><span class="line">addn-hosts=/etc/hosts.chat.freenode.net</span><br><span class="line">➜ systemctl <span class="built_in">enable</span> dnsmasq</span><br><span class="line">➜ systemctl start dnsmasq</span><br></pre></td></tr></table></figure><h3 id="安装中间人"><a href="#安装中间人" class="headerlink" title="安装中间人"></a>安装中间人</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ wget https://snapshots.mitmproxy.org/5.1.1/mitmproxy-5.1.1-linux.tar.gz</span><br><span class="line">➜ tar -xf mitmproxy-5.1.1-linux.tar.gz</span><br></pre></td></tr></table></figure><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>安装Nginx是为了模拟服务端故障和7层劫持，如果配置了证书同样可以对https进行劫持</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo apt install nginx -y</span><br><span class="line">➜ sudo tee /etc/nginx/nginx.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">user www-data;</span></span><br><span class="line"><span class="string">worker_processes auto;</span></span><br><span class="line"><span class="string">pid /run/nginx.pid;</span></span><br><span class="line"><span class="string">include /etc/nginx/modules-enabled/*.conf;</span></span><br><span class="line"><span class="string">events &#123;</span></span><br><span class="line"><span class="string">        worker_connections 768;</span></span><br><span class="line"><span class="string">        multi_accept on;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">http &#123;</span></span><br><span class="line"><span class="string">        sendfile on;</span></span><br><span class="line"><span class="string">        tcp_nopush on;</span></span><br><span class="line"><span class="string">        tcp_nodelay on;</span></span><br><span class="line"><span class="string">        keepalive_timeout 65;</span></span><br><span class="line"><span class="string">        types_hash_max_size 2048;</span></span><br><span class="line"><span class="string">        include /etc/nginx/mime.types;</span></span><br><span class="line"><span class="string">        default_type application/octet-stream;</span></span><br><span class="line"><span class="string">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; </span></span><br><span class="line"><span class="string">        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="string">        access_log /var/log/nginx/access.log;</span></span><br><span class="line"><span class="string">        error_log /var/log/nginx/error.log;</span></span><br><span class="line"><span class="string">        gzip on;</span></span><br><span class="line"><span class="string">        include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用 iptables 命令转发流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables -F</span><br><span class="line">iptables -t nat -F</span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</span><br></pre></td></tr></table></figure><ul><li>手机搜索 AP “Traffic Shark”</li><li>密码 12345678</li></ul><img src="/images/network/VMTrafficShark/wifi.png" style="height:550px"><p>下行带宽可以达到93.35Mbps<br>上行带宽可以达到30.50Mbps （主要还得看物理网卡和运营商猛不猛）<br><img src="/images/network/VMTrafficShark/traffic_test.png" style="height:550px"></p><h2 id="弱网模拟使用"><a href="#弱网模拟使用" class="headerlink" title="弱网模拟使用"></a>弱网模拟使用</h2><ul><li>弱网模拟使用的是tc</li><li>DNS劫持使用的dnsmasq</li><li>应用层劫持使用的Nginx和iptables</li><li>中间人使用的 mitmproxy</li></ul><h3 id="上行限速"><a href="#上行限速" class="headerlink" title="上行限速"></a>上行限速</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Uplink</span></span><br><span class="line">sudo tc qdisc del dev eth0 root</span><br><span class="line">sudo tc qdisc add dev eth0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev eth0 parent 1:1 classid 1:2 htb rate 100mbit</span><br><span class="line">sudo tc class add dev eth0 parent 1:1 classid 1:3 htb rate 100mbit</span><br><span class="line">sudo tc qdisc add dev eth0 parent 1:2 handle 2: sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev eth0 parent 1:3 handle 3: netem rate 2mbit</span><br><span class="line">sudo tc filter add dev eth0 protocol ip parent 1:0 u32 match ip src 192.168.100.0/24 flowid 1:3</span><br></pre></td></tr></table></figure><h3 id="下行限速"><a href="#下行限速" class="headerlink" title="下行限速"></a>下行限速</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Downlink</span></span><br><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:2 htb rate 100mbit</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:3 htb rate 100mbit</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2: sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem rate 20mbit</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1:0 u32 match ip dst 192.168.100.0/24 flowid 1:3</span><br></pre></td></tr></table></figure><h3 id="模拟丢包、高时延等弱网环境"><a href="#模拟丢包、高时延等弱网环境" class="headerlink" title="模拟丢包、高时延等弱网环境"></a>模拟丢包、高时延等弱网环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:2 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:3 htb rate 100mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2: netem rate 3000kbit</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem loss random 50%</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1:0 u32 match ip dst 192.168.0.0/24 flowid 1:2  <span class="comment"># ip 是 eth0 的出网ip</span></span><br></pre></td></tr></table></figure><h3 id="封禁DNS请求"><a href="#封禁DNS请求" class="headerlink" title="封禁DNS请求"></a>封禁DNS请求</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1: classid 1:2 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1: classid 1:3 htb rate 100mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2: sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem loss 100%</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1: prio 1 u32 match ip protocol 17 ff match ip sport 53 0xffff flowid 1:3</span><br></pre></td></tr></table></figure><h3 id="封禁IP段"><a href="#封禁IP段" class="headerlink" title="封禁IP段"></a>封禁IP段</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1: classid 1:2 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1: classid 1:3 htb rate 100mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2: sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem loss 100%</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1: u32 match ip src 8.8.0.0/16 flowid 1:3</span><br></pre></td></tr></table></figure><h3 id="组合弱网场景"><a href="#组合弱网场景" class="headerlink" title="组合弱网场景"></a>组合弱网场景</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo tc qdisc del dev wlan0 root</span><br><span class="line">sudo tc qdisc add dev wlan0 root handle 1: htb default 2</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:2 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:3 htb rate 100mbps</span><br><span class="line">sudo tc class add dev wlan0 parent 1:1 classid 1:4 htb rate 100mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:2 handle 2:  sfq perturb 10</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:3 handle 3: netem loss random 1% rate 20mbps</span><br><span class="line">sudo tc qdisc add dev wlan0 parent 1:4 handle 4: netem loss 100%</span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1:0 u32 match ip dst 192.168.100.0/24 flowid 1:3  <span class="comment"># 限制下行带宽</span></span><br><span class="line">sudo tc filter add dev wlan0 protocol ip parent 1: prio 1 u32 match ip protocol 17 ff match ip sport 443 0xffff flowid 1:4  <span class="comment">#封禁 udp 443 端口 </span></span><br></pre></td></tr></table></figure><h3 id="dns-劫持"><a href="#dns-劫持" class="headerlink" title="dns 劫持"></a>dns 劫持</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ vim /etc/dnsmasq.conf</span><br><span class="line">address=/www.kiosk007.top/127.0.0.1</span><br><span class="line"></span><br><span class="line">如果想要解析多个ip</span><br><span class="line">➜ vim /etc/hosts.chat.freenode.net</span><br><span class="line">127.0.0.1 www.kiosk007.top</span><br><span class="line">127.0.0.2 www.kiosk007.top</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7层内容劫持"><a href="#7层内容劫持" class="headerlink" title="7层内容劫持"></a>7层内容劫持</h3><ul><li>1、利用 DNS 劫持先将流量劫持到 Nginx 上</li><li>2、自签名泛域名证书，参考 <a href="https://github.com/Fishdrowned/ssl">https://github.com/Fishdrowned/ssl</a></li><li>3、配置Nginx完成劫持</li></ul><h3 id="mitm中间人"><a href="#mitm中间人" class="headerlink" title="mitm中间人"></a>mitm中间人</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables  -t nat -F</span><br><span class="line">iptables  -t nat -A PREROUTING -i wlan0 -p tcp -j REDIRECT --to-port 8080</span><br><span class="line">ip6tables -t nat -A PREROUTING -i wlan0 -p tcp --dport 443 -j REDIRECT --to-port 8080</span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</span><br><span class="line">SSLKEYLOGFILE=<span class="string">&quot;/root/sslkey/sslkeylogfile.txt&quot;</span> mitmproxy --mode transparent --showhost</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/images/network/VMTrafficShark/mitmproxy.png"><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>为了能将抓到的包在宿主机上实时显示，需要配置root用户ssh免密登陆,配合上面的mitm导出中间人密钥，再将sslkey_log所在目录挂载到宿主机导入wireshark中，可以做到实时查看tls内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ vim /etc/ssh/sshd_config</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line">➜ ssh root@172.16.246.128 <span class="string">&quot;tcpdump -i wlan0 -U -w - 2&gt;/dev/null&quot;</span>| wireshark -k -S -i -</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;VMTrafficShark是参考 &lt;a href=&quot;http://geekluo.com/contents/2017/05/02/38-trafficshark-tool-for-network.html&quot;&gt;TrafficShark&lt;/a&gt; 改造后的弱网模拟和抓包工具。其本质是参考Facebook开源的弱网模拟器 &lt;a href=&quot;https://github.com/facebookarchive/augmented-traffic-control&quot;&gt;ATC&lt;/a&gt; 。方便应用开发测试人员模拟弱网环境下的用户体验。VMTrafficShark是基于Vmware/VirtualBox 虚拟机，方便移动部署，一键开机，配置灵活，功能强大。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="network" scheme="http://kiosk007.top/tags/network/"/>
    
  </entry>
  
</feed>
