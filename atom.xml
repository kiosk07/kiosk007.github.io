<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kiosk007&#39;s Blog</title>
  
  <subtitle>专注 量变产生质变!</subtitle>
  <link href="http://kiosk007.top/atom.xml" rel="self"/>
  
  <link href="http://kiosk007.top/"/>
  <updated>2021-07-10T07:15:00.000Z</updated>
  <id>http://kiosk007.top/</id>
  
  <author>
    <name>kiosk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wireshark解析器Lua脚本</title>
    <link href="http://kiosk007.top/2021/07/10/Wireshark%E8%A7%A3%E6%9E%90%E5%99%A8Lua%E8%84%9A%E6%9C%AC/"/>
    <id>http://kiosk007.top/2021/07/10/Wireshark%E8%A7%A3%E6%9E%90%E5%99%A8Lua%E8%84%9A%E6%9C%AC/</id>
    <published>2021-07-10T07:15:00.000Z</published>
    <updated>2021-07-10T07:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Wireshark集成了Lua解释器，以支持Lua脚本（自己编译的话根据编译配置决定是否支持Lua）。</p><p>启动wireshark，依次点击“Help”，”About Wireshark“菜单，在打开的对话框中的”Wireshark”标签页上观察版本信息，如果如下图一样显示With Lua，说明此版本支持Lua插件。</p><p>然后打开wireshark主目录下的init.lua文件，确保disable_lua的值为false，即开启了lua：</p><a id="more"></a><p><img src="https://img1.kiosk007.top/static/images/wireshark/R-C.jpeg" style="height:400px"></p><p>因实际工作中需要对一种非官方的自研协议进行解析，每次可能需要对传输的内容进行对比，为了方便需要利用wireshark工具进行分析。恰好，Wireshark 可以利用其暴露的 <a href="https://wiki.wireshark.org/Lua">Lua API</a> 对抓包数据进行分析。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>Lua是一种轻量级的脚本语言，解释执行，不需要编译器之类的。基本语法可参考 <a href="https://www.w3cschool.cn/lua/lua-tutorial.html">Lua W3CSchool</a></p><p>Wireshark内置了对Lua脚本的支持，可以直接编写Lua脚本，无需配置额外的环境。使用起来方便。<br> <a href="https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html">Wireshark Developer’s Guide</a>里的第10章和第11章都是关于Lua支持的文档。</p><p>使用Lua编写Wireshark协议解析插件，有几个比较重要的概念:</p><ul><li><code>Dissector</code>: 中文直译是解剖器，就是用来解析包的类，为了解析一个新协议，我们需要编写的也是一个Dissector。</li><li><code>DissectorTable</code>: 解析器表是Wireshark中解析器的组织形式，是某一种协议的子解析器的一个列表，其作用是把所有的解析器组织成一种树状结构，便于Wireshark在解析包的时候自动选择对应的解析器。例如TCP协议的子解析器 http, smtp, sip等都被加在了”tcp.port”这个解析器表中，可以根据抓到的包的不同的tcp端口号，自动选择对应的解析器。</li></ul><p>Wireshark是用C编写的，Wireshark的剖析器通常也是用C编写的。然而，Wireshark有一个Lua实现，这使得不熟悉C的人很容易编写剖析器。对于那些不熟悉Lua的人来说，它是一种非常轻量级的编程语言，旨在作为脚本语言在应用程序中实现，以扩展其功能。</p><h2 id="Wireshark-支持"><a href="#Wireshark-支持" class="headerlink" title="Wireshark 支持"></a>Wireshark 支持</h2><p>Wireshark 天然对 Lua 有良好的支持性，且Lua在Wireshark中可以做的事情也有很多，详见<a href="https://wiki.wireshark.org/Lua/Examples">Wireshark Lua Example</a></p><p>网上的教程是点击 Help –&gt; About Wireshark –&gt; Folders，查找 Wireshark 的lua脚本存放目录。</p><p>但是实际上我找到的敌方有些不同，不过亲测有效。该目录下有一个 <code>init.lua</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux </span></span><br><span class="line">/usr/share/wireshark</span><br><span class="line"><span class="comment"># Mac</span></span><br><span class="line">/Applications/Wireshark.app/Contents/Resources/share/wireshark</span><br></pre></td></tr></table></figure><br>将<code>init.lua</code> 文件末加上， <code>dofile(DATA_DIR..&quot;your_lua_script&quot;)</code></p><p><img src="https://img1.kiosk007.top/static/images/wireshark/init_lua.png"></p><p>当 Wireshark 启动时，该脚本将处于激活状态。当脚本修改后，必须重启 Wireshark， 或者按 <code>Ctrl+Shift+L</code> （Mac 下<code>Shift+Command+L</code>） 重载 Lua 脚本。</p><h1 id="Lua-API"><a href="#Lua-API" class="headerlink" title="Lua API"></a>Lua API</h1><p>在 Lua API 之前先看一个Lua 解析脚本的示例。参考 <a href="https://zhuanlan.zhihu.com/p/114669991">自己动手编写Wireshark Lua插件解析自定义协议</a></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">--协议名称为DT，在Packet Details窗格显示为Nselab.Zachary DT</span></span><br><span class="line">    <span class="keyword">local</span> p_DT = Proto(<span class="string">&quot;DT&quot;</span>,<span class="string">&quot;Nselab.Zachary DT&quot;</span>)</span><br><span class="line">    <span class="comment">--协议的各个字段</span></span><br><span class="line">    <span class="keyword">local</span> f_identifier = ProtoField.uint8(<span class="string">&quot;DT.identifier&quot;</span>,<span class="string">&quot;Identifier&quot;</span>, base.HEX)</span><br><span class="line">    <span class="comment">--这里的base是显示的时候的进制，详细可参考https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html#lua_class_ProtoField</span></span><br><span class="line">    <span class="keyword">local</span> f_speed = ProtoField.uint8(<span class="string">&quot;DT.speed&quot;</span>, <span class="string">&quot;Speed&quot;</span>, base.HEX)</span><br><span class="line"></span><br><span class="line">    <span class="comment">--这里把DT协议的全部字段都加到p_DT这个变量的fields字段里</span></span><br><span class="line">    p_DT.fields = &#123;f_identifier, f_speed&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--这里是获取data这个解析器</span></span><br><span class="line">    <span class="keyword">local</span> data_dis = Dissector.get(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">DT_dissector</span><span class="params">(buf,pkt,root)</span></span></span><br><span class="line">        <span class="keyword">local</span> buf_len = buf:<span class="built_in">len</span>();</span><br><span class="line">        <span class="comment">--先检查报文长度，太短的不是我的协议</span></span><br><span class="line">        <span class="keyword">if</span> buf_len &lt; <span class="number">16</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">--验证一下identifier这个字段是不是0x12,如果不是的话，认为不是我要解析的packet</span></span><br><span class="line">        <span class="keyword">local</span> v_identifier = buf(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (v_identifier:uint() ~= <span class="number">0x12</span>)</span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">--取出其他字段的值</span></span><br><span class="line">        <span class="keyword">local</span> v_speed = buf(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">--现在知道是我的协议了，放心大胆添加Packet Details</span></span><br><span class="line">        <span class="keyword">local</span> t = root:add(p_DT,buf)</span><br><span class="line">        <span class="comment">--在Packet List窗格的Protocol列可以展示出协议的名称</span></span><br><span class="line">        pkt.cols.protocol = <span class="string">&quot;DT&quot;</span></span><br><span class="line">        <span class="comment">--这里是把对应的字段的值填写正确，只有t:add过的才会显示在Packet Details信息里. 所以在之前定义fields的时候要把所有可能出现的都写上，但是实际解析的时候，如果某些字段没出现，就不要在这里add</span></span><br><span class="line">        t:add(f_identifier,v_identifier)</span><br><span class="line">        t:add(f_speed,v_speed)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">--这段代码是目的Packet符合条件时，被Wireshark自动调用的，是p_DT的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">p_DT.dissector</span><span class="params">(buf,pkt,root)</span></span> </span><br><span class="line">        <span class="keyword">if</span> DT_dissector(buf,pkt,root) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">--valid DT diagram</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">--data这个dissector几乎是必不可少的；当发现不是我的协议时，就应该调用data</span></span><br><span class="line">            data_dis:call(buf,pkt,root)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">local</span> udp_encap_table = DissectorTable.get(<span class="string">&quot;udp.port&quot;</span>)</span><br><span class="line">    <span class="comment">--因为我们的DT协议的接受端口肯定是50002，所以这里只需要添加到&quot;udp.port&quot;这个DissectorTable里，并且指定值为50002即可。</span></span><br><span class="line">    udp_encap_table:add(<span class="number">50002</span>, p_DT)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如上图就是一个标准的协议解析流程。下面我们做一个详细的流程梳理。</p><h2 id="1-Proto"><a href="#1-Proto" class="headerlink" title="1. Proto"></a>1. Proto</h2><p>官方文档：<a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html#lua_class_Proto">11.6.5. Proto</a>:</p><p>表示一个新的Protocol，在Wireshark中Protocol对象有很多用处，解析器是其中主要的一个。主要接口有：</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>proto:__call(name, desc)</td><td style="text-align:right">创建Proto对象。name和desc分别是对象的名称和描述，前者可用于过滤器等</td></tr><tr><td>Proto.new(name, desc)</td><td style="text-align:right">创建一个Proto对象</td></tr><tr><td>proto:register_heuristic(listname, func)</td><td style="text-align:right">创建一个启发式解析器（<a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/30/creating-port-independent-wireshark-dissectors-in-lua.html">启发式解析器</a>）</td></tr><tr><td>proto.dissector</td><td style="text-align:right">解析函数，3个参数tvb,pinfo,tree，分别是报文内容，报文信息和解析树结构</td></tr><tr><td>proto.prefs</td><td style="text-align:right">解析器的首选项</td></tr><tr><td>proto.init</td><td style="text-align:right">初始化</td></tr><tr><td>proto.name</td><td style="text-align:right">该解析器的名字</td></tr><tr><td>proto.description</td><td style="text-align:right">该解析器的描述</td></tr><tr><td>proto.fields</td><td style="text-align:right">该解析器的内容（返回 ProtoFeild 表）</td></tr><tr><td>proto.experts</td><td style="text-align:right">该解析器的专家信息</td></tr></tbody></table></div><p>举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> NAME = <span class="string">&quot;bvc_srt&quot;</span></span><br><span class="line"><span class="keyword">local</span> bvc_srt = Proto(NAME, <span class="string">&quot;BVC_SRT Protocol&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 bvc_srt 协议首选项</span></span><br><span class="line">srt_dev.prefs[<span class="string">&quot;srt_udp_port&quot;</span>] = Pref.uint(<span class="string">&quot;SRT UDP Port&quot;</span>, <span class="number">1935</span>, <span class="string">&quot;SRT UDP Port&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注册解析器, 将 bvc_srt 自定义协议挂载到 udp 1935 端口上 </span></span><br><span class="line">DissectorTable.get(<span class="string">&quot;udp.port&quot;</span>):add(<span class="number">1935</span>, bvc_srt)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 也可以直接调用下面函数，每个数据包都会用该 bvc_srt 去解析</span></span><br><span class="line"><span class="comment">-- register_postdissector(bvc_srt)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="2-ProtoField"><a href="#2-ProtoField" class="headerlink" title="2.ProtoField"></a>2.ProtoField</h2><p>表示协议字段，一般用于解析字段后往解析树上添加节点。根据字段类型不同，其接口可以分为两大类。</p><p>这些接口都会返回一个新的字段对象。方括号内是可选字段，花括号内是可替换的类型字段。</p><p>字段可以是 uin8\uin16\uin64\string\char 等等</p><p>如下所示：<br><code>ProtoField.uint8(abbr, [name], [base], [valuestring], [mask], [desc])</code></p><ul><li>abbr: 协议字段缩写，比如 <code>bvc_srt.time_stamp</code>、<code>http.port</code></li><li>name: 字段的实际名字，比如 <code>Time Stamp</code>、<code>HTTP Port</code></li><li>base: 展示的形式，比如时间戳、端口号 是一个int64的十进制数字就可以填 <code>base.DEC</code>,再或者魔术值是一个 16进制数，可以填 <code>base.HEX</code> , 或者是HTTP的Header是字符串，可以填 <code>base.STRING</code></li><li>valuestring: 与值对应的文本表，比如TCP的Flag有 9 位，每一位的对应关系就在这里体现。</li><li>mask: 掩码，与valuestring配合，主要解决的是TCP Flag 的那种情况。</li><li>desc: 描述</li></ul><p>举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fields.peer_ipaddr = ProtoField.ipv4(<span class="string">&quot;bvc_srt.peer_ipaddr&quot;</span>, <span class="string">&quot;Peer IP address&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加到树的时候要注意</span></span><br><span class="line"><span class="comment">-- 如果是网络序，要使用add_le，而不是add</span></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/proto_field.png"><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> flag_select = &#123;[<span class="number">0</span>]=<span class="string">&quot;[Not Set]&quot;</span>,[<span class="number">1</span>]=<span class="string">&quot;[Set]&quot;</span>&#125;</span><br><span class="line">fields.tcp_flag_reserved = ProtoField.uint16(<span class="string">&quot;tcp.flag.reserved&quot;</span>, <span class="string">&quot;Reserved&quot;</span>, base.HEX, flag_select, <span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- TCP Flag 需要 3 字节，这样处理解析器即可, 0b00010000000 做掩码。</span></span><br><span class="line">data_flag_info_tree:add(fields.tcp_flag_reserved, tvb(offset, <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/proto_field_tcp.png"></p><h2 id="3-TVB"><a href="#3-TVB" class="headerlink" title="3.TVB"></a>3.TVB</h2><p>TVB 是 <code>proto.dissector(tvb, pinfo, treeitem)</code> 的第一个参数，我们将在 <code>proto.dissector</code> 函数里做我们的协议解析。</p><p><a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Tvb.html#lua_class_Tvb">Tvb（Testy Virtual Buffer）</a>表示报文缓存，也就是实际的报文数据，可以通过下面介绍的TvbRange从报文数据中解出信息。主要接口有：</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>tvb:__tostring()</td><td style="text-align:right">将报文数据转化为字符串，可用于调试</td></tr><tr><td>tvb:reported_len()</td><td style="text-align:right">get tvb的(not captured)长度</td></tr><tr><td>tvb:len()</td><td style="text-align:right">get tvb的(captured)长度</td></tr><tr><td>tvb:reported_length_remaining()</td><td style="text-align:right">获取当前tvb的剩余长度，如果偏移值大于报文长度，则返回-1</td></tr><tr><td>tvb:offset()</td><td style="text-align:right">返回原始偏移</td></tr><tr><td>tvb:raw()</td><td style="text-align:right">获取tvb中二进制字节的Lua字符串</td></tr></tbody></table></div><p>用法举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- tvb(offset, 4)表示从offset开始之后的4个字节</span></span><br><span class="line">subtree:add_le(fields.peer_ipaddr, tvb(offset, <span class="number">4</span>))</span><br></pre></td></tr></table></figure></p><h2 id="4-TvbRange"><a href="#4-TvbRange" class="headerlink" title="4.TvbRange"></a>4.TvbRange</h2><p>表示Tvb的可用范围，常用来从Tvb中解出信息。主要接口有</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>tvb:range([offset], [length])</td><td style="text-align:right">从tvb创建TvbRange，可选参数分别是偏移和长度，默认值分别是0和总长度</td></tr><tr><td>tvbrange:{type}()</td><td style="text-align:right">将tvbrange所表示范围内的数据转换成type类型的值，type包括但不限于：uint,uint64,int,int64,float,ipv4,ether,nstime,string,ustring,bytes,bitfield等，其中某些类型的方法可以带一些参数</td></tr></tbody></table></div><p>很少在实际使用中用到，大多数会取整个 tvb 进行运算位移。</p><h2 id="5-ByteArray"><a href="#5-ByteArray" class="headerlink" title="5. ByteArray"></a>5. ByteArray</h2><p>字节数组，可与Tvb互相转换。另外字符串也可以换成 <a href="https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Tvb.html#lua_class_ByteArray">ByteArray</a> ，进而换成 Tvb。</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>ByteArray.new([hexbytes], [separator])</td><td style="text-align:right">创建一个新 ByteArray 对象</td></tr><tr><td>bytearray:__concat(first, second)</td><td style="text-align:right">连接两个 ByteArray</td></tr><tr><td>bytearray:append(appended)</td><td style="text-align:right">将 ByteArray 追加到此 ByteArray</td></tr><tr><td>bytearray:len()</td><td style="text-align:right">获取 ByteArray 的长度</td></tr><tr><td>bytearray:subset(offset, length)</td><td style="text-align:right">获取 ByteArray 的一段，作为新的 ByteArray</td></tr><tr><td>bytearray:base64_decode()</td><td style="text-align:right">获取 Base64 解码的 ByteArray</td></tr><tr><td>bytearray:__tostring()</td><td style="text-align:right">获取包含 ByteArray 中的字节的 Lua 字符串，以便可以在显示过滤器中使用它 (例如 “01FE456789AB”)</td></tr><tr><td>bytearray:tvb(name)</td><td style="text-align:right">ByteArray 转Tvb</td></tr><tr><td>bytearray:raw([offset], [length])</td><td style="text-align:right">获取 ByteArray 中的二进制字节的 Lua 字符串</td></tr></tbody></table></div><p>用法举例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proto_foo.dissector</span><span class="params">(buf, pinfo, tree)</span></span></span><br><span class="line">            <span class="comment">-- Create a new tab named &quot;My Tvb&quot; and add some data to it</span></span><br><span class="line">            <span class="keyword">local</span> b = ByteArray.new(<span class="string">&quot;11223344&quot;</span>)</span><br><span class="line">            <span class="keyword">local</span> tvb = ByteArray.tvb(b, <span class="string">&quot;My Tvb&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- Create a tree item that, when clicked, automatically shows the tab we just created</span></span><br><span class="line">            tree:add( tvb(<span class="number">1</span>,<span class="number">2</span>), <span class="string">&quot;Foo&quot;</span> )</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="6-Pinfo"><a href="#6-Pinfo" class="headerlink" title="6. Pinfo"></a>6. Pinfo</h2><p>报文信息(packet information)。主要接口有：</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>pinfo.len pinfo.caplen</td><td style="text-align:right">get报文长度</td></tr><tr><td>pinfo.abs_ts</td><td style="text-align:right">get报文捕获时间</td></tr><tr><td>pinfo.number</td><td style="text-align:right">get报文编号</td></tr><tr><td>pinfo.src pinfo.dst</td><td style="text-align:right">get/set报文的源地址、目的地址</td></tr><tr><td>pinfo.columns pinfo.cols</td><td style="text-align:right">get报文列表列（界面）</td></tr></tbody></table></div><p>用法举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改协议名称（效果见下图）</span></span><br><span class="line">pinfo.cols.protocol = bvc_srt.name</span><br><span class="line"><span class="comment">-- 为报文的信息尾部添加字符串（效果见下图）</span></span><br><span class="line">pinfo.cols.info:append(<span class="string">&quot; [ACK]&quot;</span>)</span><br><span class="line"><span class="comment">-- 还有一种便是直接覆盖</span></span><br><span class="line">pinfo.cols.info = <span class="string">&quot;[ACK]&quot;</span></span><br></pre></td></tr></table></figure><br><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_pinfo.png"></p><h2 id="7-TreeItem"><a href="#7-TreeItem" class="headerlink" title="7. TreeItem"></a>7. TreeItem</h2><p>表示报文解析树中的一个树节点。主要接口有：</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>treeitem:add([protofield], [tvbrange], [value], [label])</td><td style="text-align:right">向当前树节点添加一个子节点</td></tr><tr><td>treeitem:set_text(text)</td><td style="text-align:right">设置当前树节点的文本</td></tr><tr><td>treeitem:prepend_text(text)</td><td style="text-align:right">在当前树节点文本的前面加上text</td></tr><tr><td>treeitem:append_text(text)</td><td style="text-align:right">在当前树节点文本的后面加上text</td></tr></tbody></table></div><p>还有注意一下网络字节序的问题，如果是网络字节序需要用add_le添加节点~<br>添加节点举例<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtree:add(fields.dst_sock, tvb(offset, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><br>实现协议里面添加子树例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子树其实也是一个节点，因此也需要在fields里面添加字段</span></span><br><span class="line">fields.pack_type_tree = ProtoField.uint32(NAME .. <span class="string">&quot;.pack_type_tree&quot;</span>, <span class="string">&quot;Packet Type&quot;</span>, base.HEX)</span><br><span class="line"><span class="comment">-- 创建子树</span></span><br><span class="line">pack_type_tree = subtree:add(fields.pack_type_tree, tvb(offset, <span class="number">4</span>))</span><br><span class="line">pack_type_tree:add(fields.msg_type, tvb(offset, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_treeitem.png"></p><h2 id="8-Fields"><a href="#8-Fields" class="headerlink" title="8. Fields"></a>8. Fields</h2><p>获得Wireshark已有协议字段。</p><div class="table-container"><table><thead><tr><th>接口</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Field.new(fieldname)</td><td style="text-align:right">获得一个字段</td></tr><tr><td>all_field_infos()</td><td style="text-align:right">获取当前packet的 field 信息</td></tr></tbody></table></div><p>wireshark 本身已有大量的字段，比如我们想要获取 http2 的data 帧的内容，即可用 <code>http2.data.data</code> 获取。具体的fields 可以通过以下方式获得。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = Field.list()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, name <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/wireshark/lua_api_fields.png" style="height:400px"></p><p>可以为tap定义一个回调函数packet，每当有http协议的报文时wireshark将调用这个函数，参数tvb是报文的二进制缓冲区。在该函数中调用Field变量可以取得分析好的字段，如果不存在返回nil。</p><p>我们要截获的http协议包就包括这几层协议Frame,IP,TCP,HTTP,data-text-lines（这个是http内容）,这些上层协议的字段你都可以通过Field字段取得。<br>下面这一个截获框架，你可以使用tshark -X lua_script:tap.lua来执行这个例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tap = Listener.new(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> http = Field.new(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> host = Field.new(<span class="string">&quot;http.host&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> location = Field.new(<span class="string">&quot;http.location&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dst_ip = Field.new(<span class="string">&quot;ip.dst&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> src_ip = Field.new(<span class="string">&quot;ip.src&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dst_port = Field.new(<span class="string">&quot;tcp.dstport&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> src_port = Field.new(<span class="string">&quot;tcp.srcport&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> text = Field.new(<span class="string">&quot;data-text-lines&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.packet</span><span class="params">(pinfo,tvb,tapinfo)</span></span></span><br><span class="line">    <span class="comment">--获取对应的字段</span></span><br><span class="line">    <span class="keyword">local</span> dst = dst_ip()</span><br><span class="line">    <span class="keyword">local</span> src = src_ip()</span><br><span class="line">    <span class="keyword">local</span> h = host()</span><br><span class="line">    <span class="keyword">local</span> dstp = dst_port()</span><br><span class="line">    <span class="keyword">local</span> srcp = src_port()</span><br><span class="line">    <span class="comment">--这里可以对截获的数据做存储打印等处理</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">tostring</span>(dst))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;host : &quot;</span>..<span class="built_in">tostring</span>(h))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.draw</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;draw called&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap.reset</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;reset called&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也可以调用 <code>all_field_infos</code> 获取当前 packet 中的信息，比如说以下这个 <code>MQTT Over Websocket</code> 的例子。</p><p><a href="https://cloud.tencent.com/developer/article/1093536">https://cloud.tencent.com/developer/article/1093536</a></p><h1 id="创建-Lua-解析器"><a href="#创建-Lua-解析器" class="headerlink" title="创建 Lua 解析器"></a>创建 Lua 解析器</h1><p>以下会的内容是搜集网上的一些优秀的介绍关于如何使用。</p><h2 id="MongoDB-dissector"><a href="#MongoDB-dissector" class="headerlink" title="MongoDB dissector"></a>MongoDB dissector</h2><p>以下的5篇文章是我从全网找到的最详尽的 lua 自定义协议解析脚本的教程。<br>从Lua基础到协议解析的全过程进行了阐述，从TCP Data 中解析 MongoDB 协议。</p><p>原文地址：</p><ul><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/04/creating-a-wireshark-dissector-in-lua-1.html">Creating a Wireshark dissector in Lua - part 1 (the basics)</a></li><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/06/creating-a-wireshark-dissector-in-lua-2.html">Creating a Wireshark dissector in Lua - part 2 (debugging and a more advanced dissector)</a></li><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2017/11/08/creating-a-wireshark-dissector-in-lua-3.html">Creating a Wireshark dissector in Lua - part 3 (parsing the payload)</a></li><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/16/creating-a-wireshark-dissector-in-lua-4.html">Creating a Wireshark dissector in Lua - part 4 (separate subtrees)</a></li><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/18/creating-a-wireshark-dissector-in-lua-5.html">Creating a Wireshark dissector in Lua - part 5 (modularization)</a></li></ul><p>Other</p><ul><li><a href="https://mika-s.github.io/wireshark/lua/dissector/2018/12/30/creating-port-independent-wireshark-dissectors-in-lua.html">Creating port-independent (heuristic) Wireshark dissectors in Lua</a></li></ul><h2 id="SRT协议的Wireshark解析器编写"><a href="#SRT协议的Wireshark解析器编写" class="headerlink" title="SRT协议的Wireshark解析器编写"></a>SRT协议的Wireshark解析器编写</h2><p>该文章也详细介绍了如何使用wireshark解析一个自定义协议，本文的内容也有一些参考了本文章。 github 上的 <code>srt-dev.lua</code> 也是 比较全的例子。</p><p>原文地址：</p><ul><li><a href="https://blog.csdn.net/Boring_Wednesday/article/details/99695507">SRT协议的Wireshark解析器编写</a></li></ul><p>wireshark 解析脚本示例：</p><ul><li><a href="https://github.com/Haivision/srt/blob/master/scripts/srt-dev.lua">https://github.com/Haivision/srt/blob/master/scripts/srt-dev.lua</a></li></ul><h2 id="解析Websocket上的MQTT协议"><a href="#解析Websocket上的MQTT协议" class="headerlink" title="解析Websocket上的MQTT协议"></a>解析Websocket上的MQTT协议</h2><p>这篇文章被我单独列出的一个重要原因是，这个文章列举了如何实现，在已有协议之上的 payload 接着解析协议。比如本例中的在 websocket 的payload 之上解析 MQTT 协议。</p><p>原文地址:</p><ul><li><a href="https://cloud.tencent.com/developer/article/1093536">Lua编写wireshark插件初探——解析Websocket上的MQTT协议</a></li></ul><p>github 地址：</p><ul><li><a href="https://github.com/a3135134/Wireshark-Plugin-MQTToverWebSocket/blob/master/mqttoverwebsocket.lua">https://github.com/a3135134/Wireshark-Plugin-MQTToverWebSocket/blob/master/mqttoverwebsocket.lua</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wireshark集成了Lua解释器，以支持Lua脚本（自己编译的话根据编译配置决定是否支持Lua）。&lt;/p&gt;
&lt;p&gt;启动wireshark，依次点击“Help”，”About Wireshark“菜单，在打开的对话框中的”Wireshark”标签页上观察版本信息，如果如下图一样显示With Lua，说明此版本支持Lua插件。&lt;/p&gt;
&lt;p&gt;然后打开wireshark主目录下的init.lua文件，确保disable_lua的值为false，即开启了lua：&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="wireshark" scheme="http://kiosk007.top/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>如何减少TTFB以提升WordPress加载性能</title>
    <link href="http://kiosk007.top/2021/06/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91TTFB%E4%BB%A5%E6%8F%90%E9%AB%98%E7%BD%91%E9%A1%B5%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4/"/>
    <id>http://kiosk007.top/2021/06/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91TTFB%E4%BB%A5%E6%8F%90%E9%AB%98%E7%BD%91%E9%A1%B5%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4/</id>
    <published>2021-06-05T03:19:00.000Z</published>
    <updated>2021-06-05T03:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当谈论到你的 <a href="What Is WordPress? Explained for Beginners">WordPress Site</a> 加载性能时，大多数我们都是在关注前端的性能优化来提升页面加载速度。然而我们有时候应该从服务端视角来看待这个问题。今天我们来讨论一下 <strong>TTFB (time to first byte)</strong> 是怎么影响你的网站加载速度，另外我们如何去降低他。TTFB是一个经常会被忽略的重要性能因素，但是我们在网站性能优化是必须考虑进来。</p><p><img src="http://img1.kiosk007.top/static/images/network/performance/ttfb.png" style="height:300px"></p><p>— 译 <a href="https://kinsta.com/blog/ttfb/">How to Reduce TTFB to Improve WordPress Page Load Times</a></p><a id="more"></a><ul><li><a href>什么是TTFB?</a></li><li><a href>TTFB 重要吗？</a></li><li><a href>如何测量TTFB？</a></li><li><a href>4种方法来减少Wordpress站点的TTFB</a></li></ul><h1 id="什么是TTFB？"><a href="#什么是TTFB？" class="headerlink" title="什么是TTFB？"></a>什么是TTFB？</h1><p>TTFB 表示”首字节时间”, 简单的说，表示从浏览器收到服务端的第一个字节所需要的时间。TTFB时间越长、那么页面加载显示的时间就越长。一个常见的误解是，这个时间主要是DNS查找时间计算的。然而，真正的 <a href="https://en.wikipedia.org/wiki/Time_To_First_Byte">TTFB</a> 其实包含整个网络期间的时延。并且以下三个步骤之和才是总的TTFB。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/waiting-ttfb.jpg" style="height:300px"></p><h2 id="1-请求服务"><a href="#1-请求服务" class="headerlink" title="1. 请求服务"></a>1. 请求服务</h2><p>当有用户访问你的网站时。发生的第一件事是客户端（浏览器）会先发送一个HTTP请求。在此步骤中，可能有多种因素导致延迟、<strong>缓慢的DNS</strong> 查找时间可能会增加请求的时间。如果服务器在地理上很远，这可能会导致数据传输距离的延迟。此外，如果您有复杂的防火墙规则，这可能会增加路由时间。并且不要忘记客户端的互联网速度。</p><h2 id="2-服务端处理耗时"><a href="#2-服务端处理耗时" class="headerlink" title="2. 服务端处理耗时"></a>2. 服务端处理耗时</h2><p>发送请求后，服务器现在必须处理它并生成响应。这可能会引入许多不同的延迟，例如<strong>缓慢的数据库调用</strong>、过多的第三方脚本、<strong>未缓存</strong>第一个响应、糟糕的代码或 WordPress 主题以及低效的服务器资源，例如<strong>磁盘 I/O</strong> 或<strong>内存</strong>。</p><h2 id="3-响应"><a href="#3-响应" class="headerlink" title="3. 响应"></a>3. 响应</h2><p>服务器处理完请求后，必须将其发送回客户端（或者更确切地说是发送回第一个字节）。这受到服务器和客户端网络速度的影响。如果客户端的 Wi-Fi 热点速度较慢，这将反映在 TTFB 中。</p><h1 id="TTFB-重要吗？"><a href="#TTFB-重要吗？" class="headerlink" title="TTFB 重要吗？"></a>TTFB 重要吗？</h1><p>重要的是要了解 TTFB（到第一个字节的时间）与网站速度不同。这实际上是对响应能力的衡量。网络上有很多关于 TTFB 是否重要的​​讨论。有人说它毫无意义（<a href="https://blog.cloudflare.com/ttfb-time-to-first-byte-considered-meaningles/">Cloudflare</a>、<a href>LittleBizzy</a>），而另一些人说它很重要（<a href="https://plus.google.com/+IlyaGrigorik/posts/GTWYbYWP6xP">Ilya Grigorik</a>，Google 的 Web 性能工程师）。双方都提出了一些关于为什么或为什么不重要的有效观点，以及关于它如何实际计算的一些问题。</p><p>Moz 甚至对<a href="https://moz.com/blog/improving-search-rank-by-optimizing-your-time-to-first-byte">搜索排名与第一个字节的时间之间的相关性</a>进行了深入研究。 但是，很难知道搜索排名是否是和TTFB相关的 。或者 TTFB 较低的网站是否也只是总体上更快。</p><p>然而，与其花时间讨论是否重要，我们宁愿专注于可以做的优化来改进这个指标。在我们具有更大 TTFB 的测试站点中，只需加载并感觉更慢。</p><p>通常，<strong>低于 100 毫秒的TTFB 都很棒</strong>。<a href="https://kinsta.com/blog/google-pagespeed-insights/">Google PageSpeed Insights</a> 建议服务器响应时间小于 200 毫秒。如果您在 300-500 毫秒范围内，这是非常标准的。如果超过 600 毫秒，您的服务或者链路可能有问题，或者可能是时候升级到更好的 Web 服务了。或者按照我们下面有关如何减少 TTFB 的建议进行操作。SSL/TLS 协商也可能是一个点。</p><h1 id="如何测量TTFB"><a href="#如何测量TTFB" class="headerlink" title="如何测量TTFB"></a>如何测量TTFB</h1><p>可以通过多种不同的方式来测试你站点的 TTFB。下面将探索一些。但请记住，每种工具都会给出略有不同的结果，因此重要的是只使用一种工具并坚持使用它作为基线。</p><h2 id="使用-Google-Chrome-DevTools-测量-TTFB"><a href="#使用-Google-Chrome-DevTools-测量-TTFB" class="headerlink" title="使用 Google Chrome DevTools 测量 TTFB"></a>使用 Google Chrome DevTools 测量 TTFB</h2><p>可以通过启动DevTools在 Google Chrome 中测量 TTFB 。但请记住，如果您在计算机上测试 TTFB 会受到网络延迟和 Internet 连接的影响。因此，使用从数据中心进行测试的第 3 方工具（如下所示）可能更有效。</p><ul><li>从 Chrome 菜单中选择更多工具 &gt; 开发者工具。</li><li>右键单击页面元素并选择检查</li><li>使用键盘快捷键Ctrl+ Shift+ I(Windows) 或Cmd+ Opt+ I(Mac)</li><li>您可以启动网络窗口并查看站点的性能。</li></ul><p><img src="https://img1.kiosk007.top/static/images/network/performance/google-chrome-devtools-ttfb.jpg" style="height:300px"></p><h2 id="使用-Geekflare-的工具测量-TTFB"><a href="#使用-Geekflare-的工具测量-TTFB" class="headerlink" title="使用 Geekflare 的工具测量 TTFB"></a>使用 Geekflare 的工具测量 TTFB</h2><p>Geekflare 拥有一系列很棒的免费工具，您可以使用它们来测试和排除网站上的问题。<a href="https://gf.dev/ttfb-test">Geekflare</a> 的 TTFB 工具简单、快速，可让您查看从全球三个位置获取第一个字节的时间有多快（低）</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/geekflare.png" style="height:300px"></p><h2 id="使用-WebPageTest-测量-TTFB"><a href="#使用-WebPageTest-测量-TTFB" class="headerlink" title="使用 WebPageTest 测量 TTFB"></a>使用 WebPageTest 测量 TTFB</h2><p>您还可以使用 <a href="https://www.webpagetest.org/">WebPageTest</a> 测量您的 TTFB 。根据他们的术语表，目标时间是 DNS、套接字和 SSL 协商所需的时间 + 100 毫秒。超出目标每100ms扣除一个字母等级。正如您在下面的测试中所见，该站点的 TTFB 为 0.256 秒或 256 毫秒。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/webpagetest-ttfb.jpg" style="height:300px"></p><h2 id="用-Pingdom-测量-TTFB"><a href="#用-Pingdom-测量-TTFB" class="headerlink" title="用 Pingdom 测量 TTFB"></a>用 Pingdom 测量 TTFB</h2><p>Chrome 和 WebPageTest 将其称为 TTFB。但是，如果您使用Pingdom，它实际上被称为“等待”时间。请务必查看我们关于如何使用 Pingdom的深入指南。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/wait-time-pingdom.jpg" style="height:300px"></p><h2 id="使用-GTmetrix-测量-TTFB"><a href="#使用-GTmetrix-测量-TTFB" class="headerlink" title="使用 GTmetrix 测量 TTFB"></a>使用 GTmetrix 测量 TTFB</h2><p>在 GTmetrix 中，就像 Pingdom 一样，TTFB 被称为等待时间。请务必查看我们关于如何使用 <a href="https://kinsta.com/blog/gtmetrix-speed-test/">GTmetrix的深入指南</a> 。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/gtmetrix-waiting.png" style="height:300px"></p><h2 id="使用-KeyCDN-的工具测量-TTFB"><a href="#使用-KeyCDN-的工具测量-TTFB" class="headerlink" title="使用 KeyCDN 的工具测量 TTFB"></a>使用 KeyCDN 的工具测量 TTFB</h2><p>KeyCDN 有一个很棒的 <a href="https://tools.keycdn.com/performance">网络性能测试工具</a> ，您可以在其中同时从 14 个不同的位置测量您的 TTFB。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/keycdn-ttfb-test.jpg" style="height:300px"></p><p>还有一些其他各种工具可以测量 TTFB，例如<a href="https://performance.sucuri.net/">Sucuri Performance Tool</a>和<a href="http://www.bytecheck.com/">ByteCheck</a>。</p><p><img src="https://img1.kiosk007.top/static/images/network/performance/google-analytics-ttfb.jpg" style="height:300px"></p><h1 id="减少-WordPress-网站上-TTFB-的-4-种方法"><a href="#减少-WordPress-网站上-TTFB-的-4-种方法" class="headerlink" title="减少 WordPress 网站上 TTFB 的 4 种方法"></a>减少 WordPress 网站上 TTFB 的 4 种方法</h1><blockquote><p>现在让我们深入探讨如何减少 WordPress 网站上的 TTFB。</p></blockquote><h2 id="1-使用快速的-WordPress-主机"><a href="#1-使用快速的-WordPress-主机" class="headerlink" title="1. 使用快速的 WordPress 主机"></a>1. 使用快速的 WordPress 主机</h2><p>减少 TTFB 的第一种方法是确保您使用的是快速的 WordPress 主机。我们比较了第三方云服务器的 TTFB（位于亚利桑那州凤凰城）和 Kinsta 的 TTFB（位于爱荷华州康瑟尔布拉夫斯）。我们使用了完全相同的设置，运行默认的 27 主题。Kinsta 现在拥有所有 25 个可用的Google Cloud Platform 节点，因此战略性地将您的 WordPress 站点放置在离访问者更近的位置非常重要。</p><p>切换到更快的主机可以将您网站的 TTFB 减少多达 200%。</p><p>Kinsta 还在 所有托管计划中使用了 Google Cloud Platform 的高级网络。许多其他托管服务提供商使用 Google Cloud 的标准层网络，这会导致速度变慢。</p><p>在所有地区，平均 TTFB 为 520 毫秒。在美国和加拿大，平均 TTFB 为 240 毫秒。</p><p>因此，仅通过使用更快的主机，可以显著降低 TTFB </p><h2 id="2-CDN-or-DSA"><a href="#2-CDN-or-DSA" class="headerlink" title="2. CDN or DSA"></a>2. CDN or DSA</h2><p>另一种减少 TTFB 的简单方法是利用 <strong><a href="https://kinsta.com/blog/wordpress-cdn/">内容交付网络</a></strong> (CDN)。如果您的网站为该国不同地区或全球的访问者提供服务，这会大大降低您的 TTFB。正如我们在上面看到的，位置非常重要。我们进行了一个小测试，以显示 KeyCDN 作为我们的 CDN 提供商的不同之处。每个测试运行 5 次并取平均值。</p><ul><li>没有 CDN 的 TTFB</li></ul><p>我们首先在禁用 CDN 的情况下运行测试，我们的总加载时间为 1.45 秒，资产的平均 TTFB 约为 136 毫秒。</p><ul><li>带 CDN 的 TTFB<br>我们的总加载时间下降到 788 毫秒，我们的平均 TTFB 现在是 37 毫秒！CDN 可以带来多大的不同</li></ul><p>注意：如果您使用 Cloudflare，您的TTFB可能略高。这很可能是由于运行完全代理服务的额外开销和复杂性。Cloudflare 具有某些 CDN 提供商没有的其他防火墙和其他功能。</p><h2 id="3-WordPress-缓存"><a href="#3-WordPress-缓存" class="headerlink" title="3. WordPress 缓存"></a>3. WordPress 缓存</h2><p>减少 TTFB 的第三种方法，也可能是最简单的方法之一，就是在 WordPress 网站上使用缓存。许多人只认为缓存可以帮助减少加载时间，但实际上，它也有助于减少 TTFB，因为它有助于减少服务器处理时间。</p><h2 id="4-使用高级-DNS-提供商"><a href="#4-使用高级-DNS-提供商" class="headerlink" title="4. 使用高级 DNS 提供商"></a>4. 使用高级 DNS 提供商</h2><p>DNS 也在 TTFB 中发挥作用。很难准确计算它受到的影响有多大，但您仍然可以看到总体 DNS 查找时间，并看到那里有越来越快的提供商。</p><p><a href="http://www.solvedns.com/dnsspeedtest/">SolveDNS 速度测试工具</a> 可以帮我们测试DNS解析速度。 大的云厂商，如 AWS 会比一些免费的DNS提供商的质量要好很多。</p><p>更多内容可以查看 [Why Premium DNS is No Longer Optional][<a href="https://kinsta.com/blog/premium-dns/">https://kinsta.com/blog/premium-dns/</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当谈论到你的 &lt;a href=&quot;What Is WordPress? Explained for Beginners&quot;&gt;WordPress Site&lt;/a&gt; 加载性能时，大多数我们都是在关注前端的性能优化来提升页面加载速度。然而我们有时候应该从服务端视角来看待这个问题。今天我们来讨论一下 &lt;strong&gt;TTFB (time to first byte)&lt;/strong&gt; 是怎么影响你的网站加载速度，另外我们如何去降低他。TTFB是一个经常会被忽略的重要性能因素，但是我们在网站性能优化是必须考虑进来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.kiosk007.top/static/images/network/performance/ttfb.png&quot; style=&quot;height:300px&quot;&gt;&lt;/p&gt;
&lt;p&gt;— 译 &lt;a href=&quot;https://kinsta.com/blog/ttfb/&quot;&gt;How to Reduce TTFB to Improve WordPress Page Load Times&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
  </entry>
  
  <entry>
    <title>curl 命令小结</title>
    <link href="http://kiosk007.top/2021/05/29/curl-%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>http://kiosk007.top/2021/05/29/curl-%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</id>
    <published>2021-05-29T07:22:00.000Z</published>
    <updated>2021-05-29T07:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>curl 命令是我日常工作中最常用的命令之一，所以很有必要总结一下curl命令的一些用法。如统计耗时、以指定的ip访问某个域名。添加携带某些Header等。curl命令绝对是日常debug之神。</p><p><img src="https://img1.kiosk007.top/static/images/network/curl/curl-command.png" style="height:200px"></p><a id="more"></a><ul><li>curl 官网：<a href="https://curl.se">https://curl.se</a></li><li>curl 支持：<br>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP. curl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, HTTP/2, HTTP/3, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, SCRAM-SHA, NTLM, Negotiate and Kerberos), file transfer resume, proxy tunneling and more.</li></ul><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><ul><li>指定解析：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://github.com --resolve github.com:443:13.229.188.59 -v -o /dev/null</span><br></pre></td></tr></table></figure><ul><li>POST请求携带json数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X POST -d <span class="string">&#x27;&#123;&quot;abc&quot;:123,&quot;bcd&quot;:&quot;nihao&quot;&#125;&#x27;</span> URL</span><br></pre></td></tr></table></figure><ul><li>修改请求头</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;host: www.baidu.com&quot;</span> https://127.0.0.1</span><br></pre></td></tr></table></figure><ul><li>限速</li></ul><p>限制curl使用的最大带宽；如果未指定单位，默认单位为“bytes/秒”，你也可以指定单位为“K”、“M”、“G”等单位，如：“—limit-rate 1m”为限制最大使用带宽为“1m字节/秒”；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://www.baidu.com --limit-rate 10k</span><br></pre></td></tr></table></figure></p><ul><li>下载</li></ul><p>显示进度条(option：-#)或不显示进度条(option：-s)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="comment"># -O https://img1.kiosk007.top/static/images/network/curl/curl-command.png</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p>curl 命令提供了 -w 参数，这个参数在 manpage 是这样解释的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-w, --write-out &lt;format&gt;</span><br><span class="line">              Make curl display information on stdout after a completed transfer. The format is a string that may contain plain text mixed with any number of variables. The</span><br><span class="line">              format can be specified as a literal <span class="string">&quot;string&quot;</span>, or you can have curl <span class="built_in">read</span> the format from a file with <span class="string">&quot;@filename&quot;</span> and to tell curl  to  <span class="built_in">read</span>  the  format  from</span><br><span class="line">              stdin you write <span class="string">&quot;@-&quot;</span>.</span><br><span class="line"></span><br><span class="line">              The  variables  present <span class="keyword">in</span> the output format will be substituted by the value or text that curl thinks fit, as described below. All variables are specified as</span><br><span class="line">              %&#123;variable_name&#125; and to output a normal % you just write them as %%. You can output a newline by using \n, a carriage <span class="built_in">return</span> with \r and a tab space with \t.</span><br><span class="line"></span><br><span class="line">              The output will be written to standard output, but this can be switched to standard error by using %&#123;stderr&#125;.</span><br><span class="line"></span><br><span class="line">              NOTE: The %-symbol is a special symbol <span class="keyword">in</span> the win32-environment, <span class="built_in">where</span> all occurrences of % must be doubled when using this option.</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>它能够按照指定的格式打印某些信息，里面可以使用某些特定的变量，而且支持 \n、\t和 \r 转义字符。提供的变量很多，比如 status<em>code、local_port、size_download 等等，这篇文章我们只关注和请求时间有关的变量（以 time</em> 开头的变量）。</p><p>具体支持的变量如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">% content_type   The Content-Type of the requested document, <span class="keyword">if</span> there was any.</span><br><span class="line"></span><br><span class="line">% filename_effective   The ultimate filename that curl writes out to. This is only meaningful <span class="keyword">if</span> curl is told to write to a file with the  -O,  --remote-name  or  -o, --output option. It<span class="string">&#x27;s most useful in combination with the -J, --remote-header-name option. (Added in 7.26.0)&#x27;</span></span><br><span class="line"></span><br><span class="line">% ftp_entry_path The initial path curl ended up <span class="keyword">in</span> when logging on to the remote FTP server. (Added <span class="keyword">in</span> 7.15.4)</span><br><span class="line"></span><br><span class="line">% http_code      The  numerical  response  code  that was found <span class="keyword">in</span> the last retrieved HTTP(S) or FTP(s) transfer. In 7.18.2 the <span class="built_in">alias</span> response_code was added to show the same info.</span><br><span class="line"></span><br><span class="line">% http_connect   The numerical code that was found <span class="keyword">in</span> the last response (from a proxy) to a curl CONNECT request. (Added <span class="keyword">in</span> 7.12.4)</span><br><span class="line"></span><br><span class="line">% http_version   The http version that was effectively used. (Added <span class="keyword">in</span> 7.50.0)</span><br><span class="line"></span><br><span class="line">% local_ip       The IP address of the <span class="built_in">local</span> end of the most recently <span class="keyword">done</span> connection - can be either IPv4 or IPv6 (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% local_port     The <span class="built_in">local</span> port number of the most recently <span class="keyword">done</span> connection (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% num_connects   Number of new connects made <span class="keyword">in</span> the recent transfer. (Added <span class="keyword">in</span> 7.12.3)</span><br><span class="line"></span><br><span class="line">% num_redirects  Number of redirects that were followed <span class="keyword">in</span> the request. (Added <span class="keyword">in</span> 7.12.3)</span><br><span class="line"></span><br><span class="line">% proxy_ssl_verify_result   The result of the HTTPS proxy<span class="string">&#x27;s SSL peer certificate verification that was requested. 0  means  the  verification  was  successful.  (Added  in 7.52.0)&#x27;</span></span><br><span class="line"></span><br><span class="line">% redirect_url   When an HTTP request was made without -L, --location to follow redirects (or when --max-redir is met), this variable will show the actual URL a redirect would have gone to. (Added <span class="keyword">in</span> 7.18.2)</span><br><span class="line"></span><br><span class="line">% remote_ip      The remote IP address of the most recently <span class="keyword">done</span> connection - can be either IPv4 or IPv6 (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br><span class="line">% remote_port    The remote port number of the most recently <span class="keyword">done</span> connection (Added <span class="keyword">in</span> 7.29.0)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>先往文本文件 curl-format.txt 写入下面的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat curl-format.txt</span><br><span class="line">time_namelookup:  %&#123;time_namelookup&#125;\n</span><br><span class="line">time_connect:  %&#123;time_connect&#125;\n</span><br><span class="line">time_appconnect:  %&#123;time_appconnect&#125;\n</span><br><span class="line">time_pretransfer:  %&#123;time_pretransfer&#125;\n</span><br><span class="line">time_redirect:  %&#123;time_redirect&#125;\n</span><br><span class="line">time_starttransfer:  %&#123;time_starttransfer&#125;\n</span><br><span class="line">----------\n</span><br><span class="line">time_total:  %&#123;time_total&#125;\n</span><br><span class="line">http_code:  %&#123;http_code&#125;\n</span><br><span class="line">----------\n</span><br><span class="line">local_ip:  %&#123;local_ip&#125;\n</span><br><span class="line">size_download:  %&#123;size_download&#125;\n</span><br><span class="line">size_header:  %&#123;size_header&#125;\n</span><br><span class="line">size_request:  %&#123;size_request&#125;\n</span><br><span class="line">size_upload:  %&#123;size_upload&#125;\n</span><br><span class="line">speed_download:  %&#123;speed_download&#125;\n</span><br><span class="line">speed_upload:  %&#123;speed_upload&#125;\n</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ul><li>ime_namelookup：DNS 域名解析的时候，就是把 <a href="https://zhihu.com">https://zhihu.com</a> 转换成 ip 地址的过程</li><li>time_connect：TCP 连接建立的时间，就是三次握手的时间</li><li>time_appconnect：SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间</li><li>time_redirect：从开始到最后一个请求事务的时间</li><li>time_pretransfer：从请求开始到响应开始传输的时间</li><li>time_starttransfer：从请求开始到第一个字节将要传输的时间</li><li>time_total：这次请求花费的全部时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">% curl -w<span class="string">&quot;@curl-format.txt&quot;</span> -o /dev/null -s -L https://kiosk007.top/   </span><br><span class="line">time_namelookup:  0.011032</span><br><span class="line">time_connect:  0.103585</span><br><span class="line">time_appconnect:  0.235695</span><br><span class="line">time_pretransfer:  0.235911</span><br><span class="line">time_redirect:  0.000000</span><br><span class="line">time_starttransfer:  0.375289</span><br><span class="line">----------</span><br><span class="line">time_total:  0.657439</span><br><span class="line">http_code:  200</span><br><span class="line">----------</span><br><span class="line">local_ip:  192.168.0.112</span><br><span class="line">size_download:  18180</span><br><span class="line">size_header:  661</span><br><span class="line">size_request:  74</span><br><span class="line">size_upload:  0</span><br><span class="line">speed_download:  27671.000</span><br><span class="line">speed_upload:  0.000</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="HTTP3-新特性"><a href="#HTTP3-新特性" class="headerlink" title="HTTP3 新特性"></a>HTTP3 新特性</h1><p><a href="https://curl.se/docs/http3.html">https://curl.se/docs/http3.html</a></p><p>curl 可以基于 <a href="https://github.com/cloudflare/quiche">quiche</a> 实现HTTP3 的能力，当前H3的草案还没有完全定稿，所以curl 的quic不一定能够访问成功所有的QUIC服务端实现。</p><p>通过以下方式编译支持H3特性的curl</p><p>Build quiche and BoringSSL:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% git <span class="built_in">clone</span> --recursive https://github.com/cloudflare/quiche</span><br><span class="line">% <span class="built_in">cd</span> quiche</span><br><span class="line">% cargo build --release --features ffi,pkg-config-meta,qlog</span><br><span class="line">% mkdir deps/boringssl/src/lib</span><br><span class="line">% ln -vnf $(find target/release -name libcrypto.a -o -name libssl.a) deps/boringssl/src/lib/</span><br></pre></td></tr></table></figure><br>Build curl:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">cd</span> ..</span><br><span class="line">% git <span class="built_in">clone</span> https://github.com/curl/curl</span><br><span class="line">% <span class="built_in">cd</span> curl</span><br><span class="line">% ./buildconf</span><br><span class="line">% ./configure LDFLAGS=<span class="string">&quot;-Wl,-rpath,<span class="variable">$PWD</span>/../quiche/target/release&quot;</span> --with-openssl=<span class="variable">$PWD</span>/../quiche/deps/boringssl/src --with-quiche=<span class="variable">$PWD</span>/../quiche/target/release</span><br><span class="line">% make</span><br></pre></td></tr></table></figure><br>Use HTTP/3 directly:</p><p><code>curl --http3 https://nghttp2.org:4433/</code><br>Upgrade via Alt-Svc:</p><p><code>curl --alt-svc altsvc.cache https://quic.aiortc.org/</code></p><p>See this list of <a href="https://bagder.github.io/HTTP3-test/">public HTTP/3 servers</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;curl 命令是我日常工作中最常用的命令之一，所以很有必要总结一下curl命令的一些用法。如统计耗时、以指定的ip访问某个域名。添加携带某些Header等。curl命令绝对是日常debug之神。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img1.kiosk007.top/static/images/network/curl/curl-command.png&quot; style=&quot;height:200px&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="ops" scheme="http://kiosk007.top/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>Go 测试框架 stretchr/testify</title>
    <link href="http://kiosk007.top/2021/04/29/Go-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-stretchr-testify/"/>
    <id>http://kiosk007.top/2021/04/29/Go-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-stretchr-testify/</id>
    <published>2021-04-29T14:43:40.000Z</published>
    <updated>2021-04-29T14:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>golang的测试框架stretchr/testify 简单的API去检验你的GoLang代码按照你的意愿运行。</p><p>项目地址： <code>https://github.com/stretchr/testify</code></p><a id="more"></a><p><strong>特性：</strong></p><ul><li>易用的断言接口 (<a href="https://github.com/stretchr/testify#assert-package">Easy assertions</a>)</li><li>接口模拟 (<a href="https://github.com/stretchr/testify#mock-package">Mocking</a>)</li><li>测试套件接口与性能 (<a href="https://github.com/stretchr/testify#suite-package">Testing suite interfaces and functions</a>)</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用 <code>go get</code> 安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/stretchr/testify</span><br></pre></td></tr></table></figure><br>安装后获得以下包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">github.com/stretchr/testify/assert</span><br><span class="line">github.com/stretchr/testify/require</span><br><span class="line">github.com/stretchr/testify/mock</span><br><span class="line">github.com/stretchr/testify/suite</span><br><span class="line">github.com/stretchr/testify/http (deprecated</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>assert package</li><li>require package</li><li>mock package</li><li>suite package</li></ul><p><strong>这里面最常用的是前两个 package，他们的唯一差别就是require的函数会直接导致case结束，而assert虽然也标记为case失败，但case不会退出，而是继续往下执行</strong></p><h2 id="assert-package"><a href="#assert-package" class="headerlink" title="assert package"></a>assert package</h2><p><code>assert</code> 包提供了一些有用的方法，允许您在Go中编写更好的测试代码。</p><ul><li>友好输出，更详细的问题描述</li><li>代码可读性强</li><li>可以选择用消息注释断言</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCase1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Bob&quot;</span></span><br><span class="line">age := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">assert.Equal(t, <span class="string">&quot;Bob&quot;</span>, name)</span><br><span class="line">assert.Equal(t, <span class="number">20</span>, age,<span class="string">&quot;年龄不相等&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestCase1</span><br><span class="line">    TestCase1: abc_test.go:18: </span><br><span class="line">        Error Trace:abc_test.go:18</span><br><span class="line">        Error:      Not equal: </span><br><span class="line">                    expected: 20</span><br><span class="line">                    actual  : 10</span><br><span class="line">        Test:       TestCase1</span><br><span class="line">        Messages:   年龄不相等</span><br><span class="line">--- FAIL: TestCase1 (0.00s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Expected :20</span><br><span class="line">Actual   :10</span><br><span class="line">&lt;Click to see difference&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FAIL</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="require-package"><a href="#require-package" class="headerlink" title="require package"></a>require package</h2><p><code>require</code>包提供与assert包相同的全局函数，但它们不会返回布尔结果，而是终止当前测试。</p><h2 id="mock-package"><a href="#mock-package" class="headerlink" title="mock package"></a>mock package</h2><p><code>mock</code>包提供了一种机制，可以方便地编写mock对象，在编写测试代码时可以用它代替真实对象。</p><p>如下一个示例测试函数，它测试依赖外部对象<code>testObj</code>的一段代码，可以设置期望（证明）并断言它们确实发生了。</p><p>例如，一个是消息服务或电子邮件服务，无论何时被调用，都会向客户端发送电子邮件。如果我们正在积极地开发我们的代码库，可能每天会运行数百次测试，但我们不希望每天向客户发送数百封电子邮件或消息，因为那样他们可能会不高兴。</p><blockquote><p>那么，我们要如何使用 testify 包来模拟呢？</p></blockquote><p>让我们来看一下如何将 <code>mocks</code> 应用到一个相当简单的例子中。在这个例子中，我们有一个系统会尝试向客户收取产品或服务的费用。当 <code>ChargeCustomer()</code> 被调用时，它将随后调用 <code>Message Service</code>，向客户发送 SMS 文本消息来通知他们已经被收取的金额。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MessageService 通知客户被收取的费用</span></span><br><span class="line"><span class="keyword">type</span> MessageService <span class="keyword">interface</span> &#123;</span><br><span class="line">SendChargeNotification(<span class="keyword">int</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SMSService 是 MessageService 的实现</span></span><br><span class="line"><span class="keyword">type</span> SMSService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyService 使用 MessageService 来通知客户</span></span><br><span class="line"><span class="keyword">type</span> MyService <span class="keyword">struct</span> &#123;</span><br><span class="line">messageService MessageService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SendChargeNotification 通过 SMS 来告知客户他们被收取费用</span></span><br><span class="line"><span class="comment">// 这就是我们将要模拟的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sms SMSService)</span> <span class="title">SendChargeNotification</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Sending Production Charge Notification&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChargeCustomer 向客户收取费用</span></span><br><span class="line"><span class="comment">// 在真实系统中，我们会模拟这个</span></span><br><span class="line"><span class="comment">// 但是在这里，我想在每次运行时都赚点钱</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a MyService)</span> <span class="title">ChargeCustomer</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">a.messageService.SendChargeNotification(value)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Charging Customer For the value of %d\n&quot;</span>, value)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 &quot;Production&quot; 例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">smsService := SMSService&#123;&#125;</span><br><span class="line">myService := MyService&#123;smsService&#125;</span><br><span class="line">myService.ChargeCustomer(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们如何进行测试以确保我们不会让客户疯掉？好吧，我们通过创建一个新的 struct 称之为 <code>smsServiceMock</code> ，用来模拟我们的 <code>SMSService</code>，并且将 <code>mock.Mock</code> 添加到它的字段列表中。</p><p>然后我们将改写 <code>SendChargeNotification</code> 方法，这样它就不会向我们的客户发送通知并返回 nil 错误。</p><p>最后，我们创建 <code>TestChargeCustomer</code> 测试函数，接着实例化一个新的类型实例 <code>smsServiceMock</code> 并指定 <code>SendChargeNotification</code>在被调用时应该做什么。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smsServiceMock</span></span><br><span class="line"><span class="keyword">type</span> smsServiceMock <span class="keyword">struct</span> &#123;</span><br><span class="line">mock.Mock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们模拟的 smsService 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m smsServiceMock)</span> <span class="title">SendChargeNotification</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Mocked charge notification function&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Value passed in: %d\n&quot;</span>, value)</span><br><span class="line"><span class="comment">// 这将记录方法被调用以及被调用时传进来的参数值</span></span><br><span class="line">args := m.Called(value)</span><br><span class="line"><span class="comment">// 它将返回任何我需要返回的</span></span><br><span class="line"><span class="comment">// 这种情况下模拟一个 SMS Service Notification 被发送出去</span></span><br><span class="line">args.Bool(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestChargeCustomer 是个奇迹发生的地方</span></span><br><span class="line"><span class="comment">// 在这里我们将创建 SMSService mock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChargeCustomer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> smsService smsServiceMock</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后我们将定义当 100 传递给 SendChargeNotification 时，需要返回什么</span></span><br><span class="line"><span class="comment">// 在这里，我们希望它在成功发送通知后返回 true</span></span><br><span class="line">smsService.On(<span class="string">&quot;SendChargeNotification&quot;</span>, <span class="number">100</span>).Return(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，我们要定义要测试的服务</span></span><br><span class="line">myService := MyService&#123;smsService&#125;</span><br><span class="line"><span class="comment">// 然后调用方法</span></span><br><span class="line">myService.ChargeCustomer(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，我们验证 myService.ChargeCustomer 调用了我们模拟的 SendChargeNotification 方法</span></span><br><span class="line">smsService.AssertExpectations(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当我们运行 <code>go test ./... -v</code>时，我们应该看到以下输出：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test ./... -v</span><br><span class="line">=== RUN   TestChargeCustomer</span><br><span class="line">Mocked charge notification function</span><br><span class="line">Value passed in: <span class="number">100</span></span><br><span class="line">Charging Customer For the value of <span class="number">100</span></span><br><span class="line">--- PASS: TestChargeCustomer (<span class="number">0.00</span>s)</span><br><span class="line">    main_test.<span class="keyword">go</span>:<span class="number">33</span>: PASS:      SendChargeNotification(<span class="keyword">int</span>)</span><br><span class="line">PASS</span><br><span class="line">ok      _/Users/elliot/Documents/Projects/tutorials/golang/<span class="keyword">go</span>-testify-tutorial  <span class="number">0.012</span>s</span><br></pre></td></tr></table></figure><p>这证明我们的 myService.ChargeCustomer() 方法按照我们所期望的方式在运行！</p><p>我们现在已经能够使用模拟的方法来全面测试更复杂的项目。值得注意的是，此技术可用于各种不同的系统，例如模拟数据库查询或者是如何与其他 API 交互。总的来说，模拟是非常强大的手段</p><h2 id="suite-package"><a href="#suite-package" class="headerlink" title="suite package"></a>suite package</h2><p>这个包不太常用</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;golang的测试框架stretchr/testify 简单的API去检验你的GoLang代码按照你的意愿运行。&lt;/p&gt;
&lt;p&gt;项目地址： &lt;code&gt;https://github.com/stretchr/testify&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建我的ELK 7.12</title>
    <link href="http://kiosk007.top/2021/03/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84ELK-7-2/"/>
    <id>http://kiosk007.top/2021/03/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84ELK-7-2/</id>
    <published>2021-03-27T05:52:18.000Z</published>
    <updated>2021-03-27T05:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。</p><p>“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。</p><p>引用官网的一句话：</p><blockquote><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="https://img1.kiosk007.top/static/images/elk/elk.png" style="height:500px"></p><p><strong>ElasticSearch 的目录结构</strong></p><div class="table-container"><table><thead><tr><th>目录</th><th style="text-align:right">配置文件</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>bin</td><td style="text-align:right"></td><td style="text-align:center">脚本文件，包括启动elasticsearch，安装插件，运行统计数据等 </td></tr><tr><td>config</td><td style="text-align:right">elasticsearch.yml</td><td style="text-align:center">集群配置文件，user，role based 相关配置</td></tr><tr><td>JDK</td><td style="text-align:right"></td><td style="text-align:center">java 运行环境</td></tr><tr><td>data</td><td style="text-align:right">path.data</td><td style="text-align:center">数据文件</td></tr><tr><td>lib</td><td style="text-align:right"></td><td style="text-align:center">java 类库</td></tr><tr><td>logs</td><td style="text-align:right">path.log</td><td style="text-align:center">日志文件</td></tr><tr><td>modules</td><td style="text-align:right"></td><td style="text-align:center">包含所有ES模块</td></tr><tr><td>plugins</td><td style="text-align:right"></td><td style="text-align:center">包含所有已经安装的插件</td></tr></tbody></table></div><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><p>官方文档 Set up Elasticsearch 有各个 OS 的安装指导，页面 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/install-elasticsearch.html">Installing Elasticsearch</a> 中提供了多种安装包对应的指导链接！</p><p>本文选择绿色安装包的的方式（tar.gz）安装。</p><ul><li>安装环境： ubuntu 20.04</li><li>下载链接： <a href="https://mirrors.huaweicloud.com/elasticsearch/">华为镜像站</a> 速度能快一点</li></ul><p>说明：ElasticSearch使用java语言开发，所以默认需要安装并配置JDK，设置 JAVA_HOME, 但是从 7.0 开始，ElasticSearch 内置了Java环境，无需再安装。另外ES启动不能使用root用户</p><p>内核参数修改（32C + 128G参考）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改文件描述符数量</span></span><br><span class="line">grep <span class="string">&quot;* - nofile 512000&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span>  <span class="string">&quot;* - nofile 512000&quot;</span>  &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改最大打开进程数数量</span></span><br><span class="line">grep <span class="string">&quot;work - nproc unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;elasticsearch - nproc unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"><span class="comment">#配合es mem lock，centos6无须添加</span></span><br><span class="line">grep <span class="string">&quot;* soft memlock unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;* soft memlock unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#配合es mem lock，centos6无须添加</span></span><br><span class="line">grep <span class="string">&quot;* hard memlock unlimited&quot;</span> /etc/security/limits.conf || <span class="built_in">echo</span> <span class="string">&quot;* hard memlock unlimited&quot;</span>   &gt;&gt; /etc/security/limits.conf  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改系统文件描述符</span></span><br><span class="line">grep <span class="string">&quot;fs.file-max = 1024000&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;fs.file-max = 1024000&quot;</span>  &gt;&gt; /etc/sysctl.conf </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改程序最大管理的vm</span></span><br><span class="line">grep <span class="string">&quot;vm.max_map_count = 262144&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.max_map_count = 262144&quot;</span>  &gt;&gt;  /etc/sysctl.conf  </span><br><span class="line"></span><br><span class="line">grep  <span class="string">&quot;vm.min_free_kbytes = 2097152&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.min_free_kbytes = 2097152&quot;</span>  &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">grep  <span class="string">&quot;vm.zone_reclaim_mode = 0&quot;</span> /etc/sysctl.conf || <span class="built_in">echo</span> <span class="string">&quot;vm.zone_reclaim_mode = 0&quot;</span>  &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">swapoff -a   <span class="comment">#关闭虚拟内存</span></span><br></pre></td></tr></table></figure><h2 id="1-安装-elasticsearch"><a href="#1-安装-elasticsearch" class="headerlink" title="1. 安装 elasticsearch"></a>1. 安装 elasticsearch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xf elasticsearch-7.12.0-linux-x86_64.tar.gz -C ~</span><br><span class="line"><span class="built_in">cd</span> ~/elasticsearch-7.12.0</span><br><span class="line">./bin/elasticsearch  <span class="comment"># 启动</span></span><br></pre></td></tr></table></figure><p>启动成功后访问本地的 9200 端口，可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:9200</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;k8s-master&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;sEn3TgEVSnW4kHpIAU1-5Q&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : <span class="string">&quot;7.12.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_type&quot;</span> : <span class="string">&quot;tar&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_hash&quot;</span> : <span class="string">&quot;78722783c38caa25a70982b5b042074cde5d3b3a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_date&quot;</span> : <span class="string">&quot;2021-03-18T06:17:15.410153305Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;lucene_version&quot;</span> : <span class="string">&quot;8.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;6.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p class="div-border red">如果有安装的错误，参考：</p><ul><li><strong>seccomp unavailable 错误</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：elasticsearch.yml 配置</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure></li><li><strong>max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：修改 &#x2F;etc&#x2F;security&#x2F;limits.conf，配置：</span><br><span class="line">hard nofile 80000</span><br><span class="line">soft nofile 80000</span><br></pre></td></tr></table></figure></li><li><strong>max virtual memory areas vm.max_map_count [65530] is too low</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：修改 &#x2F;etc&#x2F;sysctl.conf，添加 ：</span><br><span class="line">vm.max_map_count &#x3D; 262144</span><br><span class="line">然后 sysctl -p 生效</span><br></pre></td></tr></table></figure><blockquote><p>安装插件方式：./bin/elasticsearch-plugin install analysis-icu</p></blockquote></li></ul><p><strong>ES 相关配置</strong></p><ul><li>官网关于配置的内容主要有两处：<ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html">Configuring Elasticsearch</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">Important Elasticsearch configuration</a></li></ul></li><li>Elasticsearch 主要有三个配置文件：<ul><li><code>elasticsearch.yml</code>：ES的配置文件 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">more</a></li><li><code>jvm.options</code>: ES JVM 参数 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/jvm-options.html#jvm-options">more</a></li><li><code>log4j2.properties</code>: ES log 配置 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/logging.html#logging">more</a></li></ul></li></ul><p>默认情况，ES 告诉 JVM 使用一个最小和最大都为 4GB 的堆。但是到了生产环境，这个配置就比较重要了，确保 ES 有足够堆空间可用。</p><blockquote><p>但是我的XPS 16G内存。不改堆内存大小的只能起一个实例，再起其他实例，旧的实例总显示 Killed。<br>修复方式，更改 <code>./config/jvm.options</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g </span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>运行多个Elasticsearch 实例</strong></p><p>每个实例的配置文件需要不同，这里降低复杂度，不修改配置文件，而是直接用命令行的形式启动一个集群。</p><ul><li>启动实例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动实例1</span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -Enode.name=node0 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">false</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9200 -E transport.tcp.port=9300 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-E cluster.initial_master_nodes=<span class="string">&quot;node0&quot;</span> -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动实例2 </span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -E node.name=node1 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">true</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E path.data=./data/data_node1 -E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9201 -E transport.tcp.port=9301 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动实例3 </span></span><br><span class="line">./bin/elasticsearch -E cluster.name=myes -E node.name=node2 \</span><br><span class="line">-E node.master=<span class="literal">true</span> -E node.data=<span class="literal">true</span> -E node.ingest=<span class="literal">false</span> \</span><br><span class="line">-E path.data=./data/data_node2 -E network.host=127.0.0.1 \</span><br><span class="line">-E http.port=9202 -E transport.tcp.port=9302 \</span><br><span class="line">-E discovery.seed_hosts=<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span> \</span><br><span class="line">-d</span><br></pre></td></tr></table></figure><blockquote><ul><li>9300端口： ES节点之间通讯使用</li><li>9200端口： ES节点 和 外部 通讯使用</li><li><code>discovery.seed_hosts</code>: 发现设置。有两种重要的发现和集群形成配置，以便集群中的节点能够彼此发现并且选择一个主节点.其中 <code>discovery.seed_hosts</code> 是组件集群时比较重要的配置，用于启动当前节点时，发现其他节点的初始列表。<br>当一个已经加入过集群的节点重启时，如果他无法与之前集群中的节点通信，很可能就会报这个错误 master not discovered or elected yet, an election requires at least 2 nodes with ids from。必须至少配置 [discovery.seed_hosts，discovery.seed_providers，cluster.initial_master_nodes] 中的一个。</li><li><code>cluster.initial_master_nodes</code>: 初始的候选 master 节点列表。初始主节点应通过其 node.name 标识，默认为其主机名。确保 cluster.initial_master_nodes 中的值与 node.name 完全匹配。<p class="div-border red">`cluster.initial_master_nodes` 该配置项并不是需要每个节点设置保持一致，设置需谨慎，如果其中的主节点关闭了，可能会导致其他主节点也会关闭。因为一旦节点初始启动时设置了这个参数，它下次启动时还是会尝试和当初指定的主节点链接，当链接失败时，自己也会关闭！因此，为了保证可用性，预备做主节点的节点不用每个上面都配置该配置项！保证有的主节点上就不设置该配置项，这样当有主节点故障时，还有可用的主节点不会一定要去寻找初始节点中的主节点！</p></li><li>详细资料参考：<ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-discovery-bootstrap-cluster.html">Bootstrapping a cluster</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-settings.html">Discovery and cluster formation settings</a></li></ul></li></ul><p>在新版 7.x 的 ES 中，对 ES 的集群发现系统做了调整，不再有 discovery.zen.minimum_master_nodes 这个控制集群脑裂的配置，转而由集群自主控制，并且新版在启动一个新的集群的时候需要有cluster.initial_master_nodes 初始化集群主节点列表。如果一个集群一旦形成，你不该再设置该配置项，应该移除它。该配置项仅仅是集群第一次创建时设置的！集群形成之后，这个配置也会被忽略的！</p><ul><li><code>discovery.seed_hosts</code>: 提供群集中符合master节点资格的地址列表</li></ul></blockquote><p>node0 节点仅仅是一个 master 节点，它不是一个数据节点。</p><p>先启动 node0 节点，因为它设置了初始主节点的列表。这时候就可以使用 <code>http://&lt;host IP&gt;:9200/</code> 看到结果了。然后逐一启动 node1 和 node2。通过访问 <code>http://127.0.0.1:9200/_cat/nodes</code> 查看集群是否 OK。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:9200/_cat/nodes</span><br><span class="line">127.0.0.1 42 49 58 4.45 2.09 1.37 lmr        * node0</span><br><span class="line">127.0.0.1 42 49 54 4.45 2.09 1.37 cdfhlmrstw - node1</span><br><span class="line">127.0.0.1 42 49 45 4.45 2.09 1.37 cdfhlmrstw - node2</span><br></pre></td></tr></table></figure></p><h2 id="2-安装-Kibana"><a href="#2-安装-Kibana" class="headerlink" title="2. 安装 Kibana"></a>2. 安装 Kibana</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xf kibana-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kibana-7.12.0-linux-x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>启动kibana</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将kibana改成中文</span></span><br><span class="line">vim config/kibana.yml</span><br><span class="line">     i18n.locale: <span class="string">&quot;zh-CN&quot;</span>   <span class="comment">## 最后一行</span></span><br><span class="line">./bin/kibana</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问本地的5601端口<br>查看样例。点击右下角的 <code>try out sample data</code> ，可以导入kibana的测试数据。分别是电商网站报表、航空数据、日志<br><img src="https://img1.kiosk007.top/static/images/elk/kinana_home.png"><br>这里分 <a href="https://www.elastic.co/cn/enterprise-search?elektra=home&amp;storm=river1">Enterprise Search(企业搜索)</a>、<a href="https://www.elastic.co/guide/en/observability/7.9/observability-introduction.html">Observability(监控)</a>、<a href="https://www.elastic.co/guide/en/security/7.9/es-overview.html">Security(安全)</a></p><ul><li>Enterprise Search(企业搜索)：可建立强大的搜索体验，当然是付费滴。</li><li>Observability(监控)：日志、APM、站点SLA监控、指标打点。（支持Nginx、MySQL、Redis等日志）</li><li>Security(安全): 安全相关的解决方案</li></ul><p>另外还开以打开 <code>http://127.0.0.1:5601/app/dev_tools#/console</code> 控制台，这个是直接对接 ES 的。可在这里直接使用查询语句。</p><h2 id="3-安装-Logstash"><a href="#3-安装-Logstash" class="headerlink" title="3. 安装 Logstash"></a>3. 安装 Logstash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-安装-cerebro"><a href="#4-安装-cerebro" class="headerlink" title="4. 安装 cerebro"></a>4. 安装 cerebro</h2><p>cerebro是专业化项目管理系统，提供一个协作工作环境和项目管理软件，用于处理复杂的视觉材料。它<br>专为 CGI 和动画工作室、广告公司、电视公司和建筑设计公司而开发。也可以说它是一款Elasticsearch监控工具。</p><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/lmenezes/cerebro/releases/download/v0.9.3/cerebro-0.9.3.tgz</span><br><span class="line">tar -xf cerebro-0.9.3.tgz </span><br><span class="line"><span class="built_in">cd</span> cerebro-0.9.3 </span><br><span class="line">./bin/cerebro   <span class="comment"># 启动</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>cerebro 需要 java 才能运行，没有java环境的化，可以执行 <code>sudo apt install openjdk-11-jdk</code> 。 Java 11 是 Java 的一个长期支持版本（LTS）。它同时也是 Ubuntu 20.04的默认 Java 开发和运行环境。</p></blockquote><p>访问 <code>http://127.0.0.1:9000</code> 浏览器打开。</p><p><img src="https://img1.kiosk007.top/static/images/elk/cerebro.png "></p><p>点击左上方 node，可查看节点情况。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>下载测试样本 movielens<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://files.grouplens.org/datasets/movielens/ml-20m.zip</span><br><span class="line">unzip ml-20m.zip</span><br></pre></td></tr></table></figure><br>开始配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">&quot;/home/work/logs/ml-20m/movies.csv&quot;</span></span><br><span class="line">    start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">    sincedb_path =&gt; <span class="string">&quot;/dev/null&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  csv &#123;</span><br><span class="line">    separator =&gt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    columns =&gt; [<span class="string">&quot;id&quot;</span>,<span class="string">&quot;content&quot;</span>,<span class="string">&quot;genre&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123; <span class="string">&quot;genre&quot;</span> =&gt; <span class="string">&quot;|&quot;</span> &#125;</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;path&quot;</span>, <span class="string">&quot;host&quot;</span>,<span class="string">&quot;@timestamp&quot;</span>,<span class="string">&quot;message&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line"></span><br><span class="line">    split =&gt; [<span class="string">&quot;content&quot;</span>, <span class="string">&quot;(&quot;</span>]</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;title&quot;</span> =&gt; <span class="string">&quot;%&#123;[content][0]&#125;&quot;</span>&#125;</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;year&quot;</span> =&gt; <span class="string">&quot;%&#123;[content][1]&#125;&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    convert =&gt; &#123;</span><br><span class="line">      <span class="string">&quot;year&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    strip =&gt; [<span class="string">&quot;title&quot;</span>]</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;path&quot;</span>, <span class="string">&quot;host&quot;</span>,<span class="string">&quot;@timestamp&quot;</span>,<span class="string">&quot;message&quot;</span>,<span class="string">&quot;content&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch &#123;</span><br><span class="line">     hosts =&gt; <span class="string">&quot;http://localhost:9200&quot;</span></span><br><span class="line">     index =&gt; <span class="string">&quot;movies&quot;</span></span><br><span class="line">     document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>导入测试数据到ES中<br><code>logstash -f log.conf</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。&lt;/p&gt;
&lt;p&gt;“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。&lt;/p&gt;
&lt;p&gt;引用官网的一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Worker Pool in Golang</title>
    <link href="http://kiosk007.top/2021/03/21/Worker-Pool-in-Golang/"/>
    <id>http://kiosk007.top/2021/03/21/Worker-Pool-in-Golang/</id>
    <published>2021-03-21T07:41:37.000Z</published>
    <updated>2021-03-21T07:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。但是，如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响</p><a id="more"></a><h1 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h1><p>Pool 的出现，可以避免反复的创建一些对象，比如 TCP链接、数据库链接等等，这些对象创建都比较耗时，如果将创建好的对象放入到池子中，需要的时候取，不需要的时候归还池子，将是一个非常不错的实现方式。</p><p>通过创建一个 Worker Pool 来减少 goroutine 的使用。比如，我们实现一个 TCP 服务器，如果每一个连接都要由一个独立的 goroutine 去处理的话，在大量连接的情况下，就会创建大量的 goroutine，这个时候，我们就可以创建一个固定数量的 goroutine（Worker），由这一组 Worker 去处理连接，比如 fasthttp 中的<a href="https://github.com/valyala/fasthttp/blob/9f11af296864153ee45341d3f2fe0f5178fd6210/workerpool.go#L16">Worker Pool</a>。</p><ul><li><p>著名的TCP连接池实现：fatih 开发的 <a href="https://github.com/fatih/pool">fatih/pool</a>, 虽然已经归档，但是这是由于这个项目已经足够稳定。</p></li><li><p>数据库连接池实现：database/sql 可以参考这篇分析 <a href="https://blog.csdn.net/qq_39384184/article/details/103954821">Golang 侧数据库连接池原理和参数调优</a>，同样使用方式直接参考 <a href="https://www.jianshu.com/p/2d58243fae22">这篇文章</a></p></li></ul><p><strong>一句话总结：保存和复用临时对象，减少内存分配，降低 GC 压力。</strong></p><p>举例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int32</span></span><br><span class="line">Remark [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf, _ = json.Marshal(Student&#123;Name: <span class="string">&quot;Geektutu&quot;</span>, Age: <span class="number">25</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarsh</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := &amp;Student&#123;&#125;</span><br><span class="line">json.Unmarshal(buf, stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>json 的反序列化在文本解析和网络通信过程中非常常见，当程序并发度非常高的情况下，短时间内需要创建大量的临时对象。而这些对象是都是分配在堆上的，会给 GC 造成很大压力，严重影响程序的性能。</p><p><strong>声明对象池</strong></p><p>只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> studentPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(Student) </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Get &amp;&amp; Put </strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu := studentPool.Get().(*Student)</span><br><span class="line">json.Unmarshal(buf, stu)</span><br><span class="line">studentPool.Put(stu)</span><br></pre></td></tr></table></figure></p><ul><li>Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。</li><li>Put() 则是在对象使用完毕后，返回对象池。</li></ul><h1 id="gammazero-workerpool"><a href="#gammazero-workerpool" class="headerlink" title="gammazero/workerpool"></a>gammazero/workerpool</h1><p><a href="https://pkg.go.dev/github.com/gammazero/workerpool">gammazero/workerpool</a> gammazero/workerpool 可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</p><p>下面做一些介绍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gammazero/workerpool&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wp := workerpool.New(<span class="number">2</span>)</span><br><span class="line">requests := []<span class="keyword">string</span>&#123;<span class="string">&quot;alpha&quot;</span>, <span class="string">&quot;beta&quot;</span>, <span class="string">&quot;gamma&quot;</span>, <span class="string">&quot;delta&quot;</span>, <span class="string">&quot;epsilon&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> requests &#123;</span><br><span class="line">r := r</span><br><span class="line">wp.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Handling request:&quot;</span>, r)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wp.StopWait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用提示</strong></li></ul><p>排队的任务数没有上限，只有系统资源的限制。如果入站任务的数量太多，以至于无法排队等待处理那么解决方案就超出了workerpool的处理范围，应该通过在多个系统上分配负载来解决</p><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h2 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h2><p>用户通过 <code>Submit(task func())</code> 方法提交一个 task 到 task 队列中。<br>task 函数默认没有返回值，如果想要有返回值，可以用管道将task 的返回值传到管道中。</p><p>提交的 task 会立即开启一个可用的worker或者新创建一个worker。如果没有可用的worker或者worker数已经达到最大，task会被放入到 task 等待队列中。当worker空闲时会从task 等待队列中取出task。</p><p>一个Worker长时间闲置时可以删除并释放资源。</p><p>这个函数非常简单，就是将收到的待执行任务放入到 task等待队列中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">Submit</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> task != <span class="literal">nil</span> &#123;</span><br><span class="line">p.taskQueue &lt;- task</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有一个变种, 支持同步等待结果<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">SubmitWait</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> task == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">doneChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">p.taskQueue &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">task()</span><br><span class="line"><span class="built_in">close</span>(doneChan)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-doneChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="New"><a href="#New" class="headerlink" title="New"></a>New</h2><p><code>New()</code> 函数创建了一个 worker goroutines pool 。 Max 指定了最大的worker数量，也就是最大并发的执行数，当没有新到来的 task 时，worker会逐渐减少至0.这里注意 taskQueue 是一个只有1个buffer的缓冲，task等待队列是 <code>waitingQueue()</code> 。dispatch 里实现派发任务的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxWorkers <span class="keyword">int</span>)</span> *<span class="title">WorkerPool</span></span> &#123;</span><br><span class="line"><span class="comment">// There must be at least one worker.</span></span><br><span class="line"><span class="keyword">if</span> maxWorkers &lt; <span class="number">1</span> &#123;</span><br><span class="line">maxWorkers = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool := &amp;WorkerPool&#123;</span><br><span class="line">maxWorkers:  maxWorkers,</span><br><span class="line">taskQueue:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>, 1),</span></span><br><span class="line">workerQueue: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>),</span></span><br><span class="line">stopSignal:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">stoppedChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the task dispatcher.</span></span><br><span class="line"><span class="keyword">go</span> pool.dispatch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch 任务派发</strong> 通过设置 idleTimer ，超过这个时间还没有task，就会杀掉一个worker。这个函数刚开始判断等待队列是否为 0，如果不为0，说明任务已经积压，需要将新的task传到等待队列中 ，<code>processWaitingQueue</code>函数内将 task 传给 waitQueue，并在workerQueue有buffer时将任务传给 worker Queue。</p><p>如果 waitQueue 不存在（长度为0），说明还不存在任务排队情况，会将task传给 workerQueue（如果workerQueue能把task塞进去的话），如果塞不进去<br>就创建一个新worker，要么worker刚好又不够了（达到最大worker数量），任务扔进 waitQueue。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispatch sends the next queued task to an available worker.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(p.stoppedChan)</span><br><span class="line">timeout := time.NewTimer(idleTimeout)</span><br><span class="line"><span class="keyword">var</span> workerCount <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> idle <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.waitingQueue.Len() != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !p.processWaitingQueue() &#123;</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.taskQueue:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Got a task to do.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.workerQueue &lt;- task:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Create a new worker, if not at max.</span></span><br><span class="line"><span class="keyword">if</span> workerCount &lt; p.maxWorkers &#123;</span><br><span class="line"><span class="keyword">go</span> startWorker(task, p.workerQueue)</span><br><span class="line">workerCount++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Enqueue task to be executed by next available worker.</span></span><br><span class="line">p.waitingQueue.PushBack(task)</span><br><span class="line">atomic.StoreInt32(&amp;p.waiting, <span class="keyword">int32</span>(p.waitingQueue.Len()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">idle = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line"><span class="comment">// Timed out waiting for work to arrive.  Kill a ready worker if</span></span><br><span class="line"><span class="comment">// pool has been idle for a whole timeout.</span></span><br><span class="line"><span class="keyword">if</span> idle &amp;&amp; workerCount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.killIdleWorker() &#123;</span><br><span class="line">workerCount--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">idle = <span class="literal">true</span></span><br><span class="line">timeout.Reset(idleTimeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If instructed to wait, then run tasks that are already queued.</span></span><br><span class="line"><span class="keyword">if</span> p.wait &#123;</span><br><span class="line">p.runQueuedTasks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop all remaining workers as they become ready.</span></span><br><span class="line"><span class="keyword">for</span> workerCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">p.workerQueue &lt;- <span class="literal">nil</span></span><br><span class="line">workerCount--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>waitingQueue</code> 的目的是讲一个新的task放入到等待 task 队列。或者等待工人队列中有可用的工人时将 task 等待队列中取出 task 交给 worker 队列。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WorkerPool)</span> <span class="title">processWaitingQueue</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> task, ok := &lt;-p.taskQueue:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">p.waitingQueue.PushBack(task)</span><br><span class="line"><span class="keyword">case</span> p.workerQueue &lt;- p.waitingQueue.Front().(<span class="function"><span class="keyword">func</span><span class="params">()</span>):</span></span><br><span class="line"><span class="comment">// A worker was ready, so gave task to worker.</span></span><br><span class="line">p.waitingQueue.PopFront()</span><br><span class="line">&#125;</span><br><span class="line">atomic.StoreInt32(&amp;p.waiting, <span class="keyword">int32</span>(p.waitingQueue.Len()))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。但是，如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP/3</title>
    <link href="http://kiosk007.top/2021/02/21/HTTP3/"/>
    <id>http://kiosk007.top/2021/02/21/HTTP3/</id>
    <published>2021-02-21T03:08:54.000Z</published>
    <updated>2021-02-21T03:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不得不说国外的很多文章写的都十分优秀，将技术的历史背景和细节都讲得十分出色。下面是转自 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> ，这里有很多对外国优秀文章的翻译。关于<strong>HTTP/3</strong>相关的知识。下面做一些简短的记录。</p><a id="more"></a><blockquote><ul><li>原文地址：HTTP/3: From root to tip</li><li>原文作者：Lucas Pardue</li><li>译文出自：掘金翻译计划</li><li>译者：Starrier</li></ul></blockquote><h1 id="HTTP-3-起源"><a href="#HTTP-3-起源" class="headerlink" title="HTTP/3 起源"></a>HTTP/3 起源</h1><p>HTTP/3 是 QUIC 传输层的 HTTP 应用程序映射。该名称在最近（2018 年 10 月底）草案的第 17 个版本中被正式提出（<a href="https://tools.ietf.org/html/draft-ietf-quic-http-17">draft-ietf-quic-http-17</a>），在 11 月举行的 IETF 103 会议中进行了讨论并形成了初步的共识。HTTP/3 以前被称为 QUIC（以前被称为 HTTP/2）。在此之前，我们已经有了 gQUIC，而在更早之前，我们还有 SPDY。事实是，HTTP/3 只是一种适用于 IETF QUIC 的新 HTTP 语法 —— 基于 UDP 的多路复用和安全传输。</p><p>这篇文章将讲述 HTTP/3 的发展历史。详细发展图见 <a href="https://blog.cloudflare.com/content/images/2019/01/web_timeline_large1.svg">Cloudflare Secure Web Timeline</a></p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/gquic-stack.png" style="height:400px"></p><p>HTTP/3 分层模型（蛋糕模型）</p><h2 id="HTTP-演进"><a href="#HTTP-演进" class="headerlink" title="HTTP 演进"></a>HTTP 演进</h2><p>在我们关注 HTTP 之前，值得回忆的是两个共享 QUIC 的名称。就像我们之前解释得那样，gQUIC 通常是指 Google QUIC（协议起源），QUIC 通常用于表示与 gQUIC 不同的 IETF 标准（正在开发的版本）。</p><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP/1"></a><strong>HTTP/1</strong></h3><p>HTTP/1.1 是非常成功的协议，时间线显示 1999 年以后 IETF 并不活跃。然而，事实是，多年的积极使用，为 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 研究潜在问题提供了实战经验，但这也导致了一些交互操作的问题。此外，RFC（像 2817 和 2818）还对该协议进行了扩展。2007 年决定启动一项改进 HTTP 协议规范的新活动 —— HTTPbis（”bis” 源自拉丁语，意为“二”、“两次”或“重复”），它还采用了新的工作组形式。最初的<a href="https://tools.ietf.org/wg/httpbis/charters?item=charter-httpbis-2007-10-23.txt">章程</a>详细描述了尝试解决的问题。</p><p>简而言之，HTTPbis 决定重构 RFC 2616。它将纳入勘误修订，合并在此期间发布的其他规范的一些内容。文件将被分为几个部分，这导致 2017 年 12 月发布了 6 个 I-D：</p><ol><li>draft-ietf-httpbis-p1-messaging</li><li>draft-ietf-httpbis-p2-semantics</li><li>draft-ietf-httpbis-p4-conditional</li><li>draft-ietf-httpbis-p5-range</li><li>draft-ietf-httpbis-p6-cache</li><li>draft-ietf-httpbis-p7-auth</li></ol><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/http1_refactor.png" style="height:400px"></p><p>图表显示了这项工作是如何在长达 7 年的草案过程中取得进展的，在最终被标准化之前，已经发布了 27 份草案。2014 年 6 月，发布了 RFC 723x 系列（x 范围在 0-5）。HTTPbis 工作组的主席以 “<a href="https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead">RFC2616 is Dead</a>“ 来庆祝这一成果。如果它不够清楚，这些新文档就会弃用旧的 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>。</p><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a><strong>SPDY</strong></h3><p>尽管 IETF 的 RFC 723x 系列的工作繁忙，但是技术的进步并未停止。人们继续加强、扩展和测试因特网上的 HTTP。而 Google 已率先开始尝试名为 SPDY（发音同 Speedy）的技术。该协议宣称可以提高 Web 浏览性能，一个使用 HTTP 原则的用例。2009 年底，SPDY v1 发布，2010 年 SPDY v2 紧随其后。</p><p>Google 对 SPDY 实验表明，改变 HTTP 语法是有希望的，维持现有 HTTP 语义是有意义的。比如，保留 URL 的使用格式 —— <code>https://</code>，可以避免许多可能影响采用的问题。看到一些积极的结果后，IETF 决定考虑 HTTP/2.0。2012 年 3 月 IETF 83 期间举行的 HTTPbis 会议的 slides显示了请求、目标和成功标准。它还明确指出 “HTTP/2.0 与 HTTP/1.x 连线格式不兼容”。</p><h3 id="gQUIC-横空出世"><a href="#gQUIC-横空出世" class="headerlink" title="gQUIC 横空出世"></a><strong>gQUIC 横空出世</strong></h3><p>2012 - 2015 之间，Google 继续进行试验，他们发布了 SPDY v3 和 v3.1。他们还开始研究 gQUIC(当时的发音类似于 quick），在 2012 年年初，发布了初始的公共规范。gQUIC 的早期版本使用 SPDY v3 形式的 HTTP 语法。这个选择是有意义的，因为 HTTP/2 尚未完成。SPDY 二进制语法被打包到可以用 UDP 数据报发送数据的 QUIC 包中。</p><p>gQUIC 使用巧妙的设计来实现性能优化。其中一个是破坏应用程序与传输层之间清晰的分层。这也意味着 gQUIC 只支持 HTTP。因此，gQUIC 最后被称为 “QUIC”。它是 HTTP 下一个候选版本的同义词。QUIC 从过去的几年到现在，一直在持续更新，QUIC 也被人们理解为是初始 HTTP 的变体。不幸的是，这正是我们在讨论协议时，经常出现混乱的原因。</p><p>gQUIC 继续在实验中摸索，最后选择了更接近 HTTP/2 的语法。也正因为如此，它才被称为 “HTTP/2 over QUIC”。但因为技术上的限制，所有存在一些非常微妙的差别。一个示例是，HTTP 头是如何序列化并交换的。这是一个细微的差别，但实际上，这意味着 HTTP/2 式 gQUIC 与 IETF’s HTTP/2 并不兼容。</p><p class="div-border yellow">17年-20年市面上大多商用的QUIC均是gQuic，客户端一般为cronet（chromium的网络库），服务端接入层的Nginx一般经过chromium 的封装 </p><p>最后，同样重要的是，我们总是需要考虑互联网协议的安全方面。gQUIC 选择不使用 TLS 来提供安全性。转而使用 Google 开发的另一种称为 QUIC Crypto 的方法。其中一个有趣的方面是有一种加速安全握手的新方法。以前与服务器建立了安全会话的客户端可以重用信息来进行“零延迟往返握手”或 0-RTT 握手。0-RTT 后来被纳入 TLS 1.3。</p><h3 id="什么是HTTP-3"><a href="#什么是HTTP-3" class="headerlink" title="什么是HTTP/3"></a>什么是HTTP/3</h3><p>当然，现在可以说什么是HTTP/3 了，gQUIC 并非与众不同。在2015 年 6 月的 draft-tsvwg-quic-protocol-00 中，写有 “QUIC：基于 UDP 的安全可靠的 HTTP/2 传输” 已经提交。请记住我之前提过的，几乎都是 HTTP/2 的语法。</p><p>Google <a href="https://groups.google.com/a/chromium.org/forum/#!topic/proto-quic/otGKB4ytAyc">宣布</a>将在布拉格举行一次 Bar BoF IETF 93 会议。如有疑问，请参阅 <a href="https://tools.ietf.org/html/rfc6771">RFC 6771</a>。提示：BoF 是物以类聚（Birds of a Feather）的缩写。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_adoption.png" style="height:400px"></p><p>总之，与 IETF 的合作结果是 QUIC 在传输层提供了许多优势，而且它应该与 HTTP 分离。应该重新引入层与层之间清楚的隔离。此外，还有返回基于 TLS 握手的优先级</p><p>大约是一年后，在 2016 年，一组新的 I-D 集合被提交：</p><ul><li><a href="https://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-00">draft-hamilton-quic-transport-protocol-00</a></li><li><a href="https://tools.ietf.org/html/draft-thomson-quic-tls-00">draft-thomson-quic-tls-00</a></li><li><a href="https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00">draft-iyengar-quic-loss-recovery-00</a></li><li><a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a></li></ul><p>这里是关于 HTTP 和 QUIC 的另一个困惑的来源。<a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a> 题为 “HTTP/2 使用 QUIC 传输协议的语义”，对于自己的描述是 “HTTP/2 式 QUIC 的另一种语义映射”。但这个解释并不正确。HTTP/2 在维护语义的同时，改变了语法。而且，我很早之前就说过了，”HTTP/2 式 gQUIC” 从未对语法进行确切的描述，记住这个概念。</p><p>2016 年在柏林举行 IETF 96 会议决定了有数百人参加了这次会议。会议结束时，达成了一致的共识：<strong>QUIC 将被 IETF 采用并标准化。</strong></p><p class="div-border green">之后的QUIC必将全面IETF化</p><p>将 HTTP 映射到 QUIC 的第一个 IETF QUIC I-D —— <a href="https://tools.ietf.org/html/draft-ietf-quic-http-00">draft-ietf-quic-http-00</a>，采用了 Ronseal 方法来简化命名 —— “HTTP over QUIC”。不幸的是，它并没有达到预期效果，整个内容中都残留有 HTTP/2 术语的实例。Mike Bishop —— I-D 的新编辑，发现并修复了 HTTP/2 的错误名称。在 01 草案中，将描述修改为 “a mapping of HTTP semantics over QUIC”。</p><p>随着时间和版本的推进，”HTTP/2” 的使用逐渐减少，实例部分仅仅是对 <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> 部分的引用。从 2018 年 10 月开始向前回退两年的时间开始计算，I-D 如今已经是第 16 版本。虽然 HTTP over QUIC 与 HTTP/2 有相似内容，但始终是独立的（非向后兼容的 HTTP 语法）。然而，对那些不密切关注 IETF 发展的人来说（人数众多），他们并不能从名称中发现一些细微的差异。标准化的重点之一是帮助通信和互操作性。但像命名这样的简单事件，才是导致社区相对混乱的主要原因。<br>回顾 2012 年的内容，”HTTP/2.0 意味着 wire 格式与 HTTP/1.x 格式不兼容”。IETF 遵循现有线索。IETF 103 是经过深思熟虑才最终达成一致的，即：”HTTP over QUIC” 命名为 HTTP/3。互联网正在促使世界变得更加美好，我们可以继续进行更加重要的的探讨。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>概况来说就是：HTTP/3 只是一种适用于 IETF QUIC 的新 HTTP 语法 —— 一种基于 UDP 多路复用的安全传输层。仍有许多有趣的领域需要深入探索。</p><blockquote><p>参考文章</p><ul><li>：<a href="https://juejin.cn/post/6914561963393548295#heading-11">揭秘QUIC的性能与安全</a></li><li>：<a href="https://juejin.cn/post/6908522467107536903#heading-3">Google、Facebook等均开始支持的HTTP3到底是个什么鬼？</a></li></ul></blockquote><h1 id="QUIC的实现"><a href="#QUIC的实现" class="headerlink" title="QUIC的实现"></a>QUIC的实现</h1><h2 id="QUIC-握手"><a href="#QUIC-握手" class="headerlink" title="QUIC 握手"></a>QUIC 握手</h2><p>在2016年11月国际互联网工程任务组(IETF)召开的第一次QUIC工作组会议，受到了业界的广泛关注。这也意味着QUIC开始了它的标准化过程，成为新一代传输层协议，形成了最新的iQUIC。<strong>IETF在QUIC的加密协议上就放弃了google的加密协议使用了标准的TLS1.3。</strong></p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_struct.png"></p><p><strong>QUIC 握手</strong></p><p>QUIC 连接的建立整体流程大致为：QUIC在握手过程中使用Diffie-Hellman算法协商初始密钥，初始密钥依赖于服务器存储的一组配置参数，该参数会周期性的更新。初始密钥协商成功后，服务器会提供一个临时随机数，双方根据这个数再生成会话密钥。客户端和服务器会使用新生的的密钥进行数据加解密。</p><p>以上过程主要分为两个步骤：<span class="inline-tag grey">初始握手（Initial handshake）</span>、<span class="inline-tag grey">最终 与重复 握手（Final (and repeat) handshake）</span> ，分别介绍下这两个过程。</p><h3 id="初始握手（Initial-handshake）"><a href="#初始握手（Initial-handshake）" class="headerlink" title="初始握手（Initial handshake）"></a>初始握手（Initial handshake）</h3><p>在连接开始建立时，客户端会向服务端发送一个打招呼信息，（inchoate client hello (CHLO)），因为是初次建立，所以，服务端会返回一个拒绝消息（REJ），表明握手未建立或者密钥已过期。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake1.jpeg"></p><p>但是，这个拒绝消息中还会包含更多的信息（配置参数），主要有：</p><ol><li>Server Config：一个服务器配置，包括服务器端的Diffie-Hellman算法的长期公钥（long term Diffie-Hellman public value）</li><li>Certificate Chain：用来对服务器进行认证的信任链</li><li>Signature of the Server Config：将Server Config使用信任链的叶子证书的public key加密后的签名</li><li>Source-Address Token：一个经过身份验证的加密块，包含客户端公开可见的IP地址和服务器的时间戳。</li></ol><p>在客户端接收到拒绝消息（REJ）之后，客户端会进行数据解析，签名验证等操作，之后会将必要的配置缓存下来。<br>同时，在接收到REJ之后，客户端会为这次连接随机产生一对自己的短期密钥（ephemeral Diffie-Hellman private value） 和 短期公钥（ephemeral Diffie-Hellman public value）。</p><p>之后，客户端会将自己刚刚产生的短期公钥打包一个Complete CHLO的消息包中，发送给服务端。这个请求的目的是将自己的短期密钥传输给服务端，方便做前向保密。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake2.jpeg"></p><p>在发送了Complete CHLO消息给到服务器之后，为了减少RTT，客户端并不会等到服务器的响应，而是立刻会进行数据传输。</p><p>为了保证数据的安全性，客户端会自己的短期密钥和服务器返回的长期公钥进行运算，得到一个初始密钥（initial keys）。接下来他接收到客户端使用初始密钥加密的数据之后，就可以使用这个初识密钥进行解密了，并且可以将自己的响应再通过这个初始密钥进行加密后返回给客户端。</p><h3 id="最终（与重复）握手"><a href="#最终（与重复）握手" class="headerlink" title="最终（与重复）握手"></a>最终（与重复）握手</h3><p>那么，之后的数据传输就可以使用初始密钥（initial keys）加密了吗？<br>其实并不完全是，因为初始密钥毕竟是基于服务器的长期公钥产生的，而在公钥失效前，几乎多有的连接使用的都是同一把公钥，所以，这其实存在着一定的危险性。<br>所以，为了达到前向保密 (Forward Secrecy) 的安全性，客户端和服务端需要使用彼此的短期公钥和自己的短期密钥来进行运算。</p><p>那么现在问题是，客户端的短期密钥已经发送给服务端，而服务端只把自己的长期密钥给了客户端，并没有给到自己的短期密钥。<br>所以，服务端在收到Complete CHLO之后，会给到服务器一个server hello(SHLO)消息，这个消息会使用初始密钥（initial keys）进行加密。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake4.jpeg"></p><p>这个CHLO消息包中，会包含一个服务端重新生成的短期公钥。<br>这样客户端和服务端就都有了对方的短期公钥（ephemeral Diffie-Hellman public value）。<br>这样，客户端和服务端都可以基于自己的短期密钥和对方的短期公钥做运算，产生一个仅限于本次连接使用的前向保密密钥 (Forward-Secure Key)，后续的请求发送，都基于这个密钥进行加解密就可以了。<br>这样，双方就完成了最终的密钥交换、连接的握手并且建立了QUIC连接。<br>当下一次要重新创建连接的时候，客户端会从缓存中取出自己之前缓存下来的服务器的长期公钥，并重新创建一个短期密钥，重新生成一个初识密钥，再使用这个初始密钥对想要传输的数据进行加密，向服务器发送一个Complete CHLO 请求即可。这样就达到了0 RTT的数据传输。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake5.jpeg"></p><p>所以，如果是有缓存的长期公钥，那么数据传输就会直接进行，准备时间是0 RTT</p><p><strong>以上，通过使用Diffie-Hellman算法协商密钥，并且对加密和握手过程进行合并，大大减小连接过程的RTT ，使得基于QUIC的连接建立可以少到1 RTT甚至0 RTT。</strong></p><p>下面是建立握手的完整过程</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_handshake6.jpeg"></p><p><strong>小结</strong>：</p><p>QUIC的通讯过程在初次没有建立过连接时使用1-RTT的握手机制，同时保证连接的建立和达到安全的保障。以下是QUIC的1-RTT的握手过程：</p><ol><li>Server端会持有0-RTT公私钥对，并且生成SCFG（服务端的配置信息对象），把公钥放入SCFG中；</li><li>客户端初次请求时，需要向服务端获取0-RTT公钥，这个需要消耗一个RTT，这也QUIC的1-RTT的所在；</li><li>客户端在收到0-RTT公钥以后会缓存起来，同时生成自己的临时公私钥对，经过前面的一个RTT后客户端把自己的临时私钥与服务端发过来的0-RTT的公钥根据DH算法生成一个加密密钥K1，同时使用K1加密数据同时附送自己的临时公钥一起发送服务端，此时已有用户数据发送；</li><li>在服务端收到用户使用K1加密的用户数据和客户端发来的临时公钥以后，会做如下几件事：<ul><li>使用0-RTT私钥与客户端发来的临时公钥通过DH算法生成K1解密用户数据并递交到应用；</li><li>生成服务端临时公私钥对，使用临时公私钥对的私钥，与客户端发来的客户端临时公钥，生成K2加密服务端要传输的数据</li><li>把服务端的临时公钥和使用K2加密的应用数据发送到客户端</li></ul></li><li>客户端收到服务端发送的服务端临时公钥和使用K2加密的应用数据后会再次使用DH算法把服务端的临时公钥和客户端原来的临时私钥重新生成K2解密数据，并且从此以后使用K2进行数据层的加解密</li></ol><ul><li><strong>1RTT握手</strong></li></ul><p>0-RTT是QUIC一个很关键的属性，能够在连接的第一个数据报文就可以携带用户数据。但是我们也可以看到如果客户端和服务端从来没有通讯过，那么是不存在0-RTT的，需要一个完成的RTT之后才能承载用户数据。<br><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_1rtt.png" style="height:400px"></p><ul><li><strong>0RTT握手</strong></li></ul><p>这个流程是gQUIC的流程，iQUIC由于使用的是TLS1.3，握手阶段报文的细节会有些不一样，例如首个请求的是证书、PSK等信息。在0-RTT阶段使用的是session复用的ticket方式。</p><p><img src="https://img1.kiosk007.top/static/images/network/QUIC/quic_0rtt.png" style="height:400px"></p><p class="div-border yellow">gQUIC使用的是gQUIC Crypto，并不是TLS1.3</p><ul><li><strong>安全考虑</strong></li></ul><p>UDP的安全性存在的几个关键的地方，源地址欺骗攻击，UDP放大攻击等。在QUIC中有设计了源地址TOKEN（STK）验证的安全机制来解决源地址的欺骗攻击，在通讯过程中服务器要求确认客户端的源地址TOKEN，这个源地址TOKEN根据数据包的源地址和服务器的时间戳等因子生成STK，随后和响应数据包一起发送到客户端，而在后续的数据传输过程中客户端需要透传这个STK到服务端，从而服务端可以进行校验。当服务端发现连接对应的源地址发送变化时会主动发送RETRY报文进行服务端主动源地址验证。客户端也可以主动发起源地址验证信息。源地址验证可以保护两类攻击问题，源地址欺骗攻击和UDP放大攻击。</p><ol><li><p>连接建立时，为了验证客户端的地址是否是攻击者伪造的，服务端会生成一个令牌（token）并通过重试包（Retry packet）响应给客户端。客户端需要在后续的初始包（Initial packet）带上这个令牌，以便服务端进行地址验证。</p></li><li><p>服务端可以在当前连接中通过 NEW_TOKEN 帧预先发布令牌，以便客户端在后续的新连接使用，这是 QUIC 实现 0-RTT 很重要的一个功能。</p></li><li><p>当我们的网络路径变化时（比如从蜂窝网络切换到 WIFI），QUIC 提供了连接迁移（connection migration）的功能来避免连接中断。QUIC 通过路径验证（Path Validation）验证网络新地址的可达性（reachability），防止在连接迁移中的地址是攻击者伪造的。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;不得不说国外的很多文章写的都十分优秀，将技术的历史背景和细节都讲得十分出色。下面是转自 &lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt; ，这里有很多对外国优秀文章的翻译。关于&lt;strong&gt;HTTP/3&lt;/strong&gt;相关的知识。下面做一些简短的记录。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GoLang 编程模式 -- 基本概念</title>
    <link href="http://kiosk007.top/2021/01/30/GoLang-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://kiosk007.top/2021/01/30/GoLang-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-30T03:12:07.000Z</published>
    <updated>2021-01-30T03:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为了巩固一下 Go 的基础，主要涉及 Slice、Interface、函数式编程等。</p><a id="more"></a><p>也是读了<a href="https://coolshell.cn/" style>左耳朵耗子</a> 叔的 <a href="https://coolshell.cn/articles/21128.html">Go编程模式</a> 的系列文章发现有的细节确实之前也有遗漏，刚好也趁机复习巩固一下。</p><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">//指向存放数据的数组指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span>            <span class="comment">//长度有多大</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span>            <span class="comment">//容量有多大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Slicce标头的<strong>array</strong>字段是底层真正指向数组的指针。</p><p><img src="https://i0.wp.com/golangbyexample.com/wp-content/uploads/2020/05/slice.jpg?w=391&amp;ssl=1" alt></p><p>Golang 的切片是子集。切片可以是数组、列表或字符串的子集。可以从一个字符串中提取多个片段，每个片段作为一个新变量。</p><h3 id="与数组的不同："><a href="#与数组的不同：" class="headerlink" title="与数组的不同："></a><strong>与数组的不同</strong>：</h3><p>数组在声明为一定大小后，不能调整大小，而切片可以调整大小。切片是引用类型，而数组是值类型。</p><h3 id="在Golang中创建切片"><a href="#在Golang中创建切片" class="headerlink" title="在Golang中创建切片"></a><strong>在Golang中创建切片</strong></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> stringSlice = []<span class="keyword">string</span>&#123;<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;slice&quot;</span>&#125;</span><br><span class="line">fmt.Println(stringSlice)  <span class="comment">// prints [This is a string slice]</span></span><br><span class="line"><span class="comment">// res:  [This is a string slice]</span></span><br><span class="line"></span><br><span class="line">myset := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* take slice */</span></span><br><span class="line">s1 := myset[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">// res:  [0 1 2 3]</span></span><br><span class="line"></span><br><span class="line">mystring := <span class="string">&quot;Go programming&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* take slice */</span></span><br><span class="line">s2 := mystring[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s2)</span><br><span class="line"><span class="comment">// res:  Go</span></span><br><span class="line"></span><br><span class="line">numbers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;numbers=%v\n&quot;</span>, numbers)</span><br><span class="line">fmt.Printf(<span class="string">&quot;length=%d\n&quot;</span>, <span class="built_in">len</span>(numbers))</span><br><span class="line">fmt.Printf(<span class="string">&quot;capacity=%d\n&quot;</span>, <span class="built_in">cap</span>(numbers))</span><br><span class="line"><span class="comment">// res:</span></span><br><span class="line"><span class="comment">//numbers=[0 0 0]</span></span><br><span class="line"><span class="comment">//length=3</span></span><br><span class="line"><span class="comment">//capacity=5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片引用"><a href="#切片引用" class="headerlink" title="切片引用"></a><strong>切片引用</strong></h3><p>切片是引用类型，那么就意味着数组指针的问题——数据会发生共享！下面我们来看看 Slice 的一些操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">foo[<span class="number">3</span>] = <span class="number">42</span></span><br><span class="line">foo[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">bar  := foo[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">bar[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 foo</span></span><br><span class="line"><span class="comment">// 打印 bar</span></span><br></pre></td></tr></table></figure><ol><li>首先，创建一个 foo 的 Slice，其中的长度和容量都是 5；</li><li>然后，开始对 foo 所指向的数组中的索引为 3 和 4 的元素进行赋值；</li><li>最后，对 foo 做切片后赋值给 bar，再修改 bar[1]。</li></ol><p>最终的foo和bar的结果是什么呢? 是不是和想象的不太一样，这是因为切片操作的底层数组是同一个数组。foo 和 bar 的内存是共享的，所以，foo 和 bar 对数组内容的修改都会影响到对方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(foo)  &#x2F;&#x2F; res: [0 0 99 42 100]</span><br><span class="line">fmt.Println(bar)  &#x2F;&#x2F; res: [0 99 42]</span><br></pre></td></tr></table></figure></p><p>再来看一个 <code>append</code> 的例子。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">16</span>]</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印a</span></span><br><span class="line"><span class="comment">// 打印b</span></span><br></pre></td></tr></table></figure><br>在这段代码中，把 <code>a[1:16]</code> 的切片赋给 b ，此时，a 和 b 的内存空间是共享的，然后，对 a 做了一个 append()的操作，这个操作会让 a 重新分配内存，这就会导致 a 和 b 不再共享，如下图所示：<br><img src="https://static001.geekbang.org/resource/image/9a/13/9a29d71d309616f6092f6bea23f30013.png" style="max-width: 70%;border-radius: 6px"></p><p>这时 a 和 b 的值是多少？append()操作让 a 的容量变成了 64，而长度是 33。这里你需要重点注意一下，<strong>append()这个函数在 cap 不够用的时候，就会重新分配内存以扩大容量，如果够用，就不会重新分配内存了！</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(a)  &#x2F;&#x2F; res: [0 0 42 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]</span><br><span class="line">fmt.Println(b)  &#x2F;&#x2F; res: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>那既然这样相同的例子我们再来一遍，如果让a不要重新分配内存(比如初始化a的时候使用<code>a := make([]int, 33))</code>，那么b的结果就会变成 <code>[0 42 0 0 0 0 0 0 0 0 0 0 0 0 0]</code> <strong>注意</strong>：这时的b会因为<code>a[2]</code> 的变化而变化。</p><p>同样的例子如下，只要没有发生<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path := []<span class="keyword">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">sepIndex := bytes.IndexByte(path,<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dir1 := path[:sepIndex]</span><br><span class="line">dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir1),<span class="built_in">cap</span>(dir1)) <span class="comment">// prints: len: 4 cap: 14</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len: %d cap: %d &quot;</span>,<span class="built_in">len</span>(dir2),<span class="built_in">cap</span>(dir2)) <span class="comment">// prints: len: 9 cap: 14</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">dir1 = <span class="built_in">append</span>(dir1,<span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;dir1 =&gt;&quot;</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">fmt.Println(<span class="string">&quot;dir2 =&gt;&quot;</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; uffixBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子中，dir1 和 dir2 共享内存，虽然 dir1 有一个 append() 操作，但是因为 cap 足够，于是数据扩展到了dir2 的空间。下面是相关的图示（注意上图中 dir1 和 dir2 结构体中的 cap 和 len 的变化）：</p><p><img src="https://static001.geekbang.org/resource/image/17/aa/1727ca49dfe2e6a73627a52a899535aa.png" style="max-width: 70%;border-radius: 6px"></p><p>这里的 <code>dir1:=path[:sepIndex]</code> 没有触发重新分配内存，如果想要强行重新分配内存的话可以使用<code>dir1 := path[:sepIndex:sepIndex]</code> 最后一个参数叫“Limited Capacity”，于是，后续的 append() 操作会导致重新分配内存。</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface 接口是一个抽象概念，它支持Go中的<strong>多态</strong>。该接口的变量可以保存实现该类型的值。类型断言用于获取底层的具体值。接口也是给Go语言带来了无限扩展空间。其中 <code>io.Reader</code> 接口就是一个典型的例子，<strong>io.Reader</strong> 表示读取设备数据流的能力，可以从<a href="https://golang.cafe/blog/golang-reader-example.html">网络、文件、字符串</a>等等。先简单介绍下 <code>io.Reader</code> 接口 ，后面会介绍如何使用接口式编程的方式封装 Reader 。</p><h3 id="接口式编程"><a href="#接口式编程" class="headerlink" title="接口式编程"></a>接口式编程</h3><p><a href="https://golang.org/pkg/io/#Reader">io.Reader</a> interface 可以表示从实体中读取字节流。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即只要实现了 <code>Read(buf []byte) (n int, err error)</code> 方法便就是 <code>io.Reader</code> 接口。Read最多将 <code>len(buf)</code> 字节读入buf并返回读取的字节, 直到读到 <code>io.EOF</code> 时返回。标准库中实现了很多Reader的实现。并且很多应用程序都接受 <code>Reader</code> 作为输入。</p><ul><li><strong>直接从字节流中读取</strong></li></ul><p>这里分为 <code>Read</code>、 <code>io.ReadFull</code>、 <code>ioutil.ReadAll</code> 三种方法。每种方法都有一些区别。</p><ol><li>直接使用 Read 方法</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r := strings.NewReader(<span class="string">&quot;abcde&quot;</span>)</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(buf)</span><br><span class="line">fmt.Println(n, err, buf[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个字节流 <code>r</code>, 在循环从r中读取出数据。循环会执行3次，第一次读取4个字节，第二次读取1个字节，第三次读到 <code>io.EOF</code> 返回跳出循环。注意，Read方法读取时会清空 <code>buf</code> 里的数据，所以这里需要每次读完打印一下。再次读时，<code>buf</code> 里的数据会被重新覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 &lt;nil&gt; [97 98 99 100]</span><br><span class="line">1 &lt;nil&gt; [101]</span><br><span class="line">0 EOF []</span><br></pre></td></tr></table></figure><p>另外还可以使用 <code>io.ReadFull</code> 或者 <code>ioutil.ReadAll</code> 取读取字节流,<code>io.ReadFull</code>用法和<code>Read</code>差不多，<code>ioutil.ReadAll</code>不需要设置buf可直接返回buf。更多可参考：<a href="https://yourbasic.org/golang/io-reader-interface-explained/">How to use the io.Reader interface</a></p><ul><li><strong>利用接口特性</strong></li></ul><p>下面的代码是一个实时统计标准输入字符个数的代码。用户每次按下回车都可以看到当前输入的字符以及历史上已经输入的字符的个数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountNumber</span><span class="params">(input <span class="keyword">chan</span> []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> input &#123;</span><br><span class="line">count += <span class="built_in">len</span>(data)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> bytes := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>)</span><br><span class="line"> fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line"> <span class="keyword">go</span> CountNumber(bytes)</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，但是似乎和我们要讲到的接口式编程没什么关系。下面我们用接口封装一下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCountReader</span><span class="params">()</span> *<span class="title">CountReader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CountReader&#123;</span><br><span class="line">bytes: <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>),</span><br><span class="line">data:  <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountReader <span class="keyword">struct</span> &#123;     <span class="comment">// 声明CountReader对象</span></span><br><span class="line">bytes    <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line">data     []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123; <span class="comment">// 实现Read方法</span></span><br><span class="line">ok := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> ok &amp;&amp; <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line">h.data, ok = &lt;-h.bytes   <span class="comment">// 将bytes里的数据全部传给 data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok || <span class="built_in">len</span>(h.data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, io.EOF    <span class="comment">// 可能读到了结尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l := <span class="built_in">copy</span>(p, h.data)</span><br><span class="line">h.data = h.data[l:]</span><br><span class="line"><span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountReader)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := bufio.NewReader(h)</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">n,err := b.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">count += <span class="built_in">len</span>(buf[:n])</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Received %d Characters: === %s \n&quot;</span>,count, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明了一个结构体 <code>CountReader</code>, 再实现了一个 <code>Read()</code> 方法调用，我们知道实现了<code>Read()</code>即可以成为 <code>io.Reader</code> 接口的实现。也就是说 <code>CountReader</code> 就是一个 <code>io.Reader</code> ，那么 <code>io.Reader</code> 可以使用的方法，也可以给 <code>CountReader</code> 使用。这时就可以使用 <code>bufio</code> 这个库了。使用 <code>bufio.NewReader</code> 的函数对输入数据进行读取和计算。</p><p class="div-border yellow"><code>bufio.NewReader()</code> 方法提供一个缓存buf, 默认缓存4k buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Please enter the string to be calculated：&quot;</span>)</span><br><span class="line">Counter := NewCountReader()</span><br><span class="line"><span class="keyword">go</span> Counter.run()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;input)</span><br><span class="line">Counter.bytes &lt;- []<span class="keyword">byte</span>(input)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来通过上述代码即可完成相同的操作，这只是一个简单的例子，如果换成文件io、网络io就会有非常可观的收益。带来业务性能的提升。</p><h1 id="Functional-Option"><a href="#Functional-Option" class="headerlink" title="Functional Option"></a>Functional Option</h1><p>Functional Options 这个编程模式是一个函数式编程的应用案例，编程技巧也很好，是目前 Go 语言中最流行的一种编程模式。</p><p>假设实际编程中需要针对业务对象设置很多属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr     <span class="keyword">string</span></span><br><span class="line">    Port     <span class="keyword">int</span></span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    MaxConns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 Server 对象中，我们可以看到：</p><ul><li>要设置侦听的 IP 地址 Addr 和端口号 Port。（必填）</li><li>协议、超时时间、最大链接数、TLS选项等属性需要配置。（非必填）</li></ul><p>那么如何让调用方实现这个必填参数和非必填参数呢？一个方法是将非必填参数设成 <code>...interface&#123;&#125;</code> 但这样肯定不好，因为不同的参数类型都不一样。另一种方式就是将 必填参数和非必填参数分开了。</p><p>如非必填参数搞成一个结构体</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Protocol <span class="keyword">string</span></span><br><span class="line">    Timeout  time.Duration</span><br><span class="line">    Maxconns <span class="keyword">int</span></span><br><span class="line">    TLS      *tls.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必填参数和这个 <code>Config</code> 直接传给初始化函数，如果没有要填的参数可以将 <code>Config</code> 设为 <code>nil</code> 。</p><p>这样一来 <code>Server</code> 结构体便成了这样, 初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Conf *Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, conf *Config)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using the default configuratrion</span></span><br><span class="line">srv1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>, <span class="literal">nil</span>) </span><br><span class="line"></span><br><span class="line">conf := ServerConfig&#123;Protocol:<span class="string">&quot;tcp&quot;</span>, Timeout: <span class="number">60</span>*time.Duration&#125;</span><br><span class="line">srv2, _ := NewServer(<span class="string">&quot;locahost&quot;</span>, <span class="number">9000</span>, &amp;conf)</span><br></pre></td></tr></table></figure><p>这样便已经是大多数人的作法了。但是不是没有修改空间，下面介绍一下 Functional Option 方式。</p><h2 id="初始化-Server-示例"><a href="#初始化-Server-示例" class="headerlink" title="初始化 Server 示例"></a><strong>初始化 Server 示例</strong></h2><p>首先我们定义一个 <code>Option</code> 类型:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span></span></span><br></pre></td></tr></table></figure><p>用函数式方式定义一组函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Protocol</span><span class="params">(p <span class="keyword">string</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Protocol = p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeout</span><span class="params">(timeout time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.Timeout = timeout</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxConns</span><span class="params">(maxconns <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.MaxConns = maxconns</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TLS</span><span class="params">(tls *tls.Config)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">        s.TLS = tls</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这组代码的含义是传入一个参数，返回一个函数，函数会将 <code>Server</code> 结构的对应参数值进行设置。例如，当我们调用其中的一个函数 MaxConns(30) 时，其返回值是一个 func(s* Server) { s.MaxConns = 30 } 的函数。</p><p>这下，我们可以定义一个 <code>NewServer</code> 函数，其中有一个可变参数 <code>option</code> ,用一个循环来设置 Server 的属性。不仅提供了默认值，还提供将默认值改成可修改选项进行修改。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>, options ...<span class="keyword">func</span>(*Server)</span>) <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  srv := Server&#123;</span><br><span class="line">    Addr:     addr,</span><br><span class="line">    Port:     port,</span><br><span class="line">    Protocol: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">    Timeout:  <span class="number">30</span> * time.Second,</span><br><span class="line">    MaxConns: <span class="number">1000</span>,</span><br><span class="line">    TLS:      <span class="literal">nil</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">    option(&amp;srv)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;srv, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，我们在创建 Server 对象的时候，就可以像下面这样：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s1, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">1024</span>)</span><br><span class="line">s2, _ := NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">2048</span>, Protocol(<span class="string">&quot;udp&quot;</span>))</span><br><span class="line">s3, _ := NewServer(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8080</span>, Timeout(<span class="number">300</span>*time.Second), MaxConns(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p>这下对 Server 的封装就像搭积木一样简单容易并且可视化很好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为了巩固一下 Go 的基础，主要涉及 Slice、Interface、函数式编程等。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>探索 Webtransport</title>
    <link href="http://kiosk007.top/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/"/>
    <id>http://kiosk007.top/2021/01/23/%E6%8E%A2%E7%B4%A2-Webtransport/</id>
    <published>2021-01-23T02:33:00.000Z</published>
    <updated>2021-01-23T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://wicg.github.io/web-transport/">WebTransport</a> 是一个新一代的浏览器API，提供客户端-服务端之间的双向低延迟交互，并在顶部使用常见 API 来实现其下的可插拔协议（<font style="color:#FF7F50">尤其是基于<a style="color:#FF7F50" href=" https://www.chromium.org/quic">QUIC</a></font>）。该 API 与 WebSocket 相似，也是客户端和服务器的双向连接，但允许进一步减少客户端和服务器之间的网络通信延迟，并且还支持多个流、单向流、乱序和不可靠传输。基于QUIC的Webtransport (Quictransport)即支持通过 datagram API 发送不可靠的数据，也支持通过 stream API 实现可靠数据传输。</p><p>使用场景包括使用不可靠且乱序的消息向服务器重复发送低延迟的游戏状态、从服务器到客户端的媒体片段的低延迟传输以及大多数逻辑在服务器上运行的云场景。</p><p>WebTransport 提案详细介绍：<font style="color:#FF7F50"> <a href="https://wicg.github.io/web-transport/">https://wicg.github.io/web-transport/</a> </font></p><p><strong>重点</strong></p><ol><li>Webtransport 支持不可靠传输，通过轻量级、低延迟的UDP协议传输。</li><li>Webtransport 可基于 QUIC 实现 Client-Server 可靠的流式传输。</li><li>可支持多条流的相互独立 + QUIC 多路复用\非队头阻塞特性 完美代替当前的 Websocket。Webtransport 提供了一些当前websocket规范不可能提供的功能。可消除当前多个数据包之间的队头阻塞。</li></ol><p><strong>标准规范</strong></p><ol><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-overview-01"> WebTransport overview </a> : Webtransport 的概述及对传输层的要求。</li><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-quic"> WebTransport over QUIC</a> : 定义了基于QUIC的 Webtransport</li><li><a style="color:#FF7F50" href="https://tools.ietf.org/html/draft-vvv-webtransport-http3-02"> WebTransport over HTTP/3 </a>: 定义了基于HTTP/3的 Webtransport （实际上 HTTP/3 也是基于QUIC的）</li></ol><p>当前 Chrome 团队只实现了基于 QUIC 的 Webtransport 。然而目前也仅仅是实验性的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transport = <span class="keyword">new</span> QuicTransport(<span class="string">&#x27;quic-transport://localhost:4433/path&#x27;</span>);</span><br></pre></td></tr></table></figure><br>Webtransport draft 标明是支持TCP的， 但显然目前大家都在UDP上了投入了大量精力，也主要是以UDP去实现的。</p><p><img src="https://img1.kiosk007.top/static/images/network/WebTransport/common_transport_requirements.png"></p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>当前的Webtransport 必须基于 QUIC draft-29 或更高版本。客户端主要以 chrome 浏览器为主，版本必须 &gt;= 85 。服务端我们将基于 <a href="github.com/lucas-clemente/quic-go" style="color:#FF7F50"> github.com/lucas-clemente/quic-go </a>  go library 。因为是本地测试，我们还需要签发一个自签名证书。</p><h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>因为当前Webtransport的底层实现是基于 QUIC or HTTP/3 ，所以我们必须要实现自签名证书，确保通信过程的安全性。这里我们使用的是 <code>openssl</code> </p><p>首先需要确保你的 <code>openssl</code> 安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ <span class="built_in">which</span> openssl</span><br><span class="line">/usr/bin/openssl</span><br><span class="line">➜ openssl version</span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>创建证书和私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl req -newkey rsa:2048 -nodes -keyout certificate.key \</span><br><span class="line">-x509 -out certificate.pem -subj <span class="string">&#x27;/CN=Test Certificate&#x27;</span> \</span><br><span class="line">-addext <span class="string">&quot;subjectAltName = DNS:localhost&quot;</span></span><br></pre></td></tr></table></figure><p>计算证书的指纹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl x509 -pubkey -noout -<span class="keyword">in</span> certificate.pem |</span><br><span class="line">openssl rsa -pubin -outform der |</span><br><span class="line">openssl dgst -sha256 -binary | base64</span><br><span class="line"><span class="comment">#      The result should be a base64-encoded blob that looks like this:</span></span><br><span class="line"><span class="comment">#          &quot;Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=&quot;</span></span><br></pre></td></tr></table></figure><p>向chrome传入参数指明允许使用自签证书的服务端地址+端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--origin-to-force-quic-on=localhost:4433</span><br></pre></td></tr></table></figure><p>使用如下参数以信任证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ignore-certificate-errors-spki-list=Gi/HIwdiMcPZo2KBjnstF5kQdLI5bPrYJ8i3Vi6Ybck=</span><br></pre></td></tr></table></figure><br>更多可以参考： <a href="https://www.chromium.org/developers/how-tos/run-chromium-with-flags">docs on how to run Chrome/Chromium with custom flags.</a></p><p>最后打开 <a style="color:#FF7F50" href="https://googlechrome.github.io/samples/webtransport/client.html">https://googlechrome.github.io/samples/webtransport/client.html</a></p><p><img src="https://img1.kiosk007.top/static/images/network/WebTransport/webtransport_client.png" style="height:550px"></p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>我们使用 github.com/lucas-clemente/quic-go 来实现QUIC。</p><p>Run 方法来实现接受客户端的连接请求。quic.ListenAddr 创建一个监听器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   listener, err := quic.ListenAddr(s.config.ListenAddr, s.generateTLSConfig(), s.generateQUICConfig())</span><br><span class="line">   utils.Logging.Info().Err(err)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;WebTransport Engine v0.1 Start ...&quot;</span>)</span><br><span class="line">   utils.Logging.Info().Msgf(<span class="string">&quot;Listening for %s connections on %s&quot;</span>,<span class="string">&quot;udp&quot;</span>, s.config.ListenAddr)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      session, err := listener.Accept(context.Background())</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      utils.Logging.Info().Msgf(<span class="string">&quot;session accepted: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _ = session.CloseWithError(<span class="number">0</span>, <span class="string">&quot;bye&quot;</span>)</span><br><span class="line">            utils.Logging.Info().Msgf(<span class="string">&quot;close session: %s&quot;</span>, session.RemoteAddr().String())</span><br><span class="line">         &#125;()</span><br><span class="line">         s.handleSession(session)</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端需要在 ALPN 中携带 alpnQuicTransport = “wq-vvv-01” 服务端读取后就会针对开始Webtransport 传输。<br><img src="https://img1.kiosk007.top/static/images/network/WebTransport/wq-vvv-01_alpn.png" style="height:550px"></p><p>代码参见：<a href="https://github.com/weijiaxiang007/webtransport/" style="color:#FF7F50"> https://github.com/weijiaxiang007/webtransport/ </a></p><h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p><font style="color:#6495ED">QUIC使用流ID的最低两位指示流标识以下信息</font></p><ol><li>单向 or 双向流</li><li>由客户端 or 服务端发起。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+----------------------------------+</span><br><span class="line">| Bits | Stream Type                      |</span><br><span class="line">+======+==================================+</span><br><span class="line">| 0x0  | Client-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x1  | Server-Initiated, Bidirectional  |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x2  | Client-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br><span class="line">| 0x3  | Server-Initiated, Unidirectional |</span><br><span class="line">+------+----------------------------------+</span><br></pre></td></tr></table></figure><ul><li>对于每一个双向流，流的发起方和流的接收方均可以在一条双向流上传输数据。</li><li>对于每一条单向流，只能是流的发起方向流的接收方发送数据。接收方可以在一条新的单向流上回复数据。</li><li>对于数据报格式的数据，由于 quic-go 底层不支持，这里不再赘述。不过已经有相关的提交去支持 <a href="https://github.com/lucas-clemente/quic-go/pull/2162" style="color:#FF7F50"> https://github.com/lucas-clemente/quic-go/pull/2162 </a></li></ul><p>更多信息参见：<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1" style="color:#FF7F50">https://tools.ietf.org/html/draft-ietf-quic-transport-27#section-2.1</a></p><p><font style="color:#6495ED">客户端请求</font><br>客户端请求一般 按照 Key — Value 的方式携带请求的资源标识。如下是请求的 Origin 和 Path。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientIndicationKey <span class="keyword">int16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   clientIndicationKeyOrigin clientIndicationKey = <span class="number">0</span></span><br><span class="line">   clientIndicationKeyPath                       = <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Key (16)            |          Length (16)          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Value (*)                         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>这里只实现了双向流，可以看到双向流建立之前会先建立一个单向流用于认证信息。之后的数据会在双向流上传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WebTransportServerQuic)</span> <span class="title">handleSession</span><span class="params">(sess quic.Session)</span></span> &#123;</span><br><span class="line">stream, err := sess.AcceptUniStream(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utils.Logging.Info().Msgf(<span class="string">&quot;unidirectional stream accepted, id: %d&quot;</span>, stream.StreamID())</span><br><span class="line">indication, err := receiveClientIndication(stream)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utils.Logging.Info().Msgf(<span class="string">&quot;client indication: %+v&quot;</span>, indication)</span><br><span class="line"><span class="keyword">if</span> err := s.validateClientIndication(indication); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = s.communicate(sess)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utils.Logging.Error().Err(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的长连接协议如 websocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。时至今日，互联网的时代已由HTTP2.0 迈入了 HTTP3 的时代，而对长连接的需求日益升温，由于websocket本身的限制，完全不能复用 QUIC 的高性能优势，所以孕育而生了基于 QUIC 的新一代长连接 Webtransport 。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="QUIC" scheme="http://kiosk007.top/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>Go Reflect </title>
    <link href="http://kiosk007.top/2021/01/18/Go-Reflect/"/>
    <id>http://kiosk007.top/2021/01/18/Go-Reflect/</id>
    <published>2021-01-18T15:57:00.000Z</published>
    <updated>2021-01-18T15:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言标准库 <a href="https://golang.org/pkg/reflect/">reflect</a> 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。</p><a id="more"></a><h1 id="类型和接口-Types-and-interfaces"><a href="#类型和接口-Types-and-interfaces" class="headerlink" title="类型和接口 (Types and interfaces)"></a>类型和接口 (Types and interfaces)</h1><p>因为反射是建立在类型之上的，所以想要了解反射必须先知道Go 语言中所有的变量都有一个静态类型。例如 <code>int</code>、<code>[]byte</code>、<code>float32</code>、<code>*MyType</code>等等。<br>如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure><br>接口是一种特殊的类型，它表示固定的方法集。接口变量可以存储任何具体（非接口）值,只要该值实现接口的方法。最经典的例子便是 io.Reader \ io.Writer 。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有人说Go的接口是动态类型的，但这是误导。它们是静态类型。一个特殊的例子是空接口，即 <code>interface&#123;&#125;</code>。</p><p>在这个例子中。<font style="color:#00008B">os.OpenFile</font> 的返回参数tty的类型是 <code>*os.File</code>，由于 <code>*os.File</code> 实现了 <font style="color:#00008B">Read()</font> 方法，所以该类型可以被赋于类型 io.Reader (io.Reader是一个interface)。尽管 <code> *os.File</code> 实现了很多方法，但是变量r仅有一个方法Read。但内部的值仍包含有关该值的所有类型信息。这就是为什么我们可以做 <code>w=r.(io.Writer)</code> 的原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>) <span class="comment">// tty *os.File</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> &#125;</span><br><span class="line">r = tty</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer    </span><br><span class="line">w = r.(io.Writer)  <span class="comment">// 由于r实际内部是有Write方法的，所以r可以被断言成 io.Writer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;12345&quot;</span>));err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">_ = tty.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以继续执行下面的操作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br><span class="line">fmt.Println(reflect.TypeOf(empty))</span><br></pre></td></tr></table></figure></p><h2 id="反射基本用法"><a href="#反射基本用法" class="headerlink" title="反射基本用法"></a>反射基本用法</h2><h3 id="从接口值到反射对象"><a href="#从接口值到反射对象" class="headerlink" title="从接口值到反射对象"></a><font style="color:#483D8B"><strong>从接口值到反射对象</strong></font></h3><p>ValueOf用来获取输入参数接口中的数据的值。如果是空接口则返回 invalid 。<br>TypeOf用来动态获取输入参数接口中的值的类型，如果空接口则返回nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>,reflect.TypeOf(num))     <span class="comment">// type:  float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>,reflect.ValueOf(num))   <span class="comment">// value:  1.2345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以判断类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(v)</span><br><span class="line"><span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line">fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;   <span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从反射对象到接口值"><a href="#从反射对象到接口值" class="headerlink" title="从反射对象到接口值"></a><font style="color:#483D8B"><strong>从反射对象到接口值</strong></font></h3><p>go 提供了反射和反射的逆，可以通过 <code>.(type)</code> 断言的方式将一个Interface()转成他真正的类型。如果断言的类型不匹配，会发生panic。</p><p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说 明</th></tr></thead><tbody><tr><td>Interface() interface{}</td><td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td>Int() int64</td><td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td>Uint() uint64</td><td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td>Float() float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td>Bool() bool</td><td>将值以 bool 类型返回</td></tr><tr><td>Bytes() []bytes</td><td>将值以字节数组 []bytes 类型返回</td></tr><tr><td>String() string</td><td>将值以字符串类型返回</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi <span class="keyword">float64</span></span><br><span class="line">pi = <span class="number">3.1415926</span></span><br><span class="line">v := reflect.ValueOf(pi)</span><br><span class="line">y := v.Interface().(<span class="keyword">float64</span>) <span class="comment">// y will have type float64.</span></span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></table></figure><h3 id="要修改反射对象，该值必须可设置"><a href="#要修改反射对象，该值必须可设置" class="headerlink" title="要修改反射对象，该值必须可设置"></a><font style="color:#483D8B"><strong>要修改反射对象，该值必须可设置</strong></font></h3><p>如果运行下面的代码将会 <font style="color:#8B0000"> panic </font> ，这时因为 v 是不可设置的。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>备  注</th></tr></thead><tbody><tr><td>Elem() Value</td><td>取值指向的元素值，类似于语言层*操作</td></tr><tr><td>Addr() Value</td><td>对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机</td></tr><tr><td>CanAddr() bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet() bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>通过 <code>CanSet()</code> 即可判断，<code>CanSet()</code> 报告 v 的值是否可以改变。值只能在可寻址的情况下更改，并且不能通过使用未导出的结构字段获取。如果 CanSet 返回 false ，则调用 Set 或任何类型特定的 setter （例如 SetBool ，SetInt ）将会发生panic。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><br>v 不可寻址，因为 v 只是 x 的拷贝，即便把 x 换成 &amp;x,还是不可寻址，因为 <code>reflect.ValueOf(&amp;x)</code> 也仅仅是 x 指针的拷贝。实际上，所有通过 <code>reflect.ValueOf(x)</code> 返回的 reflect.Value 都是不可取地址的。但是通过调用 <code>reflect.ValueOf(&amp;x).Elem()</code>，来获取任意变量x对应的可取地址的 Value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span></span><br><span class="line">x = <span class="number">3.1415</span></span><br><span class="line">pv := reflect.ValueOf(&amp;x)</span><br><span class="line">pv = pv.Elem()</span><br><span class="line">pv.SetFloat(<span class="number">7.1</span>) </span><br><span class="line"></span><br><span class="line">fmt.Println(x)   <span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure><h2 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h2><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) StructField</td><td>根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生panic</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量。当类型不是结构体或索引超界时发生panic</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生 panic</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时发生 panic</td></tr><tr><td>FieldByNameFunc( match func(string) bool) (StructField,bool)</td><td>根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生panic</td></tr></tbody></table></div><h3 id="普通结构体"><a href="#普通结构体" class="headerlink" title="普通结构体"></a>普通结构体</h3><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>假设有以下 <code>User struct</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int</span></span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Work    Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">Id           <span class="keyword">int</span></span><br><span class="line">Occupation   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;My Id :%d ,My Name :%s ,My Occupation :%s&quot;</span>,u.Id,u.Name,u.Work.Occupation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFuncHasArgs</span><span class="params">(foo <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;This is number %d \n&quot;</span>, foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来演示的是如何通过反射区打印结构体中的所有对象、打印结构体中的所有字段、调用方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">Work: Worker&#123;</span><br><span class="line">Id: <span class="number">1</span>,</span><br><span class="line">Occupation: <span class="string">&quot;farmer&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(user)</span><br><span class="line">fmt.Println(<span class="string">&quot;get type is: &quot;</span>,getType.Name())  <span class="comment">// get type is:  User</span></span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line">fmt.Println(<span class="string">&quot;get all Fields is &quot;</span>, getValue) <span class="comment">// get all Fields is  &#123;1 Kiosk &#123;1 farmer&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字段进行遍历 获取方法的字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumField();i++ &#123;</span><br><span class="line">field := getType.Field(i)</span><br><span class="line">value := getValue.Field(i).Interface()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: %v = %v \n&quot;</span>,field.Name,field.Type,value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Id: int = 1</span></span><br><span class="line"><span class="comment">Name: string = Kiosk</span></span><br><span class="line"><span class="comment">Work: main.Worker = &#123;1 farmer&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; getType.NumMethod();i++ &#123;</span><br><span class="line">m := getType.Method(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s : %v\n&quot;</span>,m.Name,m.Type)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ReflectCallFunc : func(main.User)</span></span><br><span class="line"><span class="comment">   ReflectCallFuncHasArgs : func(main.User, int)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="comment">// 有参数调用</span></span><br><span class="line">methodValue := getValue.MethodByName(<span class="string">&quot;ReflectCallFuncHasArgs&quot;</span>)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(<span class="number">2</span>)&#125;</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is number 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数调用</span></span><br><span class="line">methodValue = getValue.MethodByName(<span class="string">&quot;ReflectCallFunc&quot;</span>)</span><br><span class="line">args = <span class="built_in">make</span>([]reflect.Value,<span class="number">0</span>)</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">My Id :1 ,My Name :Kiosk ,My Occupation :farmer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带tag的struct"><a href="#带tag的struct" class="headerlink" title="带tag的struct"></a>带tag的struct</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int</span> <span class="string">`json:&quot;id&quot;   bson:&quot;id&quot;`</span></span><br><span class="line">Name    <span class="keyword">string</span><span class="string">`json:&quot;name&quot; bson:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(user)</span><br><span class="line">fmt.Printf(<span class="string">&quot;get type is: %v \n&quot;</span>,getType.String())  <span class="comment">// get type is:  main.User</span></span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line">fmt.Println(getValue) <span class="comment">// &#123;1 Kiosk&#125;</span></span><br><span class="line"></span><br><span class="line">name := getValue.FieldByName(getType.Field(<span class="number">1</span>).Name).String()</span><br><span class="line">fmt.Printf(<span class="string">&quot;name is %s \n&quot;</span>, name)  <span class="comment">// name is Kiosk</span></span><br><span class="line"></span><br><span class="line">tag := getType.Field(<span class="number">0</span>).Tag</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %v  tag: &#x27;%v&#x27;\n&quot;</span>, getType.Field(<span class="number">0</span>).Name, tag) <span class="comment">// name: Id  tag: &#x27;json:&quot;id&quot;   bson:&quot;id&quot;&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;tag is %s, %s \n&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), tag.Get(<span class="string">&quot;bson&quot;</span>)) <span class="comment">//  tag is id, id </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断反射值的有效性和空"><a href="#判断反射值的有效性和空" class="headerlink" title="判断反射值的有效性和空"></a>判断反射值的有效性和空</h2><p>IsNil()和IsValid() — 判断反射值的空和有效性</p><p>反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。</p><div class="table-container"><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>IsNil() bool</td><td>返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的v== nil操作</td></tr><tr><td>IsValid() bool</td><td>判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*int的空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;var a *int:&quot;</span>, reflect.ValueOf(a).IsNil())  </span><br><span class="line">    <span class="comment">// var a *int: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//nil值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;nil:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid()) </span><br><span class="line">    <span class="comment">// nil: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*int类型的空指针</span></span><br><span class="line">fmt.Println(<span class="string">&quot;(*int)(nil):&quot;</span>, reflect.ValueOf((*<span class="keyword">int</span>)(<span class="literal">nil</span>)).Elem().IsValid()) </span><br><span class="line">    <span class="comment">// (*int)(nil): false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个结构体</span></span><br><span class="line">s := <span class="keyword">struct</span> &#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从结构体中查找一个不存在的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(s).FieldByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的结构体成员: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从结构体中查找一个不存在的方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的方法:&quot;</span>, reflect.ValueOf(s).MethodByName(<span class="string">&quot;&quot;</span>).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的方法: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个map</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的键:&quot;</span>, reflect.ValueOf(m).MapIndex(reflect.ValueOf(<span class="number">3</span>)).IsValid()) </span><br><span class="line">    <span class="comment">// 不存在的键: false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 语言标准库 &lt;a href=&quot;https://golang.org/pkg/reflect/&quot;&gt;reflect&lt;/a&gt; 提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。&lt;/p&gt;</summary>
    
    
    
    <category term="programming" scheme="http://kiosk007.top/categories/programming/"/>
    
    
    <category term="Go" scheme="http://kiosk007.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>TLS详解（三）</title>
    <link href="http://kiosk007.top/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://kiosk007.top/2021/01/16/TLS%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-01-16T08:48:00.000Z</published>
    <updated>2021-01-16T08:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。</p><a id="more"></a><ul><li><a href="https://www.kiosk007.top/2020/05/02/TLS-%E8%AF%A6%E8%A7%A3/">TLS 详解一</a></li><li><a href="https://www.kiosk007.top/2020/05/04/TLS-%E8%AF%A6%E8%A7%A3-%E4%BA%8C/">TLS 详解二</a></li></ul><h1 id="TLS1-3-Feature"><a href="#TLS1-3-Feature" class="headerlink" title="TLS1.3 Feature"></a>TLS1.3 Feature</h1><ul><li><font color="#7B68EE">Speed Benefits of TLS 1.3</font></li></ul><p>TLS1.3 可以使用1RTT建立握手，比1.2版本能节约一个网络来回。</p><p><img style="height:300px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-performance.png"></p><ul><li><font color="#7B68EE">Improved Security With TLS 1.3</font></li></ul><p>TLS1.3 移除了RC4、DES、MD5 等诸多脆弱不安全的算法，目前仅保持了支持AEAD的ECDH类等算法。</p><ul><li><font color="#7B68EE"> 1.3 Browser Support</font></li></ul><p>从 Chrome65 开始，Google公司就可以支持 <a href="http://www.chromium.org/Home/tls13">draft version of TLS 1.3 </a> , 2018年10月的 Chrome70 就完全支持了TLS1.3。同样Firefox63也在同年10月支持了TLS1.3。Microsoft Edge version 76 及 Safari 12.1 on macOS 10.14.4. 也都支持了TLS1.3 。</p><h1 id="The-TLS-handshake"><a href="#The-TLS-handshake" class="headerlink" title="The TLS handshake"></a>The TLS handshake</h1><p>总体握手流程如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">handshake</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c := hs.c</span><br><span class="line"></span><br><span class="line"><span class="comment">// For an overview of the TLS 1.3 handshake, see RFC 8446, Section 2.</span></span><br><span class="line"><span class="keyword">if</span> err := hs.processClientHello(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.checkForResumption(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.pickCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">c.buffering = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerParameters(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerCertificate(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.sendServerFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"><span class="comment">// Note that at this point we could start sending application data without</span></span><br><span class="line"><span class="comment">// waiting for the client&#x27;s second flight, but the application might not</span></span><br><span class="line"><span class="comment">// expect the lack of replay protection of the ClientHello parameters.</span></span><br><span class="line"><span class="keyword">if</span> _, err := c.flush(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err  &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.readClientCertificate(); err != <span class="literal">nil</span> &#123;  <span class="keyword">return</span> err  &#125;</span><br><span class="line"><span class="keyword">if</span> err := hs.readClientFinished(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"></span><br><span class="line">atomic.StoreUint32(&amp;c.handshakeStatus, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/network/TLSDetailAnalysis/tls-1.3.png"></p><h2 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a><font style="color:#4682B4">Client Hello</font></h2><p>由于TLS1.2已经在互联网上存在了10年。网络中大量的网络中间设备都十分老旧，这些网络设备会识别中间的TLS握手头部，所以TLS1.3的出现如果引入了未知的TLS Version 必然会存在大量的握手失败，为了解决这一点，TLS1.3 的握手头部默认是TLS1.2。</p><p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-clienthello.png"></p><p>如果客户端支持TLS1.3 则在 <strong><font style="color:#483D8B">Client Hello</font></strong> 发出时在Extensions中携带 supported_versions 并标明客户端是支持TLS1.3的，同样为了1RTT快速握手，会将客户端Key_share 发送给服务端。Key_Share是客户端提前生成好的公钥信息。其密钥派生过程依赖于密码套件的 HKDF Extract 和 HKDF Expand 函数以及 Hash函数。</p><p>在密钥交换之前，客户端和服务端使用HKDF生成密钥。（它取代了基于HMAC的伪随机密钥生成函数PRF。</p><p>下面用代码过一遍客户端的Client Hello流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> params ecdheParameters</span><br><span class="line"><span class="keyword">if</span> hello.supportedVersions[<span class="number">0</span>] == VersionTLS13 &#123;</span><br><span class="line">hello.cipherSuites = <span class="built_in">append</span>(hello.cipherSuites, defaultCipherSuitesTLS13()...)</span><br><span class="line"></span><br><span class="line">curveID := config.curvePreferences()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> _, ok := curveForCurveID(curveID); curveID != X25519 &amp;&amp; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;tls: CurvePreferences includes unsupported curve&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">params, err = generateECDHEParameters(config.rand(), curveID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">hello.keyShares = []keyShare&#123;&#123;group: curveID, data: params.PublicKey()&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，如果客户端是支持  <font style="color:#483D8B">VersionTLS13</font>, 则在创建 <font style="color:#483D8B"> Client Hello </font> 时,添加TLS1.3支持的秘钥套件，并使用 x25519 曲线和随机数生成 <font style="color:#483D8B"> PublickKey </font>放入 <font style="color:#483D8B"> Client Hello Extension</font> 中的 <font style="color:#483D8B"> KeyShares </font> 中。</p><h2 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a><font style="color:#4682B4">Server Hello</font></h2><p>服务端的TLS Version仍为TLS1.2（实际上后续的TLS版本均为1.2），如果服务端支持TLS1.3，则会在  <font style="color:#483D8B">supported_versions</font> 中的携带TLS1.3，这样后续的会话便均在TLS1.3下通信。</p><p><img style="height:400px" src="/images/network/TLSDetailAnalysis/tls-1.3-handshake-serverhello.png"></p><p>服务端会在<font style="color:#483D8B"> Server Hello </font> 中的 <font style="color:#483D8B"> key_share </font> 中携带公钥信息。</p><p>下面是完整的握手过程，BTW <font style="color:red">虽然0RTT是各大博客都吹嘘的TLS1.3亮点，但是0RTT 当前大多数的官方库都还没有实现（Nginx似乎是支持了）</font> ，比如看这里<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hs.clientHello.earlyData &#123;</span><br><span class="line"><span class="comment">// See RFC 8446, Section 4.2.10 for the complicated behavior required</span></span><br><span class="line"><span class="comment">// here. The scenario is that a different server at our address offered</span></span><br><span class="line"><span class="comment">// to accept early data in the past, which we can&#x27;t handle. For now, all</span></span><br><span class="line"><span class="comment">// 0-RTT enabled session tickets need to expire before a Go server can</span></span><br><span class="line"><span class="comment">// replace a server or join a pool. That&#x27;s the same requirement that</span></span><br><span class="line"><span class="comment">// applies to mixing or replacing with any TLS 1.2 server.</span></span><br><span class="line">c.sendAlert(alertUnsupportedExtension)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;tls: client sent unexpected early data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>服务端选择和客户端同样支持的 <font style="color:#483D8B"> CurveID </font>(代码中的 selectedGroup，并且是Client支持的Key Share)。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">params, err := generateECDHEParameters(c.config.rand(), selectedGroup)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.sendAlert(alertInternalError)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">hs.hello.serverShare = keyShare&#123;group: selectedGroup, data: params.PublicKey()&#125;</span><br><span class="line">hs.sharedKey = params.SharedKey(clientKeyShare.data)</span><br><span class="line"><span class="keyword">if</span> hs.sharedKey == <span class="literal">nil</span> &#123;</span><br><span class="line">c.sendAlert(alertIllegalParameter)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;tls: invalid client key share&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样以来，客户端和服务端便直接完成了 <font style="color:#483D8B">ECDHE</font> 密钥交换</p><ul><li>客户端生成随机数x，确定了曲线类型如Golang TLS SDK只支持的 <font style="color:#483D8B"> x25519曲线</font> 即可得方程系数a、b，再调用<code>generateECDHEParameters</code> 获得 <font style="color:#483D8B"> PublicKey Q<sub>1</sub> </font>。客户端将 Q<sub>1</sub> 、a、 b、 P 传给服务端。</li><li>服务端生成随机数y，解析客户端传来的曲线和 Key_Share 对，得到曲线类型 <font style="color:#483D8B"> x25519 </font>既得方程系数a、b，再使用 selectedGroup 和 y 调用<code>generateECDHEParameters</code> 生成 <font style="color:#483D8B"> PublicKey Q<sub>2</sub> </font> ,传给客户端</li><li>这时客户端和服务端可以计算出一个公共的值 <font style="color:#483D8B"> <strong>K</strong> </font></li></ul><p>如下图</p><p><img src="/images/network/TLSDetailAnalysis/ECDHE.png"></p><h3 id="PSK-Pre-Shared-Key"><a href="#PSK-Pre-Shared-Key" class="headerlink" title=" PSK (Pre-Shared Key)"></a><font style="color:#87CEEB"> PSK (Pre-Shared Key)</font></h3><p>这里在接着解析代码之前，先插播一个 TLS1.3 的feature 0RTT是如何实现的。这里介绍一下实现的原理 — <font style="color:#483D8B"> <strong>PSK</strong> </font></p><p>一旦一次握手完成，server 就能给 client 发送一个与一个独特密钥对应的 PSK 密钥，这个密钥来自初次握手。然后 client 能够使用这个 PSK 密钥在将来的握手中协商相关 PSK 的使用。如果 server 接受它，新连接的安全上下文在密码学上就与初始连接关联在一起，从初次握手中得到的密钥就会用于装载密码状态来替代完整的握手。在 TLS 1.2 以及更低的版本中，这个功能由 “session IDs” 和 “session tickets” [RFC5077]来提供。这两个机制在 TLS 1.3 中都被废除了。</p><p>PSK 可以与 (EC)DHE 密钥交换算法一同使用以便使共享密钥具备前向安全，或者 PSK 可以被单独使用，这样是以丢失了应用数据的前向安全为代价。</p><p>下图显示了两次握手，第一次建立了一个 PSK，第二次时使用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">       Client                                               Server</span><br><span class="line"></span><br><span class="line">Initial Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share               --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                       + key_share</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                             &#123;CertificateRequest*&#125;</span><br><span class="line">                                                    &#123;Certificate*&#125;</span><br><span class="line">                                              &#123;CertificateVerify*&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Certificate*&#125;</span><br><span class="line">       &#123;CertificateVerify*&#125;</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">                                 &lt;--------      [NewSessionTicket]</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subsequent Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share*</span><br><span class="line">       + pre_shared_key          --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                  + pre_shared_key</span><br><span class="line">                                                      + key_share*</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 server 通过一个 PSK 进行认证时，它不会发送一个 Certificate 或一个 CertificateVerify 消息。当一个 client 通过 PSK 想恢复会话的时候，它也应当提供一个 “key_share” 给 server，以允许 server 拒绝恢复会话的时候降级到重新回答一个完整的握手流程中。Server 响应 “pre_shared_key” 扩展，使用 PSK 密钥协商建立连接，同时响应 “key_share” 扩展来进行 (EC)DHE 密钥建立，由此提供前向安全。</p><p>当 PKS 在带外提供时，PSK 密钥和与 PSK 一起使用的 KDF hash 算法也必须被提供。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0 RTT"></a><font style="color:#87CEEB">0 RTT</font></h3><p>当 client 和 server 共享一个 PSK（从外部获得或通过一个以前的握手获得）时，TLS 1.3 允许 client 在第一个发送出去的消息中携带数据（”application data”）。Client 使用这个 PSK 来认证 server 并加密 early data 信息，最终实现Application数据的0RTT发送。</p><p>如下图所示，0-RTT 数据在第一个发送的消息中被加入到 1-RTT 握手过程中。握手的其余消息与带 PSK 会话恢复的 1-RTT 握手消息相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">+ early_data</span><br><span class="line">+ key_share*</span><br><span class="line">+ psk_key_exchange_modes</span><br><span class="line">+ pre_shared_key</span><br><span class="line">(Application Data*)     --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                           + pre_shared_key</span><br><span class="line">                                               + key_share*</span><br><span class="line">                                      &#123;EncryptedExtensions&#125;</span><br><span class="line">                                              + early_data*</span><br><span class="line">                                                 &#123;Finished&#125;</span><br><span class="line">                        &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;              --------&gt;</span><br><span class="line">[Application Data]      &lt;-------&gt;        [Application Data]</span><br></pre></td></tr></table></figure><p>上图是 0-RTT 的信息流</p><p>0-RTT 数组安全性比其他类型的 TLS 数据要弱一些，特别是：</p><ol><li>0-RTT 的数据是没有前向安全性的，它使用的是被提供的 PSK 中导出的密钥进行加密的。</li><li>在多个连接之间不能保证不存在重放攻击。普通的 TLS 1.3 1-RTT 数据为了防止重放攻击的保护方法是使用 server 下发的随机数，现在 0-RTT 不依赖于 ServerHello 消息，因此保护措施更差。如果数据与 TLS client 认证或与应用协议里一起验证，这一点安全性的考虑尤其重要。这个警告适用于任何使用 early_exporter_master_secret 的情况。</li></ol><p>参考 <strong><a href="https://halfrost.com/tls_1-3_introduction/">TLS 1.3 Introduction</a></strong> — Halfrost’s Field | 冰霜之地</p><h3 id="checkForResumption-—-Go"><a href="#checkForResumption-—-Go" class="headerlink" title=" checkForResumption — Go"></a><font style="color:#87CEEB"> checkForResumption — Go</font></h3><p>上面2个小节其实就是在介绍 <a href="https://golang.org/src/crypto/tls/handshake_server_tls13.go#226"><code>checkForResumption()</code></a> 这个函数的作用。</p><p>在Client Hello 包的扩展里如果有 <strong>psk_key_exchange_modes</strong> 和  <strong>pre_shared_key</strong> 就表示客户端想要会话复用，即类似TLS1.2的 <strong>Session Ticket</strong> or <strong>Session Id</strong> 的概念。</p><p>如下所示：</p><p><img src="/images/network/TLSDetailAnalysis/tls-1.3-psk_key_exchange_modes.png"></p><font style="color:#483D8B"> **psk_key_exchange_modes**</font>是 psk 密钥交互模式选择. 此处的PSK模式为(EC)DHE下的PSK，客户端和服务器必须提供KeyShare, 如果是仅PSK模式，则服务器不需要提供KeyShare。<img src="/images/network/TLSDetailAnalysis/tls-1.3-pre_shared_key.png"><font style="color:#483D8B"> **pre_shared_key**</font> 是预共享密钥认证机制，相当于session ticket再加一些检验的东西.Identity中包含的是客户端愿意进行协商的服务器身份列表。PSK binder表示已经构建当前PSK与当前握手之间的绑定。下面函数中，服务端会将 <font style="color:#483D8B">identity</font> 解析成 <font style="color:#483D8B">plaintext</font>，<font style="color:#483D8B">plaintext</font>中包含TLS版本、证书、复用秘钥、超时时间 等多个信息，如果unmarshal成功，即可以会话复用，继续向下。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, identity := <span class="keyword">range</span> hs.clientHello.pskIdentities &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= maxClientPSKIdentities &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">plaintext, _ := c.decryptTicket(identity.label)</span><br><span class="line"><span class="keyword">if</span> plaintext == <span class="literal">nil</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">sessionState := <span class="built_in">new</span>(sessionStateTLS13)</span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> ok := sessionState.unmarshal(plaintext); !ok &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">       </span><br><span class="line">       createdAt := time.Unix(<span class="keyword">int64</span>(sessionState.createdAt), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> c.config.time().Sub(createdAt) &gt; maxSessionTicketLifetime &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don&#x27;t check the obfuscated ticket age because it&#x27;s affected by</span></span><br><span class="line"><span class="comment">// clock skew and it&#x27;s only a freshness signal useful for shrinking the</span></span><br><span class="line"><span class="comment">// window for replay attacks, which don&#x27;t affect us as we don&#x27;t do 0-RTT.</span></span><br><span class="line"></span><br><span class="line">pskSuite := cipherSuiteTLS13ByID(sessionState.cipherSuite)</span><br><span class="line"><span class="keyword">if</span> pskSuite == <span class="literal">nil</span> || pskSuite.hash != hs.suite.hash &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">...</span><br><span class="line">psk := hs.suite.expandLabel(sessionState.resumptionSecret, <span class="string">&quot;resumption&quot;</span>,</span><br><span class="line"><span class="literal">nil</span>, hs.suite.hash.Size())</span><br><span class="line">hs.earlySecret = hs.suite.extract(psk, <span class="literal">nil</span>)</span><br><span class="line">binderKey := hs.suite.deriveSecret(hs.earlySecret, resumptionBinderLabel, <span class="literal">nil</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>## <font style="color:#4682B4"> Change Cipher Space</font><p>发送一个 <font style="color:#483D8B"><strong>ChangeCipherSpec record</strong></font> 报文，之后的加密方式将会改变。详见 See RFC 8446, Appendix D.4.</p><h2 id="EncryptedExtensions"><a href="#EncryptedExtensions" class="headerlink" title=" EncryptedExtensions "></a><font style="color:#4682B4"> EncryptedExtensions </font></h2><p>随后 Server 会发来建立 EncryptedExtensions Server 参数: 对 ClientHello 扩展的响应，不需要确定加密参数，而不是特定于各个证书的加密参数。一般ALPN会在这里添加。</p><h2 id="Certificate-amp-amp-Certificate-Verify-amp-amp-Finished"><a href="#Certificate-amp-amp-Certificate-Verify-amp-amp-Finished" class="headerlink" title=" Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished "></a><font style="color:#4682B4"> Certificate &amp;&amp; Certificate Verify &amp;&amp; Finished </font></h2><p>最后，Client 和 Server 交换认证消息。TLS 在每次基于证书的认证时使用相同的消息集，(基于 PSK 的认证是密钥交换中的一个副作用)特别是：</p><ul><li><p><font style="color:#483D8B">Certificate</font>: 终端的证书和每个证书的扩展。 服务器如果不通过证书进行身份验证，并且如果服务器没有发送CertificateRequest（由此指示客户端不应该使用证书进行身份验证），客户端将忽略此消息。 请注意，如果使用原始公钥 [RFC7250] 或缓存信息扩展 [RFC7924]，则此消息将不包含证书，而是包含与服务器长期密钥相对应的其他值。</p></li><li><p><font style="color:#483D8B">CertificateVerify</font>: 使用与证书消息中的公钥配对的私钥对整个握手消息进行签名。如果终端没有使用证书进行验证则此消息会被忽略。</p></li><li><p><font style="color:#483D8B">Finished</font>: 对整个握手消息的 MAC(消息认证码)。这个消息提供了密钥确认，将终端身份与交换的密钥绑定在一起，这样在 PSK 模式下也能认证握手。</p></li></ul><p>接收到 Server 的消息之后，Client 会响应它的认证消息，即 Certificate，CertificateVerify (如果需要), 和 Finished。</p><p>这时握手已经完成，client 和 server 会提取出密钥用于记录层交换应用层数据，这些数据需要通过认证的加密来保护。应用层数据不能在 Finished 消息之前发送数据，必须等到记录层开始使用加密密钥之后才可以发送。需要注意的是 server 可以在收到 client 的认证消息之前发送应用数据，任何在这个时间点发送的数据，当然都是在发送给一个未被认证的对端。</p><h2 id="New-Session-Ticket"><a href="#New-Session-Ticket" class="headerlink" title=" New Session Ticket "></a><font style="color:#4682B4"> New Session Ticket </font></h2><p>实际等同于发送 PSK 数据。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs *serverHandshakeStateTLS13)</span> <span class="title">shouldSendSessionTickets</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> hs.c.config.SessionTicketsDisabled &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t send tickets the client wouldn&#x27;t use. See RFC 8446, Section 4.2.9.</span></span><br><span class="line"><span class="keyword">for</span> _, pskMode := <span class="keyword">range</span> hs.clientHello.pskModes &#123;</span><br><span class="line"><span class="keyword">if</span> pskMode == pskModeDHE &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TLS 1.3现已于2018年8月发布。相比与TLS1.2，TLS1.3 在速度和安全性上做出了更大的性能提升，其最大的特点是支持了 Zero Round Trip Time (0-RTT). 在安全性方面，TLS1.3 摒弃了绝大多数不安全的加密套件，只支持几个AEAD的加密认证方式。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="tls" scheme="http://kiosk007.top/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>Git Quick Start</title>
    <link href="http://kiosk007.top/2020/12/19/Git-Quick-Start/"/>
    <id>http://kiosk007.top/2020/12/19/Git-Quick-Start/</id>
    <published>2020-12-19T11:11:00.000Z</published>
    <updated>2020-12-19T11:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>只是git入门的简单指南。没什么大不了的 :)</p><a id="more"></a><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br><img src="https://img1.kiosk007.top/static/images/git/git.png" style="height:340px"></p><h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><p><a href="https://git-scm.com/download/linux">安装 Git Linux 版</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install git</span><br><span class="line">$ apt-get install gitk</span><br></pre></td></tr></table></figure><br>gitk 是可以可视化的git客户端工具，更多工具参考 <a href="https://git-scm.com/download/gui/linux">git-gui</a> ，如 <a href="https://juejin.cn/post/6844903904451231757">Gitkraken (小章鱼)</a>、 <a href="https://magit.vc/manual/magit/Installing-from-the-Git-Repository.html#Installing-from-the-Git-Repository">magit</a> 等等</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li><strong>配置 user 信息</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name  <span class="string">&quot;your_name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;your_name@domain.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --local 只对某个分支有效</span></span><br><span class="line"><span class="comment"># --global 对当前用户所有仓库有效</span></span><br><span class="line"><span class="comment"># --system 对系统所有用户有效</span></span><br><span class="line"></span><br><span class="line">$ git config --global core.editor <span class="string">&quot;vim&quot;</span>    <span class="comment"># git 交互改为vim</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><strong>查看config的配置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>工作流</strong>:<br>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p><h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><ul><li><font color="#EEB422">**init 仓库**</font></li></ul><p>创建新文件夹，打开，然后执行 <strong><code>git init</code></strong> 以创建新的 git 仓库。</p><ul><li><font color="#EEB422">**添加 和 提交**</font></li></ul><ol><li>你可以提出更改（把它们添加到暂存区），使用如下命令：<strong><code>git add &lt;filename&gt;</code></strong>  或者  <strong><code>git add *</code></strong></li><li>使用如下命令以实际提交改动：<strong><code>git commit -m &quot;代码提交信息&quot;</code></strong></li><li>现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</li></ol><ul><li><font color="#EEB422">**推送改动**</font></li></ul><ol><li>改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：<strong><code>git push origin master</code></strong> (master 可以换成想要推送的分支)</li><li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<strong><code>git remote add origin &lt;server&gt;</code></strong> , 如此你就能够将你的改动推送到所添加的服务器上去了。</li></ol><h2 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><img src="https://img1.kiosk007.top/static/images/git/branches.png"></p><ul><li>创建一个叫做“feature_x”的分支，并切换过去：<strong><code>git checkout -b feature_x</code></strong></li><li>切换回主分支：<strong><code>git checkout master</code></strong></li><li>删除分支：<strong><code>git branch -d feature_x</code></strong></li><li>将自己的分支推送到远端：<strong><code>git push origin &lt;branch&gt;</code></strong></li></ul><h2 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h2><ul><li><font color="#FF8247">**基本命令**</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line">$ git mv old_filename new_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">$ git rm filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作区的状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为软件发布创建标签, 如v1.0.0</span></span><br><span class="line">$ git tag v1.0.0 1b2e1d63ff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看git提交后日志</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline     <span class="comment"># 一行显示</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 4          <span class="comment"># 查看最近的几次</span></span><br><span class="line">$ git <span class="built_in">log</span> --all --graph <span class="comment"># 以图形化方式显示所有的提交日志</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline --decorate --all  <span class="comment"># 通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签 </span></span><br><span class="line">$ git <span class="built_in">log</span> --author=bob  <span class="comment"># 只看某一个人的提交记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 查看 diff</span></span><br><span class="line">$ git diff              <span class="comment"># 对比工作区和暂存区的差异</span></span><br><span class="line">$ git diff --cached  <span class="comment"># 对比暂存区和HEAD所含文件(commit)的差异</span></span><br><span class="line">$ git diff -- style.css <span class="comment"># 只查看对某个文件的 diff 差异 (工作区和暂存区)</span></span><br><span class="line">$ git diff tmp master -- &lt;file&gt; <span class="comment"># 比较 tmp 和 master 分支的文件差异(也可以将branch改成commit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##---------- 取消提交</span></span><br><span class="line">$ git reset HEAD        <span class="comment"># 取消暂存 （取消 git add）</span></span><br><span class="line">$ git restore --staged &lt;file&gt;  <span class="comment"># 功能同上, 取消暂存 （可以 git status 查看当前的暂存状态）</span></span><br><span class="line"></span><br><span class="line">$ git checkout -- &lt;file&gt;      <span class="comment"># 在工作区的修改撤销到最近一次git add 或 git commit时的内容</span></span><br><span class="line">$ git reset --hard c04b46549  <span class="comment"># 恢复到历史上的某个 commit (工作区和暂存区都会清空)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><font color="#FF8247">**版本管理**</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">$ git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于某个历史版本创建分支(基于 ac886ae 创建一个tmp分支)</span></span><br><span class="line">$ git checkout -b tmp ac886ae </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个分支</span></span><br><span class="line">$ git checkout -d ac886ae  <span class="comment"># 没有merge的分支不能通过 -d 删除</span></span><br><span class="line">$ git checkout -D ac886ae</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###################### commit 相关 ###########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最近一次提交的 commit 信息</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改前几次提交的 commit 信息</span></span><br><span class="line">$ git rebase -i ac224ct   <span class="comment"># 交互式操作，ac224ct 是要修改的commit的父commit</span></span><br><span class="line">将pick改为r  :wq退出，</span><br><span class="line">变更内容     :wq退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="git常见使用"><a href="#git常见使用" class="headerlink" title="git常见使用"></a>git常见使用</h1><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a><font color="#FF4500"><strong>分离头指针</strong></font></h2><p>通常，我们工作在某一个分支上，比如 master 分支。这个时候 master 指针和 HEAD 指针是一起前进的，每做一次提交，这两个指针就会一起向前挪一步。但是在某种情况下（例如 checkout 了某个具体的 commit），master 指针 和 HEAD 指针这种「绑定」的状态就被打破了，变成了分离头指针状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜ git checkout fb7d808</span><br><span class="line">注意：正在切换到 <span class="string">&#x27;fb7d808&#x27;</span>。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 <span class="literal">false</span> 来关闭此建议</span><br><span class="line"></span><br><span class="line">HEAD 目前位于 fb7d808 Learn CSS demo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git 在对于这种没有 branch 的变更会被清除掉。所以如果想要变更最好跟着分支进行变更。</p><h2 id="git-stash-命令实用指南"><a href="#git-stash-命令实用指南" class="headerlink" title="git stash 命令实用指南"></a>git stash 命令实用指南</h2><p>为什么 git stash 很重要，假设Git没有暂存变更命令，当你在有2个分支（A和B）的仓库上工作时，假设这两个分支已经分叉很长时间，并且有不同的头，当你处理A的时候，团队要求修复B分支的一个错误，你迅速将你的修改保存到A分支(但没有提交 commit),并且尝试用 <code>git checkout B</code> 来切到B分支，git 会立即终止这个操作，并报错。“你对以下文件的本地修改会被签出覆盖… …请在切换分之前提交你的修改或者将他们暂存起来”</p><p>在这种情况下有几种方法来分支切换。</p><ul><li>在分支A中创建一个提交（git switch -c），提交并推送你的修改，以修复 B 中的错误。然后签出A，并运行 <code>git reset HEAD</code>, 来恢复修改。</li><li>手动保留不被Git 追踪文件中的改动。</li></ul><p>第二种就不说了，一点也不极客。第一种方法虽然看起来很传统，但是不灵活，因为保存未完成工作的修改会被当做一个检查点，而不是一个仍在进行中的补丁。这就是 <code>git stash</code> 的场景。</p><p><code>git stash</code> 将未提交的改动保存在本地，让你可以进行修改，切换分支及其他的操作。然后当你需要的时候，你可以重新应用这些存储的改动。暂存是本地范围的，不会被<code>git push</code> 推送的远端。</p><p>以下是一次 <code>git stash</code> 的操作顺序</p><ol><li>将修改保存到分支A</li><li>运行 <code>git stash</code></li><li>签出分支B</li><li>修正B分支的错误</li><li>提交并推送到远程</li><li>查看分支A</li><li>运行 <code>git stash pop</code> 来取回暂存的改动。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现将工作区的内容保存到暂存区</span></span><br><span class="line">$ git add *</span><br><span class="line"><span class="comment"># 将暂存区的内容 暂时保存</span></span><br><span class="line">$ git stash   </span><br><span class="line">$ git stash save <span class="string">&quot;message&quot;</span>   <span class="comment"># 功能同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切到历史版本修复bug ... </span></span><br><span class="line"></span><br><span class="line">$ git stash apply  <span class="comment"># 将临时保存区的内容恢复，但不会删除记录，pop会删除。</span></span><br><span class="line">$ git stash pop </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry pick"></a><font color="#FF4500"><strong>cherry pick</strong></font></h2><p>假设你在一个分支上已经做了很多次提交，但你意识到这个分支是错误的，该怎么办。<br>要么切换到正确的分支重复所有的变更。然后重新提交。要么呢就要用到 <code>cherry pick</code> 这个工具。</p><p><code>git cherry-pick</code> 可以将相同的commit提交复制到另一个分支上。就没有必要在不同的分支上做相同的操作。</p><blockquote><p>注意：<code>cherry-pick</code> 出来的提交会在另一个分支中创建带有新hash的提交，</p></blockquote><ul><li>它是如何工作的</li></ul><p>假设有2个分支，<code>toC</code> 和 <code>toB</code>, 现在有个bug在2个版本上都存在。我们在<code>toC</code> 分支上已经修复了这个bug。在 <code>toC</code>分支上运行<code>git log</code>命令，获取这次提交的 hash 值, 简单起见复制 25560 即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 255604842840febb7e11bbb443013fa584e76219 (HEAD -&gt; master, tag: v1.0.1, origin/master, origin/HEAD)</span><br><span class="line">Author: igolaizola &lt;11333576+igolaizola@users.noreply.github.com&gt;</span><br><span class="line">Date:   Thu Sep 26 09:31:17 2019 +0200</span><br></pre></td></tr></table></figure><br>然后切换到<code>toB</code>分支上，将刚刚的bugfix提交合入。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout toB</span><br><span class="line">$ git cherry-pick 25560</span><br></pre></td></tr></table></figure></p><ul><li><p>如果遇到了 “nothing to commit,working tree clean The previous cherry-pick is now empty,possibly due to conflict resolution” 不要惊慌，按照建议运行 <code>git commit --allow-empty</code> 即可。这个将打开你的编辑器，编辑提交信息即可。</p></li><li><p>如果遇到了合并重提，解决冲突后，输入 <code>git cherry-pick --continue</code> 恢复。</p></li></ul><p>参考: <a href="https://mp.weixin.qq.com/s/J7sVxIoIVClEirClBQoUtA">https://mp.weixin.qq.com/s/J7sVxIoIVClEirClBQoUtA</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/156726632">https://zhuanlan.zhihu.com/p/156726632</a></p><h2 id="指定文件不需要git管理"><a href="#指定文件不需要git管理" class="headerlink" title="指定文件不需要git管理"></a><font color="#FF4500"><strong>指定文件不需要git管理</strong></font></h2><p>在项目根目录下创建 <strong><code>.gitignore</code></strong> ,写入不需管理的文件名即可</p><h2 id="Git创建本地分支并关联远程分支"><a href="#Git创建本地分支并关联远程分支" class="headerlink" title="Git创建本地分支并关联远程分支"></a><font color="#FF4500"><strong><code>Git创建本地分支并关联远程分支</code></strong></font></h2><p>当我想从远程仓库里拉取一条本地不存在的分支时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><p>如果出现以下报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#39;dev2&#39; at the same time.</span><br><span class="line">Did you intend to checkout &#39;origin&#x2F;dev2&#39; which can not be resolved as commit?</span><br></pre></td></tr></table></figure><br>表示拉取不成功。我们需要先执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br></pre></td></tr></table></figure><br>再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><p>修改之后再推送的话，可以执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --set-upstream origin 远程分支名</span><br></pre></td></tr></table></figure></p><h1 id="git目录功能"><a href="#git目录功能" class="headerlink" title=".git目录功能"></a>.git目录功能</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ .git git:(master) ls   </span><br><span class="line">branches  COMMIT_EDITMSG  config  description  gitk.cache  HEAD  hooks  index  info  logs  objects  refs</span><br></pre></td></tr></table></figure><ul><li><code>HEAD</code>: 当前工作的分支</li><li><code>config</code>: 配置信息，包含着 repository 的配置，包括 remote 的地址，提交时的 email、 username 等等.</li><li><code>refs</code>: 这个目录一般包括三个子文件夹：heads、remotes和tags，heads中的文件标识了项目中的各个分支指向的当前commit</li><li><code>info</code>: 包含仓库的一些信息</li><li><code>hooks</code>: 这个目录存放一些shell脚本，可以设置特定的git命令后出发相应的脚本；在搭建gitweb系统或其他git托管系统会经常用到hook script</li><li><code>logs</code>: 保存所有更新的引用记录</li><li><code>index</code>: 这个文件就是暂存区（stage），是一个二进制文件</li><li><code>description</code>: 仓库的描述信息，主要给gitweb等git托管系统使用</li><li><code>objects</code>: 所有的Git对象都会存放在这个目录中，对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名</li></ul><p>git 中的对象如下图所示，每一个 commit 提交都会包含 tree、committer、blob。其中committer是提交者，tree可粗略理解为目录，blob为文件。<br><img src="https://img1.kiosk007.top/static/images/git/git_commit_tree_blob.png" style="height:350px"></p><p>比如查看一次 commit<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看一次 commit</span></span><br><span class="line">$ git cat-file -p ac886ae797a9ee60962461b50993bc2bd09920fd</span><br><span class="line">tree 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">parent 4f41c2512ce8fcfbde05622c4d0cd75f14708a84</span><br><span class="line">author orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line">committer orion &lt;weijiaxiang007@foxmail.com&gt; 1608391215 +0800</span><br><span class="line"></span><br><span class="line">Add CS JS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该commit中的 tree</span></span><br><span class="line">$ git cat-file -p 68d0c382d15b2aebd361cd004751601cd79e04ae</span><br><span class="line">100644 blob dac138d9e013a2e9a10e67d793bd4703c1b86bd1index.css</span><br><span class="line">100644 blob e1d99bb43375f52095059d6d79a9c6d3045c048bindex.html</span><br><span class="line">100644 blob 7b4dcb5b597195d0469fec0787c2a7b7a4656d81index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该tree中的blob</span></span><br><span class="line">$ git cat-file -p 7b4dcb5b597195d0469fec0787c2a7b7a4656d81</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">&quot;My First JavaScript&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="git-备份"><a href="#git-备份" class="headerlink" title="git 备份"></a>git 备份</h1><p><img src="https://img1.kiosk007.top/static/images/git/git_transport.webp" style="height:400px"></p><p>前两个协议是本地协议，后两个是远端托管平台。<br>哑协议传输进度不可见，智能协议传输可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个文件仓库 clone</span></span><br><span class="line"><span class="comment"># 哑协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare /home/kiosk/Project/Git/kiosk_demo/.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 智能协议</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare file:///home/kiosk/Project/Git/kiosk_demo/.git</span><br></pre></td></tr></table></figure><ul><li><font color="#FF8C00">**创建远程**</font></li></ul><p>可以使用 git remote add 命令将远程 URL 与名称匹配，例如<br><strong><code>git remote add origin  &lt;REMOTE_URL&gt;</code></strong><br>这会将名称 origin 与 REMOTE_URL 关联。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/user/repo.git</span><br><span class="line"><span class="comment"># Set a new remote</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># Verify new remote</span></span><br><span class="line">&gt; origin  https://github.com/user/repo.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/user/repo.git (push)</span><br></pre></td></tr></table></figure><p>远程 name 已存在,此错误消息表示您尝试添加的远程与本地仓库中的远程名称相同。可以尝试修改远程名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 查看现有远程</span></span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote rename origin destination</span><br><span class="line"><span class="comment"># 将远程名称从 &#x27;origin&#x27; 更改为 &#x27;destination&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 验证远程的新名称</span></span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; destination  https://github.com/OWNER/REPOSITORY.git (push)</span><br></pre></td></tr></table></figure><p>若远程的url发生了变化，可以通过<br><strong><code>git remote set-url origin https://github.com/USERNAME/REPOSITORY.git</code></strong><br>修改</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;只是git入门的简单指南。没什么大不了的 :)&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://kiosk007.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>gRPC Quick Start </title>
    <link href="http://kiosk007.top/2020/11/25/gRPC-Quick-Start/"/>
    <id>http://kiosk007.top/2020/11/25/gRPC-Quick-Start/</id>
    <published>2020-11-25T15:37:00.000Z</published>
    <updated>2020-11-25T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RPC 全称 (Remote Procedure Call)，远程过程调用，指的是一台计算机通过网络请求另一台计算机的上服务，从而不需要了解底层网络细节，RPC 是构建在已经存在的协议（TCP/IP，HTTP 等）之上的。<code>gRPC</code> 是云原生计算基金会（CNCF）项目，gRPC 一开始由 google 开发，是一款语言中立、平台中立的服务间通信框架，使用 gRPC 可以使得客户端像调用本地方法一样，调用远程主机提供的服务。可以在任何地方运行，它使客户端和服务器应用程序能够透明地进行通信，并使构建连接系统变得更加容易。</p><a id="more"></a><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><ul><li>gRPC 默认采用 protocol buffer 作为 IDL (Interface Description Lanage) 接口描述语言，服务之间通信的数据序列化和反序列化也是基于 protocol buffer 的，因为 protocol buffer 的特殊性，所以 gRPC 框架是跨语言的通信框架（与编程语言无关性）</li><li>gRPC 是基于 http2 协议实现,多路复用支持通过同一连接发送多个并行请求,双向全双工通信，用于同时发送客户端请求和服务器响应,内置流式传输使请求和响应能够异步流式传输大数据集</li><li>gRPC 并没有直接实现负载均衡和服务发现的功能，但是已经提供了自己的设计思路。已经为命名解析和负载均衡提供了接口。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service Greeter &#123;</span><br><span class="line">   &#x2F;*</span><br><span class="line">   以下 分别是 服务端 推送流， 客户端 推送流 ，双向流。</span><br><span class="line">   *&#x2F;</span><br><span class="line">  rpc GetStream (StreamReqData) returns (stream StreamResData)&#123;&#125;</span><br><span class="line">  rpc PutStream (stream StreamReqData) returns (StreamResData)&#123;&#125;</span><br><span class="line">  rpc AllStream (stream StreamReqData) returns (stream StreamResData)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Protocal-Buffer"><a href="#Protocal-Buffer" class="headerlink" title="Protocal Buffer"></a>Protocal Buffer</h1><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p><a href="https://developers.google.cn/protocol-buffers">Protocol buffers</a> 是一个灵活的、高效的、自动化的用于对结构化数据进行序列化的协议，与XML相比，Protocol buffers序列化后的码流更小、速度更快、操作更简单。</p><p><code>序列化(serialization、marshalling)</code>的过程是指将数据结构或者对象的状态转换成可以存储(比如文件、内存)或者传输的格式(比如网络)。反向操作就是反序列化<code>(deserialization、unmarshalling)</code>的过程。</p><ul><li>二十世纪九十年代后期，XML开始流行，它是一种人类易读的基于文本的编码方式，易于阅读和理解，但是失去了紧凑的基于字节流的编码的优势。</li><li>JSON是一种更轻量级的基于文本的编码方式，经常用在client/server端的通讯中。</li><li>YAML类似JSON，新的特性更强大，更适合人类阅读，也更紧凑。</li></ul><p>除了上面这些和Protobuf，还有许许多多的序列化格式，比如Thrift、Avro、BSON、CBOR、MessagePack, 还有很多非跨语言的编码格式。项目<a href="https://github.com/smallnest/gosercomp">gosercomp</a>对比了各种go的序列化库，包括序列化和反序列的性能，以及序列化后的数据大小。总体来说Protobuf序列化和反序列的性能都是比较高的，编码后的数据大小也不错。</p><font color="blue">如果你并不希望一定要在传输过程中消息数据可读，那么可以用 Protocal Buffer 来代替 Json 。</font><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;      &#x2F;&#x2F; 版本定义</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  int32  id &#x3D; 1;</span><br><span class="line">  string name &#x3D; 2;</span><br><span class="line">  bool   rich &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行指定<code>protobuf</code>的版本，这里是以proto3格式定义。</p><p>第三行 <code>message</code> 表示定义了一个结构体，在这个结构体里，最常见的类型有以下几种</p><ol><li><font color="#FFB90F">数值型</font> ，如 double, float, int32, int64 …</li><li><font color="#FFB90F">布尔型</font>，bool 只有True和False</li><li><font color="#FFB90F">字符型</font>，string 表示任意字符，但是长度不可超过2的32次方</li><li><font color="#FFB90F">字节型</font>，bytes表示任意的byte数组序列，但是长度也不可以超过2的32次方，比如可以用来传递一个图片。</li><li><font color="#FFB90F">枚举型</font>，enum 表示枚举。可独立在 message 之外。可通过 <code>option allow_alias = true;</code> 给枚举定义别名。</li><li>字典型，map类型需要设置键和值的类型。</li><li><font color="#FFB90F">Well-Known类型</font>, Protobuf也提供了定义，比如Timestamp和Duration。这些定义被放在<code>github.com/golang/protobuf/ptypes/</code>。</li></ol><p><strong>引入其它proto文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import  &quot;other.proto&quot;;</span><br><span class="line">import public &quot;other2.proto&quot;;</span><br><span class="line">import weak &quot;other.proto&quot;;</span><br></pre></td></tr></table></figure><br>比较少使用的是public和weak关键字。默认情况下weak引入的文件允许不存在(missing)，只为了google内部使用。public具有传递性，如果你在文件中通过public引入第三方的proto文件，那么引入你这个文件同时也会引入第三方的proto。</p><p><strong>关键字：</strong></p><ol><li><font color="#FFB90F"> option</font> ：option可以用在proto的scope中，或者message、enum、service的定义中。一般常用的就是定义某语言生成后的package名，最常见的用法，如 <code>option go_package = &quot;xxx&quot;;</code></li><li><font color="#FFB90F">repeated</font> : 指定某一个字段可以存放同一个类型的多个数据, 相当于golang里的slice。可采用<code>[packed=true]</code>以实现更高<br>效的编码。<code>repeated int32 samples = 4 [packed=true];</code></li><li><font color="#FFB90F"> reserved</font> : 保护某字段或定义，如在message中指定 数字1 被保护，或变量名 person 被保护。一般用来保护废弃的数字定义。如<code>reserved 5;reserved &quot;salary&quot;;</code> 如果再使用5 或者 salary 则会报错。</li></ol><p><strong>demo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package my.project; </span><br><span class="line"></span><br><span class="line">import &quot;google&#x2F;protobuf&#x2F;timestamp.proto&quot;;</span><br><span class="line"></span><br><span class="line">option go_package &#x3D; &quot;pb&quot;;</span><br><span class="line"></span><br><span class="line">message PersonMessage &#123;</span><br><span class="line">  int32   id &#x3D; 1;</span><br><span class="line">  bool    is_adult &#x3D;2;</span><br><span class="line">  string  name &#x3D; 3;</span><br><span class="line">  float   height &#x3D; 4;</span><br><span class="line">  float   weight &#x3D; 5;</span><br><span class="line">  bytes   avatar &#x3D; 6;</span><br><span class="line">  string  email &#x3D; 7;</span><br><span class="line">  bool    email_verified &#x3D; 8;</span><br><span class="line">  repeated string phone_numbers &#x3D; 9;  &#x2F;&#x2F; packed</span><br><span class="line">  Gender  gender &#x3D; 11;</span><br><span class="line">  Date    birthday &#x3D; 12;</span><br><span class="line">  repeated Address addresses &#x3D; 13;</span><br><span class="line">  google.protobuf.Timestamp lastModified &#x3D; 14;</span><br><span class="line"></span><br><span class="line">  enum Gender &#123;</span><br><span class="line">    option allow_alias &#x3D; true;</span><br><span class="line">    Not_SPECIFIED &#x3D; 0;</span><br><span class="line">    MALE &#x3D; 1;</span><br><span class="line">    FEMALE &#x3D; 2;</span><br><span class="line">    MAN &#x3D; 1;</span><br><span class="line">    WOMAN &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message Address &#123;</span><br><span class="line">    string province &#x3D; 1;</span><br><span class="line">    string city &#x3D; 2;</span><br><span class="line">    string zip_code &#x3D; 3;</span><br><span class="line">    string street &#x3D; 4;</span><br><span class="line">    string number &#x3D; 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reserved 10, 20 to 100, 200 to max;</span><br><span class="line">  reserved &quot;foo&quot;,&quot;bar&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Date &#123;</span><br><span class="line">  int32 year &#x3D; 1;</span><br><span class="line">  int32 month &#x3D; 2;</span><br><span class="line">  int32 day &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Golang-protocol-buffer"><a href="#Golang-protocol-buffer" class="headerlink" title="Golang protocol buffer"></a>Golang protocol buffer</h2><p>定义 <code>.proto</code> 文件后，使用命令<br><code>protoc --protoc_path src/ -go_out=src/ src/person.proto</code> 生成golang 文件</p><p><strong>定义一个pb</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonMessage</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">PersonMessage</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.PersonMessage&#123;</span><br><span class="line">Id: <span class="number">1</span>,</span><br><span class="line">IsAdult: <span class="literal">true</span>,</span><br><span class="line">Name: <span class="string">&quot;Kiosk&quot;</span>,</span><br><span class="line">Height: <span class="number">177</span>,</span><br><span class="line">Weight: <span class="number">140</span>,</span><br><span class="line">Gender: pb.PersonMessage_MALE,</span><br><span class="line">PhoneNumbers: []<span class="keyword">string</span>&#123;<span class="string">&quot;15667026708&quot;</span>,<span class="string">&quot;17610660213&quot;</span>&#125;,</span><br><span class="line">Email: <span class="string">&quot;weijiaxiang007@foxmail.com&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong> 将 pb 写入文件 </strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToFile</span><span class="params">(filename <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">dataBytes, err := proto.Marshal(pb)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;无法序列化&quot;</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(filename, dataBytes, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;无法写入文件&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;成功写入到文件&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pm := NewPersonMessage()</span><br><span class="line">_ = writeToFile(<span class="string">&quot;person.bin&quot;</span>,pm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong> 从文件读出 pb </strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromFile</span><span class="params">(filename <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">dataBytes, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;读取文件错误&quot;</span>,err.Error()) &#125;</span><br><span class="line"><span class="keyword">if</span> err := proto.Unmarshal(dataBytes, pb); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;反序列化失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pm := &amp;demo.PersonMessage&#123;&#125;</span><br><span class="line">_ = readFromFile(<span class="string">&quot;person.bin&quot;</span>, pm)</span><br><span class="line">fmt.Println(pm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>pb 转 json &amp;&amp; json 转 pb</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toJson</span><span class="params">(pb proto.Message)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">marshaler := jsonpb.Marshaler&#123;Indent: <span class="string">&quot;    &quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">str ,err := marshaler.MarshalToString(pb)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatalln(<span class="string">&quot;转换为JSON时发生错误&quot;</span>,err.Error()) &#125;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fromJson</span><span class="params">(in <span class="keyword">string</span>, pb proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> jsonpb.UnmarshalString(in, pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>gogo库</strong></p><p>虽然官方库 <font color="#68228B"><a href="https://github.com/golang/protobuf">golang/protobu</a> </font>提供了对Protobuf的支持，但是使用最多还是第三方实现的库<a href="https://github.com/gogo/protobuf">gogo/protobuf</a>。</p><p>gogo库基于官方库开发，增加了很多的功能，包括：</p><ol><li>快速的序列化和反序列化</li><li>更规范的Go数据结构</li><li>goprotobuf兼容</li><li>可选择的产生一些辅助方法，减少使用中的代码输入</li><li>可以选择产生测试代码和benchmark代码</li><li>其它序列化格式</li></ol><blockquote><p>更多参考github： <a href="http://github.com/gogo/protobuf">http://github.com/gogo/protobuf</a></p></blockquote><h1 id="gRPC-Start"><a href="#gRPC-Start" class="headerlink" title="gRPC Start"></a>gRPC Start</h1><p>进入主题了, gRPC 是Google发布的基于HTTP 2.0传输层协议承载的高性能开源软件框架。提供了支持多种编程语言的、对网络设备进行配置和纳管的方法。</p><p>RPC是远程函数调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间。因此传统的RPC方法调用对于上传和下载较大数据量场景并不适合。同时传统RPC模式也不适用于对时间不确定的订阅和发布模式。为此，gRPC框架针对服务器端和客户端分别提供了流特性。</p><font color="#483D8B">支持 服务端 推送流， 客户端 推送流 ，双向流。</font><p><img alt="Smiley face" height="420" src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_concept_diagram.png"></p><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>gRPC要求 Go 版本 &gt;= 1.6</p><ol><li>安装grpc<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u -v google.golang.org/grpc</span><br></pre></td></tr></table></figure></li><li>安装 Protocol Buffers v3、protoc-gen-go:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -v -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure></li><li>生成grpc代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc -I. --go_out=plugins=grpc:. helloworld.proto</span><br></pre></td></tr></table></figure><h2 id="define-proto"><a href="#define-proto" class="headerlink" title="define proto"></a>define proto</h2></li></ol><p>gRPC需要事先定义proto文件，如下所示。定义完成后需要执行命令 <code>protoc --go_out=plugins=grpc:. message.proto</code> 生成相关的go语言代码。更多详细的操作参考官方例子 <a href="https://grpc.io/docs/languages/go/quickstart/">Quick start - gRPC</a></p><p><a href="/images/network/gRPC/message.proto">点击查看</a></p><h2 id="gRPC-server"><a href="#gRPC-server" class="headerlink" title="gRPC server"></a>gRPC server</h2><p>gRPC服务的启动流程和标准库的RPC服务启动流程类似：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> port  = <span class="string">&quot;:5001&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  log.Fatalln(err.Error() &#125;</span><br><span class="line"><span class="keyword">var</span> options []grpc.ServerOption</span><br><span class="line">options = <span class="built_in">append</span>(options, grpc.HeaderTableSize(<span class="number">2048</span>))</span><br><span class="line"></span><br><span class="line">server := grpc.NewServer(options...)</span><br><span class="line">pb.RegisterEmployeeServiceServer(server, <span class="built_in">new</span>(example.EmployeeService))</span><br><span class="line">log.Printf(<span class="string">&quot;gRPC Server started ...\n Listen on port %s&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">_ = server.Serve(listen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>这里设置监听在 tcp 的 5001 端口.</li><li><code>grpc.ServerOption</code> 可以设置gRPC的服务端监听参数， 这里我仅设置了 H2 的 header 动态表大小。除此之外，如设置 TLS证书载入：<code>grpc.Creds(c credentials.TransportCredentials)</code>。<br>最大并发数、收发最大消息Size等等，详见 <a href="https://godoc.org/google.golang.org/grpc#ServerOption">https://godoc.org/google.golang.org/grpc#ServerOption</a></li><li><code>pb.RegisterEmployeeServiceServer</code> 是proto生成的 message.pb.go 提供的服务端注册方法。<code>example.EmployeeService</code> 是我们后面手动创建的空结构，后面的函数方法都需要基于这个空结构实现。</li><li>server.Serve 将监听套接字传入。</li></ul><p><strong>实现 EmployeeService</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service EmployeeService &#123;</span><br><span class="line">  rpc GetByNo(GetByNoRequest) returns (EmployeeResponse);         &#x2F;&#x2F; 一元请求</span><br><span class="line">  rpc GetAll(GetAllRequest) returns (stream EmployeeResponse);    &#x2F;&#x2F; 客户端推送流</span><br><span class="line">  rpc AddPhoto(stream AddPhotoRequest) returns (AddPhotoResponse); &#x2F;&#x2F; 服务端推送流</span><br><span class="line">  rpc SaveAll(stream EmployeeRequest) returns (stream EmployeeResponse); &#x2F;&#x2F; 双向流</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对应的pb生成代码</span><br><span class="line">&#x2F;&#x2F; EmployeeServiceServer is the server API for EmployeeService service.</span><br><span class="line">type EmployeeServiceServer interface &#123;</span><br><span class="line">GetByNo(context.Context, *GetByNoRequest) (*EmployeeResponse, error)</span><br><span class="line">GetAll(*GetAllRequest, EmployeeService_GetAllServer) error</span><br><span class="line">AddPhoto(EmployeeService_AddPhotoServer) error</span><br><span class="line">SaveAll(EmployeeService_SaveAllServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先需要定义 <code>type EmployeeService struct &#123;&#125;</code> 后面的所有方法都需要基于这个实现，这个也是服务端注册的参数。</p><ul><li><strong>一元请求 <code>GetByNo()</code> </strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">GetByNo</span><span class="params">(ctx context.Context, request *pb.GetByNoRequest)</span> <span class="params">(*pb.EmployeeResponse, error)</span></span> &#123;</span><br><span class="line">log.Println(request.No)</span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line"><span class="keyword">if</span> request.No == e.No &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.EmployeeResponse&#123;</span><br><span class="line">Employee:           &amp;e,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;the employee does not exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>请求参数是 <code>GetByNoRequest</code>， 通过上面的pb定义得知，这个message是有一个No参数。所以可以取出来当请求参数。返回的参数是<code>EmployeeResponse</code>，通过pb定义得知，其返回参数是 <code>Employee</code> 对象。</li></ul><ul><li><strong>服务端返回流 <code>GetAll()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">GetAll</span><span class="params">(request *pb.GetAllRequest, stream pb.EmployeeService_GetAllServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">err := stream.Send(&amp;pb.EmployeeResponse&#123;</span><br><span class="line">Employee: &amp;e,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意，返回的参数是一条流，其流发送的方法也可以使用Send函数，这里是一个循环，将employee对象循环写入这条流中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type EmployeeService_GetAllServer interface &#123;</span><br><span class="line">Send(*EmployeeResponse) error</span><br><span class="line">grpc.ServerStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端推送流 <code>AddPhoto()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">AddPhoto</span><span class="params">(stream pb.EmployeeService_AddPhotoServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">md, ok := metadata.FromIncomingContext(stream.Context())</span><br><span class="line"><span class="keyword">if</span> ok &#123; fmt.Printf(<span class="string">&quot;employee: %s&quot;</span>, md[<span class="string">&quot;no&quot;</span>][<span class="number">0</span>]) &#125;</span><br><span class="line"><span class="keyword">var</span> images []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">data, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;File Size %d\n&quot;</span>, <span class="built_in">len</span>(images))</span><br><span class="line"><span class="keyword">return</span> stream.SendAndClose(&amp;pb.AddPhotoResponse&#123;IsOk: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;File received: %d\n&quot;</span>, <span class="built_in">len</span>(data.Data))</span><br><span class="line">images = <span class="built_in">append</span>(images, data.Data...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实现了客户端将一张图片拆分成 bytes 再一点一点发送给服务端的demo。读到EOF表示成功读完。Data正是在 pb 里定义的<code>AddPhotoRequest</code>的客户端请求内容。</p></li><li><p><strong>双向流 <code>SaveAll()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmployeeService)</span> <span class="title">SaveAll</span><span class="params">(stream pb.EmployeeService_SaveAllServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">empReq, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">employees = <span class="built_in">append</span>(employees, *empReq.Employee)</span><br><span class="line">time.Sleep(<span class="number">1000</span> * time.Microsecond)</span><br><span class="line">_ = stream.Send(&amp;pb.EmployeeResponse&#123;Employee: empReq.Employee&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _ , emp := <span class="keyword">range</span> employees &#123;</span><br><span class="line">fmt.Println(emp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，服务端每读一份数据，休眠100ms，再将读入的数据原封不动的返回给客户端。</p></li></ul><h2 id="gRPC-client"><a href="#gRPC-client" class="headerlink" title="gRPC client"></a>gRPC client</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> options []grpc.DialOption</span><br><span class="line">options = <span class="built_in">append</span>(options, grpc.WithInsecure())</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;localhost&quot;</span> + port, options...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;can&#x27;t dial server &quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">client := pb.NewEmployeeServiceClient(conn)</span><br><span class="line"><span class="comment">// GetByNo(client)</span></span><br><span class="line"><span class="comment">// getAll(client)</span></span><br><span class="line"><span class="comment">//addPhoto(client)</span></span><br><span class="line">saveAll(client)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端也有一个类似Server端的<code>grpc.DialOption</code>, 这里因为服务端没有使用证书，所以客户端必须添加 <code>WithInsecure</code> 选项。调用 <code>pb.NewEmployeeServiceClient(conn)</code> 会返回一个 Client <code>employeeServiceClient</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> employeeServiceClient <span class="keyword">struct</span> &#123;</span><br><span class="line">cc grpc.ClientConnInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个client拥有之前定义的客户端可调用的 RPC 方法。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; For semantics around ctx use and closing&#x2F;ending streaming RPCs, please refer to https:&#x2F;&#x2F;godoc.org&#x2F;google.golang.org&#x2F;grpc#ClientConn.NewStream.</span><br><span class="line">type EmployeeServiceClient interface &#123;</span><br><span class="line">GetByNo(ctx context.Context, in *GetByNoRequest, opts ...grpc.CallOption) (*EmployeeResponse, error)</span><br><span class="line">GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (EmployeeService_GetAllClient, error)</span><br><span class="line">AddPhoto(ctx context.Context, opts ...grpc.CallOption) (EmployeeService_AddPhotoClient, error)</span><br><span class="line">SaveAll(ctx context.Context, opts ...grpc.CallOption) (EmployeeService_SaveAllClient, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>实现 Client 调用</strong></p><ul><li><strong>一元请求 <code>GetByNo()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetByNo</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">res, err := client.GetByNo(context.Background(), &amp;pb.GetByNoRequest&#123;No: <span class="number">1996</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>传入的参数拥有 <code>GetByNo()</code> 这个方法，直接调用即可。</li></ul><p>抓包可以看到，整个gRPC的调用过程是基于HTTP2的, 本质是发起了一个H2的POST请求, 和传统H2不同的是，response 的 Header帧有2个，结尾处还有一个。第2个表示调用结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stream: HEADERS, Stream ID: 1, Length 80, POST /employee.EmployeeService/GetByNo</span><br><span class="line">    Length: 80</span><br><span class="line">    Type: HEADERS (1)</span><br><span class="line">    Flags: 0x04</span><br><span class="line">    0... .... .... .... .... .... .... .... = Reserved: 0x0</span><br><span class="line">    .000 0000 0000 0000 0000 0000 0000 0001 = Stream Identifier: 1</span><br><span class="line">    [Pad Length: 0]</span><br><span class="line">    Header Block Fragment: 3fe10f8386459960b4d741fd14abe0a6ba0fe8a5dc5b3b98…</span><br><span class="line">    [Header Length: 202]</span><br><span class="line">    [Header Count: 8]</span><br><span class="line">    Header table size update</span><br><span class="line">    Header: :method: POST</span><br><span class="line">    Header: :scheme: http</span><br><span class="line">    Header: :path: /employee.EmployeeService/GetByNo</span><br><span class="line">    Header: :authority: localhost:5001</span><br><span class="line">    Header: content-type: application/grpc</span><br><span class="line">    Header: user-agent: grpc-go/1.33.2</span><br><span class="line">    Header: te: trailers</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_v1.png" alt></p><ul><li><strong>服务端返回流 <code>GetAll()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAll</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">stream, err := client.GetAll(context.Background(), &amp;pb.GetAllRequest&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>服务端返回的流可以使用 <code>stream.Recv()</code> 循环接收。<br><img src="https://img1.kiosk007.top/static/images/network/gRPC/grpc_v2.png" alt></li></ul><ul><li><strong>客户端推送流 <code>AddPhoto()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">imgFile,err := os.Open(<span class="string">&quot;/home/kiosk007/Pictures/2020-09-22_00-15.png&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> imgFile.Close()</span><br><span class="line"></span><br><span class="line">md := metadata.New(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;no&quot;</span>: <span class="string">&quot;1996&quot;</span>&#125;)</span><br><span class="line">context := context.Background()</span><br><span class="line">context = metadata.NewOutgoingContext(context, md)</span><br><span class="line">stream,err := client.AddPhoto(context)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">chunk := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>*<span class="number">24</span>)</span><br><span class="line">chunkSize,err := imgFile.Read(chunk)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chunkSize &lt; <span class="built_in">len</span>(chunk) &#123;</span><br><span class="line">chunk = chunk[:chunkSize]</span><br><span class="line">&#125;</span><br><span class="line">_ = stream.Send(&amp;pb.AddPhotoRequest&#123;Data: chunk&#125;)</span><br><span class="line">&#125;</span><br><span class="line">res, err := stream.CloseAndRecv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.IsOk)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>客户端推送流实现了一个照片流式上传的功能。每次发送 3072字节 (128*24)。</li></ul><ul><li><strong>双向流 <code>SaveAll()</code></strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveAll</span><span class="params">(client pb.EmployeeServiceClient)</span></span> &#123;</span><br><span class="line">employees := []pb.Employee&#123;</span><br><span class="line">pb.Employee&#123;</span><br><span class="line">Id:                   <span class="number">300</span>,</span><br><span class="line">No:                   <span class="number">5001</span>,</span><br><span class="line">FirstName:            <span class="string">&quot;Monica&quot;</span>,</span><br><span class="line">LastName:             <span class="string">&quot;Geller&quot;</span>,</span><br><span class="line">MonthSalary:          <span class="number">15500</span>,</span><br><span class="line">Status:               pb.EmployeeStatus_RETIRED,</span><br><span class="line">LastModified:         &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix() &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">pb.Employee&#123;</span><br><span class="line">Id:                   <span class="number">301</span>,</span><br><span class="line">No:                   <span class="number">5002</span>,</span><br><span class="line">FirstName:            <span class="string">&quot;Joey&quot;</span>,</span><br><span class="line">LastName:             <span class="string">&quot;Green&quot;</span>,</span><br><span class="line">MonthSalary:          <span class="number">200</span>,</span><br><span class="line">Status:               pb.EmployeeStatus_RESIGNED,</span><br><span class="line">LastModified:         &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix() &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">stream, err := client.SaveAll(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">finishChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res,err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">finishChannel &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res.Employee)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">err := stream.Send(&amp;pb.EmployeeRequest&#123;Employee: &amp;e&#125;)</span><br><span class="line">time.Sleep(<span class="number">500</span> * time.Microsecond)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_ = stream.CloseSend()</span><br><span class="line">&lt;- finishChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>参考：</strong></p><ol><li><a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go">Protobuf 终极教程  — 鸟窝</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPC 全称 (Remote Procedure Call)，远程过程调用，指的是一台计算机通过网络请求另一台计算机的上服务，从而不需要了解底层网络细节，RPC 是构建在已经存在的协议（TCP/IP，HTTP 等）之上的。&lt;code&gt;gRPC&lt;/code&gt; 是云原生计算基金会（CNCF）项目，gRPC 一开始由 google 开发，是一款语言中立、平台中立的服务间通信框架，使用 gRPC 可以使得客户端像调用本地方法一样，调用远程主机提供的服务。可以在任何地方运行，它使客户端和服务器应用程序能够透明地进行通信，并使构建连接系统变得更加容易。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="grpc" scheme="http://kiosk007.top/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>基于Nginx的实时音频直播服务</title>
    <link href="http://kiosk007.top/2020/11/16/%E5%9F%BA%E4%BA%8ENginx%E5%AE%9E%E7%8E%B0%E7%9A%84RTMP%E6%9C%8D%E5%8A%A1/"/>
    <id>http://kiosk007.top/2020/11/16/%E5%9F%BA%E4%BA%8ENginx%E5%AE%9E%E7%8E%B0%E7%9A%84RTMP%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-11-16T15:02:00.000Z</published>
    <updated>2020-11-16T15:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在百度云上下了一些学习视频（别想歪..），苦于一台笔记本不方便同时跟着操作变播放，那么既然都有笔记本了，何不搭建一个视频播放服务呢？笔记本使用Nginx搭建一个视频服务器，iPad上使用播放器（Aplayer），不仅是播放还可以直播，这不正契合了当前的高热话题“实时音视频直播技术”么，最近也找了一部分资料，趁着直播的热度在这里总结一下。</p><a id="more"></a><p>  随着互联网用户消费内容和交互方式的升级，支撑这些内容和交互方式的基础设施也正在悄悄发生变革。手机设备拍摄视频能力和网络的升级催生了大家对视频直播领域的关注，吸引了很多互联网创业者或者成熟企业进入该领域。</p><h1 id="直播中的各个环节"><a href="#直播中的各个环节" class="headerlink" title="直播中的各个环节"></a>直播中的各个环节</h1><h2 id="完整的直播流程"><a href="#完整的直播流程" class="headerlink" title="完整的直播流程"></a>完整的直播流程</h2><p><img src="https://img1.kiosk007.top/static/images/live/live.jpg" alt></p><ul><li><font color="red"><code>音视频采集</code></font>: 采集是播放环节中的第一环，iOS 系统因为软硬件种类不多，硬件适配性较好，所以比较简单。Android 则不同，市面上硬件机型非常多，难以做到一个库适配所有硬件。PC 端的采集也跟各种摄像头驱动有关，推荐使用目前市面上最好用的 PC 端开源免费软件 OBS。</li><li><code>音视频处理</code>: 美颜、水印等也都是在这个环节做。目前 iOS 端比较知名的是 GPUImage 这个库，提供了丰富端预处理效果，还可以基于这个库自己写算法实现更丰富端效果。Android 也有 GPUImage 这个库的移植，叫做 android-gpuimage。</li><li><code>音视频编码</code>: iOS 端硬件兼容性较好，可以直接采用硬编。而 Android 的硬编的支持则难得多，需要支持各种硬件机型，推荐使用软编。</li><li><code>推流和传输</code>: 涉及 1、从主播端到服务端 2、从收流服务端到边缘节点 3、从边缘节点到观众端 。推流端和分发端理论上需要支持的并发用户数应该都是亿级的，不过毕竟产生内容的推流端在少数，和消费内容端播放端不是一个量级。对推流稳定性和速度的要求比播放端高很多，这涉及到所有播放端能否看到直播，以及直播端质量如何。</li><li><code>实时音视频转码</code>: 为了让主播推上来的流适配各个平台端各种不同协议，需要在服务端做一些流处理工作，比如转码成不同格式支持不同协议如 RTMP、HLS 和 FLV，一路转多路流来适配各种不同的网络状况和不同分辨率的终端设备。</li><li><code>解码和渲染</code>: 解码和渲染，也即音视频的播放，目前 iOS 端的播放兼容性较好，在延迟可接受的情况下使用 HLS 协议是最好的选择，市面上也提供了能够播放 RTMP 和 HLS 的播放器 SDK。</li></ul><p>参考：<a href="http://www.52im.net/thread-853-1-1.html">《移动端实时音视频直播技术详解》</a></p><p>编码器的介绍可以参考 <a href="http://www.52im.net/thread-965-1-1.html">编码与封装</a>，下面主要说一说“推流和拉流”</p><h2 id="推流和拉流"><a href="#推流和拉流" class="headerlink" title="推流和拉流"></a>推流和拉流</h2><h3 id="推送协议"><a href="#推送协议" class="headerlink" title="推送协议"></a><strong>推送协议</strong></h3><p>推流，指的是把采集阶段封包好的内容传输到服务器的过程。其实就是将现场的视频信号传到网络的过程。</p><p>“推流”对网络要求比较高，如果网络不稳定，直播效果就会很差，观众观看直播时就会发生卡顿等现象，观看体验很是糟糕。</p><p>要想用于推流还必须把音视频数据使用传输协议进行封装，变成流数据。常用的流传输协议有RTSP、RTMP、WebRTC、HLS等，使用RTMP传输的延时通常在1–3秒，对于手机直播这种实时性要求非常高的场景，RTMP也成为手机直播中最常用的流传输协议。</p><p>下面介绍一下以下协议以及他们在直播领域的现状和优缺点：<strong>1、RTMP 2、WebRTC</strong></p><h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a><strong>RTMP</strong></h4><p>RTMP 是 Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash/AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media Server/red5 等。<br>RTMP 是目前主流的流媒体传输协议，广泛用于直播领域，可以说市面上绝大多数的直播产品都采用了这个协议。<br>另外，RTMPT封装在HTTP请求之上，可穿透防火墙；</p><p><strong>优点:</strong></p><blockquote><p>CDN 支持良好，主流的 CDN 厂商都支持；<br>协议简单，在各平台上实现容易。</p></blockquote><p><strong>缺点:</strong></p><blockquote><p>基于 TCP ，传输成本高，在弱网环境丢包率高的情况下问题显著；<br>不支持浏览器推送；<br>Adobe 私有协议，Adobe 已经不再更新。</p></blockquote><h4 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a><strong>WebRTC</strong></h4><p>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的 API。它于 2011 年 6 月 1 日开源并在 Google、Mozilla、Opera 支持下被纳入万维网联盟的 W3C 推荐标准<br><a href="https://webrtc.org.cn/">WebRTC</a> </p><p><strong>目前主要应用于视频会议和连麦中</strong></p><p><strong>优点：</strong></p><blockquote><p>W3C 标准，主流浏览器支持程度高，Google 在背后支撑，并在各平台有参考实现；<br>底层基于 SRTP 和 UDP，弱网情况优化空间大；<br>可以实现点对点通信，通信双方延时低。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>ICE、STUN、TURN 传统 CDN 没有类似的服务提供</p></blockquote><h3 id="拉流协议"><a href="#拉流协议" class="headerlink" title="拉流协议"></a><strong>拉流协议</strong></h3><p>拉流是指服务器已有直播内容，根据协议类型（如RTMP、RTP、RTSP、HTTP等），与服务器建立连接并接收数据，进行拉取的过程。</p><p>拉流端的核心处理在播放器端的解码和渲染，在互动直播中还需集成聊天室、点赞和礼物系统等功能。下面介绍几个常见的拉流协议。</p><h4 id="RTMP-1"><a href="#RTMP-1" class="headerlink" title="RTMP"></a><strong>RTMP</strong></h4><p>没错，推流和拉流都是RTMP所擅长的。现在 PC 市场巨大，PC 主要是 Windows，Windows 的浏览器基本上都支持 Flash。另外RTMP适合长时间播放，曾经有过测试，联系 100 万秒，即 10 天多连续播放没有出现问题。最后 RTMP 的延迟相对较低，一般延时在 1-3s 之间，一般的视频会议，互动式直播，完全是够用的。</p><p>不过，在移动端上，Flash Player 已经被杀绝了，那为啥还会出现这个呢？<br>因为它主要是针对 PC 端的。现在推流协议各大云厂商基本都是直接支持 rtmp 。</p><p><strong>拉流用 rtmp 的话就不太现实了，现在对 flash 支持都不友好了。</strong></p><h4 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a><strong>HLS</strong></h4><p>HLS 是苹果提出的基于HTTP的流媒体传输协议，优点是跨平台性比较好，HTML5可以直接打开播放，移动端兼容性良好，但是缺点是延迟比较高。</p><p>HLS 主要的两块内容是 .m3u8 文件和 .ts 播放文件。接受服务器会将接受到的视频流进行缓存，然后缓存到一定程度后，会将这些视频流进行编码格式化，同时会生成一份 .m3u8 文件和其它很多的 .ts 文件。</p><p>HLS 支持的功能，并不只是分片播放（专门适用于直播），它还包括其他应有的功能。</p><blockquote><p>使用 HTTPS 加密 ts 文件<br>快/倒放<br>广告插入<br>不同分辨率视频切换</p></blockquote><p><strong>HLS 之所以能这么流行，关键在于它的支持度是真的广，所以，对于一般 H5 直播来说，应该是非常友好的。</strong></p><h4 id="HDL-HTTP-FLV"><a href="#HDL-HTTP-FLV" class="headerlink" title="HDL(HTTP-FLV)"></a><strong>HDL(HTTP-FLV)</strong></h4><p>HTTP-FLV 和 RTMPT 类似，都是针对于 FLV 视频格式做的直播分发流。<br>但，两者有着很大的区别：</p><p><strong>相同点：</strong></p><blockquote><p>两者都是针对 FLV 格式<br>两者延时都很低<br>两者都走的 HTTP 通道</p></blockquote><p><strong>不同点：</strong></p><blockquote><p>HTTP-FLV直接发起长连接，下载对应的 FLV 文件<br>头部信息简单</p></blockquote><p>RTMPT握手协议过于复杂。分包，组包过程耗费精力大，因为 RTMP 发的包很容易处理，通常 RTMP 协议会作为视频上传端来处理，然后经由服务器转换为 FLV 文件，通过 HTTP-FLV 下发给用户。</p><p>参考：<a href="https://driverzhang.github.io/post/%E7%9B%B4%E6%92%AD%E5%8D%8F%E8%AE%AErtmphlshttp-flv/">直播协议RTMP、HLS、HTTP FLV</a></p><h1 id="基于Nginx搭建视频服务"><a href="#基于Nginx搭建视频服务" class="headerlink" title="基于Nginx搭建视频服务"></a>基于Nginx搭建视频服务</h1><blockquote><p>系统版本: Ubuntu 20.04 focal<br>Nginx版本:1.17.3<br>Nginx Rtmp模块: nginx-rtmp-module</p></blockquote><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><strong>Nginx</strong></h2><p>我是基于 XPS 上的Ubuntu搭建的，搭建过程之前在 <a href="https://kiosk007.top/2020/04/18/%E8%87%AA%E5%BB%BA-Nginx-%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2/">自建 Nginx 部署</a> 文章中已经提过，这里需要注意的是需要安装 <code>nginx-rtmp-module</code> 模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -m</span></span><br><span class="line">KServer version: KServer/2.3.2</span><br><span class="line">nginx version: nginx/1.17.3</span><br><span class="line">nginx: loaded modules:</span><br><span class="line">nginx:     ngx_core_module (static)</span><br><span class="line">...</span><br><span class="line">nginx:     ngx_rtmp_module (static)</span><br><span class="line">nginx:     ngx_rtmp_core_module (static)</span><br><span class="line">nginx:     ngx_rtmp_cmd_module (static)</span><br><span class="line">nginx:     ngx_rtmp_codec_module (static)</span><br><span class="line">nginx:     ngx_rtmp_access_module (static)</span><br><span class="line">nginx:     ngx_rtmp_record_module (static)</span><br><span class="line">nginx:     ngx_rtmp_live_module (static)</span><br><span class="line">nginx:     ngx_rtmp_play_module (static)</span><br><span class="line">nginx:     ngx_rtmp_flv_module (static)</span><br><span class="line">nginx:     ngx_rtmp_mp4_module (static)</span><br><span class="line">nginx:     ngx_rtmp_netcall_module (static)</span><br><span class="line">nginx:     ngx_rtmp_relay_module (static)</span><br><span class="line">nginx:     ngx_rtmp_exec_module (static)</span><br><span class="line">nginx:     ngx_rtmp_auto_push_module (static)</span><br><span class="line">nginx:     ngx_rtmp_auto_push_index_module (static)</span><br><span class="line">nginx:     ngx_rtmp_notify_module (static)</span><br><span class="line">nginx:     ngx_rtmp_log_module (static)</span><br><span class="line">nginx:     ngx_rtmp_limit_module (static)</span><br><span class="line">nginx:     ngx_rtmp_hls_module (static)</span><br><span class="line">nginx:     ngx_rtmp_dash_module (static)</span><br><span class="line">nginx:     ngx_openssl_module (static)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="视频直播服务"><a href="#视频直播服务" class="headerlink" title="视频直播服务"></a>视频直播服务</h2><p>Nginx本身是一个非常出色的HTTP服务器,FFMPEG是非常好的音视频解决方案.这两个东西通过一个Nginx的模块nginx-rtmp-module,组合在一起即可以搭建一个功能相对比较完善的流媒体服务器. 这个流媒体服务器可以支持RTMP和HLS(Live Http Stream)。</p><p>配置时需要在Nginx的主配置加上一句<code>include /home/work/nginx/rtmp/*.conf;</code>，因为 rtmp 是单独一个块，等价于 http 块。再创建目录 <code>/home/work/nginx/rtmp/</code>，之后 rtmp 的配置会放在该目录下。</p><h3 id="安装FFmpeg"><a href="#安装FFmpeg" class="headerlink" title="安装FFmpeg"></a><strong>安装FFmpeg</strong></h3><p>FFmpeg 是视频处理最常用的开源软件。名称来自MPEG视频编码标准，前面的“FF”代表“Fast Forward”，FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。可以轻易地实现多种视频格式之间的相互转换，FFmpeg的用户有Google，Facebook，Youtube，优酷，爱奇艺，土豆等。可参考阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">FFmpeg 视频处理</a> 这篇文章。</p><p>安装方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure></p><h3 id="RTMP-直播"><a href="#RTMP-直播" class="headerlink" title="RTMP 直播"></a>RTMP 直播</h3><p>在 <code>/home/work/nginx/rtmp/live.conf</code> 里创建如下内容。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">notify_method</span> get;</span><br><span class="line">        <span class="attribute">access_log</span>  /home/work/log/nginx/http_rtmp.log;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line">        <span class="attribute">application</span> rtmplive &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;                <span class="comment"># 开启直播模式</span></span><br><span class="line">            <span class="attribute">allow</span> publish all;      <span class="comment"># 允许从任何源push流</span></span><br><span class="line">            <span class="attribute">allow</span> play all;         <span class="comment"># 允许从任何地方来播放流</span></span><br><span class="line">            <span class="attribute">drop_idle_publisher</span> <span class="number">20s</span>; <span class="comment"># 20秒内没有push，就断开链接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查nginx配置后reload nginx,使之生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /home/work/nginx/sbin/nginx -t</span></span><br><span class="line"><span class="comment"># /home/work/nginx/sbin/nginx -s reload</span></span><br></pre></td></tr></table></figure><p><strong>试验</strong></p><p>使用 ffmpeg 推流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i .&#x2F;Golang从入门到癫狂.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv &#39;rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;room&#39;</span><br></pre></td></tr></table></figure><br>ipad 上去App Store下载 <strong>Aplyer</strong><br><img src="https://img1.kiosk007.top/static/images/live/aplyer.jpeg" style="height:350px"></p><p>打开Aplayer，选择最下方的“网络”，在输入框中输入<code>rtmp://192.168.1.10/live/room</code> 即可观看直播了。</p><h3 id="HLS直播"><a href="#HLS直播" class="headerlink" title="HLS直播"></a>HLS直播</h3><p>配置hls需要有两个步骤</p><ol><li>配置rtmp流产生hls文件</li><li>设置nginx来访问hls文件</li></ol><p><strong>配置rtmp流产生hls文件</strong><br>创建存放hls文件的目录, 确保 Nginx worker 用户可以读写该目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;work&#x2F;data&#x2F;hls</span><br><span class="line">chown work:work &#x2F;home&#x2F;work&#x2F;data&#x2F;hls</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改配置，增加hls相关配置<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>; <span class="comment"># Listen on standard RTMP port</span></span><br><span class="line">        <span class="attribute">notify_method</span> get;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">application</span> hlslive &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;   <span class="comment"># Turn on HLS</span></span><br><span class="line">            <span class="attribute">hls</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">hls_path</span> /home/work/data/hls;</span><br><span class="line">            </span><br><span class="line">            <span class="attribute">allow</span> publish all;          <span class="comment"># 允许从任何源push流</span></span><br><span class="line">            <span class="attribute">allow</span> play all;             <span class="comment"># 允许从任何地方来播放流</span></span><br><span class="line">            <span class="attribute">drop_idle_publisher</span> <span class="number">20s</span>;    <span class="comment"># 20秒内没有push，就断开链接。</span></span><br><span class="line">            <span class="attribute">hls_fragment</span> <span class="number">3</span>;</span><br><span class="line">            <span class="attribute">hls_playlist_length</span> <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>添加了如下两个配置:</p><ul><li><code>hls on</code> : 开启HLS</li><li><code>hls_path /home/work/data/hls</code> : 设置hls目录</li></ul><p>此时使用ffmpeg进行推流后，在/home/work/data/hls目录下，就会有HLS要用到的m3u8和ts文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls</span><br><span class="line">room1-0.ts  room1-1.ts  room1.m3u8</span><br></pre></td></tr></table></figure><p>设置nginx来访问hls文件<br>配置nginx通过http访问hls文件, 在server中添加如下location。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /hls &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Cache-Control&#x27;</span> <span class="string">&#x27;no-cache&#x27;</span>;   <span class="comment"># Disable cache</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># CORS setup</span></span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span> always;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="string">&#x27;Content-Length&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># allow CORS preflight requests</span></span><br><span class="line">        <span class="attribute">if</span> ($request_method = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain charset=UTF-8&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">types</span> &#123;</span><br><span class="line">            application/dash+xml mpd;</span><br><span class="line">            application/vnd.apple.mpegurl m3u8;</span><br><span class="line">            video/mp2t ts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /home/work/data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>然后使用支持 HLS 拉流的播放器输入 <code>http://192.168.1.8:8081/hls/room1.m3u8</code></p><p>参考：<a href="https://www.vultr.com/docs/setup-nginx-rtmp-on-centos-7#Security_Note">Setup Nginx-RTMP on CentOS 7</a></p><h2 id="视频播放服务"><a href="#视频播放服务" class="headerlink" title="视频播放服务"></a>视频播放服务</h2><p>毕竟是已经下载好的视频，这里是不存在直播推流的，那么可以直接播放已经存在的视频。视频的格式最好是 mp4 格式，Nginx 配置文件如下即可：</p><h3 id="mp4"><a href="#mp4" class="headerlink" title="mp4"></a>mp4</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">8088</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#错误日志和访问日志的路径配置</span></span><br><span class="line">   <span class="attribute">access_log</span>  /home/work/log/nginx/http_video.log  jxjson;</span><br><span class="line">   <span class="attribute">error_log</span>   /home/work/log/nginx/video-<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">#项目的路径 </span></span><br><span class="line">   <span class="attribute">root</span> /home/work/data/mp4;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#所有的mp4文件的自动解析</span></span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~ \.mp4$</span> &#123;</span><br><span class="line">      mp4;</span><br><span class="line">      <span class="attribute">mp4_buffer_size</span>     <span class="number">1m</span>;</span><br><span class="line">      <span class="attribute">mp4_max_buffer_size</span> <span class="number">5m</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器输入 <code>192.168.1.8:8088/2-1.mp4</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在百度云上下了一些学习视频（别想歪..），苦于一台笔记本不方便同时跟着操作变播放，那么既然都有笔记本了，何不搭建一个视频播放服务呢？笔记本使用Nginx搭建一个视频服务器，iPad上使用播放器（Aplayer），不仅是播放还可以直播，这不正契合了当前的高热话题“实时音视频直播技术”么，最近也找了一部分资料，趁着直播的热度在这里总结一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://kiosk007.top/categories/Nginx/"/>
    
    
    <category term="点播" scheme="http://kiosk007.top/tags/%E7%82%B9%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>玩转 tshark 命令行工具</title>
    <link href="http://kiosk007.top/2020/11/07/%E7%8E%A9%E8%BD%AC-tshark-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://kiosk007.top/2020/11/07/%E7%8E%A9%E8%BD%AC-tshark-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</id>
    <published>2020-11-07T14:26:00.000Z</published>
    <updated>2020-11-07T14:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>玩转TShark（Wireshark的命令行版）<br>wireshark 是一个伟大的网络问题分析工具，当然它也是有终端命令行工具的。<strong>tshark</strong>就是wireshark的命令行之一。WireShark的功能基本都有，还能组合grep/awk等编程处理分析抓包文件。</p><a id="more"></a><h1 id="wireshark-自带命令集"><a href="#wireshark-自带命令集" class="headerlink" title="wireshark 自带命令集"></a>wireshark 自带命令集</h1><p>Wireshark除了能够手动的分析报文之外，还额外的提供了几个命令行工具，方便开发者日常的报文处理需求，比如批量的合并以及编辑报文。这几个命令都是安装wireshark之后能够直接使用的，同时有的有对应的wireshark GUI 的操作。这些命令分别有<code>tshark</code>、<code>tcpdump</code>、<code>capinfos</code>、<code>dumpcap</code>、<code>text2cap</code>、<code>editcap</code>、<code>reordercap</code>、<code>rawshark</code>、<code>mergecap</code>、<code>pcapfix(需单独安装)</code>。</p><ul><li>tshark：基于终端的Wireshark</li><li>tcpdump：使用“tcpdump”捕获以便使用Wireshark查看</li><li>dumpcap：捕获“dumpcap”以便使用Wireshark查看</li><li>capinfos：打印有关捕获文件的信息</li><li>rawshark：转储和分析网络流量。</li><li>editcap：编辑捕获文件</li><li>mergecap：将多个捕获文件合并为一个</li><li>text2pcap：将ASCII hexdumps转换为网络捕获</li><li>reordercap：重新排序捕获文件</li><li>pcapfix: 修复pcap文件</li></ul><h1 id="pcap"><a href="#pcap" class="headerlink" title="pcap"></a>pcap</h1><h2 id="认识-pcap"><a href="#认识-pcap" class="headerlink" title="认识 pcap"></a>认识 pcap</h2><p>尝试查找网络问题的根源时，有助于查看可能是症状的数据包。为了查看这些数据包，必须首先捕获它们。</p><p>Wireshark默认的存储方式是pcap格式，最新版本的wireshark默认存储方式是pcapng。ng是next generation 的缩写，pcap和pcapng格式文件有是存在一定的差异。</p><p>pcap报文文件结构示意图<br><img src="https://img1.kiosk007.top/static/images/tshark/pcap_file_format.png" alt="pcap_format"></p><ol><li>Global Header是整个文件的文件头，包含文件格式标识，pcap格式版本号等文件指示信息。</li><li>Packet Header是每一片数据报文的头部信息，这些信息都是在形成pcap 报文的过程中由抓包软件wireshark添加的额外信息，例如报文捕获时间等。</li><li>Packet Data是抓取通信过程中的实际数据，包括协议数据和内容数据。</li></ol><p>Wireshark 中对 Global Header 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcap_hdr_s</span> &#123;</span></span><br><span class="line">        guint32 magic_number;   <span class="comment">/* magic number */</span></span><br><span class="line">        guint16 version_major;  <span class="comment">/* major version number */</span></span><br><span class="line">        guint16 version_minor;  <span class="comment">/* minor version number */</span></span><br><span class="line">        gint32  thiszone;       <span class="comment">/* GMT to local correction */</span></span><br><span class="line">        guint32 sigfigs;        <span class="comment">/* accuracy of timestamps */</span></span><br><span class="line">        guint32 snaplen;        <span class="comment">/* max length of captured packets, in octets */</span></span><br><span class="line">        guint32 network;        <span class="comment">/* data link type */</span></span><br><span class="line">&#125; <span class="keyword">pcap_hdr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Wireshark 中对 Packet Header 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcaprec_hdr_s</span> &#123;</span></span><br><span class="line">        guint32 ts_sec;         <span class="comment">/* timestamp seconds */</span></span><br><span class="line">        guint32 ts_usec;        <span class="comment">/* timestamp microseconds */</span></span><br><span class="line">        guint32 incl_len;       <span class="comment">/* number of octets of packet saved in file */</span></span><br><span class="line">        guint32 orig_len;       <span class="comment">/* actual length of packet */</span></span><br><span class="line">&#125; <span class="keyword">pcaprec_hdr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取-pcap"><a href="#获取-pcap" class="headerlink" title="获取 pcap"></a>获取 pcap</h2><ul><li><strong>服务器</strong> :推荐使用 tcpdump or tshark (tshark —color 可以染色哦) 命令行</li><li><strong>个人电脑</strong>: 推荐使用 wireshark </li><li><strong>Android 移动设备</strong>: 推荐使用 <a href="https://github.com/egorovandreyrm/pcap-remote">Pcap Remote</a> (需要在 Google Play 下载) </li><li><strong>iOS 移动设备</strong>: 推荐使用 <code>rvictl -s [设备udid]</code> 方式抓包，参考 <a href="https://www.jianshu.com/p/c67baf5fce6d">Wireshark 抓包iOS设备</a></li></ul><p>更多获取 pcap 方法参考 <a href="https://tshark.dev/capture/">捕获pcap</a></p><h1 id="tshark"><a href="#tshark" class="headerlink" title="tshark"></a>tshark</h1><p><a href="https://www.wireshark.org/docs/man-pages/tshark.html">tshark官方文档</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TShark是一个网络分析工具。它能帮你在实时网络中捕获数据包，或是从预先保存好的捕获文件中读取数据包，或是打印出这些数据包的解码形式到标准输出，再或是把数据包写入到一个文件中。TShark的本地捕获文件格式是pcapng格式，这种pcapng格式也被wireshark和多种其他工具使用。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><a href="https://tshark.dev/packetcraft/arcana/profiles/#-o-keyvalue">-o ${key:value} </a> : 配置首选项中的settings, 一般可配置显示时间戳、是否相关seq number，或者TLS、WPA 解密等。</li></ul><p><img src="/images/tshark/tshark_o.png" style="height:200px"></p><ul><li><a href="https://www.wireshark.org/docs/man-pages/tshark.html">-z ${statistics} </a> : 集各种类型的统计信息, 这里面有一些信息是很有用的，如专家信息、时序统计飞行中的报文、时序丢包都需要这个参数来</li></ul><p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_z.png" style="height:350px"></p><p><strong>其余参数如下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓包接口类</span></span><br><span class="line">-i 设置抓包的网络接口，不设置则默认为第一个非自环接口。</span><br><span class="line">-D 列出当前存在的网络接口。在不了解OS所控制的网络设备时，一般先用“tshark -D”查看网络接口的编号以供-i参数使用。</span><br><span class="line">-f 设定抓包过滤表达式（capture filter expression）。抓包过滤表达式的写法雷同于tcpdump</span><br><span class="line">-s 设置每个抓包的大小，默认为65535，多于这个大小的数据将不会被程序记入内存、写入文件</span><br><span class="line">-p 设置网络接口以非混合模式工作，即只关心和本机有关的流量</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止抓包参数</span></span><br><span class="line">-c 抓取的packet数，在处理一定数量的packet后，停止抓取，程序退出。</span><br><span class="line">-a 设置tshark抓包停止向文件书写的条件，事实上是tshark在正常启动之后停止工作并返回的条件。条件写为<span class="built_in">test</span>:value的形式，如“-a duration:5”表示tshark启动后在5秒内抓包然后停止；“-a filesize:10”表示tshark在输出文件达到10kB后停止；“-a files:n”表示tshark在写满n个文件后停止。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理类</span></span><br><span class="line">-R 设置读取（显示）过滤表达式（<span class="built_in">read</span> filter expression）。不符合此表达式的流量同样不会被写入文件。</span><br><span class="line">-n 禁止所有地址名字解析（默认为允许所有）。</span><br><span class="line">-N 启用某一层的地址名字解析。“m”代表MAC层，“n”代表网络层，“t”代表传输层，“C”代表当前异步DNS查找。如果-n和-N参数同时存在，-n将被忽略。如果-n和-N参数都不写，则默认打开所有地址名字解析。</span><br><span class="line">-d 将指定的数据按有关协议解包输出。如要将tcp 8888端口的流量按http解包，应该写为“-d tcp.port==8888,http”。注意选择子和解包协议之间不能留空格。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类</span></span><br><span class="line">-w 设置raw数据的输出文件。这个参数不设置，tshark将会把解码结果输出到stdout。“-w-”表示把raw输出到stdout。如果要把解码结果输出到文件，使用重定向“&gt;”而不要-w参数。</span><br><span class="line">-F 设置输出raw数据的格式，默认为libpcap。“tshark -F”会列出所有支持的raw格式。</span><br><span class="line">-V 设置将解码结果的细节输出，否则解码结果仅显示一个packet一行的summary。</span><br><span class="line">-x 设置在解码输出结果中，每个packet后面以HEX dump的方式显示具体数据。</span><br><span class="line">-T 设置解码结果输出的格式，包括text,ps,psml和pdml，默认为text。</span><br><span class="line">-E: -E &lt;fieldsoption&gt;=&lt;value&gt;如果-T fields选项指定，使用-E来设置一些属性，比如</span><br><span class="line">　　　　header=y|n</span><br><span class="line">　　　　separator=/t|/s|&lt;char&gt;</span><br><span class="line">　　　　occurrence=f|l|a</span><br><span class="line">　　　　aggregator=,|/s|&lt;char&gt;</span><br><span class="line">-t 设置解码结果的时间格式。“ad”表示带日期的绝对时间，“a”表示不带日期的绝对时间，“r”表示从第一个包到现在的相对时间，“d”表示两个相邻包之间的增量时间（delta）。</span><br><span class="line">-S 在向raw文件输出的同时，将解码结果打印到控制台。</span><br><span class="line">-l 在处理每个包时即时刷新输出。</span><br><span class="line">-X 扩展项。</span><br><span class="line">-q 设置安静的stdout输出（例如做统计时）</span><br><span class="line">-z 设置统计参数。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line">-h 显示命令行帮助。</span><br><span class="line">-v 显示tshark的版本信息。</span><br><span class="line">-o 重载选项</span><br></pre></td></tr></table></figure><h2 id="利用-tshark-打印pcap"><a href="#利用-tshark-打印pcap" class="headerlink" title="利用 tshark 打印pcap"></a>利用 tshark 打印pcap</h2><p>我们通过tcpdump或者wireshark抓到 pcap 文件，接下来就可以利用 <code>tshark</code> 这个强大的命令行工具进行抓包。其中 <code>-o</code>的几个选项可以指定 ssl 解密（需要sslkeylog），<code>-T</code> 指定输出格式，<code>-e</code> 指定都需要输出哪些字段（字段列表参考 <a href="https://www.wireshark.org/docs/dfref/）。输出是将每个Package中指定的字段输出。">https://www.wireshark.org/docs/dfref/）。输出是将每个Package中指定的字段输出。</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tshark -o ssl.keylog_file:./sslkeylog.txt \</span><br><span class="line">-o <span class="string">&quot;ssl.desegment_ssl_records: TRUE&quot;</span> \</span><br><span class="line">-o <span class="string">&quot;ssl.desegment_ssl_application_data: TRUE&quot;</span> \</span><br><span class="line">-e ssl.handshake.ciphersuite \  </span><br><span class="line">-e tcp.analysis.zero_window \</span><br><span class="line">-e http.host \</span><br><span class="line">-e dns.time \</span><br><span class="line">-e tcp.flags.urg \</span><br><span class="line">-e http.request.line \</span><br><span class="line">-e dns.qry.name \</span><br><span class="line">-e ip.version \</span><br><span class="line">-e tcp.analysis.window_full \</span><br><span class="line">-e ipv6.dst \</span><br><span class="line">-e http.request.version \</span><br><span class="line">-e udp.dstport \</span><br><span class="line">-e dns.flags.response \</span><br><span class="line">.... \</span><br><span class="line">-T json -r <span class="string">&quot;./capturedump.pcap&quot;</span></span><br></pre></td></tr></table></figure><br>其余更多的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//打印http协议流相关信息</span><br><span class="line">tshark -s 512 -i eth0 -n -f <span class="string">&#x27;tcp dst port 80&#x27;</span> -Y <span class="string">&#x27;http.host and http.request.uri&#x27;</span> -T fields -e http.host -e http.request.uri -l</span><br><span class="line"></span><br><span class="line">//实时打印当前mysql查询语句</span><br><span class="line">tshark -s 512 -i eth0 -n -f <span class="string">&#x27;tcp dst port 3306&#x27;</span> -Y <span class="string">&#x27;mysql.query&#x27;</span> -T fields -e mysql.query</span><br><span class="line"></span><br><span class="line">//解析MySQL协议</span><br><span class="line">tshark -r ./mysql-compress.cap -o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields -e mysql.caps.cp -e frame.number \</span><br><span class="line">-e frame.time_epoch  -e frame.time_delta_displayed  \</span><br><span class="line">-e ip.src -e tcp.srcport -e tcp.dstport -e ip.dst \</span><br><span class="line">-e tcp.time_delta -e frame.time_delta_displayed \</span><br><span class="line">-e tcp.stream -e tcp.len -e mysql.query</span><br><span class="line"></span><br><span class="line">//抓取详细SQL语句, 快速确认client发过来的具体SQL内容：</span><br><span class="line">sudo tshark -i any -f <span class="string">&#x27;port 3306&#x27;</span> -s 0 -l -w - |strings</span><br><span class="line">sudo tshark -i eth0 -d tcp.port==3306,mysql -T fields -e mysql.query <span class="string">&#x27;port 3306&#x27;</span></span><br><span class="line">sudo tshark -i eth0 -Y <span class="string">&quot;ip.addr==11.163.182.137&quot;</span> -d tcp.port==3306,mysql -T fields -e mysql.query <span class="string">&#x27;port 3306&#x27;</span></span><br><span class="line">sudo tshark -i eth0 -Y <span class="string">&quot;tcp.srcport==62877&quot;</span> -d tcp.port==3001,mysql -T fields -e tcp.srcport -e mysql.query <span class="string">&#x27;port 3001&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查看请求目标信息"><a href="#查看请求目标信息" class="headerlink" title="查看请求目标信息"></a>查看请求目标信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcap -o <span class="string">&#x27;gui.column.format:&quot;Source Net Addr&quot;,&quot;%uns&quot;,&quot;Dest Net Addr&quot;, &quot;%und&quot;&#x27;</span> -Y <span class="string">&quot;ip&quot;</span> | sort | uniq</span><br><span class="line">111.206.101.25 → 192.168.100.115</span><br><span class="line">111.206.4.92 → 192.168.100.115</span><br><span class="line">119.167.215.208 → 192.168.100.115</span><br><span class="line">122.14.230.129 → 192.168.100.115</span><br><span class="line">123.125.102.19 → 192.168.100.115</span><br><span class="line">192.168.100.115 → 111.161.111.119</span><br><span class="line">192.168.100.115 → 111.206.101.25</span><br><span class="line">192.168.100.115 → 111.206.4.92</span><br><span class="line">192.168.100.115 → 119.167.215.208</span><br></pre></td></tr></table></figure><h2 id="查看丢包、带宽、吞吐、延迟"><a href="#查看丢包、带宽、吞吐、延迟" class="headerlink" title="查看丢包、带宽、吞吐、延迟"></a>查看丢包、带宽、吞吐、延迟</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 统计 ip 情况</span><br><span class="line">$ tshark -r wechat.pcap -q -z conv,ip</span><br><span class="line"></span><br><span class="line">// 跟踪一条流打印 16进制数据</span><br><span class="line">$ tshark -r wechat.pcap -q -z <span class="string">&quot;follow,tcp,hex,0&quot;</span> </span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_conv.png" alt="conv"></p><p><strong>计算丢包情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcap -q \</span><br><span class="line">-z io,<span class="built_in">stat</span>,1,<span class="string">&quot;COUNT(tcp.analysis.retransmission) tcp.analysis.retransmission&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.fast_retransmission) tcp.analysis.fast_retransmission&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.duplicate_ack) tcp.analysis.duplicate_ack&quot;</span>,<span class="string">&quot;COUNT(tcp.analysis.lost_segment) tcp.analysis.lost_segment&quot;</span></span><br></pre></td></tr></table></figure><p><strong>计算上行带宽</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -o tcp.desegment_tcp_streams:TRUE -n \</span><br><span class="line">-q -r  ./wechat.pcap \</span><br><span class="line">-z io,<span class="built_in">stat</span>,99999999,<span class="string">&quot;BYTES()(ip.src!=10.0.0.0/8 and ip.src!=172.16.0.0/12 and ip.src!=192.168.0.0/16)&quot;</span></span><br></pre></td></tr></table></figure><br><strong>计算 TCP RTT</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -o tcp.desegment_tcp_streams:TRUE -n \</span><br><span class="line">-q -r  ./wechat.pcap  -z \</span><br><span class="line">io,<span class="built_in">stat</span>,99999999,<span class="string">&quot;AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br></pre></td></tr></table></figure><p><strong>分析 <code>tcp.stream</code> id 为 0 的传输带宽 。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -o tcp.desegment_tcp_streams:FALSE -n \</span><br><span class="line">-q -r wechat.pcapng -z io,stat,1,&quot;BYTES()tcp.stream&#x3D;&#x3D;0&quot;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">| IO Statistics               |</span><br><span class="line">|                             |</span><br><span class="line">| Duration: 50.712225 secs    |</span><br><span class="line">| Interval:  1 secs           |</span><br><span class="line">|                             |</span><br><span class="line">| Col 1: BYTES()tcp.stream&#x3D;&#x3D;0 |</span><br><span class="line">|-----------------------------|</span><br><span class="line">|          |1       |         |</span><br><span class="line">| Interval |  BYTES |         |</span><br><span class="line">|-------------------|         |</span><br><span class="line">|  0 &lt;&gt;  1 |      0 |         |</span><br><span class="line">|  1 &lt;&gt;  2 |      0 |         |</span><br><span class="line">...</span><br><span class="line">|  8 &lt;&gt;  9 | 128301 |         |</span><br><span class="line">|  9 &lt;&gt; 10 | 127132 |         |</span><br><span class="line">| 10 &lt;&gt; 11 | 128667 |         |</span><br><span class="line">| 11 &lt;&gt; 12 | 127749 |         |</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>wireshark 的TCP流图中的吞吐量</p><p><img src="https://img1.kiosk007.top/static/images/tshark/wireshark_throughput.png" style="height:300px"></p><p>对比通过 tshark的 io graph 绘出的图。</p><p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_throughput.png" style="weight:300px"></p><p>同理可以绘 丢包重传、飞行中的报文等。</p><p>对于排查网络延时/应用问题有一些过滤条件是非常有用的：</p><ul><li><code>tcp.analysis.lost_segment</code>：表明已经在抓包中看到不连续的序列号。报文丢失会造成重复的ACK，这会导致重传。</li><li><code>tcp.analysis.duplicate_ack</code>：显示被确认过不止一次的报文。大量的重复ACK是TCP端点之间高延时的迹象。</li><li><code>tcp.analysis.retransmission</code>：显示抓包中的所有重传。如果重传次数不多的话还是正常的，过多重传可能有问题。这通常意味着应用性能缓慢和/或用户报文丢失。</li><li><code>tcp.analysis.window_update</code>：将传输过程中的TCP window大小图形化。如果看到窗口大小下降为零，这意味着发送方已经退出了，并等待接收方确认所有已传送数据。这可能表明接收端已经不堪重负了。</li><li><code>tcp.analysis.bytes_in_flight</code>：某一时间点网络上未确认字节数。未确认字节数不能超过你的TCP窗口大小（定义于最初3此TCP握手），为了最大化吞吐量你想要获得尽可能接近TCP窗口大小。如果看到连续低于TCP窗口大小，可能意味着报文丢失或路径上其他影响吞吐量的问题。</li><li><code>tcp.analysis.ack_rtt</code>：衡量抓取的TCP报文与相应的ACK。如果这一时间间隔比较长那可能表示某种类型的网络延时（报文丢失，拥塞，等等）。</li></ul><h2 id="专家信息"><a href="#专家信息" class="headerlink" title="专家信息"></a>专家信息</h2><p>可统计重传、TLS 会话复用、HTTP 会话、TCP RST 等等。功能强大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tshark -r refresh_video.pcap -q -z expert</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img1.kiosk007.top/static/images/tshark/tshark_expert.png"></p><h2 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h2><ul><li>分析SQL查询的时间分布</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">tshark -r gege_drds.pcap \</span><br><span class="line">-Y <span class="string">&quot;mysql.query or (tcp.srcport==3306  and tcp.len&gt;60)&quot;</span> \</span><br><span class="line">-o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields \</span><br><span class="line">-e frame.number -e frame.time_epoch  \</span><br><span class="line">-e frame.time_delta_displayed  \</span><br><span class="line">-e ip.src -e tcp.srcport -e tcp.dstport -e ip.dst \</span><br><span class="line">-e tcp.time_delta -e tcp.stream -e tcp.len \</span><br><span class="line">| awk <span class="string">&#x27;BEGIN &#123; \</span></span><br><span class="line"><span class="string">sum0=0;sum3=0;sum10=0;sum30=0;sum50=0; \</span></span><br><span class="line"><span class="string">sum100=0;sum300=0;sum500=0;sum1000=0;\</span></span><br><span class="line"><span class="string">sumo=0;count=0;sum=0</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">&#123; \</span></span><br><span class="line"><span class="string">rt=$8; \</span></span><br><span class="line"><span class="string">if(rt&gt;=0.000) sum=sum+rt; count=count+1; \</span></span><br><span class="line"><span class="string">if(rt&lt;=0.000) sum0=sum0+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.003) sum3=sum3+1 ;\</span></span><br><span class="line"><span class="string">else if(rt&lt;0.01) sum10=sum10+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.03) sum30=sum30+1; \</span></span><br><span class="line"><span class="string">else if(rt&lt;0.05) sum50=sum50+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.1) sum100=sum100+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.3) sum300=sum300+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 0.5) sum500=sum500+1; \</span></span><br><span class="line"><span class="string">else if(rt &lt; 1) sum1000=sum1000+1; \</span></span><br><span class="line"><span class="string">else sum=sum+1 ; \</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">END &#123; printf &quot;-------------\n3ms:\t%s \n10ms:\t%s \n30ms:\t%s \n50ms:\t%s \n100ms:\t%s \n300ms:\t%s \n500ms:\t%s \n1000ms:\t%s \n&gt;1s:\t %s\n-------------\navg: %.6f \n&quot; , sum3,sum10,sum30,sum50,sum100,sum300,sum500,sum1000,sumo,sum/count;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"> -------------</span><br><span class="line">3ms:    145037 </span><br><span class="line">10ms:    78811 </span><br><span class="line">30ms:    7032 </span><br><span class="line">50ms:    2172 </span><br><span class="line">100ms:    1219 </span><br><span class="line">300ms:    856 </span><br><span class="line">500ms:    449 </span><br><span class="line">1000ms:118</span><br><span class="line">&gt;1s:    0</span><br><span class="line">-------------</span><br><span class="line">avg: 0.005937 </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>分析每个包的response time</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r rsb2.cap -o tcp.calculate_timestamps:<span class="literal">true</span> \</span><br><span class="line">-T fields -e frame.number -e frame.time_epoch \</span><br><span class="line">-e ip.src -e ip.dst -e tcp.stream -e tcp.len \</span><br><span class="line">-e tcp.analysis.initial_rtt -e tcp.time_delta</span><br><span class="line"></span><br><span class="line">14811465269331.308138000100.98.199.3610.25.92.1330200.002276000</span><br><span class="line">14821465269331.30818600010.25.92.13    100.98.199.36361110.000063000</span><br><span class="line">14831465269331.308209000100.98.199.3610.25.92.1349600.004950000</span><br><span class="line">14841465269331.308223000100.98.199.3610.25.92.1351300.000000000</span><br><span class="line">14851465269331.308238000100.98.199.3610.25.92.1332600.055424000</span><br><span class="line">14861465269331.308246000100.98.199.3610.25.92.1351400.000000000</span><br><span class="line">14871465269331.30826100010.25.92.71    10.25.92.134800.000229000</span><br><span class="line">14881465269331.308277000100.98.199.3610.25.92.1325400.055514000</span><br></pre></td></tr></table></figure><ul><li>分析rtt时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r wechat.pcapng -q -z \</span><br><span class="line">io,<span class="built_in">stat</span>,5,<span class="string">&quot;MIN(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span>,\</span><br><span class="line"><span class="string">&quot;MAX(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span>,\</span><br><span class="line"><span class="string">&quot;AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br><span class="line"></span><br><span class="line">========================================================</span><br><span class="line">| IO Statistics                                        |</span><br><span class="line">|                                                      |</span><br><span class="line">| Duration: 50.712225 secs                             |</span><br><span class="line">| Interval:  5 secs                                    |</span><br><span class="line">|                                                      |</span><br><span class="line">| Col 1: MIN(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|     2: MAX(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|     3: AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt |</span><br><span class="line">|------------------------------------------------------|</span><br><span class="line">|          |1         |2         |3         |          |</span><br><span class="line">| Interval |    MIN   |    MAX   |    AVG   |          |</span><br><span class="line">|-------------------------------------------|          |</span><br><span class="line">|  0 &lt;&gt;  5 | 0.000000 | 0.000000 | 0.000000 |          |</span><br><span class="line">|  5 &lt;&gt; 10 | 0.000987 | 0.358817 | 0.293383 |          |</span><br><span class="line">| 10 &lt;&gt; 15 | 0.001537 | 1.125008 | 0.336217 |          |</span><br><span class="line">| 15 &lt;&gt; 20 | 0.001598 | 0.745323 | 0.632126 |          |</span><br><span class="line">| 20 &lt;&gt; 25 | 0.002196 | 1.454920 | 0.584168 |          |</span><br><span class="line">| 25 &lt;&gt; 30 | 0.002674 | 0.892343 | 0.771408 |          |</span><br><span class="line">| 30 &lt;&gt; 35 | 0.001505 | 1.406873 | 1.066937 |          |</span><br><span class="line">| 35 &lt;&gt; 40 | 0.001333 | 1.372204 | 1.267557 |          |</span><br><span class="line">| 40 &lt;&gt; 45 | 0.001366 | 1.410311 | 1.204430 |          |</span><br><span class="line">| 45 &lt;&gt; 50 | 0.001513 | 1.360609 | 1.008420 |          |</span><br><span class="line">| 50 &lt;&gt; Dur| 0.001609 | 1.378431 | 0.956597 |          |</span><br><span class="line">========================================================</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="tshark-抓包"><a href="#tshark-抓包" class="headerlink" title="tshark 抓包"></a>tshark 抓包</h1><p>最后让我们来用伟大的tshark抓包吧，快放弃古老的 tcpdump。</p><p>执行 <code>sudo tshark -Y &#39;ip.addr == 8.8.8.8&#39; --color</code><br>会在终端以wireshark的风格开始抓包。<br><img src="https://img1.kiosk007.top/static/images/tshark/tshark_capture.png" alt></p><p>参考：</p><ul><li><a href="https://plantegg.github.io/2019/06/21/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82%E6%8A%93%E5%8C%85--WireShark%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88tshark/">就是让你懂抓包—WireShark之命令行版tshark</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;玩转TShark（Wireshark的命令行版）&lt;br&gt;wireshark 是一个伟大的网络问题分析工具，当然它也是有终端命令行工具的。&lt;strong&gt;tshark&lt;/strong&gt;就是wireshark的命令行之一。WireShark的功能基本都有，还能组合grep/awk等编程处理分析抓包文件。&lt;/p&gt;</summary>
    
    
    
    <category term="network" scheme="http://kiosk007.top/categories/network/"/>
    
    
    <category term="wireshark" scheme="http://kiosk007.top/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>设计模式（Design Pattern）</title>
    <link href="http://kiosk007.top/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Pattern%EF%BC%89/"/>
    <id>http://kiosk007.top/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Pattern%EF%BC%89/</id>
    <published>2020-10-24T08:08:00.000Z</published>
    <updated>2020-10-24T08:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><a id="more"></a><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>“设计模式”总的来说有设计原则6个.</p><ul><li><strong>单一职责原则(Single Responsibility Principle, SRP)</strong> : 每个模块或类都应该对软件提供的功能的一部分负责，而这个责任应该完全由类来封装。它的所有服务都应严格遵守这一职责。</li><li><strong>开闭原则(Open Close Principle, OCP)</strong> : 软件中的对象(类、模块、函数等)对扩展是开放的，对修改是封闭的。</li><li><strong>里氏替换原则(Liskov Substitution Principle, LSP)</strong> : 所有使用基类的地方必须能透明地使用其子类的对象</li><li><strong>依赖倒转原则(Dependence Inversion Principle, DIP)</strong> : 是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</li><li><strong>接口隔离原则(Interface Segregation Principle, ISP)</strong> : 客户端不应该依赖它不需要的接口。</li><li><strong>迪米特法则(Law of Demeter, LoD), 最少知识原则(Principle of Least Knowledge)</strong> : 1. 每个对象应该对其他对象尽可能最少的知道 2. 每个对象应该仅和其朋友通信；不和陌生人通信 3. 仅仅和直接朋友通信</li></ul><hr><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 (Singleton)"></a>单例模式 (Singleton)</h2><ul><li><font color="#200000">定义以及使用场景</font></li></ul><ol><li>确保某一个类只有一个实例，而且向整个系统提供这个实例</li><li>确保某个类有且仅有一个对象的场景，避免产生多个对象消耗过多的资源；或者某种类型的对象应该有且只有一个。（如 Logger 实例、Config 实例等）</li></ol><ul><li><font color="#200000">实现单例模式的几个关键点</font></li></ul><ol><li>构造函数不对外开放，一般为private</li><li>通过一个静态方法或者枚举返回单例类对象</li><li>确保单例类的对象有且只有一个，尤其是在多线程环境下</li><li>确保单例类对象在反序列化时不会重新构建对象</li></ol><ul><li><font color="#200000">饥汉模式</font></li></ul><p>直接创建好对象，这样不需要判断为空，同时也是线程安全。唯一的缺点是在导入包的同时会创建该对象，并持续占有在内存中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance Tool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="#200000"> 懒汉模式 (Lazy Loading) </font></li></ul><p>只有需要时才会初始化，在一定程度上节约了资源。如果不加锁的话非线程安全，即在多线程下可能会创建多次对象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private</span></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// public</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">instance = &amp;singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="#200000"> DCL(双重检查)模式 (推荐) </font></li></ul><p>DCL的优点就是资源利用率高，只有第一次执行getInstance才会初始化。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> instance Tool</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第一次判断不加锁，第二次加锁保证线程安全，一旦对象建立后,获取对象就不用加锁了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Tool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">            instance = <span class="built_in">new</span>(Tool)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在golang中还可以使用 <code>sync.Once</code> 保证单例。</p><pre><code>var once sync.Oncefunc GetInstance() *Tool &#123;    once.Do(func() &#123;        instance = new(Tool)    &#125;)    return instance&#125;</code></pre><hr><h2 id="工厂方法模式-Factory-method"><a href="#工厂方法模式-Factory-method" class="headerlink" title="工厂方法模式(Factory method)"></a>工厂方法模式(Factory method)</h2><ul><li><font color="#808080"> 定义以及使用场景</font></li></ul><p>创建一个用户创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p><p><strong>使用场景</strong>：</p><ol><li>工厂方法模式通过依赖抽象来达到解耦的效果，并且将实例化的任务交给子类去完成，有非常好的扩展性</li><li>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂方法</li><li>工厂方法模式的应用非常广泛，然而缺点也很明显，就是每次我们为工厂方法添加新的产品时，都需要编写一个新的产品类，所以要根据实际情况来权衡是否要用工厂方法模式</li></ol><p>类似我要造汽车，将造汽车的通用的几个方法定义好，就可以创建一个接口。任何实现了这套造汽车标准的厂商都可以被初始化。并造出一辆汽车。</p><ul><li><font color="#808080"> 举例实现工厂方法模式 </font></li></ul><p>假设我们在做一款小型翻译软件，软件可以将德语、英语、日语都翻译成目标中文，并显示在前端。</p><ul><li><font color="#200000"> 简单工厂模式 </font></li></ul><p>我们会有三个具体的语言翻译结构体，或许以后还有更多，但现在分别是GermanTranslater、EnglishTranslater、JapaneseTranslater，他们都共同实现了一个接口Translator。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻译接口</span></span><br><span class="line"><span class="keyword">type</span> Translator <span class="keyword">interface</span> &#123;</span><br><span class="line">Translate(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//德语翻译类</span></span><br><span class="line"><span class="keyword">type</span> GermanTranslator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*GermanTranslator)</span> <span class="title">Translate</span><span class="params">(words <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;德语&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//英语翻译类</span></span><br><span class="line"><span class="keyword">type</span> EnglishTranslator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*EnglishTranslator)</span> <span class="title">Translate</span><span class="params">(words <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;英语&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在程序入口获取用户输入的文本，并将其翻译</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lan <span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s ,%s&quot;</span>, <span class="string">&quot;以下是可翻译的语言种类，请输入代表数字&quot;</span>, <span class="string">&quot;1：德语、2：英语&quot;</span>)</span><br><span class="line">_, _ = fmt.Scanln(&amp;lan)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入要翻译成中文的文本：&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> inputWords <span class="keyword">string</span></span><br><span class="line">_, _ = fmt.Scanln(&amp;inputWords)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> translator Translator</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的语言种类，实例化不同的翻译类</span></span><br><span class="line"><span class="keyword">switch</span> lan &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">translator = <span class="built_in">new</span>(GermanTranslator)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">translator = <span class="built_in">new</span>(EnglishTranslator)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;no such translator&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(translator.Translate(inputWords))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ol><li>违背了开闭原则，以后还可能有法语、俄语、阿拉伯语等其他翻译器，每一次添加翻译器都要在客户端代码增加对应的switch分支，维护成本高。倘若还有不止一处调用了创建逻辑，还要维护多处代码。</li><li>违背了单一职责原则，客户端处理类的职责应该只是负责接收用户的输入并将其打印，现在还负责翻译类的创建逻辑，导致这个类的职责过多。</li></ol><p>改造</p><pre>// 工厂函数func CreateTranslator(lan int) Translator {    var translator Translator    switch lan {    case 1:        translator = new(GermanTranslator)    case 2:        translator = new(EnglishTranslator)    default:        panic("no such translator")    }    return translator}// 主函数...    fmt.Println("请输入要翻译成中文的文本：")    var inputWords string    fmt.Scanln(&inputWords)    //客户端只关注如何获取翻译类，而不用关注创建翻译类的细节    translator:=CreateTranslator(lan)    fmt.Println(translator.Translate(inputWords))...</pre><hr><h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式(Builder)"></a>建造者模式(Builder)</h2><ul><li><strong>定义以及使用场景</strong> </li></ul><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>使用场景</strong></p><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果却又不相同时<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的结果，这个时候使用建造者模式非常合适</li><li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时</li></ol><blockquote><p><strong>Product</strong> 产品类——产品的抽象类<br><strong>Builder</strong> 抽象Builder类，规范产品的组建，一般由子类实现具体的组建过程<br><strong>ConcreteBuilder</strong> 具体的Builder类<br><strong>Director</strong> 统一组装过程</p></blockquote><ul><li><strong>举个例子</strong> </li></ul><p>我们需要创建汽车，而汽车有轮胎的个数以及车身的颜色可定制，那么用Builder模式可以这样。</p><p>我们的目标是建一辆车</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一辆车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Wheels <span class="keyword">string</span></span><br><span class="line">Chassis <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Builder Complete ...&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Wheels : %s Chassis: %s \n&quot;</span>, c.Wheels, c.Chassis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计出完整的建设规划</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为建造者实现 Builder 接口</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">NewProduct()       <span class="comment">// 创建一个空产品</span></span><br><span class="line">BuildWheels()      <span class="comment">// 建造轮子</span></span><br><span class="line">BuildChassis()    <span class="comment">// 建造底盘</span></span><br><span class="line">GetResult() <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 获取建造好的产品</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照Builder规划一个大型项目构造者CarBuilder, 包含如何具体实现Build</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义汽车建造项目 CarBuilder</span></span><br><span class="line"><span class="keyword">type</span> CarBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">Car *Car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> cb.Car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">NewProduct</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car = <span class="built_in">new</span>(Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">BuildWheels</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car.Wheels = <span class="string">&quot;米其林轮胎&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CarBuilder)</span> <span class="title">BuildChassis</span><span class="params">()</span></span> &#123;</span><br><span class="line">cb.Car.Chassis = <span class="string">&quot;沃尔沃底盘&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面要把具体建造者传入指挥者:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把建造者传入指挥者</span></span><br><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span> &#123;</span><br><span class="line">builder Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">SetBuilder</span><span class="params">(builder Builder)</span></span> &#123;</span><br><span class="line">d.builder = builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建造实施</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">CarBuilderImpl</span><span class="params">()</span> *<span class="title">Car</span></span> &#123;</span><br><span class="line">d.builder.NewProduct()</span><br><span class="line">d.builder.BuildChassis()</span><br><span class="line">d.builder.BuildWheels()</span><br><span class="line"><span class="keyword">return</span> d.builder.GetResult().(*Car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整过程</p><pre>func main() {    // 创建一个指挥者    director := new(Director)    // 创建建造者    builder := new(CarBuilder)    director.SetBuilder(builder)    car := director.CarBuilderImpl()    car.Show()}</pre><hr><h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h2><ul><li><font color="#808080">**定义以及使用场景**</font></li></ul><p>原型模式用于创建重复的对象。当一个类在创建时开销比较大时(比如大量数据准备，数据库连接)，我们可以缓存该对象，当下一次调用时，返回该对象的克隆。</p><blockquote><p><strong>不过大多数原型模式不在日常中使用，一般会使用 <code>sync.pool</code> 替代，详见 <a href="Worker Pool in Golang">https://kiosk007.top/2021/03/21/Worker-Pool-in-Golang/#Pool</a></strong></p></blockquote><p><strong>使用场景</strong></p><ol><li>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗</li><li>原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好滴体现其优点</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝</li></ol><ul><li><font color="#200000">**举个例子**</font></li></ul><p>定义一个原型管理器</p><pre>// 样品（原型）Clone能力约定类type Cloneable interface {    Clone() Cloneable}// 样品（原型）管理器类type PrototypeManager struct {    prototypes map[string]Cloneable}func (that *PrototypeManager) Set( cloneName string, cloneable Cloneable) {    that.prototypes[cloneName] = cloneable}func (that *PrototypeManager) Get(cloneName string) (prototype Cloneable, err error) {    if prototype, ok:=that.prototypes[cloneName]; ok {        return prototype, nil    } else {        return nil, errors.New(fmt.Sprintf("%s 不存在", cloneName))    }}</pre><p>获取一个样品（原型）管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个样品（原型）管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrototypeManager</span> <span class="params">()</span> *<span class="title">PrototypeManager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PrototypeManager&#123;</span><br><span class="line">prototypes:<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Cloneable),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manager *PrototypeManager</span><br></pre></td></tr></table></figure><p>定义一个样品原型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个样品（原型） 实现 Clone 方法 相当于把自己做成了一个样品</span></span><br><span class="line"><span class="keyword">type</span> PT <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(that *PT)</span> <span class="title">Clone</span><span class="params">()</span> <span class="title">Cloneable</span></span> &#123;</span><br><span class="line">temp := *that</span><br><span class="line"><span class="keyword">return</span> &amp;temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><pre>func Test() {    prototypeOne,_ := manager.Get("prototypeOne")    prototypeTwo := prototypeOne.Clone()    prototypeThree := prototypeOne.Clone()    fmt.Printf(" prototypeOne地址:%v \n " +        "prototypeTwo地址: %v \n " +        "prototypeThree地址: %v \n", &prototypeOne, &prototypeTwo, &prototypeThree)}func main() {    manager = NewPrototypeManager()    pt1 := &PT{}    manager.Set("prototypeOne", pt1)    Test()}// 输出 prototypeOne地址:   0xc000010200  prototypeTwo地址:   0xc000010210  prototypeThree地址: 0xc000010220 </pre><hr><h2 id="过滤器模式-Pipe-filter"><a href="#过滤器模式-Pipe-filter" class="headerlink" title="过滤器模式 (Pipe-filter)"></a>过滤器模式 (Pipe-filter)</h2><ul><li><font color="#808080">**定义以及使用场景**</font></li></ul><p>对一数据需要经过顺序的多个过滤器函数处理。</p><p><strong>使用场景</strong></p><ol><li>多个对象可以处理同一请求，其架构适用于 解析，过滤，处理，返回这样的架构，如数据分析。</li><li>在请求处理者不明确的情况下向多个对象中的一个提交一个请求需要动态指定一组对象处理请求<br><img style="height:320px" src="https://img1.kiosk007.top/static/images/design_pattern/pipe_filter.webp"></li></ol><ul><li><font color="#200000">**举个例子**</font></li></ul><p>下面的例子是一个将 字符串“1，2，3” 按逗号切分后，再字符转数字相加的过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1,2,3&quot;</span> --&gt; [SplitFilter] --&gt; [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>] --&gt; [ToIntFilter] --&gt; [1,2,3] -&gt; [SumFilter] --&gt; 6</span><br></pre></td></tr></table></figure><p>首先实现一个 filter 的接口。该接口定义了数据的来源接口，输出接口，该filter接口必须拥有的处理方法, 所有的过滤器必须参考这个接口实现。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request is the input of the filter</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response is the output of the filter</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter interface is the definition of the data processing components</span></span><br><span class="line"><span class="comment">// Pipe-Filter structure</span></span><br><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(data Request) (Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现SplitFilter，SplitFilter必须实现处理器Process。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SplitFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SplitFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">    delimiter <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSplitFilter</span><span class="params">(delimiter <span class="keyword">string</span>)</span> *<span class="title">SplitFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SplitFilter&#123;delimiter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SplitFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    str, ok := data.(<span class="keyword">string</span>) <span class="comment">//检查数据格式/类型，是否可以处理</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, SplitFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    parts := strings.Split(str, sf.delimiter)</span><br><span class="line">    <span class="keyword">return</span> parts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现ToIntFilter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ToIntFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ToIntFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToIntFilter</span><span class="params">()</span> *<span class="title">ToIntFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ToIntFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tif *ToIntFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    parts, ok := data.([]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ToIntFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">        s, err := strconv.Atoi(part)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 SumFilter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SumFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []int&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SumFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSumFilter</span><span class="params">()</span> *<span class="title">SumFilter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SumFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SumFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    elems, ok := data.([]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, SumFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">        ret += elem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个pipe-line， 目的是为了将所有的filter串起来。循环遍历整个filter并执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewStraightPipeline create a new StraightPipelineWithWallTime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStraightPipeline</span><span class="params">(name <span class="keyword">string</span>, filters ...Filter)</span> *<span class="title">StraightPipeline</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;StraightPipeline&#123;</span><br><span class="line">        Name:    name,</span><br><span class="line">        Filters: &amp;filters,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StraightPipeline is composed of the filters, and the filters are piled as a straigt line.</span></span><br><span class="line"><span class="keyword">type</span> StraightPipeline <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Filters *[]Filter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process is to process the coming data by the pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *StraightPipeline)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> _, filter := <span class="keyword">range</span> *f.Filters &#123;</span><br><span class="line">        ret, err = filter.Process(data)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret, err</span><br><span class="line">        &#125;</span><br><span class="line">        data = ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行</p><pre>func main() {    spliter := pipe_filter.NewSplitFilter(",")    converter := pipe_filter.NewToIntFilter()    sum := pipe_filter.NewSumFilter()    sp := pipe_filter.NewStraightPipeline("p1", spliter, converter, sum)    ret, err := sp.Process("1,2,3")    if err != nil {        log.Fatal(err)    }    if ret != 6 {        log.Fatalf("The expected is 6, but the actual is %d", ret)    }    fmt.Println(ret)}执行结果：6</pre><hr><h2 id="微内核模式-Micro-Kernel"><a href="#微内核模式-Micro-Kernel" class="headerlink" title="微内核模式 (Micro Kernel)"></a>微内核模式 (Micro Kernel)</h2><ul><li><font color="#808080"> 定义以及使用场景 </font></li></ul><p>可以将 微核心架构理解成一个 核心要添加新功能就是加插件。其特点为 易扩展，错误隔离，保持架构的一致性。</p><p><strong>使用场景</strong></p><ol><li>如Nginx，启动前可以加载多个某块功能在应用上，不需要的时候可以剔除，但不影响整个应用的生命周期，适合一个应用的整体架构设计</li></ol><ul><li><font color="#200000"> 举个例子 </font></li></ul><p><strong>Agent</strong>: agent 相当于一个注册中心，所有要Agent去做的事情都注册到Agent里面来，注册进Agent的操作叫做 Collector 。每个Collector有一个名字。用map存储。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Agent <span class="keyword">struct</span> &#123;</span><br><span class="line">    collectors <span class="keyword">map</span>[<span class="keyword">string</span>]Collector  <span class="comment">//  注册进 Agent的collector</span></span><br><span class="line">    evtBuf     <span class="keyword">chan</span> Event            <span class="comment">//  collector 回传给 Agent 的事件</span></span><br><span class="line">    cancel     context.CancelFunc <span class="comment">//  任务取消的方法</span></span><br><span class="line">    ctx        context.Context    <span class="comment">//  任务取消的上下文</span></span><br><span class="line">    state      <span class="keyword">int</span>                <span class="comment">//  Agent 的运行状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Collector</strong>: Collector 是一个执行器，是需要注册进上面的Agent的。每个Collector需要实现 Init，Start，Stop，Destroy 方法，到时候由 Agent 统一进行Init，Start等操作，这里在Init中提到了 EventReceiver，所有的Collector在初始化的时候传入一个事件接收源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Collector <span class="keyword">interface</span> &#123;</span><br><span class="line">    Init(evtReceiver EventReceiver) error    <span class="comment">// Collector 将收集到的数据回传到 Agent （任何实现EventReceiver的对象）</span></span><br><span class="line">    Start(agtCtx context.Context) error      <span class="comment">// 启动所有的Collector（参数为agent中的取消上下文）</span></span><br><span class="line">    Stop() error                              <span class="comment">//   停止</span></span><br><span class="line">    Destroy() error                           <span class="comment">//   摧毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Event</strong>: Agent 实现了 OnEvent 方法，所以Agent 可以作为上面Init 方法的参数，作为事件的接收者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">    Source  <span class="keyword">string</span>   <span class="comment">// 事件源</span></span><br><span class="line">    Content <span class="keyword">string</span>   <span class="comment">// 事件内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EventReceiver <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnEvent(evt Event)  <span class="comment">// 实现OnEvent 既可以作为 EventReciver来接收事件 如下面的 Agent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">OnEvent</span><span class="params">(evt Event)</span></span> &#123;</span><br><span class="line">    agt.evtBuf &lt;- evt  <span class="comment">// Agent 可以来接收事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>开始起一个微内核</strong>: 整个 微内核的架构就是这样了，刚才提到了，Agent会统一对注册进去的Collector进行初始化（Init），启动（Start），停止（Stop）的操作。 所以这里还差一个注册函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">RegisterCollector</span><span class="params">(name <span class="keyword">string</span>, collector Collector)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line">        <span class="keyword">return</span> WrongStateError</span><br><span class="line">    &#125;</span><br><span class="line">    agt.collectors[name] = collector   <span class="comment">// agent map注册</span></span><br><span class="line">    <span class="keyword">return</span> collector.Init(agt)  <span class="comment">// 注册完立即进行Init 操作。且事件接收者为Agent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>启动、停止、摧毁</strong><br>启动会将所有的Controller都拉起来，同理停止和摧毁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> agt.state != Waiting &#123;     <span class="comment">// 状态不对，直接报错</span></span><br><span class="line">        <span class="keyword">return</span> WrongStateError</span><br><span class="line">    &#125;</span><br><span class="line">    agt.state = Running    <span class="comment">// 启动了，更改状态</span></span><br><span class="line">    agt.ctx, agt.cancel = context.WithCancel(context.Background())  <span class="comment">// 来一个取消的上下文和取消函数</span></span><br><span class="line">    <span class="keyword">go</span> agt.EventProcessGroutine()    <span class="comment">// 收集事件 (具体业务了)</span></span><br><span class="line">    <span class="keyword">return</span> agt.startCollectors()    <span class="comment">//  启动所有的Collector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的收集具体的业务事件。这里的事件是由各个 collector 上报的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">EventProcessGroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> evtSeg [<span class="number">10</span>]Event</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> evtSeg[i] = &lt;-agt.evtBuf:   <span class="comment">// 将 collector 收集的事件放到 evtBuf 中</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-agt.ctx.Done():           <span class="comment">// 执行上下文完成，结束 </span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(evtSeg)   <span class="comment">// 当 collector 收集的事件满 10 个，打印一次。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Agent 来拉起所有的 Collectors</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">startCollectors</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">var</span> errs CollectorsError</span><br><span class="line">    <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, collector Collector, ctx context.Context)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">            &#125;()</span><br><span class="line">            err = collector.Start(ctx)</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                errs.CollectorErrors = <span class="built_in">append</span>(errs.CollectorErrors,</span><br><span class="line">                    errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(name, collector, agt.ctx)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorErrors) == <span class="number">0</span> &#123;     <span class="comment">// 这里需要判断有没有错误，确定没有错误，返回nil。否则其实返回的也不是nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模拟</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DemoCollector <span class="keyword">struct</span> &#123;      <span class="comment">// 示例 Collector</span></span><br><span class="line">    evtReceiver microkernel.EventReceiver   <span class="comment">// 事件发给这里</span></span><br><span class="line">    stopChan    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;    <span class="comment">// 用来停止该Collector</span></span><br><span class="line">    name        <span class="keyword">string</span>    <span class="comment">// Collector 名字</span></span><br><span class="line">    content     <span class="keyword">string</span>    <span class="comment">// Collector 的要做的内容（假设，这个根据业务场景，都不一定是string）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCollect</span><span class="params">(name <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> *<span class="title">DemoCollector</span></span> &#123;   <span class="comment">// 创建一个 Collect</span></span><br><span class="line">    <span class="keyword">return</span> &amp;DemoCollector&#123;</span><br><span class="line">        stopChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        name:     name,</span><br><span class="line">        content:  content,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Init</span><span class="params">(evtReceiver microkernel.EventReceiver)</span> <span class="title">error</span></span> &#123;   <span class="comment">// 初始化一个这个 Collect</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;initialize collector&quot;</span>, c.name)</span><br><span class="line">    c.evtReceiver = evtReceiver    <span class="comment">// Agent 作为数据的上报源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Start</span><span class="params">(agtCtx context.Context)</span> <span class="title">error</span></span> &#123;   <span class="comment">// 拉起一个 Collect</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;start collector&quot;</span>, c.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;    <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-agtCtx.Done():      <span class="comment">// 收到 Done 了</span></span><br><span class="line">            c.stopChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="comment">// 停掉该 Collect （Stop 方法那里会等 stopChan 这个信号）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">            c.evtReceiver.OnEvent(microkernel.Event&#123;c.name, c.content&#125;) <span class="comment">// 向 Agent 上报事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;stop collector&quot;</span>, c.name)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-c.stopChan:   <span class="comment">// 收到停止信号了，停掉</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// 一般停完再做点啥，在这做些善后吧</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;failed to stop for timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Destroy</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(c.name, <span class="string">&quot;released resources.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error = <span class="literal">nil</span></span><br><span class="line">    agt := microkernel.NewAgent(<span class="number">100</span>)</span><br><span class="line">    c1 := NewCollect(<span class="string">&quot;c1&quot;</span>, <span class="string">&quot;1a&quot;</span>)</span><br><span class="line">    c2 := NewCollect(<span class="string">&quot;c2&quot;</span>, <span class="string">&quot;2b&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err = agt.RegisterCollector(<span class="string">&quot;c1&quot;</span>, c1);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = agt.RegisterCollector(<span class="string">&quot;c2&quot;</span>, c2);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = agt.Start();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err = agt.Stop();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ERR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ERR:</span><br><span class="line">    fmt.Println(<span class="string">&quot;An Error Occur :&quot;</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 (Command)"></a>命令模式 (Command)</h2><ul><li><font color="#808080">**定义以及使用场景**</font></li></ul><p>它可将请求或简单操作转换为一个对象。此类转换让你能够延迟进行或远程执行请求， 还可将其放入队列中。</p><p><strong>使用场景</strong></p><ol><li>需要抽象出待执行的行动，然后以参数的形式提供出来——类似于过程设计中的回调机制，而命令模式正是回调机制的一个面向对象的代替品。</li><li>在不同的时刻指定、排列和执行请求，一个命令对象可以有与初始请求无关的生存期</li><li>需要支持事务操作</li></ol><ul><li><font color="#200000">**举个例子**</font></li></ul><p><strong>电视遥控器</strong>:</p><p>遥控器从实现 ON 命令对象并以电视机作为接收者入手。 当在此命令上调用 execute执行方法时， 方法会调用 TV.on打开电视函数。 最后的工作是定义请求者： 这里实际上有两个请求者： 遥控器和电视机。 两者都将嵌入 ON 命令对象。</p><ul><li>实现 command 和 device </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command define</span></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">interface</span> &#123;</span><br><span class="line">execute()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> button <span class="keyword">struct</span> &#123;</span><br><span class="line">command command</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *button)</span> <span class="title">press</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.command.execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// device define ， 设备可执行的命令</span></span><br><span class="line"><span class="keyword">type</span> device <span class="keyword">interface</span> &#123;</span><br><span class="line">on()</span><br><span class="line">off()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现要执行命令</span></span><br><span class="line"><span class="keyword">type</span> onCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">device device</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *onCommand)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.device.on()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> offCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">device device</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *offCommand)</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.device.off()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建命令的发出者和执行者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令的执行者</span></span><br><span class="line"><span class="keyword">type</span> tv <span class="keyword">struct</span> &#123;</span><br><span class="line">isRunning <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tv)</span> <span class="title">on</span><span class="params">()</span></span> &#123;</span><br><span class="line">t.isRunning = <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Turning tv on&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tv)</span> <span class="title">off</span><span class="params">()</span></span> &#123;</span><br><span class="line">t.isRunning = <span class="literal">false</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Turning tv off&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行者就是按下按钮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tv := &amp;tv&#123;&#125;</span><br><span class="line"></span><br><span class="line">onButton := &amp;button&#123;</span><br><span class="line">command: &amp;onCommand&#123; device: tv &#125;,</span><br><span class="line">&#125;</span><br><span class="line">onButton.press()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 (Bridge)"></a>桥接模式 (Bridge)</h2><ul><li><strong>定义以及使用场景</strong> </li></ul><p>将抽象与实现分离，使它们可以独立变化。</p><p><strong>使用场景</strong></p><ol><li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMsgSender IMsgSender</span></span><br><span class="line"><span class="keyword">type</span> IMsgSender <span class="keyword">interface</span> &#123;</span><br><span class="line">Send(msg <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EmailMsgSender 发送邮件</span></span><br><span class="line"><span class="comment">// 可能还有 电话、短信等各种实现</span></span><br><span class="line"><span class="keyword">type</span> EmailMsgSender <span class="keyword">struct</span> &#123;</span><br><span class="line">emails []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewEmailMsgSender NewEmailMsgSender</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEmailMsgSender</span><span class="params">(emails []<span class="keyword">string</span>)</span> *<span class="title">EmailMsgSender</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;EmailMsgSender&#123;emails: emails&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send Send</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmailMsgSender)</span> <span class="title">Send</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里去发送消息</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// INotification 通知接口</span></span><br><span class="line"><span class="keyword">type</span> INotification <span class="keyword">interface</span> &#123;</span><br><span class="line">Notify(msg <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrorNotification 错误通知</span></span><br><span class="line"><span class="comment">// 后面可能还有 warning 各种级别</span></span><br><span class="line"><span class="keyword">type</span> ErrorNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">sender IMsgSender</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewErrorNotification NewErrorNotification</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewErrorNotification</span><span class="params">(sender IMsgSender)</span> *<span class="title">ErrorNotification</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ErrorNotification&#123;sender: sender&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify 发送通知</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *ErrorNotification)</span> <span class="title">Notify</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.sender.Send(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestErrorNotification_Notify</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">sender := NewEmailMsgSender([]<span class="keyword">string</span>&#123;<span class="string">&quot;test@test.com&quot;</span>&#125;)</span><br><span class="line">n := NewErrorNotification(sender)</span><br><span class="line">err := n.Notify(<span class="string">&quot;test msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="访问者模式-visitor"><a href="#访问者模式-visitor" class="headerlink" title="访问者模式 (visitor)"></a>访问者模式 (visitor)</h2><ul><li><strong>定义以及使用场景</strong> </li></ul><p>由于没有函数重载，所以我们并不知道传递过来的对象是什么类型，这个时候只能采用类型断言的方式来对不同的类型做不同的操作，但是正式由于没有函数重载，所以其实完全可以不用访问者模式直接传入参数。</p><p><strong>使用场景</strong></p><p>访问者模式一共有五种角色：</p><p>(1) Vistor（抽象访问者）：为该对象结构中具体元素角色声明一个访问操作接口。<br>(2) ConcreteVisitor（具体访问者）：每个具体访问者都实现了Vistor中定义的操作。<br>(3) Element（抽象元素）：定义了一个accept操作，以Visitor作为参数。<br>(4) ConcreteElement（具体元素）：实现了Element中的accept()方法，调用Vistor的访问方法以便完成对一个元素的操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;path&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visitor 访问者</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">Visit(IResourceFile) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IResourceFile IResourceFile</span></span><br><span class="line"><span class="keyword">type</span> IResourceFile <span class="keyword">interface</span> &#123;</span><br><span class="line">Accept(Visitor) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewResourceFile NewResourceFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourceFile</span><span class="params">(filepath <span class="keyword">string</span>)</span> <span class="params">(IResourceFile, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> path.Ext(filepath) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;.ppt&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> &amp;PPTFile&#123;path: filepath&#125;, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;.pdf&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> &amp;PdfFile&#123;path: filepath&#125;, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found file type: %s&quot;</span>, filepath)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PdfFile PdfFile</span></span><br><span class="line"><span class="keyword">type</span> PdfFile <span class="keyword">struct</span> &#123;</span><br><span class="line">path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept Accept</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PdfFile)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> visitor.Visit(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PPTFile PPTFile</span></span><br><span class="line"><span class="keyword">type</span> PPTFile <span class="keyword">struct</span> &#123;</span><br><span class="line">path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept Accept</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PPTFile)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> visitor.Visit(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compressor 实现压缩功能</span></span><br><span class="line"><span class="keyword">type</span> Compressor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visit 实现访问者模式方法</span></span><br><span class="line"><span class="comment">// 我们可以发现由于没有函数重载，我们只能通过断言来根据不同的类型调用不同函数</span></span><br><span class="line"><span class="comment">// 但是我们即使不采用访问者模式，我们其实也是可以这么操作的</span></span><br><span class="line"><span class="comment">// 并且由于采用了类型断言，所以如果需要操作的对象比较多的话，这个函数其实也会膨胀的比较厉害</span></span><br><span class="line"><span class="comment">// 后续可以考虑按照命名约定使用 generate 自动生成代码</span></span><br><span class="line"><span class="comment">// 或者是使用反射简化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">Visit</span><span class="params">(r IResourceFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> f := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *PPTFile:</span><br><span class="line"><span class="keyword">return</span> c.VisitPPTFile(f)</span><br><span class="line"><span class="keyword">case</span> *PdfFile:</span><br><span class="line"><span class="keyword">return</span> c.VisitPDFFile(f)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not found resource typr: %#v&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VisitPPTFile VisitPPTFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">VisitPPTFile</span><span class="params">(f *PPTFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;this is ppt file&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VisitPDFFile VisitPDFFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">VisitPDFFile</span><span class="params">(f *PdfFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;this is pdf file&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCompressor_Visit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">path    <span class="keyword">string</span></span><br><span class="line">wantErr <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">&quot;pdf&quot;</span>,</span><br><span class="line">path: <span class="string">&quot;./xx.pdf&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">&quot;ppt&quot;</span>,</span><br><span class="line">path: <span class="string">&quot;./xx.ppt&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name:    <span class="string">&quot;404&quot;</span>,</span><br><span class="line">path:    <span class="string">&quot;./xx.xx&quot;</span>,</span><br><span class="line">wantErr: <span class="string">&quot;not found file type&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">f, err := NewResourceFile(tt.path)</span><br><span class="line"><span class="keyword">if</span> tt.wantErr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">require.Error(t, err)</span><br><span class="line">require.Contains(t, err.Error(), tt.wantErr)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">require.NoError(t, err)</span><br><span class="line">compressor := &amp;Compressor&#123;&#125;</span><br><span class="line">f.Accept(compressor)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
    <category term="design pattern" scheme="http://kiosk007.top/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>算法 - (二叉树)</title>
    <link href="http://kiosk007.top/2020/10/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://kiosk007.top/2020/10/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-10-17T02:44:00.000Z</published>
    <updated>2020-10-17T02:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。以下会以几道 LeetCode 巩固自己的基础</p><a id="more"></a><p><a href="https://leetcode-cn.com/leetbook/detail/data-structure-binary-tree/?utm_campaign=leetbook&amp;utm_medium=%E9%A2%98%E5%BA%93&amp;utm_source=leetcode-cn&amp;utm_term=%E9%A2%98%E5%BA%93%E9%A1%B5%E6%A0%87%E7%AD%BE&amp;gio_link_id=q9A0Bxko">leetcode 树</a></p><h1 id="生成一个二叉树"><a href="#生成一个二叉树" class="headerlink" title="生成一个二叉树"></a>生成一个二叉树</h1><h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">Val int</span><br><span class="line">Left *TreeNode</span><br><span class="line">Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的工厂模式"><a href="#二叉树的工厂模式" class="headerlink" title="二叉树的工厂模式"></a>二叉树的工厂模式</h2><ul><li>创建节点、打印节点、设置节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">Print</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Print(node.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">SetVal</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">node.Val = val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">Add</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val &lt; node.Val &#123;</span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Left = CreateNode(val)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">node.Left.Add(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Right = CreateNode(val)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">node.Right.Add(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/">动画演示</a><br><img src="https://img1.kiosk007.top/static/images/leetcode/tree_1.jpg"></p><ul><li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p></li><li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p></li><li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = <span class="built_in">print</span> r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：(中序排列结果为有序数组)</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;<span class="built_in">print</span> r-&gt;inOrder(r-&gt;right) </span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;<span class="built_in">print</span> r</span><br></pre></td></tr></table></figure><h2 id="LC二叉树-前序遍历"><a href="#LC二叉树-前序遍历" class="headerlink" title="LC二叉树 前序遍历"></a>LC二叉树 前序遍历</h2><p>例题链接：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span> <span class="title">preorderTraversal</span><span class="params">(f <span class="keyword">func</span>(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f(root)</span><br><span class="line">root.Left.preorderTraversal(f)</span><br><span class="line">root.Right.preorderTraversal(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line">list = <span class="built_in">append</span>(list, root.Val)</span><br><span class="line">resLeft := preorderTraversal(root.Left)</span><br><span class="line">resRight := preorderTraversal(root.Right)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(list, resLeft...), resRight...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 channel 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TraversalTreeWithChannel</span><span class="params">(rootNode *TreeNode)</span> <span class="params">(out <span class="keyword">chan</span> *TreeNode)</span></span> &#123;</span><br><span class="line">out = <span class="built_in">make</span>(<span class="keyword">chan</span> *TreeNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rootNode.preorderTraversal(<span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">out &lt;- node</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">treeRoot := CreateNode(<span class="number">0</span>)</span><br><span class="line">treeRoot.Add(<span class="number">1</span>)</span><br><span class="line">treeRoot.Add(<span class="number">2</span>)</span><br><span class="line">fmt.Println(preorderTraversal(treeRoot))</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line">treeRoot.preorderTraversal(<span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">cnt++</span><br><span class="line">node.Print()</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;All Count: &quot;</span>, cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过通道的方式遍历二叉树</span></span><br><span class="line">out := TraversalTreeWithChannel(treeRoot)</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> out &#123;</span><br><span class="line">c.Print()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树的层次遍历（BFS广度优先遍历）"><a href="#二叉树的层次遍历（BFS广度优先遍历）" class="headerlink" title="二叉树的层次遍历（BFS广度优先遍历）"></a>二叉树的层次遍历（BFS广度优先遍历）</h2><p>例题链接：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/</a></p><p>题解：<br>创建一个先进先出的队列，从最顶层的节点依次加入节点，并遍历该层，每遍历该层的一个节点，把该层的子节点加入的队列的后面，这样就可以实现层次遍历，如果要蛇形遍历也是一个道理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> level [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line">queue := list.New()  <span class="comment">// 一个先进先出的队列,所有的元素需要依次进队</span></span><br><span class="line">queue.PushFront(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> curLevel []<span class="keyword">int</span></span><br><span class="line">curLevelLength := queue.Len()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; curLevelLength; i++ &#123;</span><br><span class="line">node := queue.Remove(queue.Back()).(*TreeNode)</span><br><span class="line">curLevel = <span class="built_in">append</span>(curLevel, node.Val)</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;  <span class="comment">// 下一层遍历做准备, 把当前节点的子节点都加进去</span></span><br><span class="line">queue.PushFront(node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue.PushFront(node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">level = <span class="built_in">append</span>(level, curLevel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="剑指Offer-判断平衡二叉树"><a href="#剑指Offer-判断平衡二叉树" class="headerlink" title="剑指Offer - 判断平衡二叉树"></a>剑指Offer - 判断平衡二叉树</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a></li><li>思路：平衡二叉树的判断方式即某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br>而一个数的高度为左子树和右子树中最高的。即只要比对左右子树的高度即可判断是否为平衡二叉树。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTreeDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(getTreeDepth(root.Left)), <span class="keyword">float64</span>(getTreeDepth(root.Right)))) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">left := getTreeDepth(root.Left)</span><br><span class="line">right := getTreeDepth(root.Right)</span><br><span class="line">    <span class="comment">// 判断左子树和右子树的绝对差值小于1 且 左子树 和 右子树 也满足平衡</span></span><br><span class="line"><span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(left) - <span class="keyword">float64</span>(right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-235-二叉搜索树的公共祖先"><a href="#No-235-二叉搜索树的公共祖先" class="headerlink" title="No.235 二叉搜索树的公共祖先"></a>No.235 二叉搜索树的公共祖先</h2><ul><li><p>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p></li><li><p>思路：</p><ul><li>通过搜索的方式查找节点，并记录所有节点，查到2个点之后，比对两个查找链路上的最后一个公共节点即可</li><li>判断P,Q 两个节点如果在都小于root，则公共节点一定是在左子树，反之同理。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || root == q || root == p &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.Val &lt;= root.Val &amp;&amp; q.Val &lt;= root.Val &#123;   <span class="comment">//p和q都小于root,公共祖先节点一定在root的左边</span></span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root.Left,p,q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.Val &gt;= root.Val &amp;&amp; q.Val &gt;= root.Val &#123;   <span class="comment">//p和q都大于root,公共祖先节点一定在root的右边</span></span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root.Right,p,q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-112-路径总和"><a href="#No-112-路径总和" class="headerlink" title="No.112 路径总和"></a>No.112 路径总和</h2><ul><li>链接：<a href="https://leetcode-cn.com/submissions/detail/23501756/">https://leetcode-cn.com/submissions/detail/23501756/</a></li><li>思路：这种类似与 二叉树的深度遍历DFS肯定是要用到递归了。。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sum == root.Val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.Left, sum-root.Val) || hasPathSum(root.Right, sum-root.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。以下会以几道 LeetCode 巩固自己的基础&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>算法 - (数组、链表)</title>
    <link href="http://kiosk007.top/2020/09/26/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/"/>
    <id>http://kiosk007.top/2020/09/26/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</id>
    <published>2020-09-26T02:58:00.000Z</published>
    <updated>2020-09-26T02:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组、链表是编程语言中最常见的数据结构，也是最基础的数据结构。以下会以几道 LeetCode 巩固自己的基础</p><a id="more"></a><h1 id="结构对比"><a href="#结构对比" class="headerlink" title="结构对比"></a>结构对比</h1><p>数组和链表各有各的优势，比如数组的随机插入和删除都是O(n)的，可谓是很低效了。但是数组的查找是是O(1)，直接指定下标即可找到对应的元素。而链表必须遍历，也就是想要查找你一个元素的时间复杂度是 O(n)。所以数组和链表各有各的优势，互相补充。</p><div class="table-container"><table><thead><tr><th>数据结构</th><th style="text-align:right">操作</th><th style="text-align:center">时间复杂度</th></tr></thead><tbody><tr><td>数组</td><td style="text-align:right">prepend</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">append</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">lookup</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">insert</td><td style="text-align:center">O(n)</td></tr><tr><td></td><td style="text-align:right">delete</td><td style="text-align:center">O(n)</td></tr><tr><td></td><td style="text-align:right">—</td><td style="text-align:center">—</td></tr><tr><td>链表</td><td style="text-align:right">prepend</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">append</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">lookup</td><td style="text-align:center">O(n)</td></tr><tr><td></td><td style="text-align:right">insert</td><td style="text-align:center">O(1)</td></tr><tr><td></td><td style="text-align:right">delete</td><td style="text-align:center">O(1)</td></tr></tbody></table></div><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">int</span></span><br><span class="line">b = <span class="built_in">append</span>(c, <span class="number">11</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, a...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// make( []Type, size, cap )</span></span><br><span class="line"><span class="comment">// 其中 Type 是指切片的元素类型，</span></span><br><span class="line"><span class="comment">// size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，</span></span><br><span class="line"><span class="comment">// 这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)  </span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义单链表</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;     </span><br><span class="line">Val <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *ListNode)</span> <span class="title">add</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ln == <span class="literal">nil</span> &#123;</span><br><span class="line">ln = &amp;ListNode&#123;Val: v,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ln.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">ln = ln.Next</span><br><span class="line">&#125;</span><br><span class="line">ln.Next = &amp;ListNode&#123;Val: v,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *ListNode)</span> <span class="title">traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ln != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>,ln.Val)</span><br><span class="line">ln = ln.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="No-1-两数之和"><a href="#No-1-两数之和" class="headerlink" title="No.1 两数之和"></a>No.1 两数之和</h3><ul><li>链接：<a href="https://leetcode-cn.com/problems/two-sum/submissions/">https://leetcode-cn.com/problems/two-sum/submissions/</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line"><span class="keyword">if</span> index, ok := tmp[target-nums[i]]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;index,i&#125;</span><br><span class="line">&#125;</span><br><span class="line">tmp[nums[i]] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="No-26-删除排序数组中的重复项"><a href="#No-26-删除排序数组中的重复项" class="headerlink" title="No.26 删除排序数组中的重复项"></a>No.26 删除排序数组中的重复项</h3><ul><li>链接: <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></li><li>思路1：<strong>双指针法</strong> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/26-shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xia-89/">题解动画</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">j++</span><br><span class="line">nums[j] = nums[i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路2： <strong>*旋转数组法</strong> 旋转数组应该是我比较喜欢的一种方式，比较简单，那就是数组翻转2次，可以将首位数转到末尾曲，重复项判断刚好使用这种方式，<font style="color:red">对于移动数组类的题是比较通吃的一个方法</font>问题就是时间复杂度比较大<br><a href="https://img1.kiosk007.top/static">https://img1.kiosk007.top/static</a><img src="/images/leetcode/list_1.jpeg" style="height:300px"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversal</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; length &gt; <span class="number">1</span> &amp;&amp; i &lt; length/<span class="number">2</span>; i ++ &#123;</span><br><span class="line">nums[i],nums[length<span class="number">-1</span>-i] = nums[length<span class="number">-1</span>-i],nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i ++ &#123;</span><br><span class="line"><span class="keyword">if</span> i + <span class="number">1</span> &lt; length &amp;&amp; nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">reversal(nums[i+<span class="number">1</span>:length])</span><br><span class="line">reversal(nums[i+<span class="number">1</span>:length<span class="number">-1</span>])</span><br><span class="line">length = length - <span class="number">1</span></span><br><span class="line">i = i - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h3 id="No-21-合并两个链表"><a href="#No-21-合并两个链表" class="headerlink" title="No.21 合并两个链表"></a>No.21 合并两个链表</h3><ul><li>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/">https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/</a></li><li>思路1: <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">迭代法</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">tmp := &amp;ListNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">prev := tmp</span><br><span class="line"><span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt; l2.Val&#123;</span><br><span class="line">prev.Next = l1</span><br><span class="line">prev = prev.Next</span><br><span class="line"></span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">prev.Next = l2</span><br><span class="line">prev = prev.Next</span><br><span class="line"></span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">prev.Next = l2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">prev.Next = l1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-83-删除排序链表重复项"><a href="#No-83-删除排序链表重复项" class="headerlink" title="No.83 删除排序链表重复项"></a>No.83 删除排序链表重复项</h2></li><li>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></li><li>思路1：题解感觉和我差不太多，我的思路是先把重复项移到尾端，然后cur 指针指向重复项的尾端就好了。但不知道为啥 8ms 打败 7.3% 。理论就是 O(N) 啊。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur := &amp;ListNode&#123;&#125; </span><br><span class="line">tmp := cur   <span class="comment">// 记录链表头</span></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> head.Next != <span class="literal">nil</span> &amp;&amp; head.Val == head.Next.Val &#123;</span><br><span class="line"> head = head.Next</span><br><span class="line">&#125;</span><br><span class="line">cur.Next = head</span><br><span class="line">cur = cur.Next</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-141-环形链表"><a href="#No-141-环形链表" class="headerlink" title="No.141 环形链表"></a>No.141 环形链表</h2></li><li>链接: <a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></li><li>思路1：这道题思路非常简单，就是快慢指针，慢指针每次前进一步，快指针每次前进两步。如果存在环快指针一定会追上慢指针，<strong>问题就是边界条件太多，需要仔细判断。</strong></li><li>思路2：hash表存已有的数据做对比，这个最简单，不演示啦~</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow := head</span><br><span class="line">fast := head.Next</span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line"><span class="keyword">if</span> slow == fast &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-206-反转链表"><a href="#No-206-反转链表" class="headerlink" title="No.206 反转链表"></a>No.206 反转链表</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></li><li>思路1：<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/206-fan-zhuan-lian-biao-shuang-zhi-zhen-fa-di-gui-/">双指针</a>  本质还是遍历 head， 上面的<code>next := head.Next</code>和下面的<code>head = next</code> 就是为了遍历， 中间的三行是 当前head的节点的下一个指向之前，cur即为当前head节点，cur 成为历史 prev</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prev *ListNode = <span class="literal">nil</span></span><br><span class="line">cur := prev</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">next := head.Next  <span class="comment">// 存下一个</span></span><br><span class="line"></span><br><span class="line">head.Next = prev <span class="comment">// haed 的Next指向 prev</span></span><br><span class="line">cur = head       <span class="comment">// cur 就是 head</span></span><br><span class="line">prev = cur <span class="comment">// cur 成为 prev</span></span><br><span class="line"></span><br><span class="line">head = next   <span class="comment">// head 前进</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个-LRU-缓存"><a href="#实现一个-LRU-缓存" class="headerlink" title="实现一个 LRU 缓存"></a>实现一个 LRU 缓存</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lru</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/list&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MemoryOverFlow<span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">MemorySizeError<span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">NotFoundObject<span class="keyword">int</span> = <span class="number">11</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lruErrorName = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">MemoryOverFlow:      <span class="string">&quot;MemoryOverFlow&quot;</span>,</span><br><span class="line">MemorySizeError:  <span class="string">&quot;MemorySizeError&quot;</span>,</span><br><span class="line">NotFoundObject:  <span class="string">&quot;NotFoundObject&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录存储数据的大小</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">Len() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储的对象</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key <span class="keyword">string</span></span><br><span class="line">value Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">maxBytes <span class="keyword">int64</span>        <span class="comment">// 最大使用内存</span></span><br><span class="line">nBytes  <span class="keyword">int64</span>        <span class="comment">// 当前已使用内存</span></span><br><span class="line">ll *list.List         <span class="comment">// 链表存储淘汰关系</span></span><br><span class="line">cache  <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element   <span class="comment">//节点放到字典中，加速查找</span></span><br><span class="line">OnEvicted  <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value Value)</span>   //某条记录被删除时候的回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateLRUCache</span><span class="params">(maxByte <span class="keyword">int64</span>,evicted <span class="keyword">func</span>(<span class="keyword">string</span>,Value)</span>) *<span class="title">Cache</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">maxBytes:  maxByte,</span><br><span class="line">nBytes:    <span class="number">0</span>,</span><br><span class="line">ll:        <span class="built_in">new</span>(list.List),</span><br><span class="line">cache:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element),</span><br><span class="line">OnEvicted: evicted,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value Value,err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class="line">c.ll.MoveToFront(ele)</span><br><span class="line"><span class="keyword">return</span> ele.Value.(*entry).value, <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(lruErrorName[NotFoundObject])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">string</span>, value Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断是否可以加入(太大会把所有缓存冲掉)</span></span><br><span class="line"><span class="keyword">if</span> c.isOutOfMaxMemory(value.Len()) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(lruErrorName[MemoryOverFlow])   <span class="comment">// 内存不足以添加该缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断缓存中已有该键, 更新</span></span><br><span class="line"><span class="keyword">if</span> v, ok := c.cache[key]; ok &#123;</span><br><span class="line">oldValue := v.Value.(*entry)</span><br><span class="line"><span class="comment">// 可以加入,将该键移动到队头</span></span><br><span class="line">c.ll.MoveToFront(v)</span><br><span class="line">c.cache[oldValue.key] = &amp;list.Element&#123;Value: &amp;entry&#123;key,value&#125;&#125;</span><br><span class="line">c.nBytes = c.nBytes - oldValue.value.Len() + value.Len()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有该键,第一次添加</span></span><br><span class="line">ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">c.cache[key] = ele</span><br><span class="line">c.nBytes = c.nBytes + value.Len()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若内存不够，需要循环删除掉最老的</span></span><br><span class="line"><span class="keyword">for</span> c.maxBytes != <span class="number">0</span> &amp;&amp; c.maxBytes &lt; c.nBytes &#123;</span><br><span class="line"><span class="keyword">if</span> err := c.RemoveOldest(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">oldest := c.ll.Back()</span><br><span class="line"><span class="keyword">if</span> oldest != <span class="literal">nil</span> &#123;</span><br><span class="line">oldestEntry := oldest.Value.(*entry)</span><br><span class="line">c.ll.Remove(oldest) <span class="comment">// 删除链表节点</span></span><br><span class="line">c.nBytes = c.nBytes - oldestEntry.value.Len() <span class="comment">// 删除字节长度</span></span><br><span class="line"><span class="built_in">delete</span>(c.cache, oldestEntry.key)  <span class="comment">// 删除字典</span></span><br><span class="line"><span class="keyword">if</span> c.nBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(lruErrorName[MemorySizeError])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">c.OnEvicted(oldestEntry.key, oldestEntry.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(c.ll.Len())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">isOutOfMaxMemory</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> size &gt; c.maxBytes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GeeByte <span class="keyword">struct</span> &#123;</span><br><span class="line">Value []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GeeByte)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(g.Value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLruCache</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">lruObject := lru.CreateLRUCache(<span class="number">20</span>, <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value lru.Value)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 被删除了, 释放了 %d 字节的空间\n&quot;</span>, key, value.Len())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">_ = lruObject.Add(<span class="string">&quot;key1&quot;</span>, GeeByte&#123;[]<span class="keyword">byte</span>(<span class="string">&quot;Hello, Golang&quot;</span>)&#125;)</span><br><span class="line">_ = lruObject.Add(<span class="string">&quot;key2&quot;</span>, GeeByte&#123;[]<span class="keyword">byte</span>(<span class="string">&quot;Hello, ByteDance&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value, err := lruObject.Get(<span class="string">&quot;key2&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>,value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组、链表是编程语言中最常见的数据结构，也是最基础的数据结构。以下会以几道 LeetCode 巩固自己的基础&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://kiosk007.top/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>systemd 基本概念</title>
    <link href="http://kiosk007.top/2020/09/20/systemd-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://kiosk007.top/2020/09/20/systemd-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-09-20T15:29:00.000Z</published>
    <updated>2020-09-20T15:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>systemd 是 PID 为1的一个程序，负责初始化系统。所有的程序不是systemd直接启动就是由systemd的子系统启动。systemd是内核直接启动，所以信号9(KILL)对systemd也无效。</p><p>systemd 使用Linux控制组跟踪进程，维护安装和自动挂载点，并实现基于事务性依赖关系的详尽服务控制逻辑。其他部分包括日志记录守护程序，用于控制基本系统配置的实用程序，例如主机名，日期，区域设置，维护已登录用户和正在运行的容器和虚拟机的列表，系统帐户，运行时目录和设置，以及用于管理简单网络的守护程序配置，网络时间同步，日志转发和名称解析。</p><a id="more"></a><p><img src="https://img1.kiosk007.top/static/images/systemd/systemd.png" style="height:400px"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="对比-systemV"><a href="#对比-systemV" class="headerlink" title="对比 systemV"></a>对比 systemV</h2><p>从CentOS 7.x 以后，Red Hat 系列的 distribution 放弃沿用多年的System V 开机启动服务的流程. systemd 也是当年我从6.x 到 7.x 过度时感觉到最大的变化了，直到今天，MySQL的启动脚本还是可以通过 <code>service mysqld start</code> 启动的，但是升级到 CentOS 7.x 之后，就变成了 <code>systemd start mysqld</code> 了。当然还有经典的<code>init 0</code>的关机指令。</p><p>相比于 initd，systemd有以下几个大的进步。</p><ul><li><font color="blue">并行启动</font>：旧的 init 启动脚本是一项一项任务依序启动的模式，因此不相依的服务也是得要一个一个的等待。systemd可以让所有的服务同时启动，因此你会发现到，系统启动的速度变快了！</li><li><font color="blue">一经要求就回应的on-demand启动方式</font>：systemd全部就是仅有一只systemd服务搭配systemctl指令来处理，无须其他额外的指令来支援。不像systemV还要init, chkconfig, service…等等指令。此外， systemd由于常驻记忆体，因此任何要求(on-demand)都可以立即处理后续的daemon启动的任务。</li><li><font color="blue">服务相依性的自我检查</font>：由于systemd可以自订服务相依性的检查，因此如果B服务是架构在A服务上面启动的，那当你在没有启动A服务的情况下仅手动启动B服务时， systemd会自动帮你启动A服务。</li><li><font color="blue">依daemon功能分类</font>：systemd下管理的服务非常多，为了厘清所有服务的功能，因此，首先systemd先定义所有的服务为一个服务单位(unit)，并将该unit归类到不同的服务类型(type)去。旧的init仅分为stand alone与super daemon，systemd将服务单位(unit)区分为service, socket, target, path, snapshot, timer等多种不同的类型(type)，方便管理员的分类与记忆。</li><li><font color="blue">将多个daemons集合成为一个群组</font>：如同systemV的init里头有个runlevel的特色，systemd亦将许多的功能集合成为一个所谓的target项目，这个项目主要在设计操作环境的建置，所以是集合了许多的daemons，亦即是执行某个target就是执行好多个daemon的意思！</li><li><font color="blue">向下相容旧有的init服务脚本</font>：基本上， systemd是可以相容于init的启动脚本的，因此，旧的init启动脚本也能够透过systemd来管理，这也是为什么到现在还可以使用<code>serivce mysqld start</code> 这样命令的原因。</li></ul><blockquote><p><strong>综上可知，systemd 已经足够强大，可以管理一个进程的生命周期，如果是自己写的一套代码完全可以交给systemd 来维护呀，以前公司使用 <a href="https://ruby-china.org/topics/21354">god</a>(进程监控守护工具) 来管理服务，god 提供了服务启动、服务宕机自动拉起、环境变量和chroot、服务资源限制、定时任务等，但是systemd 的出现已经足够替代 god 这样的第三方服务，systemd 已经足够实现服务托管。</strong></p></blockquote><p><img src="https://img1.kiosk007.top/static/images/systemd/systemd_components2.png" style="height:400px"></p><h2 id="systemd-的配置文件"><a href="#systemd-的配置文件" class="headerlink" title="systemd 的配置文件"></a>systemd 的配置文件</h2><p>基本上， systemd 将过去所谓的daemon 执行脚本通通称为一个服务单位(unit)，而每种服务单位依据功能来区分时，就分类为不同的类型(type)。在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p><ul><li><font color="blue">automount</font>：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li><li><font color="blue">device</font>：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li><li><font color="blue">mount</font>：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li><li><font color="blue">path</font>：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li><li><font color="blue">scope</font>：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li><li><font color="blue">service</font>：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li><li><font color="blue">slice</font>：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li><li><font color="blue">snapshot</font>：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li><li><font color="blue">socket</font>：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li><li><font color="blue">swap</font>：定义一个用户做虚拟内存的交换分区</li><li><font color="blue">target</font>：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式。其实是一群unit 的集合，例如上面表格中谈到的multi-user.target 其实就是一堆服务的集合～也就是说， 选择执行multi-user.target 就是执行一堆其他.service 或/及.socket 之类的服务就是了！</li><li><font color="blue">timer</font>：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li></ul><p><strong>文件目录</strong><br>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p><ul><li><font color="blue">/etc/systemd/system/</font>：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能。</li><li><font color="blue">/run/systemd/system/</font>：系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li><font color="blue">/usr/lib/systemd/system/</font>：每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li></ul><p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p><h1 id="Systemd-Service-Unit"><a href="#Systemd-Service-Unit" class="headerlink" title="Systemd Service Unit"></a>Systemd Service Unit</h1><h2 id="Unit-文件结构"><a href="#Unit-文件结构" class="headerlink" title="Unit 文件结构"></a>Unit 文件结构</h2><p>一般可以使用 <font style="color=blue">systemctl cat networking</font> 查看 Unit 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Hello World</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker <span class="built_in">kill</span> busybox1</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm busybox1</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c <span class="string">&quot;while true; do echo Hello World; sleep 1; done&quot;</span></span><br><span class="line">ExecStop=<span class="string">&quot;/usr/bin/docker stop busybox1&quot;</span></span><br><span class="line">ExecStopPost=<span class="string">&quot;/usr/bin/docker rm busybox1&quot;</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><strong><font style="color:red"><code>[Unit]</code></font></strong> 区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p><blockquote><ul><li><code>Description</code>：简短描述</li><li><code>Documentation</code>：文档地址</li><li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li><li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li><li><code>BindsTo</code>：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li><li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li><li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li><li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li><li><code>Condition</code>：当前 Unit 运行必须满足的条件，否则不会运行</li><li><code>Assert</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li></ul></blockquote><p><strong><font style="color:red"><code>[Service]</code></font></strong> 区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><blockquote><ul><li><code>Type</code>：定义启动时的进程行为。它有以下几种值。</li><li><code>Type=simple</code>：默认值，执行ExecStart指定的命令，启动主进程</li><li><code>Type=forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li><li><code>Type=oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li><li><code>Type=dbus</code>：当前服务通过D-Bus启动</li><li><code>Type=notify</code>：当前服务启动完毕，会通知Systemd，再继续往下执行</li><li><code>Type=idle</code>：若有其他任务执行完毕，当前服务才会运行</li><li><code>ExecStart</code>：启动当前服务的命令</li><li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li><li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li><li><code>ExecReload</code>：重启当前服务时执行的命令</li><li><code>ExecStop</code>：停止当前服务时执行的命令</li><li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li><li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li><li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li><li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li><li><code>Environment</code>：指定环境变量</li><li><code>EnvironmentFile</code>：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li><li><code>Nice</code>：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li><li><code>WorkingDirectory</code>：指定服务的工作目录</li><li><code>RootDirectory</code>：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li><li><code>User</code>：指定运行服务的用户</li><li><code>Group</code>：指定运行服务的用户组</li><li><code>MountFlags</code>：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private<ul><li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li><li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li><li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上</li></ul></li><li><code>LimitCPU</code> / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li></ul></blockquote><p><strong><font style="color:red"><code>[Install]</code></font></strong> 通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><blockquote><ul><li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</li><li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</li><li><code>Alias</code>：当前 Unit 可用于启动的别名</li><li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li></ul></blockquote><p><strong>Unit 配置文件的完整字段清单，请参考 <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">官方文档</a>。</strong></p><h2 id="Unit-管理"><a href="#Unit-管理" class="headerlink" title="Unit 管理"></a>Unit 管理</h2><p><font style="color:blue">systemctl list-units </font>命令可以查看当前系统的所有 Unit 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出正在运行的 Unit</span></span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有没有运行的 Unit</span></span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有加载失败的 Unit</span></span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看开机自启动的 service</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span> service |grep enabled</span><br></pre></td></tr></table></figure></p><h1 id="Systemd-Target"><a href="#Systemd-Target" class="headerlink" title="Systemd Target"></a>Systemd Target</h1><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p><p>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的所有 Target</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动时的默认 Target</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动时的默认 Target</span></span><br><span class="line">$ sudo systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span></span><br><span class="line"><span class="comment"># systemctl isolate 命令改变这种行为，</span></span><br><span class="line"><span class="comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure><p>Target 与 传统 RunLevel 的对应关系如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Traditional runlevel      New target name     Symbolically linked to...</span><br><span class="line"></span><br><span class="line">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</span><br><span class="line">Runlevel 1           |    runlevel1.target -&gt; rescue.target</span><br><span class="line">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</span><br><span class="line">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</span><br><span class="line">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</span><br><span class="line">Runlevel 5           |    runlevel5.target -&gt; graphical.target</span><br><span class="line">Runlevel 6           |    runlevel6.target -&gt; reboot.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>它与<font style="color:blue">init</font>进程的主要差别如下。</p><p>（1）默认的 RunLevel（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p><p>（2）启动脚本的位置，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p><p>（3）配置文件的位置，以前init进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p><h1 id="Systemd-管理"><a href="#Systemd-管理" class="headerlink" title="Systemd 管理"></a>Systemd 管理</h1><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p><font style="color:blue"> systemctl </font> 是 Systemd 的主命令，用于管理系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU停止工作</span></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停系统</span></span><br><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入冬眠状态</span></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入交互式休眠状态</span></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure><h2 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h2><p><font style="color:blue"> systemd-analyze </font> 命令用于查看启动耗时。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure></p><h2 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h2><p><font style="color:blue"> hostnamectl </font> 命令用于查看当前主机的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure><h2 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h2><p><font style="color:blue"> localectl </font> 命令用于查看本地化设置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ sudo localectl set-locale LANG=en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure></p><h2 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h2><p><font style="color:blue"> timedatectl </font>命令用于查看当前时区设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ sudo timedatectl set-timezone America/New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure><h2 id="loginctl"><a href="#loginctl" class="headerlink" title="loginctl"></a>loginctl</h2><p><font style="color:blue"> loginctl </font> 命令用于查看当前登录的用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<font style="color:blue"><code>journalctl</code></font>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since=<span class="string">&quot;2012-10-30 18:17:16&quot;</span></span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;20 min ago&quot;</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;2015-01-10&quot;</span> --until <span class="string">&quot;2015-01-11 03:00&quot;</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">&quot;1 hour ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部的最新10行日志</span></span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"> -o json-pretty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">systemd 入门教程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;systemd 是 PID 为1的一个程序，负责初始化系统。所有的程序不是systemd直接启动就是由systemd的子系统启动。systemd是内核直接启动，所以信号9(KILL)对systemd也无效。&lt;/p&gt;
&lt;p&gt;systemd 使用Linux控制组跟踪进程，维护安装和自动挂载点，并实现基于事务性依赖关系的详尽服务控制逻辑。其他部分包括日志记录守护程序，用于控制基本系统配置的实用程序，例如主机名，日期，区域设置，维护已登录用户和正在运行的容器和虚拟机的列表，系统帐户，运行时目录和设置，以及用于管理简单网络的守护程序配置，网络时间同步，日志转发和名称解析。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://kiosk007.top/categories/Linux/"/>
    
    
    <category term="devops" scheme="http://kiosk007.top/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 调度对象</title>
    <link href="http://kiosk007.top/2020/08/22/Kubernetes-Pod/"/>
    <id>http://kiosk007.top/2020/08/22/Kubernetes-Pod/</id>
    <published>2020-08-22T01:53:00.000Z</published>
    <updated>2020-08-22T01:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在容器的世界中，Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统，而如果仅仅是这样的化，容器是没有价值的，因为这样很难实现线上生产环境迁移到容器集群中，线上环境复杂多变，多个服务需要通过本地socket通信或者通过文件交互内容，所以在 k8s 中，pod才是最小的调度单元。</p><a id="more"></a><p>Pod是Kubernetes创建或部署的最小/最简单的基本单位，一个Pod代表集群上正在运行的一组进程。Pod 在 k8s 中扮演着重要的角色：<strong>容器的设计模式</strong>。</p><blockquote><p>Docker是Kubernetes Pod中最常见的runtime ，Pods也支持其他容器runtimes。</p></blockquote><h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><strong>首先要了解的一个事实是 Pod 只是一个逻辑概念，简单的理解是一组超亲密关系的容器</strong></p><p>这些容器共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。<br>在Docker中就有诸如 <code>$ docker run --net=B --volumes-from=B -name =A ...</code> 这样的命令可以让多个容器共享一个Namespace。</p><p>没错既然需要共享，那么就需要有容器的启动顺序，先启动一个基础容器，再将后启动的容器共享该基础容器的Namespace。<br><img src="https://img1.kiosk007.top/static/images/k8s/k8s_infra1.png" style="height:400px"></p><p>正如上图所示，在其他容器启动之前会先启动一个infra容器，infra容器一定只占用很少的资源，这个容器叫做‘k8s.gcr.io/pause’。这个镜像使用汇编编写，永远处于“暂停”状态，而infra容器提供基础的Namespace环境供该Pod里的其他容器共享。</p><p>所以，对于同一个Pod的里的所有容器来讲，他们的进出流量可以认为是通过 infra 容器完成的。<strong>之后如果要给k8s开发一个网络插件，应该考虑配置该Pod的Network Namesapce，Infra容器的rootfs里几乎什么东西都没有</strong></p><p>Pod 只是 k8s 里面的一个概念，提供的是一个编排思想，而不是具体的技术方案，比如 Mirantis 公司的 <a href="https://github.com/Mirantis/virtlet">virtlet</a> , 可以实现一个带有 systemd 进程的容器，来模拟传统的操作系统。</p><h2 id="Pod-配置文件"><a href="#Pod-配置文件" class="headerlink" title="Pod 配置文件"></a>Pod 配置文件</h2><p>Pod的创建时基于k8s 的配置文件 — yaml 文件创建的，这样的好处是可以记录每一个Pod的基础信息,<strong>凡是调度、网络、存储、安全相关的属性，基本上都是Pod级别的</strong></p><p>下面是Pod中的几个重要字段的含义和用法。具体更多的用法可以参考 <code>$GOPATH/src/k8s.io/kubernetes/vendor/k8s.io/api/core/v1/types.go</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1    # 版本号</span><br><span class="line">kind: Pod         # Pod</span><br><span class="line">metadata:         # 元数据</span><br><span class="line">  name: nginx     # Pod名称</span><br><span class="line">  namespace: string    # Pod所属的命名空间</span><br><span class="line">  labels:         # 自定义标签</span><br><span class="line">    - name: string   # 自定义标签名字</span><br><span class="line">  annotations:       # 自定义注释列表</span><br><span class="line">    - name: string </span><br><span class="line">spec:          # Pod中容器的详细定义</span><br><span class="line">  hostNetwork: true   # 共享宿主机网络</span><br><span class="line">  hostIPC: true       # 共享宿主机IPC</span><br><span class="line">  hostPID: true       # 共享宿主机PID</span><br><span class="line">  shareProcessNamespace: true   # Pod间共享PID</span><br><span class="line">  nodeSelector:       # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">  imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br><span class="line">    - name: string</span><br><span class="line">   disktype: ssd        </span><br><span class="line">  hostAliases:        # 设置 &#x2F;etc&#x2F;hosts</span><br><span class="line">   - ip: &quot;10.1.2.3&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.remote&quot;</span><br><span class="line">    - &quot;bar.remote&quot;</span><br><span class="line">  restartPolicy: [Always | Never | OnFailure]  # Pod的重启策略</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: shell</span><br><span class="line">    image: busybox</span><br><span class="line">    stdin: true</span><br><span class="line">    tty: true</span><br></pre></td></tr></table></figure><ul><li><strong>spec</strong></li></ul><p><strong>nodeSeletor</strong> 是一个供用户将 Pod 与 Node 进行绑定的字段<br>这样的配置意味着该Pod只能运行在携带了“disktype：ssd”标签（Label）的节点上；否则会调度失败。</p><p><strong>hostAliases</strong> 定义了Pod中的 hosts 文件（比如 /etc/hosts）里的内容<br>在k8s中如果想要设置hosts文件的内容一定要通过这种方式，否则，Pod被删除重建后，kubelet会自动覆盖掉修改过的内容。</p><p><strong>restartPolicy</strong> ，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod。</p><blockquote><p>Pod在恢复过程中，永远是发生在当前的Node节点上，而不会去别的节点。如果想要Pod出现在其他可用节点，就需要使用 Deployment 这样的调度器来管理Pod，</p></blockquote><ul><li><strong>Namespace共享</strong></li></ul><p>凡是和Namespace相关的内容那么也一定是Pod级别的，Pod的设计就是要让Pod里的容器共享Namesapce，<code>shareProcessNamespace: true</code> 这条指令就可以实现Pod内的容器共享PID Namespace。</p><blockquote><p>创建Pod之后可以通过 <code>kubectl attach -it nginx -c shell</code> 后就可以通过ps 命令查看该Pod中的所有进程。</p></blockquote><p>同样添加 <code>hostNetwork</code>、<code>hostIPC</code>、<code>hostPID</code> 即可共享宿主机资源。</p><ul><li><strong>容器 &amp;&amp; 镜像</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:     # Pod中容器列表</span><br><span class="line">  - name: demo    # 容器名</span><br><span class="line">    image: nginx:1.19.2</span><br><span class="line">    command: [string]    # 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">    args: [string]       # 容器的启动命令参数列表</span><br><span class="line">    workingDir: string   # 容器的工作目录</span><br><span class="line">    imagePullPolicy: [Always | Never | IfNotPresent] # 容器拉取策略</span><br><span class="line">    nodeSelector: obeject  # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">    lifecycle:      # 容器生命周期</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; &#x2F;usr&#x2F;share&#x2F;message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]</span><br><span class="line">    volumes:       #在该pod上定义共享存储卷列表</span><br><span class="line">    - name: string     #共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">      emptyDir: &#123;&#125;     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br><span class="line">      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br><span class="line">        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录</span><br><span class="line">      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span><br><span class="line">        scretname: string  </span><br><span class="line">        items:     </span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br><span class="line">        name: string</span><br><span class="line">        items:</span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">    volumeMounts:    #挂载到容器内部的存储卷配置</span><br><span class="line">    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br><span class="line">      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符</span><br><span class="line">      readOnly: boolean    #是否为只读模式</span><br><span class="line">    ports:       #需要暴露的端口库号列表</span><br><span class="line">    - name: string     #端口号名称</span><br><span class="line">      containerPort: int   #容器需要监听的端口号</span><br><span class="line">      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同</span><br><span class="line">      protocol: string     #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    env:       #容器运行前需设置的环境变量列表</span><br><span class="line">    - name: string     #环境变量名称</span><br><span class="line">      value: string    #环境变量的值</span><br><span class="line">    resources:       #资源限制和请求的设置</span><br><span class="line">      limits:      #资源限制的设置</span><br><span class="line">        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br><span class="line">        memory: string     #内存限制，单位可以为Mib&#x2F;Gib，将用于docker run --memory参数</span><br><span class="line">      requests:      #资源请求的设置</span><br><span class="line">        cpu: string    #Cpu请求，容器启动的初始可用数量</span><br><span class="line">        memory: string     #内存请求，容器启动的初始可用数量</span><br><span class="line">    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span><br><span class="line">      exec:      #对Pod容器内检查方式设置为exec方式</span><br><span class="line">        command: [string]  #exec方式需要制定的命令或脚本</span><br><span class="line">      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式</span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged:false</span><br></pre></td></tr></table></figure><p><strong>ImagePullPolicy</strong> 定义了镜像拉取的策略，是一个Container级别的属性，默认值是Always，即每次创建Pod都重新拉取一次镜像，如果被定义为Never或者 ifNotPresent 时，则意味着Pod永远不会主动拉取这个镜像，或者只有宿主机不存在这个镜像时才会拉取。</p><p><strong>Lifecycle</strong> 定义了容器生命周期的一些钩子，可以执行容器启动前启动后的一些命令，</p><ul><li><strong>Projected Volume</strong></li></ul><p>在 k8s 中有一种特殊的Volume，叫做Projected Volume，存在的意义不是为了存放容器内的数据，也不是用来做数据交换，<strong>而是提供预先准备好的数据，所以从容器的角度来看就仿佛是被 k8s “投射”（Project）进入容器的，这正是Projected Volume 的含义。</strong></p><p>到目前为止，k8s共支持4种 Projected Volume.</p><ol><li>Secret   (例如加载数据库密码等)</li><li>ConfigMap   (例如加载配置文件等)</li><li>Downward API  (暴露Pod的meta信息给容器)</li><li>ServiceAccountToken  (保存授权信息)</li></ol><p>以Secret为例，其存在的意义其实就是将一些重要的数据投射进容器，比如数据库密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-projected-volume </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - &quot;86400&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: &quot;&#x2F;projected-volume&quot;</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: user</span><br><span class="line">      - secret:</span><br><span class="line">          name: pass</span><br></pre></td></tr></table></figure><p>数据库的用户名和密码，正是以Secret对象交付给 k8s 保存的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat .&#x2F;username.txt</span><br><span class="line">admin</span><br><span class="line">$ cat .&#x2F;password.txt</span><br><span class="line">c1oudc0w!</span><br><span class="line"></span><br><span class="line">$ kubectl create secret generic user --from-file&#x3D;.&#x2F;username.txt</span><br><span class="line">$ kubectl create secret generic pass --from-file&#x3D;.&#x2F;password.txt</span><br><span class="line"></span><br><span class="line">$ kubectl get secrets</span><br><span class="line">NAME           TYPE                                DATA      AGE</span><br><span class="line">user          Opaque                                1         51s</span><br><span class="line">pass          Opaque                                1         51s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以通过yaml文件的格式创建Secret对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  user: YWRtaW4&#x3D;</span><br><span class="line">  pass: MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>Pod 看似复杂的API对象，实际上是容器的进一步抽象和封装。而控制器（Deployment）则是控制Pod的抽象。有了控制器，我们可以定义需要2个pod，当pod个数不够时，自动创建pod直到pod个数满足配置文件 replicas 里 定义的个数。</p><p>在 k8s 架构中，有一个叫做 kube-controller-manager 的组件，这个组件负责了k8s集群中的集群属性。使用Deployment控制的pod在生产环境才有意义。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>定义Deployment来创建Pod和ReplicaSet</li><li>滚动升级和回滚应用</li><li>扩容和缩容</li><li>暂停和继续Deployment</li></ol><p>Deployment 本质也是从Etcd中获取到所有携带了“app：nginx” 标签的Pod，统计其数量，并根据 ReplicaSet 字段进行调整。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1   </span><br><span class="line">kind: Deployment                 </span><br><span class="line">metadata:</span><br><span class="line">  name: string         # Deployment名称</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3            # 目标副本数量</span><br><span class="line">  revisonHistoryLimit: 0 # 控制历史版本个数，0的话就没办法再进行回滚操作</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:       # 滚动更新</span><br><span class="line">      maxSurge: 1        # 滚动升级时最大同时升级1个pod</span><br><span class="line">      maxUnavailable: 1  # 滚动升级时最大允许不可用的pod个数</span><br><span class="line">  template:         </span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: string      # 模板名称</span><br><span class="line">    sepc:                # 定义容器模板，该模板可以包含多个容器</span><br><span class="line">      containers:                               </span><br><span class="line">        - name: string                                 </span><br><span class="line">          image: string </span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 8080  # 对service暴露端口</span><br></pre></td></tr></table></figure><p><strong>template</strong> Deployment里的template 字段和一个标准的Pod对象的API定义丝毫不差，而所有被这个Deployment管理的Pod实例就是根据这个template创建出来的。</p><ul><li><strong>ReplicaSet 对象</strong></li></ul><p>滚动更新不仅仅是 Deployment 中的一个字段，而是可以单独作为一个 k8s 中的重要的 API 对象。一个 ReplicaSet 对象，其实就是由副本数目的定义和一个Pod模板的组成。其实ReplicaSet是Deployment的一个子集。</p><p>滚动更新的过程可以通过 <code>kubectl rollout status xxx(deployment)</code>指令查看。或者 <code>kubectl describe deployment xxx(deployment)</code> 查看<br>，当修改了Pod 模板之后，Deployment Controller 会使用这个修改过的Pod模板，创建一个新的 ReplicaSet （hash=173242546624），这个新的 ReplicaSet 的初始化Pod的副本数是 0 。然后会扩展出一个新的Pod集群。</p><ol><li>想要查看replicaSet 对象 <code>kubectl get rs</code> </li><li>想要查看滚动升级历史 <code>kubectl rollout history xxx(deployment)</code></li><li>想要回滚升级至历史版本2 <code>kubectl rollout undo xxx(deployment) --revision=2</code></li><li>暂停更新和恢复 <code>kubectl rolllout pause xxxx</code> 和 <code>kubectl roolout resume xxxx</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在容器的世界中，Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统，而如果仅仅是这样的化，容器是没有价值的，因为这样很难实现线上生产环境迁移到容器集群中，线上环境复杂多变，多个服务需要通过本地socket通信或者通过文件交互内容，所以在 k8s 中，pod才是最小的调度单元。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://kiosk007.top/categories/k8s/"/>
    
    
  </entry>
  
</feed>
